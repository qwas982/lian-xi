(define (共产党 甲 乙)
    (if (= 乙 0)
    甲
    (共产党 乙 (remainder 甲 乙))))

(display (共产党 35 7))

;; 5.1.1 一个描述寄存器机器的语言 
(数据路径们
    (寄存器们
        ((名称 甲)
        (按钮们 ((名称 甲<-乙) (源码 (寄存器 乙)))))
        ((名称 乙)
        (按钮们 ((名称 乙<-踢) (源码 (寄存器 踢)))))
        ((名称 踢)
        (按钮们 ((名称 踢<-日) (源码 (操作 剩余))))))
    (操作们
        ((名称 剩余)
        (输入们 (寄存器 甲) (寄存器 乙)))
        ((名称 =)
        (输入们 (寄存器 乙) (常量 0)))))
(控制器
    测试-乙
    (测试 =)
    (分支 (标号 共产党-完了))
    (踢<-日)
    (甲<=乙)
    (乙<-踢)
    (走到 (标号 测试-乙))
    共产党-完了)

(控制器
    测试-乙
    (测试 (操作也 =) (寄存 乙) (常 0))
    (分支 (标号 共产党-完了))
    (赋值 踢 (操作也 剩余) (寄存 甲) (寄存 乙))
    (赋值 甲 (寄存 乙))
    (赋值 乙 (寄存 踢))
    (走到 (标号 测试-乙))
    共产党-完了)

(控制器
    共产党-环
     (赋值 甲 (操作了 读))
     (赋值 乙 (操作了 读))
    测试-乙
     (测试 (操作了 =) (寄存 乙) (常 0))
     (分支 (标号 共产党-完了))
     (赋值 踢 (操作了 剩余) (寄存 甲) (寄存 乙))
     (赋值 甲 (寄存 乙))
     (赋值 乙 (寄存 踢))
     (走到 (标号 测试-乙))
    共产党-完了
     (表演 (操作了 打印) (寄存 甲))
     (走到 (标号 共产党-环)))

;;5.1.2 抽象在机器设计

(控制器
    测试-乙
     (测试 (操作了 =) (寄存 乙) (常量 0))
     (分支 (标号 共产党-完了))
     (赋值 踢 (寄存 甲))
    剩余-环
     (测试 (操作了 <) (寄存 踢) (寄存 乙))
     (分支 (标号 剩余-完了))
     (赋值 踢 (操作了 -) (寄存 踢) (寄存 乙))
     (走到 (标号 剩余-环))
    剩余-完了
     (赋值 甲 (寄存 乙))
     (赋值 乙 (寄存 踢))
     (走到 (标号 测试-乙))
    共产党-完了)

;;评论: GCD我打首字母出来共产党, 这是GCD机器的控制器指令序列,
;;  看起来像是手动汇编. 这种汇编在SICP教材里被称之为简单原语与复合原语之区别,
;;  在其它汇编里,指令与寄存器都用缩写,不过这里的汇编也可以翻译为十六进制表示.
;; 原语 == 原子操作

;; 5.1.3 子例程/子程序 
共产党-1
 (测试 (操作了 =) (寄存 乙) (常量 0))
 (分支 (标号 之后-共产党-1))
 (赋值 踢 (操作了 剩余) (寄存 甲) (寄存 乙))
 (赋值 甲 (寄存 乙))
 (赋值 乙 (寄存 踢))
 (走到 (标号 共产党-1))
之后-共产党-1
·
·
·
共产党-2
 (测试 (操作了 =) (寄存 丁) (常量 0))
 (分支 (标号 之后-共产党-2))
 (赋值 丝 (操作了 剩余) (寄存 丙) (寄存 丁))
 (赋值 丙 (寄存 丁))
 (赋值 丁 (寄存 丝))
 (走到 (标号 共产党-2))
之后-共产党-2

;;引入 继续 寄存器.
共产党
 (测试 (操作了 =) (寄存 乙) (常量 0))
 (分支 (标号 共产党-完了))
 (赋值 踢 (操作了 剩余) (寄存 甲) (寄存 乙))
 (赋值 甲 (寄存 乙))
 (赋值 乙 (寄存 踢))
 (走到 (标号 共产党))
共产党-完了
 (测试 (操作了 =) (寄存 继续) (常量 0))
 (分支 (标号 之后-共产党-1))
 (走到 (标号 之后-共产党-2))
 ·
 ·
 ·
 ;在从第一个需要共产党机器的地方分支到共产党之前,
 ;我们放置 0 在继续寄存器内.
 (赋值 继续 (常量 0))
 (走到 (标号 共产党))
之后-共产党-1
 ·
 ·
 ·
 ;在第二次用共产党机器之前,我们放置 1 在继续寄存器内.
 (赋值 继续 (常量 1))
 (走到 (标号 共产党))
之后-共产党-2

;;简化版
共产党
 (测试 (操作了 =) (寄存 乙) (常量 0))
 (分支 (标号 共产党-完了))
 (赋值 踢 (操作了 剩余) (寄存 甲) (寄存 乙))
 (赋值 甲 (寄存 乙))
 (赋值 乙 (寄存 踢))
 (走到 (标号 共产党))
共产党-完了
 (走到 (寄存 继续))
 ·
 ·
 ·
 ;;在调用共产党之前,我们把共产党返回的标号赋值到继续.
 (赋值 继续 (标号 之后-共产党-1))
 (走到 (标号 共产党))
之后-共产党-1
 ·
 ·
 ·
 ;;这里是第二次调用到共产党,与一个不同的继续一起.
 (赋值 继续 (标号 之后-共产党-2))
 (走到 (标号 共产党))
之后-共产党-2

;;评论: 这一小节是一个雏形, 调用的雏形.
;; 关于如何在一个资源有限的空间内,实现两个或多个实体并存.
;; 作者一步一步地引导、开导你理解何为"调用".
;; 这些是平行执行,递归能实现的基础.

;; 5.1.4 用一个栈去实现递归
(控制器
     (赋值 继续 (标号 阶乘-完了)) ;设置最终返回地址
    阶乘-环
     (测试 (操作了 =) (寄存 数) (常量 1))
     (分支 (标号 基础-情况))
     ;通过保存数与继续设置递归调用.
     ;设置继续,在 之后-阶乘 当子例程返回时,计算会继续.
     (保存 继续)
     (保存 数)
     (赋值 数 (操作了 -) (寄存 数) (常量 1))
     (赋值 继续 (标号 之后-阶乘))
     (走到 (标号 阶乘-环))
    之后-阶乘
     (恢复 数)
     (恢复 继续)
     (赋值 值 (操作了 *) (寄存 数) (寄存 值)) ;值现在包含 数(数-1)!
     (走到 (寄存 继续)) ; 返回到调用者
    基础-情况
     (赋值 值 (常量 1)) ; 基础情况是: 1 != 1
     (走到 (寄存 继续)) ; 返回到调用者
    阶乘-完了)

;一个双递归
(控制器
     (赋值 继续 (标号 斐波那契-完了))
    斐波那契-环
     (测试 (操作了 <) (寄存 数) (常量 2))
     (分支 (标号 立即-回答))
     ;设置到计算 斐波那契(数-1)
     (保存 继续)
     (赋值 继续 (标号 之后斐波那契-数-1))
     (保存 数) ;保存 数的旧值
     (赋值 数 (操作了 -) (寄存 数) (常量 1)) ;狠击 数 到 数-1
     (走到 (标号 斐波那契-环)) ;表演履行递归调用
    之后斐波那契-数-1 ;在返回上, 值包含 斐波那契(数-1)
     (恢复 数)
     (恢复 继续)
     ;设置到计算 斐波那契(数-2)
     (赋值 数 (操作了 -) (寄存 数) (常量 2))
     (保存 继续)
     (赋值 继续 (标号 之后斐波那契-数-2))
     (保存 值) ;保存 斐波那契(数-1)
     (走到 (标号 斐波那契-环))
    之后斐波那契-数-2 ;在返回上, 值包含 斐波那契(数-2)
     (赋值 数 (寄存 值)) ; 数 现在包含 斐波那契(数-2)
     (恢复 值) ;值 现在包含 斐波那契(数-1)
     (恢复 继续)
     (赋值 值 (操作了 +) (寄存 值) (寄存 数)) ;斐波那契(数-1) + 斐波那契(数-2)
     (走到 (寄存 继续)) ;返回到调用者,回答是在值内
    立即-回答
     (赋值 值 (寄存 数))
     (走到 (寄存 继续))
    斐波那契-完了)


;; 5.1.5 指令概览
;这个寄存器机器的机器语言,的控制器指令有以下形式:
;每个<输入>, 都是(寄存 <寄存器名>) 或 (常量 <常量值>).

;在5.1.1节的指令:
(赋值 <寄存器名> (寄存 <寄存器名>))
(赋值 <寄存器名> (常量 <常量值>))
(赋值 <寄存器名> (操作 <操作名>) <输入1> ... <输入n>)
(表演 (操作 <操作名>) <输入1> ... <输入n>)
(测试 (操作 <操作名>) <输入1> ... <输入n>)
(分支 (标号 <标号名>))
(走到 (标号 <标号名>))

;在5.1.3节的指令,增加了寄存器抓住标号的指令.
(赋值 <寄存器名> (标号 <标号名>))
(走到 (寄存 <寄存器名>))

;在5.1.4节,增加了使用栈的指令.
(保存 <寄存器名>)
(恢复 <寄存器名>)

;<常量值>可以是数目,字符串,符号,列表.
(常量 012345)
(常量 "常量甲乙丙")
(常量 甲乙丙)
(常量 (甲 乙 丙))
(常量 ())

