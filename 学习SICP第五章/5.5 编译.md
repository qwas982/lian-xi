5.5 编译

第5.4节中的显式控制求值器是一台寄存器机器，其控制器解释Scheme程序。在本节中，我们将探讨如何在一个控制器不是Scheme解释器的寄存器机器上运行Scheme程序。

显式控制求值器是通用的——它可以执行任何可以用Scheme描述的计算过程。求值器的控制器协调其数据路径的使用，以执行所期望的计算。因此，求值器的数据路径也是通用的：只要有适当的控制器，它们就能够执行我们想要的任何计算。

商用通用计算机是围绕一组寄存器和操作构建的寄存器机器，这些寄存器和操作构成了一个高效且方便的通用数据通道集。通用机的控制器是一个解释器，用于解释类似于我们一直使用的寄存器机器语言。这种语言被称为机器的母语，或简称机器语言。用机器语言编写的程序是一系列使用机器数据路径的指令。例如，显式控制求值器的指令序列可以被看作是通用计算机的机器语言程序，而不是专用解释器机器的控制器。

在缩小高级语言与寄存器机器语言之间的差距方面，有两种常见的策略。显式控制求值器展示了解释策略。用机器母语编写的解释器配置机器执行以某种语言（称为源语言）编写的程序，这种语言可能不同于执行求值的机器的母语。源语言的基本过程是用特定机器的母语编写的子程序库实现的。待解释的程序（称为源程序）以数据结构形式表示。解释器遍历这个数据结构，分析源程序。在此过程中，它通过调用库中适当的原语子程序来模拟源程序预期的行为。

在本节中，我们将探讨另一种编译策略。针对给定源语言和机器的编译器会将源程序翻译成用机器母语编写的等效程序（称为目标程序）。我们在本节中实现的编译器可将用Scheme编写的程序转换为指令序列，并使用显式控制求值器机器的数据路径来执行。

与解释相比，编译可以极大地提高程序执行的效率，我们将在下面的编译器概述中对此进行解释。另一方面，解释器为交互式程序开发和调试提供了更强大的环境，因为在运行时可以检查和修改正在执行的源程序。此外，由于存在整个原语库，因此在调试过程中可以构建新程序并添加到系统中。

鉴于编译和解释的优势互补，现代程序开发环境采取了混合策略。Lisp解释器的组织通常使得解释后的过程和已编译过程可以相互调用。这使得程序员可以编译那些已经调试完毕的程序部分，从而获得编译的效率优势，同时对于那些处于交互式开发和调试过程中的程序部分，保留解释执行模式。在第5.5.7节中，当我们实现了编译器之后，我们将展示如何将编译器与解释器链接起来，以产生一个集成的解释器-编译器开发系统。

编译器概述
我们的编译器在结构和功能上都与解释器相似。因此，编译器用于分析表达式的机制将与解释器类似。此外，为了便于将已编译代码与解释后的代码链接起来，我们将设计编译器，使其生成的代码在寄存器的使用上遵守与解释器相同的惯例：环境将保存在 `env` 寄存器中，参数列表将保存在 `argl` 中，要应用的过程将保存在 `proc` 中，过程将在 `val` 中返回其答案，过程应返回的位置将保存在 `continue` 中。总的来说，编译器将源程序翻译成目标程序时，执行的寄存器操作与解释器求值相同源程序时执行的操作基本相同。

这段描述提出了一种实现简单编译器的策略：我们以解释器的方式遍历表达式。当我们遇到解释器在求值表达式时会执行的寄存器指令时，我们不执行该指令，而是将其累积到一个序列中。由此产生的指令序列将是目标代码。观察编译相对于解释的效率优势。每次解释器求值一个表达式——例如，`(f 84 96)`——它都会进行分类表达式的工作（发现这是一个过程应用）并测试操作数列表的结束（发现有两个操作数）。使用编译器，表达式只在编译时生成指令序列时分析一次。编译器生成的目标代码仅包含求值操作符和两个操作数、组装参数列表并将过程（在 `proc` 中）应用于参数（在 `argl` 中）的指令。

这是我们在第4.1.7节分析型求值器中实现的优化。但在编译代码中还有进一步提高效率的机会。当解释器运行时，它遵循的过程必须适用于语言中的任何表达式。相比之下，给定的编译代码段旨在执行某个特定的表达式。这可以在使用栈保存寄存器时产生很大的差异。当解释器求值一个表达式时，它必须为任何意外情况做好准备。在求值子表达式之前，解释器会保存所有后续需要的寄存器，因为子表达式可能需要任意求值。另一方面，编译器可以利用它正在处理的特定表达式的结构来生成避免不必要栈操作的代码。

作为一个具体的例子，考虑组合表达式 `(f 84 96)`。在解释器求值组合的运算符之前，它会通过保存包含操作数和环境的寄存器来为这次求值做准备，因为这些值稍后会需要。然后，解释器求值运算符以在 `val` 中获得结果，恢复保存的寄存器，最后将结果从 `val` 移动到 `proc`。然而，在我们正在处理的特定表达式中，运算符是符号 `f`，其求值是通过机器操作 `lookup-variable-value` 完成的，该操作不会改变任何寄存器。我们在本节中实现的编译器将利用这一事实，并生成使用指令求值运算符的代码：

(assign proc (op lookup-variable-value) (const f) (reg env))

这段代码不仅避免了不必要的保存和恢复操作，还将查找的值直接赋给 `proc`，而解释器则会在 `val` 中获得结果，然后再将其移动到 `proc`。

编译器还可以优化对环境的访问。通过对代码进行分析，编译器在许多情况下可以知道特定变量将位于哪个框中，并直接访问该框，而不是执行 `lookup-variable-value` 搜索。我们将在第5.5.6节讨论如何实现这种变量访问。然而，在此之前，我们将重点放在上述寄存器和栈优化上。编译器可以执行许多其他优化，例如将基本操作“内联”编码，而不是使用通用的 `apply` 机制（参见练习5.38）；但我们在这里不会强调这些。我们在本节中的主要目标是在简化（但仍然有趣）的上下文中说明编译过程。



5.5.1 编译器的结构
在第4.1.7节中，我们修改了最初的元循环解释器，将分析与执行分离。我们分析每一个表达式以生成一个执行过程，该过程接收一个环境作为参数并执行所需的操作。在我们的编译器中，我们将基本上做同样的分析。但是，我们不会生成执行过程，而是生成由寄存器机器运行的指令序列。

`compile` 过程是编译器中的顶层调度。它对应于第4.1.1节中的 `eval` 过程，第4.1.7节中的 `analyze` 过程，以及第5.4.1节中显式控制求值器的 `eval-dispatch` 入口点。编译器和解释器一样，使用在第4.1.2节中定义的表达式语法过程。`compile` 对要编译的表达式的语法类型进行了条件分析。对于每种类型的表达式，它会调度到一个专门的代码生成器：

目标和链接描述
`Compile` 和它调用的代码生成器除了编译的表达式之外还需要两个实参。一个是目标，它指定了已编译代码应该将表达式的值返回到哪个寄存器中。另一个是链接描述符，它描述了编译得到的代码在其执行完毕后应该如何继续执行。链接描述符可以要求代码执行以下三件事情之一：

	在序列中的下一条指令处继续执行（这是由链接描述符 `next` 指定的），

	从已编译的过程返回（这是由链接描述符 `return` 指定的），或者

	跳转到命名的入口点（这是通过使用指定的标号作为链接描述符来指定的）。

例如，如果以 `val` 寄存器为靶并且链接为 `next` 来编译表达式 5（它是自求值的），那么应该生成如下指令：

(assign val (const 5))

如果以链接为 `return` 来编译同一个表达式，那么应该生成如下指令：

(assign val (const 5))
(goto (reg continue))

在第一种情况下，执行将继续进行到序列中的下一条指令。在第二种情况下，我们将从一个过程调用中返回。在这两种情况下，表达式的值都将被放置到靶 `val` 寄存器中。

指令序列与栈用法
每个代码生成器都会返回一个包含为表达式生成的目标代码的指令序列。复合表达式的代码生成是通过组合更简单的代码生成器为组成表达式生成的输出来实现的，正如复合表达式的求值是通过求值组成表达式来实现的一样。

组合指令序列的最简单方法是一个叫做 `append-instruction-sequences` 的过程。它接受任意数量的需要按顺序执行的指令序列作为参数；它把这些序列链接起来并返回组合后的序列。也就是说，如果 `<seq1>` 和 `<seq2>` 是指令序列，那么计算

(append-instruction-sequences <seq1> <seq2>)

会产生这样的序列：

<seq1>
<seq2>

每当寄存器可能需要被保存时，编译器的代码生成器使用了一种更为精细的方法来组合指令序列，这种方法叫做 `preserving`。`Preserving` 接受三个参数：一组寄存器和两个需要按顺序执行的指令序列。它以这样的方式链接这些序列：如果第二个序列的执行需要第一个序列执行期间寄存器的内容保持不变，那么这组寄存器中的每个寄存器的内容在第一个序列的执行期间会被保护。也就是说，如果第一个序列修改了寄存器并且第二个序列实际上需要寄存器的原始内容，那么 `preserving` 会在第一个序列前后包裹上保存和恢复寄存器的操作，然后再将这些序列链接起来。否则，`preserving` 仅仅是返回链接后的指令序列。因此，例如，

(preserving (list <reg1> <reg2>) <seq1> <seq2>)

会产生以下四种指令序列之一，具体情况取决于 <seq1> 和 <seq2> 如何使用 <reg1> 和 <reg2>：

如果 <seq1> 和 <seq2> 都不需要 <reg1> 和 <reg2> 的原始值，那么不需要任何保存和恢复操作：

如果只有 <seq2> 需要 <reg1> 的原始值（假定 <seq2> 不需要 <reg2> 的原始值），则在执行 <seq1> 前保存 <reg1>，并在 <seq1> 执行后恢复 <reg1>：

如果只有 <seq2> 需要 <reg2> 的原始值（假定 <seq2> 不需要 <reg1> 的原始值），则在执行 <seq1> 前保存 <reg2>，并在 <seq1> 执行后恢复 <reg2>：

如果 <seq2> 同时需要 <reg1> 和 <reg2> 的原始值，则在执行 <seq1> 前保存 <reg2> 和 <reg1>，并在 <seq1> 执行后恢复它们：

通过使用 `preserving` 来组合指令序列，编译器避免了不必要的栈操作。这也把是否生成保存和恢复指令的细节隔离在 `preserving` 过程内部，使其与编写各个独立代码生成器时出现的问题分开。事实上，代码生成器并不会显式地生成任何保存或恢复指令。

原则上，我们可以将一个指令序列简单地表示为一个指令列表。`Append-instruction-sequences` 可以通过普通的列表链接来组合指令序列。然而，这样做的话，`preserving` 将成为一个复杂的操作，因为它必须分析每个指令序列来确定序列是如何使用其寄存器的。`Preserving` 不仅会变得复杂，而且也会效率低下，因为它必须分析每个指令序列参数，即使这些序列本身可能是通过调用 `preserving` 构建的，在这种情况下，它们的部分已经被分析过了。为了避免这种重复分析，我们将为每个指令序列关联一些关于其寄存器使用的资料。当我们构造一个基本的指令序列时，我们将明确地提供这些信息，而组合指令序列的过程将从复合序列关联的信息中推导出组合序列的寄存器使用信息。

一个指令序列将包含三部分信息：

	必须在序列中的指令被执行之前初始化的寄存器集合（这些寄存器被认为是由序列所需要的），

	在序列中的指令执行过程中其值被修改的寄存器集合，

	序列中的实际指令（也称为语句）。

我们将用一个列表来表示一个指令序列，这个列表包含了它的这三个部分。因此，指令序列的构造器如下：

例如，一个包含两条指令的序列，该序列首先在当前环境中查找变量 x 的值，然后将结果赋给 val 寄存器，最后返回。这个序列需要 env 和 continue 寄存器已经被初始化，并且会修改 val 寄存器。因此，这个序列可以这样构造：

我们有时需要构造一个没有语句的指令序列:

组合指令序列的过程见5.5.4节所示。

编译表达式 5.5.2
在本节和下一节中，我们将实现编译过程所调度的代码生成器。

编译链接代码
通常，每个代码生成器的输出将以由过程 `compile-linkage` 生成的指令结束，这些指令实现了所需的链接。如果链接类型是返回（return），则我们必须生成指令 `(goto (reg continue))`。这需要继续（continue）寄存器，并且不会修改任何寄存器。如果链接类型是下一个（next），那么我们不需要包含任何额外的指令。否则，链接是一个标号（label），我们需要生成跳转到该标号的指令，而这个指令不需要也不修改任何寄存器。

链接代码会被附加到一个指令序列中，同时会保留继续（continue）寄存器，因为返回类型的链接需要使用继续寄存器：如果给定的指令序列修改了 continue 寄存器，并且链接代码需要它，则会在链接代码执行前后保存并恢复 continue 寄存器的状态。

编译简单表达式
对于自求值表达式（self-evaluating expressions）、引用（quotations）和变量（variables）的代码生成器构建了指令序列，这些序列将所需值赋给靶寄存器，然后根据链接描述符指定的方式继续执行。

编译所有这些赋值指令都会修改靶寄存器，而查找变量的操作需要 env 寄存器。

处理赋值（assignments）和定义（definitions）的方式与解释器中的处理方式相似。我们递归地生成用于计算要分配给变量的值的代码，并在其后附加一个两步指令序列，该序列实际设置或定义变量，并将整个表达式的值（符号 ok）赋给目标寄存器。递归编译的目标是 val，链接类型是 next，这样代码会将其结果放入 val 并继续执行附加在其后的代码。附加操作是在保留 env 的情况下进行的，因为环境对于设置或定义变量是必需的，并且变量值的代码可能是对复杂表达式的编译，可能会以任意方式修改寄存器。

附加的两步指令序列需要 env 和 val，并且会修改目标寄存器。需要注意的是，尽管我们为这个序列保留了 env，但我们并不保留 val，因为获取值的代码（get-value-code）是专门设计用来将其结果显式地放置在 val 中供此序列使用的。（事实上，如果我们保留了 val，就会导致一个错误，因为这会导致在获取值的代码运行后立即恢复 val 的先前内容。）

编译条件表达式
编译给定靶和链接的 若 表达式的代码形式如下：

为了生成这段代码，我们编译谓词（predicate）、后果（consequent）和替代物（alternative），并将生成的代码与用于测试谓词结果的指令以及新生成的用于标记真分支、假分支和条件语句结尾的标号组合起来。 在这种代码布局中，如果测试结果为假，则必须绕过真分支。唯一稍微复杂的地方在于如何处理真分支的链接（linkage）。如果条件语句的链接是返回（return）或是一个标号（label），那么真分支和假分支都将使用相同的链接。如果链接是下一个（next），则真分支将以跳过假分支代码并跳转到条件语句结尾的标号处作为结束。

环境（env）在编译谓词代码时被保留下来，因为它可能被真分支和假分支需要用到，同时继续（continue）寄存器也被保留下来，因为它可能被那些分支中的链接代码所需要。真分支和假分支的代码（它们不是顺序执行的）是通过一个特殊的组合器 `parallel-instruction-sequences`（在第 5.5.4 节中描述）附加在一起的。

需要注意的是，`cond` 是一个派生表达式，因此编译器处理它所需要的只是应用 `cond->if` 转换器（来自第 4.1.2 节），然后编译转换后得到的 `if` 表达式。

编译序列
序列的编译（来自过程物自体或显式的开始表达式）与其求值过程相平行。序列中的每个表达式都会被编译——最后一个表达式按照序列指定的链接方式进行编译，而其他表达式则以链接到下一个（以执行序列的剩余部分）的方式进行编译。各个表达式的指令序列被追加形成单一的指令序列，从而确保 env（用于序列的其余部分）和 continue（可能在序列末尾的链接处需要）得到保留。

编译 入 表达式
入 表达式用于构造过程。一个 入 表达式的对象代码必须具有如下形式：

当我们编译 入 表达式时，我们也生成过程物自体的代码。虽然在过程构造时物自体不会被执行，但将其代码紧接在 入 的代码后面插入到对象代码中是方便的。如果 入 表达式的链接方式是标号或返回，这是可以的。但如果链接方式是 next，我们将需要使用一种链接方式跳转到插入在物自体后面的标号，以此来绕过过程物自体的代码。因此，对象代码具有如下形式。

Compile-lambda 生成用于构造过程对象的代码，其后是过程物自体的代码。过程对象将在运行时通过组合当前环境（定义点处的环境）与编译后过程物自体的入口点（一个新生成的标号）来构建。

Compile-lambda 使用特殊的组合器 tack-on-instruction-sequence（第 5.5.4 节）而不是 append-instruction-sequences 来将过程物自体附加到 lambda 表达式的代码上，因为物自体不是当组合序列被进入时将要执行的指令序列的一部分；相反，它出现在序列中仅仅是因为那里是一个放置它的方便位置。

Compile-lambda-body 构造过程物自体的代码。这段代码首先是一个作为入口点的标号。接下来是将导致运行时求值环境切换到求值过程物自体的正确环境的指令——即扩展以包含形式形参绑定到调用过程的实参的值的过程定义环境。在这之后是构成过程物自体的一系列表达式的代码。这一序列以链接方式为 return 并且目标为 val 进行编译，以便它将以带有过程结果存放在 val 中的方式从过程中返回。


;;5.5.3 编译组合
;编译处理的本质是过程应用的编译,为组合了已编译的代码和给定靶与链接一起,有其形式:

寄存器 env、proc 和 argl 在操作者与操作范围的求值过程中可能需要保存和恢复。请注意，这是编译器中唯一指定 val 之外的靶的地方。

其请求代码由 compile-application 生成。这递归地编译操作者，生成将要应用的过程放入 proc 的代码，并编译操作范围，生成求值应用的各个实参的代码。操作范围的指令序列被组合（通过 construct-arglist）成在 argl 中构造实参列表的代码，并且由此产生的实参列表代码与过程代码以及执行过程调用的代码（由 compile-procedure-call 生成）相结合。在追加代码序列时，env 寄存器必须在操作者的求值周围被保留（因为求值操作者可能会修改 env，而 env 将需要用来求值操作范围），并且 proc 寄存器必须在构造实参列表周围被保留（因为求值操作范围可能会修改 proc，而 proc 将需要用于实际的过程应用）。Continue 必须在整个过程中被保留，因为它对于过程调用中的链接是必需的。

构造实参列表的代码将会把每个操作范围求值到 val 中，然后将该值连接到正在 argl 中累积的实参列表上。由于我们按顺序将实参连接到 argl 上，我们必须从最后一个实参开始并以第一个实参结束，以便实参在最终的列表中从第一个到最后一个依次出现。为了避免通过将 argl 初始化为空列表来设置这个求值序列而浪费一条指令，我们让第一条代码序列构造初始的 argl。因此，构造实参列表的一般形式如下：

Argl 在除第一个以外的每个操作范围的求值周围必须被保留（这样之前累积的实参才不会丢失），并且 env 在除最后一个以外的每个操作范围的求值周围必须被保留（以供后续的操作范围求值使用）。

编译这个实参代码稍微有些棘手，因为对要求值的第一个操作范围的特殊处理以及在不同地方保留 argl 和 env 的需求。construct-arglist 过程接收求值各个操作范围的代码作为实参。如果没有操作范围，它简单地发出指令

(assign argl (const ()))

否则，construct-arglist 创建初始化 argl 为最后一个实参的代码，并追加求值其余实参并将它们依次附加到 argl 上的代码。为了从最后一个到第一个处理实参，我们必须逆向由 compile-application 提供的操作范围代码序列的顺序。

应用过程
在对组合中的元素进行求值之后，已编译代码必须将proc中的过程应用到argl中的实参上。这段代码执行的调度与4.1.1节中元循环求值器的apply过程或5.4.1节中显式控制求值器的apply-dispatch入口点基本上相同的调度。它会检查要应用的过程是否是一个原语过程还是一个已编译过程。对于原语过程，它使用apply-primitive-procedure；我们很快会看到它是如何处理编译后过程的。过程应用代码的形式如下：

注意，编译分支必须绕过原语分支。因此，如果原始过程调用的链接是紧接着的（next），那么复合分支必须使用一种跳转到插入在原语分支之后的标号的链接（这类似于在编译if语句时用于真分支的链接方式）。

原语分支和复合分支，就像在compile-if中的真分支和假分支一样，是通过平行指令序列（parallel-instruction-sequences）而不是通常的平常的追加指令序列（append-instruction-sequences）来追加的，因为它们不会被顺序执行。

应用已编译过程
手握过程应用的代码是编译器中最微妙的部分，尽管它生成的指令序列非常短。一个已编译过程（如由compile-lambda构造的）有一个入口点，这是一个标号，指定了过程代码开始的位置。在这个入口点处的代码会在val中计算结果并通过执行指令（goto (reg continue)）返回。因此，我们可以预期，如果链接是一个标号，带有特定目标和链接的已编译过程应用（由compile-proc-appl生成）的代码看起来可能是这样的。

这段代码设置continue，使得过程将返回到一个名为proc-return的标号，并跳转到该过程的入口点。在proc-return处的代码将过程的结果从val转移到靶寄存器（如果必要的话），然后跳转到由链接指定的位置。（链接总是return或一个标号，因为compile-procedure-call将复合过程分支的next链接替换为after-call标号。）

事实上，如果目标不是val，这确实是我们编译器将生成的代码。然而，通常情况下，目标是val（编译器唯一指定不同寄存器的时候是将操作者的计算作为 proc 的靶时），因此过程的结果直接放入靶寄存器，不需要返回到一个专门的位置来进行复制。相反，我们通过设置continue，使得过程能够“直接返回”到由调用者的链接所指定的地方，从而简化了代码：

如果链接是一个标号，我们就设置continue，使得过程将返回到那个标号。（也就是说，过程结尾处的 (goto (reg continue)) 变成了等同于上述proc-return处的 (goto (label <linkage>))。）

如果链接是return，我们根本不需要设置continue：它已经手持其渴望定位。（也就是说，过程结尾处的 (goto (reg continue)) 直接跳转到原本在proc-return处的 (goto (reg continue)) 会去的地方。）

通过这种返回链接的实现，编译器生成尾递归代码。在过程物自体的最后一步调用一个过程会直接进行转移，而无需在栈上保存任何信息。

假设我们像上面处理非val靶那样处理带有return链接和val靶的过程调用情况。这将会破坏尾递归。我们的系统仍然会对任何表达式给出相同的值，但是每次我们调用一个过程时，我们会保存continue并在调用后返回以撤销（无用的）保存。这些额外的保存会在一系列的过程调用中累加。

compile-proc-appl通过考虑四个情况来生成上述的过程应用代码，这取决于调用的靶是否是val以及链接是否是return。需要注意的是，由于执行过程物自体可以任意改变寄存器，所以声明这些指令序列会修改所有寄存器。此外，请注意，对于靶是val且链接是return的情况，其代码序列声明需要continue：即使在这两步指令序列中没有显式使用continue，我们也必须确保在进入编译过程时continue会有正确的值。

5.5.4 组合指令序列
本节描述了指令序列是如何表示及组合的细节。回顾在5.5.1节中提到，一个指令序列是以所需寄存器列表、所修改寄存器列表以及实际指令的形式来表示的。我们也将一个标号（符号）视作指令序列的一种退化情形，它不需要也不修改任何寄存器。因此，为了确定指令序列所需的和所修改的寄存器，我们使用选择器。

并且，为了确定给定的序列是否需要或修改了某个给定的寄存器，我们使用谓词（predicates）。

基于这些谓词和选择器，我们可以实现编译器中使用的各种指令序列组合器。

最基本的一种组合器是 `append-instruction-sequences`。这个函数接受任意数量的按顺序执行的指令序列作为参数，并返回一个新的指令序列，这个新序列的语句是所有输入序列语句的已追加。关键点在于确定结果序列所需的和所修改的寄存器。它修改的是任一序列所修改的那些寄存器；它需要的是那些必须在第一个序列开始前初始化的寄存器（即第一个序列所需的寄存器），再加上其他序列中未被前面序列初始化（修改）的那些所需的寄存器。

序列的已追加通过 `append-2-sequences` 两个两个地进行。这接收两个指令序列 `seq1` 和 `seq2`，并返回一个新指令序列，该序列的语句是 `seq1` 的语句后面跟着 `seq2` 的语句，其修改的寄存器是 `seq1` 或 `seq2` 所修改的寄存器，而所需的寄存器则是 `seq1` 所需的寄存器加上 `seq2` 所需的但没有被 `seq1` 修改的寄存器。（用集合操作来说，新的所需寄存器集合是 `seq1` 所需寄存器集合与 `seq2` 所需寄存器集合减去 `seq1` 修改的寄存器集合的差集的并集。）因此，`append-instruction-sequences` 是这样实现的：

这个过程使用了一些简单的操作来操纵以列表形式表示的集合，类似于在第2.3.3节中描述的（无序的）集合表示方法：


保留（Preserving），作为第二个主要的指令序列组合器，它接收一个寄存器列表 `regs` 和两个需要按顺序执行的指令序列 `seq1` 和 `seq2`。它返回一个新的指令序列，该序列的语句首先是 `seq1` 的语句接着是 `seq2` 的语句，并在 `seq1` 周围添加适当的保存和恢复指令，以保护那些被 `seq1` 修改但又被 `seq2` 需要的寄存器。为了完成这一点，`preserving` 首先创建一个序列，该序列包含所需的保存操作，接着是 `seq1` 的语句，最后是所需的恢复操作。这个序列除了 `seq1` 所需的寄存器之外还需要被保存和恢复的寄存器，并且修改除了那些被保存和恢复之外的由 `seq1` 修改的寄存器。然后，这个增强的序列和 `seq2` 按照通常的方式被追加在一起。下面的过程递归地遍历需要保留的寄存器列表来实现这一策略：

另一种指令序列组合器 `tack-on-instruction-sequence` 被 `compile-lambda` 使用来将一个过程物自体追加到另一个序列上。由于过程物自体不是“在线”的，不会作为组合序列的一部分被执行，因此它的寄存器使用情况对嵌入它的序列的寄存器使用没有影响。因此，当我们把过程物自体追加到其他序列上时，我们会忽略该过程物自体所需的和所修改的寄存器集合。

`compile-if` 和 `compile-procedure-call` 使用一个特殊的组合器 `parallel-instruction-sequences` 来追加在测试后跟随的两个可选分支。这两个分支永远不会被顺序执行；对于任何特定的测试求值，将会进入其中一个分支。正因为如此，即使这些寄存器被第一个分支修改了，第二个分支所需的寄存器在组合序列中仍然是必需的。

5.5.5 一个编译代码的例子
现在我们已经看到了编译器的所有元素，让我们来检查一个编译代码的例子，看看这些元素是如何组合在一起的。我们将通过调用compile来编译一个递归阶乘过程的定义：

我们指定了define表达式的值应该被放置在val寄存器中。我们并不关心编译代码在执行define之后做了什么，所以我们将next作为链接描述符的选择是任意的。

编译器确定该表达式是一个定义，因此它调用compile-definition来编译计算待分配值（靶为val）的代码，接着是安装定义的代码，然后是将define的值（即符号ok）放入靶寄存器的代码，最后是链接代码。Env在计算值的过程中被保留下来，因为安装定义时需要它。由于链接方式是next，在这种情况下就没有链接代码。因此，编译代码的骨架如下：

要编译以产生变量factorial的值的表达式是一个lambda表达式，其值是计算阶乘的过程。编译通过调用compile-lambda来处理这个过程，后者会编译过程物自体，并将其标号为一个新的入口点，且生成指令以在新的入口点处将过程物自体与运行时环境结合起来，并将结果赋给val寄存器。接下来序列会跳过在此处插入的编译后过程代码。过程代码本身首先通过一个框扩展过程的定义环境，该框将形式形参n绑定到过程实参。然后是实际的过程物自体。由于变量值的这段代码不会修改env寄存器，上面可选的保存和恢复就不会被生成。（entry2处的过程代码此时不会被执行，因此它对env的使用无关紧要。）因此，编译代码的骨架变为： 

一个过程物自体总是被编译（通过compile-lambda-body）为一个目标为val且链接方式为return的序列。在这个情况下的序列由一个单一的if表达式组成：

Compile-if生成的代码首先计算谓词（靶为val），然后检查结果并在谓词为假的情况下跳过真分支。由于后续可能需要使用Env和continue，所以在谓词代码周围保留了它们。由于if表达式是构成过程物自体的最终表达式（也是唯一的表达式），它的靶是val，链接方式是return，因此真分支和假分支都是以靶为val和链接方式为return来编译的。（也就是说，条件表达式的值，即由其任一分支计算出的值，就是过程的值。）

谓词 (= n 1) 是一个过程调用。这会查找操作者（符号=）并将这个值放置在proc中。接着它会将实参1和n的值汇编进argl。然后它测试proc是否包含一个原语或复合过程，并相应地调度到原语分支或复合分支。两个分支都会在调用后的标号处恢复执行。由于在本例中，操作者和操作范围的求值都不会修改相关寄存器，因此保留寄存器不变的需求并不会导致任何寄存器的保存操作。

假分支的代码是另一个过程调用，其中过程是符号 * 的值，实参是 n 和另一个过程调用（对 factorial 的调用）的结果。这些调用各自设置了 proc 和 argl 并且有各自的原语分支和复合分支。图5.17展示了阶乘过程定义的完整编译。请注意，如上所述，在谓词周围的 continue 和 env 的可能保存和恢复事实上被生成了，这是因为这些寄存器被谓词中的过程调用所修改，并且在分支中的过程调用及返回链接中需要它们。

5.5.6 词法寻址
编译器执行的最常见的优化之一是对变量查找的优化。到目前为止，我们实现的编译器生成使用求值器机器的lookup-variable-value操作的代码。这种操作通过从内向外逐框对比变量与当前已绑定的每个变量来查找一个变量。如果框嵌套得很深或者有很多变量，这种搜索可能会很昂贵。例如，考虑在求值由某个过程返回的应用程序中的表达式 (* x y z) 时查找 x 的值的问题：

每次lookup-variable-value搜索x时，它必须确定符号x不等于y或z（在第一框中），也不等于a、b、c、d或e（在第二框中）。暂时假设我们的程序不使用define——即变量仅通过lambda进行绑定。因为我们的语言具有词法作用域，任何表达式的运行时环境将会有一个结构，这个结构平行于表达式出现的程序的词法结构。因此，当编译器分析上述表达式时，它可以知道每次应用该过程时，(* x y z)中的变量x将在当前框之外两框的位置找到，并且它是那一框中的第一个变量。

我们可以利用这一事实，发明一种新的变量查找操作，称为lexical-address-lookup，该操作接收一个环境和一个词法地址作为实参，这个地址由两个数字组成：一个框编号，指定需要跨越多少框；一个位移编号，指定在那一框中需要跨越多少变量。lexical-address-lookup将根据当前环境产生存储在那个词法地址处的变量的值。如果我们向我们的机器中添加lexical-address-lookup操作，我们就可以让编译器生成使用这个操作而不是lookup-variable-value来引用变量的代码。同样地，我们的编译代码可以使用一个新的lexical-address-set!操作代替set-variable-value!。

为了生成这样的代码，编译器必须能够确定它即将编译引用的变量的词法地址。程序中变量的词法地址取决于代码中的位置。例如，在以下程序中，<e1>表达式中x的地址是(2,0)——即两框之前并且是框中的第一个变量。在这一点上，y的地址是(0,0)，而c的地址是(1,2)。<e2>表达式中，x的地址是(1,0)，y的地址是(1,1)，而c的地址是(0,2)。

编译器生成使用词法地址的代码的一种方法是维护一个称为编译时环境的数据结构。这个结构跟踪特定的变量访问操作被执行时，哪些变量位于运行时环境中的哪些框的哪些位置。编译时环境是一个框列表，每个框包含一个变量列表。（当然，在编译时刻，变量是没有值绑定的，因为值是在运行时刻才计算出来的。）编译时环境成为了传递给compile函数的一个附加实参，并且沿着各个代码生成器传递。顶层对compile的调用使用的是一个空的编译时环境。当编译lambda物自体时，compile-lambda-body通过增加一个包含了过程形参的框来扩展编译时环境，这样组成过程物自体的序列就会使用这个扩展后的环境进行编译。在编译的每一步，compile-variable和compile-assignment都会使用编译时环境来生成适当的词法地址。

练习5.39至5.43描述了如何完成这个关于词法地址策略的草图，以便将词法查找整合进编译器。练习5.44描述了编译时环境的另一种用途。 


;;5.5.7 其求值器的已编译代码接口
我们还没有解说如何将已编译代码加载到求值器中或者如何跑它。我们将假设显式控制求值器机器已经按照第5.4.4节定义好了，并且包含了注脚38中指定的附加操作。我们将实现一个叫做compile-and-go的过程，这个过程编译一个Scheme表达式，载入其结果对象代码到求值器机器中，并使机器在求值器的全局环境中跑该代码，打印结果，并进入求值器的驱动环。我们还会修改求值器，使得被解释的表达式能够调用已编译的过程以及已解释的过程。这样我们就可以把一个已编译过程放入机器中，并使用求值器来调用它。

为了让求值器能够处理已编译过程们（例如，求值上述对阶乘的调用），我们需要更改apply-dispatch（见5.4.1节）处的代码，使其能够识别已编译过程们（将其与复合过程或原语过程区分开），并将控制直接转移到已编译代码的入口点。

注意在compiled-apply处继续的恢复。回想一下，求值器是如此安排的，以至于在apply-dispatch处，继续会位于栈顶。另一方面，已编译代码入口点期望继续位于continue中，所以在执行已编译代码之前必须恢复continue。

去启用我们在启动求值器机器时能够跑一些已编译代码，我们在求值器机器的开始处添加一个分支指令，若旗寄存器是集，会导致机器去走到一个新入口点。

外部入口假设机器启动时val包含一条指令序列的定位，该序列将结果放入val后以（goto (reg continue)）终。从该入口点开始会跳转到val指定的定位，但首先赋值continue以便执行会返回到print-result，其打印val中的值然后进入求值器的读取-求值-打印循环的开始。

现在我们可以使用下列过程来编译过程定义，执行已编译代码，与跑其读取-求值-打印循环能尝试该过程。因为我们想要已编译代码将其结果返回到continue中指定的定位并在val中，所以我们以val作靶和return为链接来编译表达式。为了将编译器产生的对象代码过程变形为求值器寄存器机器可执行的指令，我们使用寄存器机器模拟器中的assemble过程（第5.2.2节）。然后我们初始化val寄存器指向指令列表，集其旗使求值器走到外部入口，与启动求值器。

将此例与使用解释器版本同一过程求值 (factorial 5) 进行对比，如第5.4.4节末尾所示。解释器版本需要144次推，最大栈深度为28。这阐明了我们的编译策略所带来的优化结果。

解释与编译
有了本节中的程序，我们现在能实验解释与编译这两种替代物的执行策略。解释器将机器升起到用户程序级；编译器将用户程序降低到机器语言级。我们可以将Scheme语言（或任意编程语言）视为建立在机器语言上的抽象家庭。解释器好交互式程序开发和调试，因为程序执行步骤是被组织在它们的抽象里，因此更多可智慧给程序员。已编译代码可以执行更快，因为程序执行步骤被组织在它们的机器语言里，并且编译器可以自由进行跨越高级抽象制作优化。

解释与编译的替代物选择也导致了向新计算机移植语言的不同策略。假设我们要为新机器实现Lisp。一种策略是从第5.4节的显式控制求值器开始，翻译它的指令到指令为新机器。另一种策略是从编译器开始，改变代码生成器使其生成适用于新机器的代码。第二种策略允许我们在新机器上跑任意 Lisp 程序，方法是先用跑在原创 Lisp 系统上的编译器对其进行编译,与链接它和其运行时库的已编译版本一起.更好的是，我们能编译其编译器自身，与跑这个在其新机器上去编译其它lisp程序.或我们能编译第4.1节中的某个解释器以产生跑在新机器上的解释器(直译)过程。

练习 5.45。通过对比已编译代码用于相同计算的栈操作与求值器用于相同计算的栈操作，我们可以确定编译器在栈使用方面的优化程度，包括在速度内（简化其栈操作的总数目）和在空间内（简化其最大栈深度）。将这种已优化的栈使用与为相同计算设计的特殊目的机器的性能进行对比，可以大致反映出编译器的质量。

练习 5.49。作为使用显式控制求值器的读取-求值-打印循环的替代物，设计一个表演读取-编译-执行-打印循环的寄存器机器。也就是说，机器应跑一个循环，读取表达式，编译它，汇编与执行其结果代码，与打印其结果。在我们的已模拟环境中跑这是容易的，因为我们能通过调用其编译和汇编过程作为“寄存器机器操作”来安排。

