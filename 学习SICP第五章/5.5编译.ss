;;描述详见 5.5编译.md 
;编译与解释的区别: 解释: 分析表达式与执行其过程, 编译: 分析表达式与生成指令序列.

;5.5.1编译器的结构
(define (编译器 表达式 靶 链接)
    (cond ((自求值? 表达式)
        (编译自求值 表达式 靶 链接))
        ((已引号? 表达式)
         (编译已引号 表达式 靶 链接))
        ((变量? 表达式)
         (编译变量 表达式 靶 链接))
        ((赋值? 表达式)
         (编译赋值 表达式 靶 链接))
        ((定义? 表达式)
         (编译定义 表达式 靶 链接))
        ((若? 表达式)
         (编译若 表达式 靶 链接))
        ((入? 表达式)
         (编译入 表达式 靶 链接))
        ((开始? 表达式)
         (编译序列 (开始动作 表达式) 靶 链接))
        ((条件? 表达式)
         (编译 (条件到若 表达式) 靶 链接))
        ((应用程序? 表达式)
         (编译应用程序 表达式 靶 链接))
        (else (错误 "不懂的表达式类型 -- 编译" 表达式))))

(define (制作指令序列 需要的 修改的 语句)
    (list 需要的 修改的 语句))

(制作指令序列 '(环境 继续) '(值)
    '((赋值 值 (操作了 查找变量值) (常量 x) (寄存 环境))
    (走到 (寄存 继续))))

(define (空指令序列)
    (制作指令序列 '() '() '()))

;;5.5.2 编译表达式
;编译链接代码
(define (编译链接 链接)
    (cond ((eq? 链接 '返回)
        (制作指令序列 '(继续) '() '((走到 (寄存 继续)))))
        ((eq? 链接 '下一个)
         (空指令序列))
        (else (制作指令序列 '() '() `((走到 (标号 ,链接)))))))

(define (终与链接一起 链接 指令序列)
    (保留 '(继续) 指令序列 (编译链接 链接)))

;编译简单表达式
(define (编译自求值 表达式 靶 链接)
    (终与链接一起 链接 (制作指令序列 '() (list 靶)
    `((赋值 ,靶 (常量 ,表达式))))))
(define (编译已引号 表达式 靶 链接)
    (终与链接一起 链接 (制作指令序列 '() (list 靶)
    `((赋值 ,靶 (常量 ,(引号文本 表达式)))))))
(define (编译变量 表达式 靶 链接)
    (终与链接一起 (制作指令序列 '(环境) (list 靶)
    `((赋值 ,靶 (操作了 查找变量值) (常量 ,表达式) (寄存 环境))))))

(define (编译赋值 表达式 靶 链接)
    (let ((变量了 (赋值变量 表达式)) 
        (获取值代码 (编译 (赋值值 表达式) '值 '下一个)))
    (终与链接一起 链接 (保留 '(环境) 获取值代码 (制作指令序列 '(环境 值) (list 靶)
        `((表演 (操作了 集变量值!) 
         (常量 ,变量了) 
         (寄存 值) 
         (寄存 环境)) 
         (赋值 ,靶 (常量 没问题))))))))

(define (编译定义 表达式 靶 链接)
    (let ((变量了 (定义变量 表达式))
        (获取值代码 (编译 (定义值 表达式) '值 '下一个)))
    (终与链接一起 (保留 '(环境) 获取值代码 (制作指令序列 '(环境 值) (list 靶)
        `((表演 (操作了 定义变量!)
         (常量 变量了)
         (寄存 值)
         (寄存 环境))
         (赋值 ,靶 (常量 没问题))))))))

;;编译条件表达式
;编译给定靶和链接的 若 表达式的代码形式如下:
<谓词的编译,靶 值,链接 下一个>
(测试 (操作了 假?) (寄存 值))
(分支 (标号 假分支))
真分支
<后果的编译 和 给定靶 与 给定链接 或 若之后 一起>
假分支
<替代物的编译 和 给定靶 与 给定链接 一起>
若之后

(define (编译若 表达式 靶 链接)
    (let ((真分支 (制作标号 '真分支))
        (假分支 (制作标号 '假分支))
        (若之后 (制作标号 '若之后)))
    (let ((后果链接 (if (eq? 链接 '下一个) 若之后 链接)))
    (let ((谓词代码 (编译 (若谓词 表达式) '值 '下一个))
        (后果代码 (编译 (若后果 表达式) 靶 后果链接))
        (替代物代码 (编译 (若替代物 表达式) 靶 链接)))
    (保留 '(环境 继续) 谓词代码 (追加指令序列 (制作指令序列 '(值) '()
        `((测试 (操作了 假?) (寄存 值))
         (分支 (标号 ,假分支))))
        (平行指令序列 (追加指令序列 真分支 后果代码)
            (追加指令序列 假分支 替代物代码))
            若之后))))))


;编译序列
(define (编译序列 序列 靶 链接)
    (if (最后表达式? 序列)
        (编译 (第一个表达式 序列) 靶 链接)
        (保留 '(环境 继续)
         (编译 (第一个表达式 序列) 靶 '下一个)
         (编译序列 (剩余表达式 序列) 靶 链接))))

;编译 入 表达式
;入 表达式用于构造过程。一个 入 表达式的对象代码必须具有如下形式：
<构造过程对象 与 赋值它到靶寄存器>
<链接>

<构造过程对象 与 赋值它到靶寄存器>
<代码为给定链接> 或 (走到 (标号 入之后))
<过程物自体的编译>
入之后

(define (编译入 表达式 靶 链接)
    (let ((过程入口 (制作标号 '入口点))
        (入之后 (制作标号 '入之后)))
        (let ((入链接 (if (eq? 链接 '下一个) 入之后 链接)))
        (追加指令序列 (图钉上指令序列 (终与链接一起 入链接 (制作指令序列 '(环境) (list 靶)
         `((赋值 ,靶 (操作了 制作已编译过程)
          (标号 ,过程入口)
          (寄存 环境)))))
        (编译入物自体 表达式 过程入口))
        入之后))))

(define (编译入物自体 表达式 过程入口)
    (let ((形式们 (入形参们 表达式)))
        (追加指令序列 (制作指令序列 '(环境 过程 实参列) '(环境)
        `(,过程入口 (赋值 环境 (操作了 已编译过程环境) (寄存 过程))
         (赋值 环境 (操作了 扩展环境)
         (常量 ,形式们)
         (寄存 实参列)
         (寄存 环境))))
    (编译序列 (入物自体 表达式) '值 '返回))))

;;5.5.3 编译组合
;编译处理的本质是过程应用的编译,为组合了已编译的代码和给定靶与链接一起,有其形式:
<操作者的编译,靶过程,链接下一个>
<求值操作范围 与 构造实参列表 在实参列内>
<过程调用的编译和给定靶与链接一起>

(define (编译应用程序 表达式 靶 链接)
    (let ((过程代码 (编译 (操作者 表达式) '过程 '下一个))
        (操作范围代码们 (map (lambda (操作范围) (编译 操作范围 '值 '下一个))
            (操作范围们 表达式))))
    (保留 '(环境 继续) 过程代码 (保留 '(过程 继续)
        (构造实参列表 操作范围代码们)
        (编译过程调用 靶 链接)))))

<最后操作范围的编译,靶到值>
(赋值 实参列 (操作了 列表) (寄存 值))
<下一个操作范围的编译,靶到值>
(赋值 实参列 (操作了 cons) (寄存 值) (寄存 实参列))
...<第一个操作范围的编译,靶到值>
(赋值 实参列 (操作了 cons) (寄存 值) (寄存 实参列))

(define (构造实参列表 操作范围代码们)
    (let ((操作范围代码们 (逆向 操作范围代码们)))
        (if (null? 操作范围代码们)
            (制作指令序列 '() '(实参列)
            '((赋值 实参列 (常量 ()))))
            (let ((代码到获取最后实参 (追加指令序列 (car 操作范围代码们)
                (制作指令序列 '(值) '(实参列)
                '((赋值 实参列 (操作了 列表) (寄存 值)))))))
            (if (null? (cdr 操作范围代码们)) 代码到获取最后实参 (保留 '(环境)
                代码到获取最后实参 (代码到获取剩余实参们 (cdr 操作范围代码们))))))))

(define (代码到获取剩余实参们 操作范围代码们)
    (let ((代码为下一个实参 (保留 '(实参列)
        (car 操作范围代码们)
        (制作指令序列 '(值 实参列) '(实参列)
        '((赋值 实参列 (操作了 cons) (寄存 值) (寄存 实参列)))))))
    (if (null? (cdr 操作范围代码们))
        代码为下一个实参
        (保留 '(环境) 代码为下一个实参
        (代码到获取剩余实参们 (cdr 操作范围代码们))))))

;应用过程

(测试 (操作了 原语过程?) (寄存 过程))
(分支 (标号 原语分支))
已编译分支
<代码到应用已编译过程 和给定靶与拔出链接一起>
原语分支
(赋值 <靶> (操作了 应用原语过程)
(寄存 过程)
(寄存 实参列))
<链接>
调用之后

(define (编译过程调用 靶 链接)
    (let ((原语分支 (制作标号 '原语分支))
        (已编译分支 (制作标号 '已编译分支))
        (调用之后 (制作标号 '调用之后)))
    (let ((已编译链接
        (if (eq? 链接 '下一个)
            调用之后 链接)))
        (追加指令序列 (制作指令序列 '(过程) '()
            `((测试 (操作了 原语过程?) (寄存 过程))
             (分支 (标号 ,原语分支))))
        (平行指令序列 (追加指令序列 已编译分支
            (编译过程应用 靶 已编译链接))
            (追加指令序列 原语分支
                (终与链接一起 链接 (制作指令序列 '(过程 实参列) (list 靶)
                    `((赋值 ,靶 (操作了 应用原语过程)
                     (寄存 过程)
                     (寄存 实参列)))))))
        调用之后))))


;;应用已编译过程
 (赋值 继续 (标号 过程返回))
 (赋值 值 (操作了 已编译过程入口) (寄存 过程))
 (走到 (寄存 值))
过程返回
 (赋值 <靶> (寄存 值)) ;已包括若靶是 非 值
 (走到 (标号 <链接>)) ;链接代码

;或像这样, 若其链接是返回.
 (保存 继续)
 (赋值 继续 (标号 过程返回))
 (赋值 值 (操作了 已编译过程入口) (寄存 过程))
 (走到 (寄存 值))
过程返回
 (赋值 <靶> (寄存 值)) ;已包括若靶是 非 值,
 (恢复 继续)
 (走到 (寄存 继续)) ;链接代码

<设置继续为链接>
(赋值 值 (操作了 已编译过程入口) (寄存 过程))
(走到 (寄存 值))

;如果链接是一个标号，我们就设置continue，使得过程将返回到那个标号。（也就是说，过程结尾处的 (goto (reg continue)) 变成了等同于上述proc-return处的 (goto (label <linkage>))。）
(赋值 继续 (标号 <链接>))
(赋值 值 (操作了 已编译过程入口) (寄存 过程))
(走到 (寄存 值))

;如果链接是return，我们根本不需要设置continue：它已经手持其渴望定位。（也就是说，过程结尾处的 (goto (reg continue)) 直接跳转到原本在proc-return处的 (goto (reg continue)) 会去的地方。）
(赋值 值 (操作了 已编译过程入口) (寄存 过程))
(走到 (寄存 值))

(define (编译过程应用 靶 链接)
    (cond 
        ((and (eq? 靶 '值) (not (eq? 链接 '返回)))
            (制作指令序列 '(过程) 全部寄存们
                `((赋值 继续 (标号 ,链接))
                 (赋值 值 (操作了 已编译过程入口) (寄存 过程))
                 (走到 (寄存 值)))))
        ((and (not (eq? 靶 '值)) (not (eq? 链接 '返回)))
            (let ((过程返回 (制作标号 '过程返回)))
                (制作指令序列 '(过程) 全部寄存们
                    `((赋值 继续 (标号 ,过程返回))
                     (赋值 值 (操作了 已编译过程入口) (寄存 过程))
                     (走到 (寄存 值))
                     ,过程返回
                     (赋值 ,靶 (寄存 值))
                     (走到 (标号 ,链接))))))
        ((and (eq? 靶 '值) (eq? 链接 '返回))
            (制作指令序列 '(过程 继续) 全部寄存们
                '((赋值 值 (操作了 已编译过程入口) (寄存 过程))
                 (走到 (寄存 值)))))
        ((and (not (eq? 靶 '值)) (eq? 链接 '返回))
            (错误 "返回链接, 靶非值 -- 编译" 靶))))

#|
单引号 '
反引号 `
逗号 ,

没想到是三种不同的操作者.
我搞混了,竟然都用单引号, 险些大错.
都怪没有看PDF版本的SICP,
没想到代码里的句法高亮, 排版里代码格式样式的显式, 如此重要.
一步错步步错.

一些呓语_臆想,
找到了!我找到了永生的实现方法.
问题的关键在于干细胞,
人类该如何掌握干细胞的能力.这是第一,
第二是,忒休斯之船的哲学,这也可以称之为不断替换_逐渐替换,
可以视为是迭代,但是一种微观操作层面的迭代.
还要一种能力,使用编程的方式,从程序层面来复制对干细胞的控制.
但首先要破解干细胞的能力_作用_如何掌握,这需要人类掌握的最高级工具;群体智慧_集群智能.
需要一种新的全功能通用处理器,一种抽象可移植的通用编程平台,
一种接近AGI的全功能大模型,让编程完全实现自动化,
最后把这些整合到一个硬件内,并做得极为便宜,卖到80亿人手里,
使得人手一个,在这个基础上实现自组织的群体智慧_集群智能.
使用这种工具来分析_学习干细胞的能力,理解干细胞这种知识.
最终达到目的-实现永生.
身体里的细胞通过各种干细胞(包括神经细胞),不断地实现忒休斯之船哲学,
这个过程中,利用干细胞无限更新,能永恒复制自身的功能,像忒休斯之船一样不断替换_逐渐替换人体细胞,以此达到永生的实现.

这个方法利用了可编程的灵活型,不单单是写代码编程,原来干细胞也是一种可编程的原语.

我看到干细胞除了能复制已有_已知细胞的能力外,它还有创造出全新的细胞这种能力,这让我瞬间意识到,超能力是可以被人类创造出来的,
人类可以通过干细胞设计出人类本身不具备的细胞,进而器官,直到实现各色各样的超能力,我好像理解到了工程师文明那高超的生物学科技是怎么实现的了.
原来根本不需要深入到基因层级甚至原子层级,仅仅是对细胞层级的研究,就能让人类得到梦寐以求的东西,并解决人类社会面临的所有问题,
碳基真是宝贵的资源,按照西方人读写字母文明的单线程思维,完全无视和浪费了碳基的强大,
星际争霸里的异虫_虫族文明,就是基于碳基进行自由进化,一样获得了利用恒星能量,并进化到宇宙级生命,星系级文明.
碳基只要稍微改造就能获得适应宇宙生活的能力,零下200度,还是零上1亿度,不管是真空还是强酸,碳基的灵活型远超硅基,
突然意识到,人类要是再任由西方人读写字母文明的单线程思维来领导人类前进,那就真是要科技树点歪,无法突破费米悖论的大过滤器了. |#

;;5.5.4 组合指令序列
(define (寄存器已需要 丝)
    (if (符号? 丝) '() (car 丝)))

(define (寄存器已修改 丝)
    (if (符号? 丝) '() (cadr 丝)))

(define (语句们 丝)
    (if (符号? 丝) (list 丝) (caddr 丝)))

;并且，为了确定给定的序列是否需要或修改了某个给定的寄存器，我们使用谓词（predicates）。
(define (需要的寄存器? 序列了 寄存)
    (memq 寄存 (寄存器已需要 序列了)))

(define (修改的寄存器? 序列了 寄存)
    (memq 寄存 (寄存器已修改 序列了)))

(define (追加指令序列 . 序列们)
    (define (追加2序列 序列1 序列2)
        (制作指令序列
            (列表联合 (寄存器已需要 序列1)
            (列表不同 (寄存器已需要 序列2)
                (寄存器已修改 序列1)))
            (列表联合 (寄存器已修改 序列1)
                (寄存器已修改 序列2))
            (追加 (语句们 序列1) (语句们 序列2))))
    (define (追加序列列表 序列们)
        (if (null? 序列们)
            (空指令序列)
            (追加2序列 (car 序列们) (追加序列列表 (cdr 序列们)))))
    (追加序列列表 序列们))

;这个过程使用了一些简单的操作来操纵以列表形式表示的集合，类似于在第2.3.3节中描述的（无序的）集合表示方法：
(define (列表联合 丝1 丝2)
    (cond ((null? 丝1) 丝2)
        ((memq (car 丝1) 丝2) (列表联合 (cdr 丝1) 丝2))
        (else (cons (car 丝1) (列表联合 (cdr 丝1) 丝2)))))

(define (列表不同 丝1 丝2)
    (cond ((null? 丝1) '())
        ((memq (car 丝1) 丝2) (列表不同 (cdr 丝1) 丝2))
        (else (cons (car 丝1) (列表不同 (cdr 丝1) 丝2)))))

(define (保留 寄存们 序列1 序列2)
    (if (null? 寄存们)
        (追加指令序列 序列1 序列2)
        (let ((第一个寄存 (car 寄存们)))
            (if (and (需要的寄存器? 序列2 第一个寄存) (修改的寄存器? 序列1 第一个寄存))
                (保留 (cdr 寄存们)
                    (制作指令序列 (列表联合 (list 第一个寄存) (寄存器已需要 序列1))
                        (列表不同 (寄存器已修改 序列1) (list 第一个寄存))
                        (追加 `((保存 ,第一个寄存))
                            (语句们 序列1)
                            `((恢复 ,第一个寄存))))
                    序列2)
                (保留 (cdr 寄存们) 序列1 序列2)))))

(define (图钉上指令序列 序列了 物自体序列)
    (制作指令序列
        (寄存器已需要 序列了) (寄存器已修改 序列了)
        (追加 (语句们 序列了) (语句们 物自体序列))))

(define (平行指令序列 序列1 序列2)
    (制作指令序列
        (列表联合 (寄存器已需要 序列1) (寄存器已需要 序列2))
        (列表联合 (寄存器已修改 序列1) (寄存器已修改 序列2))
        (追加 (语句们 序列1) (语句们 序列2))))

;;5.5.5 一个已编译代码的例子
;现在我们已经看到了编译器的所有元素，让我们来检查一个编译代码的例子，看看这些元素是如何组合在一起的。我们将通过调用compile来编译一个递归阶乘过程的定义
(编译
    '(define (阶乘 数)
        (if (= 数 1)
            1
            (* (阶乘 (- 数 1)) 数)))
    '值
    '下一个)

<保存环境若已修改通过代码到计算值>
<定义值的编译,靶值,链接下一个>
<恢复环境若已保存上面>
(表演 (操作了 定义变量!)
    (常量 阶乘)
    (寄存 值)
    (寄存 环境))
(赋值 值 (常量 没问题))

 (赋值 值 (操作了 制作已编译过程)
    (标号 入口2)
    (寄存 环境))
 (走到 (标号 入1之后))
入口2
 (赋值 环境 (操作了 已编译过程环境) (寄存 过程))
 (赋值 环境 (操作了 扩展环境)
    (常量 (数))
    (寄存 实参列)
    (寄存 环境))
 <过程物自体的编译>
入1之后
 (表演 (操作了 定义变量!)
    (常量 阶乘)
    (寄存 值)
    (寄存 环境))
 (赋值 值 (常量 没问题))

;一个过程物自体总是被编译（通过compile-lambda-body）为一个目标为val且链接方式为return的序列。在这个情况下的序列由一个单一的if表达式组成
(if (= 数 1)
    1
    (* (阶乘 (- 数 1)) 数))

<保存继续,环境若已修改通过谓词与已需要通过分支们>
<谓词的编译,靶值,链接下一个>
<恢复继续,环境若已保存上面>
 (测试 (操作了 假?) (寄存 值))
 (分支 (标号 假分支4))
真分支5
 <真分支的编译,靶值,链接返回>
假分支4
 <假分支的编译,靶值,链接返回>
若之后3

 (赋值 过程 (操作了 查找变量值) (常量 =) (寄存 环境))
 (赋值 值 (常量 1))
 (赋值 实参列 (操作了 列表) (寄存 值))
 (赋值 值 (操作了 查找变量值) (常量 数) (寄存 环境))
 (赋值 实参列 (操作了 cons) (寄存 值) (寄存 实参列))
 (测试 (操作了 原语过程?) (寄存 过程))
 (分支 (标号 原语分支17))
已编译分支16
 (赋值 继续 (标号 调用之后15))
 (赋值 值 (操作了 已编译过程入口) (寄存 过程))
 (走到 (寄存 值))
原语分支17
 (赋值 值 (操作了 应用原语过程) (寄存 过程) (寄存 实参列))
调用之后15

;其真分支，即常量1，编译时（和靶_值与链接_返回一起）会生成如下代码
(赋值 值 (常量 1))
(走到 (寄存 继续))

;;5.5.6 词法地址
(let ((甲 3) (乙 4))
    (lambda (金 木 水 火 土)
        (let ((乙 (* 金 木 甲))
            (丙 (+ 水 火 甲)))
        (* 甲 乙 乙))))

;由于let表达式仅是lambda组合的句法糖，因此这个表达式等价于：
((lambda (甲 乙)
    (lambda (金 木 水 火 土)
        ((lambda (乙 丙) (* 甲 乙 丙))
            (* 金 木 甲)
            (+ 水 火 甲))))
    3 4)

((lambda (甲 乙)
    (lambda (金 木 水 火 土)
        ((lambda (乙 丙) <e1>)
        <e2>
        (+ 水 火 甲))))
    3 4)


#|
wasm网汇,就是编译为16进制表示的机器码,也执行的是16进制表示的机器码.
wasm虚拟机的解释器,充当CPU前端的功能与作用,只不过是用纯软件的形式,纯逻辑的形式实现.
需要特别说明的是,wasm虚拟机执行的不是字节码,而是机器码,
它跟JVM v8 cPython这些虚拟机是不一样的,
把wasm的16进制表示的机器码反汇编出来,就得到了wat,像lisp的符号表达式一样的汇编代码形式.
它也可以充当一种中间码, 比LLVM IR要简单很多,
LLVM IR与wasm的价值几乎一样,只不过LLVM IR是用C++与静态单赋值构成,
比wasm复杂很多倍.
|#

;;5.5.7 其求值器的已编译代码接口
;我们还没有解说如何将编译后的代码加载到求值器中或者如何跑它。
;我们将假设显式控制求值器机器已经按照第5.4.4节定义好了，
;并且包含了注脚38中指定的附加操作。
;我们将实现一个叫做compile-and-go的过程，
;这个过程编译一个Scheme表达式，载入其结果对象代码到求值器机器中，
;并使机器在求值器的全局环境中跑该代码，打印结果，并进入求值器的驱动环。
;我们还会修改求值器，使得被解释的表达式能够调用已编译的过程以及已解释的过程。
;这样我们就可以把一个已编译过程放入机器中，并使用求值器来调用它。

(编译与走
    '(define (阶乘 数)
        (if (= 数 1)
            1
            (* (阶乘 (- 数 1)) 数))))

;;显控求值_值:
没问题
;;显控求值_输入:
(阶乘 5)
;;显控求值_值:
120

;为了让求值器能够处理已编译过程们（例如，求值上述对阶乘的调用），
;我们需要更改apply-dispatch（见5.4.1节）处的代码，
;使其能够识别已编译过程们（将其与复合过程或原语过程区分开），并将控制直接转移到已编译代码的入口点。

应用调度
 (测试 (操作了 原语过程?) (寄存 过程))
 (分支 (标号 原语应用))
 (测试 (操作了 复合过程?) (寄存 过程))
 (分支 (标号 复合应用))
 (测试 (操作了 已编译过程?) (寄存 过程))
 (分支 (标号 已编译应用))
 (走到 (标号 不懂过程类型))
已编译应用
 (恢复 继续)
 (赋值 值 (操作了 已编译过程入口) (寄存 过程))
 (走到 (寄存 值))


;注意在compiled-apply处继续的恢复。回想，求值器安排使在apply-dispatch处，继续位于栈顶。
;另一方面，已编译代码入口点期望继续位于continue中，故在执行已编译代码前必须恢复continue。
;为使我们启动求值器机器时能跑已编译代码，我们在求值器机器开始处添加分支指令，
;若旗寄存器是集，则机器走到新入口点。
 (分支 (标号 外部入口)) ;分支们若旗是集
读求值印环
 (表演 (操作了 初始化栈))
 ...

外部入口
 (表演 (操作了 初始化栈))
 (赋值 环境 (操作了 获取全局环境))
 (赋值 继续 (标号 打印结果))
 (走到 (寄存 值))

(define (编译与走 表达式)
    (let ((指令们
        (汇编 (语句们
            (编译 表达式 '值 '返回))
            显式控制求值)))
    (集! 其全局环境 (设置环境))
    (集寄存器内容! 显式控制求值 '值 指令们)
    (集寄存器内容! 显式控制求值 '旗 真)
    (起始 显式控制求值)))

;若我们设置了栈监视，如同第5.4.4节末尾所述，我们能检验已编译代码的栈用法。
(编译与走
    '(define (阶乘 数)
        (if (= 数 1)
            1
            (* (阶乘 (- 数 1)) 数))))

(总推 = 0 最大深度 = 0)
;;显控求值_值:
没问题
;;显控求值_输入:
(阶乘 5)
(总推 = 31 最大深度 = 14)
;;显控求值_值:
120

;将此例与使用解释器版本同一过程求值 (factorial 5) 进行对比，如第5.4.4节末尾所示。
;解释器版本需要144次推，最大栈深度为28。这阐明了我们的编译策略所带来的优化结果。

;解释与编译  ;原来解释还有另一个意思-直译.

#|
有了本节中的程序，我们现在能实验解释与编译这两种替代物的执行策略。
解释器将机器升起到用户程序级；编译器将用户程序降低到机器语言级。
我们可以将Scheme语言（或任意编程语言）视为建立在机器语言上的抽象家庭。
解释器好交互式程序开发和调试，因为程序执行步骤是被组织在它们的抽象里，因此更多可智慧给程序员。
已编译代码可以执行更快，因为程序执行步骤被组织在它们的机器语言里，并且编译器可以自由进行跨越高级抽象制作优化。

解释与编译的替代物选择也导致了向新计算机移植语言的不同策略。
假设我们要为新机器实现Lisp。一种策略是从第5.4节的显式控制求值器开始，翻译它的指令到指令为新机器。
另一种策略是从编译器开始，改变代码生成器使其生成适用于新机器的代码。
第二种策略允许我们在新机器上跑任意 Lisp 程序，方法是先用跑在原创 Lisp 系统上的编译器对其进行编译,与链接它和其运行时库的已编译版本一起.
更好的是，我们能编译其编译器自身，与跑这个在其新机器上去编译其它lisp程序.
或我们能编译第4.1节中的某个解释器以产生跑在新机器上的解释器(直译)过程。
|#

#|
练习 5.45。通过对比已编译代码用于相同计算的栈操作与求值器用于相同计算的栈操作，
我们可以确定编译器在栈使用方面的优化程度，包括在速度内（简化其栈操作的总数目）和在空间内（简化其最大栈深度）。
将这种已优化的栈使用与为相同计算设计的特殊目的机器的性能进行对比，可以大致反映出编译器的质量。

练习 5.49。作为使用显式控制求值器的[读取-求值-打印循环]的替代物，设计一个表演[读取-编译-执行-打印循环]的寄存器机器。
也就是说，机器应跑一个循环，读取表达式，编译它，汇编与执行其结果代码，与打印其结果。
在我们的已模拟环境中跑这是容易的，因为我们能通过调用其编译和汇编过程作为“寄存器机器操作”来安排。
|#

