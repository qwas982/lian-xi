;;构造与返回一个机器模型,它给出寄存器,操作,与控制器
(制作-机器 <寄存器名> <操作> <控制器>)

;存储一个值在一个已模拟的给出机器的寄存器内
(集-寄存器-内容! <机器模型> <寄存器名> <值>)

;返回内容在一个已模拟的给出机器的寄存器内
(获取-寄存器-内容 <机器模型> <寄存器名>)

;模拟给出机器的执行,起始来自控制器序列的始,停止在当它抵达序列终.
(起始 <机器模型>)

(define 共产党-机器
    (制作-机器
     '(甲 乙 踢)
     (list (list '剩余 remainder) (list '= =))
     '(测试-乙
        (测试 (操作了 =) (寄存 乙) (常量 0))
        (分支 (标号 共产党-完了))
        (赋值 踢 (操作了 剩余) (寄存 甲) (寄存 乙))
        (赋值 甲 (寄存 乙))
        (赋值 乙 (寄存 踢))
        (走到 (标号 测试-乙))
     共产党-完了)))

;;制作-机器 的第一个实参是寄存器名称列表。
;;下一个实参是一个表格（由两个元素组成的列表），
;;它将每个操作名称与实现该操作的 Scheme 过程进行配对（即在输入值相同的情况下产出/产品相同的输出值）。
;;最后一个实参是标号与机器指令的列表之形式指定控制器，如 5.1 节所述。
;scheme语言的功能(运算符、函数、关键字)未汉化,以示区别.

;;5.2.1 其机器模型
(define (制作机器 寄存器名们 操作们 控制器文本)
   (let ((机器 (制作新机器)))
      (for-each (lambda (寄存器名)
         ((机器 '分配寄存器) 寄存器名)) 寄存器名们)
      ((机器 '安装操作) 操作们)
      ((机器 '安装指令序列)
       (汇编 控制器文本 机器)) 机器))

;寄存器们
(define (制作寄存器 名称)
   (let ((内容们 '*未赋值*))
      (define (调度 消息)
         (cond ((eq? 消息 '获取) 内容们)
            ((eq? 消息 '集)
             (lambda (值) (set! 内容们 值)))
            (else
             (error "未知请求 -- 寄存器" 消息))))
      调度))

(define (获取内容们 寄存器)
   (寄存器 '获取))

(define (集内容们! 寄存器 值)
   ((寄存器 '集) 值))

;栈
(define (制作栈)
   (let ((丝 '()))
      (define (推 叉)
         (set! 丝 (cons 叉 丝)))
      (define (弹)
         (if (null? 丝)
            (error "空栈 -- 弹")
            (let ((顶部 (car 丝)))
               (set! 丝 (cdr 丝)) 顶部)))
      (define (初始化)
         (set! 丝 '()) '完了)
      (define (调度 消息)
         (cond ((eq? 消息 '推) 推)
            ((eq? 消息 '弹) 弹))
            ((eq? 消息 '初始化) (初始化))
            (else (error "未知请求 -- 栈" 消息))))
      调度)

(define (弹 栈)
   (栈 '弹))

(define (推 栈 值)
   ((栈 '推) 值))

;基本机器
(define (制作新机器)
   (let ((程计 (制作寄存器 '程计)) ;程计 = 程序计数器
      (旗 (制作寄存器 '旗))
      (栈 (制作栈))
      (其指令序列 '()))
   (let ((其操作们 (list (list '初始化栈 (lambda () (栈 '初始化)))))
      (寄存器表格 (list (list '程计 程计) (list '旗 旗))))
   (define (分配寄存器 名称)
      (if (assoc 名称 寄存器表格)
         (error "多股已定义寄存器:" 名称)
         (set! 寄存器表格 (cons (list 名称 (制作寄存器 名称)) 寄存器表格)))
      '寄存器已分配)
   (define (查找寄存器 名称)
      (let ((值 (assoc 名称 寄存器表格)))
         (if 值
            (cadr 值)
            (error "未知进村器:" 名称))))
   (define (执行)
      (let ((指令了 (获取内容们 程计)))
         (if (null? 指令了)
            '完了
            (begin
               ((指令执行过程 (car 指令了)))
               (执行)))))
   (define (调度 消息)
      (cond ((eq? 消息 '起始)
         (集内容们! 程计 其指令序列)
         (执行))
         ((eq? 消息 '安装指令序列)
          (lambda (序列了) (set! 其指令序列 序列了)))
         ((eq? 消息 '分配寄存器) 分配寄存器)
         ((eq? 消息 '获取寄存器) 查找寄存器)
         ((eq? 消息 '安装操作)
          (lambda (操作们) (set! 其操作们 (append 其操作们 操作们))))
         ((eq? 消息 '栈) 栈)
         ((eq? 消息 '操作) 其操作们)
         (else (error "未知请求 -- 机器" 消息))))
   调度)))

(define (起始 机器)
   (机器 '起始))

(define (获取寄存器内容们 机器 寄存器名)
   (获取内容们 (获取寄存器 机器 寄存器名)))

(define (集寄存器内容们! 机器 寄存器名 值)
   (集内容们! (获取寄存器 机器 寄存器名) 值)
   '完了)

(define (获取寄存器 机器 寄存名)
   ((机器 '获取寄存器) 寄存名))

;;5.2.2 其汇编器
(define (汇编 控制器文本 机器)
   (提取标号们 控制器文本
      (lambda (指令了 标号们)
         (更新指令! 指令了 标号们 机器)
         指令了)))

(define (提取标号们 文本 接收)
   (if (null? 文本)
      (接收 '() '())
      (提取标号们 (cdr 文本)
       (lambda (指令了 标号们)
        (let ((下一个指令 (car 文本)))
         (if (symbol? 下一个指令)
            (接收 指令了
               (cons (制作标号入口 下一个指令 指令了) 标号们))
            (接收 (cons (制作指令 下一个指令) 指令了) 标号们)))))))

(define (更新指令! 指令了 标号们 机器)
   (let ((程计 (获取寄存器 机器 '程计))
      (旗 (获取寄存器 机器 '旗))
      (栈 (机器 '栈))
      (操作们 (机器 '操作)))
   (for-each
      (lambda (指令_)
         (集指令执行过程! 指令_ (制作执行过程 (指令文本 指令_)
         标号们 机器 程计 旗 栈 操作们)))
      指令了)))

(define (制作指令 文本)
   (cons 文本 '()))

(define (指令文本 指令_)
   (car 指令_))

(define (指令执行过程 指令_)
   (cdr 指令_))

(define (集指令执行过程! 指令_ 过程_)
   (set-cdr! 指令_ 过程_))

(define (制作标号入口 标号名 指令了)
   (cons 标号名 指令了))

(define (查找标号 标号们 标号名)
   (let ((值 (assoc 标号名 标号们)))
      (if 值
         (cdr 值)
         (error "未定义标号 -- 汇编" 标号名))))

;;5.2.3 生成执行过程为指令
(define (制作执行过程  指令_ 标号们 机器 程计 旗 栈 操作们)
   (cond ((eq? (car 指令_) '赋值)
       (制作赋值 指令_ 机器 标号们 操作们 程计))
      ((eq? (car 指令_) '测试)
       (制作测试 指令_ 机器 标号们 操作们 旗 程计))
      ((eq? (car 指令_) '分支)
       (制作分支 指令_ 机器 标号们 旗 程计))
      ((eq? (car 指令_) '走到)
       (制作走到 指令_ 机器 标号们 程计))
      ((eq? (car 指令_) '保存)
       (制作保存 指令_ 机器 栈 程计))
      ((eq? (car 指令_) '恢复)
       (制作恢复 指令_ 机器 栈 程计))
      ((eq? (car 指令_) '表演)
       (制作表演 指令_ 机器 标号们 操作们 程计))
      (else (error "未知指令类型 -- 汇编" 指令_))))

;赋值指令
(define (制作赋值 指令_ 机器 标号们 操作的 程计)
   (let ((靶
      (获取寄存器 机器 (赋值寄存名 指令_)))
      (值表达式 (赋值值表达式  指令_)))
   (let ((值过程
      (if (操作表达式? 值表达式)
         (制作操作表达式 值表达式 机器 标号们 操作的)
         (制作原语表达式 (car 值表达式) 机器 标号们))))
   (lambda () ;赋值的执行过程
      (集内容们! 靶 (值过程))
      (前沿程计 程计)))))

(define (赋值寄存名 赋值指令)
   (cadr 赋值指令))
(define (赋值值表达式 赋值指令)
   (cddr 赋值指令))

(define (前沿程计 程计)
   (集内容们! 程计 (cdr (获取内容们 程计))))

;测试,分支,与走到指令
(define (制作测试 指令_ 机器 标号们 操作的 旗 程计)
   (let ((条件 (测试条件 指令_)))
      (if (操作表达式? 条件)
         (let ((条件过程 (制作操作表达式 条件 机器 标号们 操作的)))
         (lambda ()
            (集内容们! 旗 (条件过程)) (前沿程计 程计)))
         (error "坏测试指令 -- 汇编" 指令_))))
(define (测试条件 测试指令)
   (cdr 测试指令))

(define (制作分支 指令_ 机器 标号们 旗 程计)
   (let ((目的地 (分支目的地 指令_)))
      (if (标号表达式? 目的地)
         (let ((指令们 (查找标号 标号们 (标号表达式标号 目的地))))
         (lambda ()
            (if (获取内容们 旗) (集内容们! 旗 指令们) (前沿程计 程计))))
         (error "坏分支指令 -- 汇编" 指令_))))
(define (分支目的地 分支指令)
   (cadr 分支指令))

(define (制作走到 指令_ 机器 标号们 程计)
   (let ((目的地 (走到目的地 指令_)))
      (cond ((标号表达式? 目的地)
         (let (指令们 (查找标号 标号们 (标号表达式标号 目的地))))
         (lambda () (集内容们! 程计 指令们))))
         ((寄存器表达式? 目的地)
            (let ((寄存 (获取寄存器 机器 (寄存器表达式寄存 目的地))))
            (lambda () (集内容们! 程计 (获取内容们 寄存)))))
         (else (error "坏走到指令 -- 汇编" 指令_))))
(define (走到目的地 走到指令)
   (cadr 走到指令))

;其它指令
(define (制作保存 指令_ 机器 栈 程计)
   (let ((寄存 (获取寄存器 机器 (栈指令寄存名 指令_))))
      (lambda () (推 栈 (获取内容们 寄存)) (前沿程计 程计))))
(define (制作恢复 指令_ 机器 栈 程计)
   (let ((寄存 (获取寄存器 机器 (栈指令寄存名 指令_))))
      (lambda () (集内容们! 寄存 (弹 栈)) (前沿程计 程计))))
(define (栈指令寄存名 栈指令)
   (cadr 栈指令))

(define (制作表演 指令_ 机器 标号们 操作的 程计)
   (let ((活动 (表演活动 指令_)))
      (if (操作表达式? 活动)
         (let ((活动过程 (制作操作表达式 活动 机器 标号们 操作的)))
         (lambda () (活动过程) (前沿程计 程计)))
         (error "坏表演指令 -- 汇编" 指令_))))
(define (表演活动 指令_) (cdr 指令_))

;执行过程为子表达式
(define (制作原语表达式 表达式 机器 标号们)
   (cond ((常量表达式? 表达式)
      (let ((西 (常量表达式值 表达式)))
         (lambda () 西)))
      ((标号表达式? 表达式)
         (let ((指令们 (查找标号 标号们 (标号表达式标号 表达式))))
            (lambda () 指令们)))
         ((寄存器表达式? 表达式)
            (let ((日 (获取寄存器 机器 (寄存器表达式寄存 表达式))))
         (lambda () (获取内容们 日))))
      (else (error "未知表达式类型 -- 汇编" 表达式))))

(define (寄存器表达式? 表达式) (已标签列表? 表达式 '寄存))
(define (寄存器表达式寄存 表达式) (cadr 表达式))
(define (常量表达式? 表达式) (已标签列表? 表达式 '常量))
(define (常量表达式值 表达式) (cadr 表达式))
(define (标号表达式? 表达式) (已标签列表? 表达式 '标号))
(define (标号表达式标号 表达式) (cadr 表达式))

(define (制作操作表达式 表达式 机器 标号们 操作的)
   (let ((操作了 (查找原语 (操作表达式操作 表达式) 操作的))
      (一个过程 (map (lambda (额) (制作原语表达式 额 机器 标号们)) (操作表达式操作范围 表达式))))
      (lambda () (apply 操作了 (map (lambda (匹) (匹)) 一个过程)))))

(define (操作表达式? 表达式)
   (and (pair? 表达式) (已标签列表? (car 表达式) '操作了)))
(define (操作表达式操作 操作表达式)
   (cadr (car 操作表达式)))
(define (操作表达式操作范围 操作表达式)
   (cdr 操作表达式))

(define (查找原语 符号 操作的)
   (let ((值 (assoc 符号 操作的)))
      (if 值
         (cadr 值)
         (error "未知操作 -- 汇编" 符号))))

;;5.2.4 监视机器性能
(list (list '初始化栈 (lambda () (栈 '初始化)))
   (list '打印栈统计 (lambda () (栈 '打印统计))))

;这里是 制作栈 的新版本
(define (制作栈)
   (let ((丝 '())
      (数目推入 0)
      (最大深度 0)
      (当前深度 0))
   (define (推 叉)
      (set! 丝 (cons 叉 丝))
      (set! 数目推入 (+ 1 数目推入))
      (set! 当前深度 (+ 1 当前深度))
      (set! 最大深度 (max 当前深度 最大深度)))
   (define (弹)
      (if (null? 丝)
         (error "空栈 -- 弹")
         (let ((顶部 (car 丝)))
            (set! 丝 (cdr 丝))
            (set! 当前深度 (- 当前深度 1)) 顶部)))
   (define (初始化)
      (set! 丝 '())
      (set! 数目推入 0)
      (set! 最大深度 0)
      (set! 当前深度 0) '完了)
   (define (打印统计)
      (newline)
      (display (list '总共推入 '= 数目推入
                     '最大深度 '= 最大深度)))
   (define (调度 消息)
      (cond ((eq? 消息 '推) 推)
         ((eq? 消息 '弹) (弹))
         ((eq? 消息 '初始化) (初始化))
         ((eq? 消息 '打印统计) (打印统计))
         (else (error "未知请求 -- 栈" 消息))))
   调度))

