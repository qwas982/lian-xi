'''有用指令的收集内容,或机器原语'''

import 错误们

def _断言数目(*实参们):
    import 解释器
    for 实参 in 实参们:
        if not 解释器.是否数目(实参):
            raise 错误们.机器错误("非一个整数: %s" % str(实参))
        
def _断言布尔(*实参们):
    import 解释器
    for 实参 in 实参们:
        if not 解释器.是否布尔(实参):
            raise 错误们.机器错误("非一个布尔: %s" % str(实参))
        
def _断言二元(*实参们):
    import 解释器
    for 实参 in 实参们:
        if not 解释器.是否二元(实参):
            raise 错误们.机器错误("非布尔或数值: %s" % str(实参))
            
def 加法(虚机):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言数目(甲, 乙)
    虚机.推(甲 + 乙)

def 减法(虚机):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言数目(甲, 乙)
    虚机.推(乙 - 甲)

def 调用(虚机):
    虚机.返回栈.推(虚机.指令指针)
    跳(虚机)

def 返回_(虚机):
    虚机.指令指针 = 虚机.返回栈.弹()

def 乘法(虚机, 模数=None):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言数目(甲, 乙)

    if 模数 is None:
        虚机.推(甲 * 乙)
    else:
        虚机.推((甲 * 乙) % 模数)

def 除法(虚机):
    除数 = 虚机.弹()
    被除数 = 虚机.弹()
    _断言数目(被除数, 除数)
    if 除数 == 0:
        raise 错误们.机器错误(ZeroDivisionError("除零"))
    虚机.推(被除数 / 除数)

def 取模(虚机):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言数目(甲, 乙)
    if 甲 == 0:
        raise 错误们.机器错误(ZeroDivisionError("除零"))
    虚机.推(乙 % 甲)

def 绝对值_(虚机):
    _断言二元(虚机.顶部)
    虚机.推(abs(虚机.弹()))

def 无操作(虚机):
    '''无操作: 啥都不做'''
    pass

def 出口(虚机):
    raise StopIteration

def 副本(虚机):
    虚机.推(虚机.顶部)

def 超过(虚机):
    乙 = 虚机.弹()
    甲 = 虚机.弹()
    虚机.推(甲)
    虚机.推(乙)
    虚机.推(甲)

def 落下(虚机):
    虚机.弹()

def 交换(虚机):
    乙 = 虚机.弹()
    甲 = 虚机.弹()
    虚机.推(乙)
    虚机.推(甲)

def 旋转(虚机):
    '''旋转顶端三个物品一次, 到其左边. (甲 乙 丙 -- 乙 丙 甲)'''
    丙 = 虚机.弹()
    乙 = 虚机.弹()
    甲 = 虚机.弹()
    虚机.推(乙)
    虚机.推(丙)
    虚机.推(甲)

def 返回栈在(虚机):
    '''弹出返回栈顶与推入数据栈上'''
    虚机.推(虚机.数据栈.弹())

def 来自返回栈(虚机):
    '''复制返回栈顶与推入数据栈上'''
    虚机.推(虚机.数据栈.顶部)

def 写(虚机, 刷新=True):
    值 = str(虚机.弹())
    try:
        if 虚机.输出 is not None:
            虚机.输出.write(值)
            if 刷新:
                虚机.输出.flush()
    except IOError:
        raise 错误们.机器错误(StopIteration)
    
def 在(虚机):
    '''推前一个位置到返回栈'''
    虚机.返回栈.推(虚机.指令指针 - 1)

def 点(虚机, 刷新=True):
    写(虚机, 刷新=False)
    try:
        if 虚机.输出 is not None:
            虚机.输出.write("\n")
            if 刷新:
                虚机.输出.flush()
    except IOError:
        raise 错误们.机器错误(IOError)
    
def 读(虚机):
    行 = 虚机.输入.readline().rstrip()
    虚机.推(行)

    #为了与依赖 raw_input 升起 EOFError 的旧代码兼容, 我们暂时也应该这样做(以后我们应该使用另一种机制
    if 行 == "":
        raise EOFError()
    
def 转换浮点(虚机):
    try:
        float(虚机.顶部)
    except ValueError:
        raise 错误们.机器错误("不能被转换到浮点: '%s'" % str(虚机.顶部))
    
def 转换整型(虚机):
    try:
        int(虚机.顶部)
    except ValueError:
        raise 错误们.机器错误("不能被转换到整型: '%s'" % str(虚机.顶部))
    else:
        虚机.推(int(虚机.弹()))

def 转换布尔(虚机):
    try:
        bool(虚机.顶部)
    except ValueError:
        raise 错误们.机器错误("不能被转换到布尔: '%s'" % str(虚机.顶部))
    else:
        虚机.推(bool(虚机.弹()))

def 转换串(虚机):
    try:
        虚机.推(str(虚机.弹()))
    except ValueError as 错了:
        raise 错误们.机器错误(错了)
    
def 等号(虚机):
    虚机.推(虚机.弹() == 虚机.弹())

def 不等(虚机):
    虚机.推(虚机.弹() != 虚机.弹())

def 小于(虚机):
    甲 = 虚机.弹()
    虚机.推(甲 < 虚机.弹())

def 小等(虚机):
    甲 = 虚机.弹()
    虚机.推(甲 <= 虚机.弹())

def 大等(虚机):
    甲 = 虚机.弹()
    虚机.推(甲 >= 虚机.弹())

def 大于(虚机):
    甲 = 虚机.弹()
    虚机.推(甲 > 虚机.弹())

def 真_(虚机):
    虚机.推(True)

def 假_(虚机):
    虚机.推(False)

def 若语句(虚机):
    import 解释器
    假子句 = 虚机.弹()
    真子句 = 虚机.弹()
    测试 = 虚机.弹()

    # 假值: 假, 0, "", 每个否则是真
    if 解释器.是否布尔(测试) and 测试 == False:
        结果 = False
    elif 解释器.是否字符串(测试) and len(测试) == 0:
        结果 = False
    elif 解释器.是否数目(测试) and 测试 == 0:
        结果 = False
    else:
        结果 = True

    if 结果 == True:
        虚机.推(真子句)
    else:
        虚机.推(假子句)

def 跳(虚机):
    if not (isinstance(虚机.顶部, int) or isinstance(虚机.顶部, long)): # long型是兼容py2.0
        raise 错误们.机器错误("跳的地址必须是一个整数: %s" % str(虚机.顶部))
    地址 = 虚机.弹()
    if 0 <= 地址 < len(虚机.代码):
        虚机.指令指针 = 地址
    else:
        raise 错误们.机器错误("跳的地址出范围: %s" % str(地址))
    
def 转储栈(虚机):
    虚机.输出.write("数据栈: \n")
    for 值了 in reversed(虚机.数据栈._值们):
        虚机.输出.write(" - 类型 %s, 值 '%s'\n" % (type(值了), 值了))
        
    虚机.输出.write("返回栈: \n")
    for 值了 in reversed(虚机.返回栈._值们):
        虚机.输出.write(" - 地址 %s \n" % str(值了))

    虚机.输出.flush()

def 位移与(虚机):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言二元(甲, 乙)
    虚机.推(乙 & 甲)

def 位移或(虚机):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言二元(甲, 乙)
    虚机.推(乙 | 甲)

def 位移异或(虚机):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言二元(甲, 乙)
    虚机.推(乙 ^ 甲)

def 位移补码(虚机): # 字面是补码, 意思是取反
    甲 = 虚机.弹()
    _断言二元(甲)
    虚机.推(~甲)

def 布尔非(虚机):
    甲 = 虚机.弹()
    _断言布尔(甲)
    虚机.推(not 甲)

def 布尔与(虚机):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言布尔(甲, 乙)
    虚机.推(乙 and 甲)

def 布尔或(虚机):
    甲 = 虚机.弹()
    乙 = 虚机.弹()
    _断言布尔(甲, 乙)
    虚机.推(乙 or 甲)

def 负号(虚机):
    _断言数目(虚机.顶部)
    虚机.推(-虚机.弹())

def 查找(指令, 指令们=None):
    '''查找指令,它能是一个函数或一个字符串.
    若它是字符串, 返回其对应方法.
    若它是函数, 返回其对应名称'''
    if 指令们 is None:
        指令们 = 默认指令们

    if isinstance(指令, str):
        return 指令们[指令]
    elif hasattr(指令, "__call__"):
        重新版本 = dict(((值了, 键了) for (键了, 值了) in 指令们.items()))
        return 重新版本[指令]
    else:
        raise 错误们.机器错误(KeyError("未知指令: %s" % str(指令)))
    
默认指令们 = {
    "%": 取模,
    "&": 位移与,
    "*": 乘法,
    "+": 加法,
    "-": 减法,
    ".": 点,
    "/": 除法,
    "<": 小于,
    "<=": 小等,
    "<>": 不等,
    "=": 等号,
    ">": 大于,
    ">=": 大等,
    "@": 在,
    "^": 位移异或,
    "绝对值": 绝对值_,
    "与": 布尔与,
    "布尔": 转换布尔,
    "调用": 调用,
    "落下": 落下,
    "副本": 副本,
    "出口": 出口,
    "假": 假_,
    "浮点": 转换浮点,
    "若": 若语句,
    "整型": 转换整型,
    "跳": 跳,
    "负号": 负号,
    "无操作": 无操作,
    "非": 布尔非,
    "或": 布尔或,
    "超过": 超过,
    "读": 读,
    "返回": 返回_,
    "旋转": 旋转,
    "串": 转换串,
    "交换": 交换,
    "真": 真_,
    "写": 写,
    "|": 位移或,
    "~": 位移补码,  # 取反
    ".栈": 转储栈,
    "返>": 来自返回栈,
    "返@": 返回栈在,
}