'''编译器'''

from 错误们 import 编译错误
from 解释器 import 机器, 是否常量, 是否字符串, 是否布尔, 是否数目
import 指令们
import 优化器

嵌入_推_标签 = "嵌入_推"

def 制作嵌入推(值):
    '''返回一个闭包,推给定值上到一个机器的栈
    
        我们使用这个方法在虚拟机代码中嵌入栈推送,
        这样解释器可以假设所有指令都是可调用的Python函数.
        这使得调度比检查一个指令是否是常量(数目、字符串等)或Python函数要快得多.'''
        
    推 = lambda 虚拟机: 虚拟机.推(值)
    推.标签 = 嵌入_推_标签
    return 推

def 是否嵌入推(对象):
    '''检查若一个指令对象是嵌入推'''
    return callable(对象) and hasattr(对象, "标签") and 对象.标签 == 嵌入_推_标签

def 获取嵌入推值(对象):
    '''提取其嵌入推值'''
    assert(是否嵌入推(对象))
    assert(len(对象.__closure__) == 1)
    return 对象.__closure__[0].cell_contents

def 检查(代码):
    '''检查代码中的明显错误'''
    def 安全查找(操作):
        try:
            return 指令们.查找(操作)
        except Exception:
            return 操作
        
    for 指了, 甲 in enumerate(代码):
        乙 = 代码[指了 + 1] if 指了 + 1 < len(代码) else None

        # 指令存在吗?
        if not 是否常量(甲):
            try:
                指令们.查找(甲)
            except KeyError as 错了:
                # 跳过嵌入推闭包
                if not (len(错了.args) == 1 and 是否嵌入推(错了.args[0])):
                    raise 编译错误("指令在索引 %d 是未知: %s" % (指了, 甲))
                
        # 无效: <串> int
        if 是否字符串(甲) and 安全查找(乙) == 指令们.转换整型:
            raise 编译错误("不能转换字符串到整数(索引 %d): %s %s" % (指了, 甲, 乙))
        
        # 无效: <整型> <二元操作>
        布尔操作们 = [指令们.布尔非,
                 指令们.布尔或,
                 指令们.布尔与]
        
        if not 是否布尔(甲) and 安全查找(乙) in 布尔操作们:
            raise 编译错误("只能用二元操作在布尔上(索引 %d): %s %s" % (指了, 甲, 乙))
        
    return 代码

def 编译(代码, 静默=True, 忽视错误=False, 优化=True):
    '''编译子例程形式入到一个完成的工作代码.
    
        一个程序如这样:
            : 子1 <子1 代码 ...> ;
            : 子2 <子2 代码 ...> ;
            子1 食 子2 酒吧
            
        是编译入到:
            <子1 地址> 调用
            食
            <子2 地址> 调用
            出口
            <子1 代码 ...> 返回
            <子2 代码 ...> 返回
        
        首先对子例程体进行优化,
        之后在主循环上进行优化,
        最后解决符号(即,用实际的地址替换子例程地址的占位符).
        
        实参们:
            静默: 若集到假, 会打印优化消息.
            
            忽视错误: 仅适用于优化引擎,
                若集到假, 它不会升起任意异常.
                实际的编译仍会升起错误.

            优化: 控制是否优化代码的旗
            
            升起: 编译错误 - 升起异常,若无效代码被检测到
            
            返回: 一个能通过机器跑的代码数组.
                通常, 你想在对代码不做优化的情况下将其传递给机器.
                
            用法:
                源 = 解析("<源代码>")
                代码 = 编译(源)
                机器乎 = 机器(代码, 优化=假)
                机器乎.跑()
            '''
    assert(isinstance(代码, list))

    输出 = []
    子例程 = {}
    内置们 = 机器([]).指令们

    # 聚集起子例程
    try:
        它 = 代码.__iter__()
        while True:
            字 = next(它)
            if 字 == ":":
                名称 = next(它)
                if 名称 in 内置们:
                    raise 编译错误("不能覆盖内部字定义 '%s'." % 名称)
                if 名称 in [":", ";"]:
                    raise 编译错误("无效字名称 '%s'." % 名称)
                子例程[名称] = []
                while True:
                    操作 = next(它)
                    if 操作 == ";":
                        子例程[名称].append(指令们.查找(指令们.返回_))
                        break
                    else:
                        子例程[名称].append(操作)
            else:
                输出.append(字)
    except StopIteration:
        pass

    # 扩展全部子例程字到 ["<名称>", "调用"]
    for 名称, 代码 in 子例程.items():
        # 为子例程们
        未知代码 = []
        for 操作 in 代码:
            未知代码.append(操作)
            if 操作 in 子例程:
                未知代码.append(指令们.查找(指令们.调用))
        子例程[名称] = 未知代码

    # 编译主代码 (代码在子例程的外边塞)
    未知代码 = []
    for 操作 in 输出:
        未知代码.append(操作)
        if 操作 in 子例程:
            未知代码.append(指令们.查找(指令们.调用))

    # 因为主代码在子例程之前, 我们需要显式加上一个 [出口] 指令
    输出 = 未知代码
    if len(子例程) > 0:
        输出 = 输出 + [指令们.查找(指令们.出口)]

    #优化主代码
    if 优化:
        输出 = 优化器.已优化(输出, 静默=静默, 忽视错误=False)

    # 加上子例程到输出, 追踪它们的定位
    定位 = {}
    for 名称, 代码 in 子例程.items():
        定位[名称] = len(输出)
        if 优化:
            输出 = 输出 + 优化器.已优化(代码, 静默=静默, 忽视错误=False)
        else:
            输出 = 输出 + 代码

    # 解决全部子例程引用
    for 游标, 操作 in enumerate(输出):
        if 操作 in 定位:
            输出[游标] = 定位[操作]

    # 输出 = 土著类型(输出)
    if not 忽视错误:
        检查(输出)
    return 输出

def 到布尔(指令了):
    if isinstance(指令了, bool):
        return 指令了
    elif 指令了 == 指令们.查找(指令们.真_):
        return True
    elif 指令了 == 指令们.查找(指令们.假_):
        return False
    else:
        raise 编译错误("未知指令: %s" % 指令了)
    
def 土著类型(代码):
    '''转换代码元素来自字符串到土著Python类型.'''
    出 = []
    for 字符的 in 代码:
        if 是否常量(字符的, 已引号=True):
            if 是否字符串(字符的, 已引号=True):
                值了 = 字符的[1:-1]
            elif 是否布尔(字符的):
                值了 = 到布尔(字符的)
            elif 是否数目(字符的):
                值了 = 字符的
            else:
                raise 编译错误("未知类型 %s: %s" % (type(字符的).__name__, 字符的))
            
            # 我们一直推可调用的 Python 函数, 而不是在代码内推常量, 以便快速调度
            出.append(制作嵌入推(值了))
        else:
            try:
                出.append(指令们.查找(字符的))
            except KeyError:
                raise 编译错误("未知字 '%s'" % 字符的)
    return 出
