'''解释指令如何执行'''

import 错误们
import 指令们
import 解析器
import 栈
import sys

def 代码到字符串(代码):
    import 编译器
    串 = []
    for 操作 in 代码:
        if 是否常量(操作):
            if 是否字符串(操作):
                串.append(repr(操作))
            else:
                串.append(str(操作))
        elif 编译器.是否嵌入推(操作):
            值了 = 编译器.获取嵌入推值(操作)
            串.append('"%s"' % repr(值了)[1:-1] if isinstance(值了, str) else repr(值了))
        else:
            串.append(str(指令们.查找(操作)))
    return " ".join(串)

def 是否字符串(实参们, 已引号=False):
    '''检查若值是一个已加上引号的字符串'''
    是否已引号 = lambda 字符的: 字符的[0] == 字符的[-1] and 字符的[0] in ['"', "'"]

    if 已引号:
        检查 = lambda 字符的: isinstance(字符的, str) and 是否已引号(字符的)
    else:
        检查 = lambda 字符的: isinstance(字符的, str)

    if isinstance(实参们, list):
        return all(map(检查, 实参们))
    else:
        return 检查(实参们)
    
def 是否数目(*实参们):
    '''检查若值是一个整数, 长整数或浮点.
        视布尔为数目, 真=1 与 假=0 '''
    return all(map(lambda 字符的: isinstance(字符的, int) or isinstance(字符的, float), 实参们))

def 是否布尔(*实参们):
    '''检查若值是布尔'''
    真或假 = [指令们.查找(指令们.真_),
           指令们.查找(指令们.假_)]
    return all(map(lambda 字符的: isinstance(字符的, bool) or 字符的 in 真或假, 实参们))

def 是否二元(*实参们):
    '''检查若值能成为二元/位移操作的一部分'''
    return all(map(lambda 字符的: 是否数目(字符的) or 是否布尔(字符的), 实参们))

def 是否常量(实参们, 已引号=False):
    '''检查若值是一个布尔, 数目或字符串'''
    检查 = lambda 字符的: 是否布尔(字符的) or 是否数目(字符的) or 是否字符串(字符的, 已引号)
    if isinstance(实参们, list):
        return all(map(检查, 实参们))
    else:
        return 检查(实参们)
    
def 执行(源, 优化=True, 输出=sys.stdout, 输入=sys.stdin, 步们=-1):
    '''编译与跑程序, 返回其机器用来执行其代码
    
    实参们:
        优化: 要不要优化其代码在解析它后
        输出: 流哪个程序能写到输出
        输入: 流哪个程序能读来自输入
        步们: 指令的可选最大数目在虚拟机器上去执行, 集到-1为无极限
        
    返回:
        一个机器实例. '''
    
    import 编译器
    代码 = 编译器.编译(解析器.解析(源), 优化=优化)
    机器的 = 机器(代码, 输出=输出, 输入=输入)
    return 机器的.跑(步们)

def 求值(源, 优化=True, 输出=sys.stdout, 输入=sys.stdin, 步们=-1):
    '''编译与跑程序, 返回其值在栈上
        去返回其机器代替, 视 执行().
        
    实参们:
        优化: 要不要优化其代码在解析它后
        输出: 流哪个程序能写到输出
        输入: 流哪个程序能读来自输入
        步们: 指令的可选最大数目在虚拟机器上去执行, 集到-1为无极限
        
    返回:
        没有: 若其栈是空的
        对象: 若其栈含有一个单值
        [对象, 对象, ...]: 若其栈含有很多值'''
    
    机器的 = 执行(源, 优化=优化, 输出=输出, 输入=输入, 步们=步们)
    数据栈 = 机器的.栈

    if len(数据栈) == 0:
        return None
    elif len(数据栈) == 1:
        return 数据栈[-1]
    else:
        return 数据栈
    
class 机器(object):
    '''一个虚拟机器与代码一起, 一个数据栈与一个指令栈.'''
    def __init__(自身, 代码, 输出=sys.stdout, 输入=sys.stdin):
        '''实参们:
            代码: 其代码去跑.
            输出: 输出流那机器的代码能去写.
            输入: 输入流那机器的代码能来自读.
            优化: 若真, 优化其给出的代码. '''
        自身.重置()
        自身.代码 = 代码
        自身.输出 = 输出
        自身.输入 = 输入
        自身.指令们 = 指令们.默认指令们

    def 查找(自身, 指令):
        '''查找名到函数或函数到名'''
        return 指令们.查找(指令, 自身.指令们)
    
    @property
    def 栈(自身):
        '''返回其数据栈值(操作范围)'''
        return 自身.数据栈._值们
    
    def 重置(自身):
        '''重置栈与指令指针'''
        自身.数据栈 = 栈.栈()
        自身.返回栈 = 栈.栈()
        自身.指令指针 = 0
        return 自身
    
    def __repr__(自身):
        return "<机器: 指令指针=%d | 数据栈=%d | 返回栈=%d | 栈顶=%s>" % (自身.指令指针,
                len(自身.数据栈), len(自身.返回栈), str(自身.顶部))
    
    def __str__(自身):
        return 自身.__repr__()
    
    @property
    def 代码字符串(自身):
        '''返回代码作为一个可解析字符串'''
        return 代码到字符串(自身.代码)
    
    def 弹(自身):
        '''弹出其数据栈, 返回其值'''
        try:
            return 自身.数据栈.弹()
        except 错误们.机器错误 as 错了:
            raise 错误们.机器错误("%s: 在索引 %d 在代码内: %s" % (错了,
                                自身.指令指针, 自身.代码字符串))
        
    def 推(自身, 值):
        '''推一个值在其数据栈上'''
        自身.数据栈.推(值)

    @property
    def 顶部(自身):
        '''返回其数据栈顶'''
        return 自身.数据栈.顶部
    
    def 步(自身):
        '''执行一个指令与停'''
        操作 = 自身.代码[自身.指令指针]
        if isinstance(操作, str):
            # 解码字符串为函数
            操作 = 自身.查找(操作)
        自身.指令指针 = 自身.指令指针 + 1
        操作(自身)

    def 跑(自身, 步们=None):
        '''跑线程码在机器内.
        
        实参们:
            步们: 若已规格, 跑指定的指令数目在停止前. '''
        try:
            while 自身.指令指针 < len(自身.代码):
                自身.步()

                if 步们 is not None:
                    步们 = 步们 - 1
                    if 步们 == 0:
                        break
        except StopIteration:
            pass
        return 自身
    