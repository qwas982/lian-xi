/*
词法分析

由于Python版本是在Unicode环境下,已经省去字符编码这一步,
当移植到C环境下,就需要先对字符编码进行解码.
我定义这个版本的scheme解释器只解码UTF16BE编码的字符,原因无二,省空间+简单.
并且将拉丁英文字母一类的字符与中文汉字字符放在一个平等的位置上存储 处理 运算.
在编写源码之前,请先检查源码文件的编码是否为UTF16BE.
*/

#include <stdio.h>
#include <stdlib.h>

// 定义代码点结构体
typedef struct {
    unsigned short *代码点;
    short 长度;
} 代码点结构体;

// 函数声明
代码点结构体 *创建代码点结构体(short 预分配长度);
void 释放代码点结构体(代码点结构体 *代码点结构);
void 解码_UTF16BE(unsigned char *字节序列, short 长度, 代码点结构体 *代码点结构);
short 字节到代码点(unsigned char 高字节, unsigned char 低字节);

// 创建代码点结构体的函数实现
代码点结构体 *创建代码点结构体(short 预分配长度) {
    代码点结构体 *新结构体 = (代码点结构体 *)malloc(sizeof(代码点结构体));
    新结构体->代码点 = (unsigned short *)malloc(预分配长度 * sizeof(unsigned short));
    新结构体->长度 = 0;
    return 新结构体;
}

// 释放代码点结构体的函数实现
void 释放代码点结构体(代码点结构体 *代码点结构) {
    free(代码点结构->代码点);
    free(代码点结构);
}

// UTF-16BE字节序列解码为Unicode代码点的函数实现
void 解码_UTF16BE(unsigned char *字节序列, short 长度, 代码点结构体 *代码点结构) {
    for(short 游标 = 0; 游标 < 长度; 游标 += 2) {
        代码点结构->代码点[代码点结构->长度++] = 字节到代码点(字节序列[游标], 字节序列[游标 + 1]);
    }
}

// 将两个字节转换为Unicode代码点的函数
short 字节到代码点(unsigned char 高字节, unsigned char 低字节) {
    return (高字节 << 8) | 低字节;
}

/*
// 示例字节序列
    unsigned char 字节序列[] = {0x00, 0x61, 0x00, 0x62, 0x00, 0x63}; // "abc" 的UTF-16BE编码
    short 长度 = sizeof(字节序列) / sizeof(字节序列[0]);
    
    // 创建代码点结构体实例
    代码点结构体 *代码点 = 创建代码点结构体(长度 / 2);
    
    // 解码
    解码_UTF16BE(字节序列, 长度, 代码点);
    
    // 打印解码后的代码点
    for(short i = 0; i < 代码点->长度; i++) {
        printf("Code point: %hu\n", 代码点->代码点[i]);
    }
    
    // 释放内存
    释放代码点结构体(代码点);
    
*/

// 全局变量定义
unsigned int 数字开始全局 = 0;
unsigned int 中文汉字字符全局 = 0;
unsigned int 符号字符全局 = 0;
unsigned int 字符串分隔符全局 = 0;
unsigned int 空格制表换行回车全局 = 0;
unsigned int 括号和单体符号全局 = 0;
unsigned int 终结符牌全局 = 0;
unsigned int 分隔符全局 = 0;
// 全局变量定义
unsigned int 未识别代码点全局 = 0;

// 判断函数
void 判断并更新全局变量(unsigned int 代码点) {
    // 数字判断
    if ((代码点 >= 48 && 代码点 <= 57) || 代码点 == 43 || 代码点 == 45 || 代码点 == 46) {
        数字开始全局 = 代码点;
        符号字符全局 = 代码点;
    }
    // 中文汉字判断
    else if (代码点 >= 19968 && 代码点 <= 40959) {
        中文汉字字符全局 = 代码点;
        符号字符全局 = 代码点;
    }
    // 符号判断（示例：包括一些英文标点和大写、小写字母）// a到z A到Z !$%&*/:<=>?@^_~
    else if ((代码点 >= 97 && 代码点 <= 122) || 
             (代码点 >= 65 && 代码点 <= 90) || 
             代码点 == 33 || 代码点 == 36 || 代码点 == 37 || 代码点 == 38 ||
             代码点 == 42 || 代码点 == 47 || 代码点 == 58 || 代码点 == 60 ||
             代码点 == 61 || 代码点 == 62 || 代码点 == 63 || 代码点 == 64 ||
             代码点 == 94 || 代码点 == 95 || 代码点 == 126) { 
        符号字符全局 = 代码点;
    }
    // 字符串分隔符判断（示例：包括双引号和单引号）
    else if (代码点 == 34) {
        字符串分隔符全局 = 代码点;
        终结符牌全局 = 代码点;
    }
    // 空格、制表、换行、回车判断
    else if (代码点 == 32 || 代码点 == 13 || 代码点 == 10 || 代码点 == 9) {
        空格制表换行回车全局 = 代码点;
        终结符牌全局 = 代码点;
    }
    // 括号和单个符号判断（示例：包括一些常用括号和符号）
    else if (代码点 == 40 || 代码点 == 41 || 代码点 == 91 || 代码点 == 93 ||
         代码点 == 39 || 代码点 == 96) {
        括号和单体符号全局 = 代码点;
        终结符牌全局 = 代码点;
        分隔符全局 = 代码点;
    }
    unsigned short 甲 = 44;
    unsigned short 乙 = 64;
    unsigned int 组合甲乙;
    组合甲乙 = (甲 << 16) | 乙;
    // 终结符判断（示例：包括一些特殊符号）
    else if (代码点 == 44 || 代码点 == 组合甲乙) { // NULL字符作为终结符示例
        终结符牌全局 = 代码点;
    }
    // 分隔符判断（示例：包括逗号和句号）
    else if (代码点 == 46 || 代码点 == 44 || 代码点 == 组合甲乙) {
        分隔符全局 = 代码点;
    }
    // 如果都不符合，使用默认处理
    else if (代码点 != 0) { // 排除终结符（例如，0x0000）
        未识别代码点全局 = 代码点;
        printf("警告:未识别的Unicode范围,本程序仅识别0x0000到0xFFFF之间的区段 0x%08X\n", 未识别代码点全局);
    }
}

// 处理代码点的函数
void 处理代码点(代码点结构体 *输入) {
    for (short i = 0; i < 输入->长度; ++i) {
        判断并更新全局变量(输入->代码点[i]);
    }
}

/*
int main() {
    // 示例代码点数组
    unsigned short 代码点数组[] = {0x0030, 0x4e2d, 0x0041, 0x0009, 0x0028, 0x0000};
    short 数组长度 = sizeof(代码点数组) / sizeof(代码点数组[0]);
    代码点结构体 输入 = {代码点数组, 数组长度};

    // 处理代码点
    处理代码点(&输入);

    // 打印结果
    printf("数字开始全局: %04X\n", 数字开始全局);
    printf("中文汉字字符全局: %04X\n", 中文汉字字符全局);
    printf("符号字符全局: %04X\n", 符号字符全局);
    printf("字符串分隔符全局: %04X\n", 字符串分隔符全局);
    printf("空格制表换行回车全局: %04X\n", 空格制表换行回车全局);
    printf("括号和单体符号全局: %04X\n", 括号和单体符号全局);
    printf("终结符牌全局: %04X\n", 终结符牌全局);
    printf("分隔符全局: %04X\n", 分隔符全局);
    // ... (打印全局变量的代码)
    printf("未识别代码点全局: %04X\n", 未识别代码点全局);

    return 0;
}
*/