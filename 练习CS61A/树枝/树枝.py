# 目的: 实现一个中文汉字scheme编程.

from 树枝原语 import *
from 树枝读 import *
from 树枝ucb import main, 追踪

#scheme.py  解释器与读求值印环

'''求值/应用'''
def 树枝求值(表达式, 环境, _=None):
    '''求值树枝表达式在环境内'''
    #求值原子
    if 树枝符号谓(表达式):
        return 环境.查找(表达式)
    elif 自身的求值(表达式):
        return 表达式
    
    #全部非原子表达式是列表(组合)
    if not 树枝列表谓(表达式):
        raise 树枝错误('畸形列表: {0}'.format(str(表达式)))
    第一, 其余 = 表达式.第一, 表达式.第二
    if 树枝符号谓(第一) and 第一 in 特殊形式全局:
        return 特殊形式全局[第一](其余, 环境)
    else:
        操作者 = 树枝求值(第一, 环境)
        检查过程(操作者)
        return 操作者.求值调用(其余, 环境)
    
def 自身的求值(表达式):
    return 树枝原子谓(表达式) or 树枝串谓(表达式) or 表达式 is None

def 树枝应用(过程乎, 实参们, 环境):
    '''应用树枝的过程到实参值的实参们(一个树枝列表)在环境内'''
    检查过程(过程乎)
    return 过程乎.应用(实参们, 环境)

def 求值全部(表达式乎, 环境):
    '''求值每个表达式在树枝的列表表达式内在环境内与返回其最后的值'''
    if 表达式乎 is 无:
        return None
    elif 表达式乎.第二 is 无:
        return 树枝求值(表达式乎.第一, 环境, True)
    else:
        树枝求值(表达式乎.第一, 环境)
        return 求值全部(表达式乎.第二, 环境)
    
'''环境'''
class 帧:
    '''一个环境帧绑树枝的符号到树枝的值'''
    def __init__(自身, 父母):
        '''一个空帧与父母帧一起'''
        自身.绑定 = {}
        自身.父母 = 父母
    
    def __repr__(自身):
        if 自身.父母 is None:
            return '<全局帧>'
        排序 = sorted(['{0}: {1}'.format(键, 值) for 键, 值 in 自身.绑定.items()])
        return '<{{{0}}} -> {1}>'.format(', '.join(排序), repr(自身.父母))
    
    def 定义(自身, 符号, 值):
        '''定义树枝的符号到有值'''
        自身.绑定[符号] = 值

    def 查找(自身, 符号):
        '''返回其值限制到符号,错了若符号是未找到'''
        if 符号 in 自身.绑定:
            return 自身.绑定[符号]
        elif 自身.父母:
            return 自身.父母.查找(符号)
        raise 树枝错误('未知标识符: {0}'.format(符号))
    
    def 制作孩子帧(自身, 形式, 值):
        '''返回一个新本地帧其父母是自身,
        在符号内在一个树枝列表的形式形参内,是限制到树枝值在其树枝列表内
        升起一个错误若太多或太少值是给定'''
        孩子 = 帧(自身)
        if len(值) > len(形式):
            raise 树枝错误("太多值被给定")
        elif len(值) < len(形式):
            raise 树枝错误("太少值被给定")
        while 形式 is not 无:
            孩子.定义(形式.第一, 值.第一)
            形式 = 形式.第二
            值 = 值.第二
        return 孩子
    
'''过程'''

class 过程:
    '''全部树枝过程的超级类型'''
    def 求值调用(自身, 操作范围, 环境):
        '''对 自身 进行标准函数调用求值,
        操作范围 是未求值的实际形参表达式,
        环境 是求值操作范围的环境.'''
        求值操作范围 = lambda 表达式: 树枝求值(表达式, 环境)
        return 树枝应用(自身, 操作范围.映射(求值操作范围), 环境) #每个操作范围都将被求值
    
def 树枝过程谓(甲):
    return isinstance(甲, 过程)

class 原语过程(过程):
    '''一个树枝过程定义为一个Python函数'''
    def __init__(自身, 函, 用环境=False, 名称='原语'):
        自身.名称 = 名称
        自身.函 = 函
        自身.用环境 = 用环境

    def __str__(自身):
        return '#[{0}]'.format(自身.名称)
    
    def 应用(自身, 实参们, 环境):
        '''将 自身 应用于 环境 中的 实参们,其中 实参们 是树枝的列表'''
        if not 树枝列表谓(实参们):
            raise 树枝错误('实参们是不在一个列表里: {0}'.format(实参们))
        蟒蛇实参 = []
        while 实参们 is not 无:
            蟒蛇实参.append(实参们.第一)
            实参们 = 实参们.第二
        if 自身.用环境:
            蟒蛇实参.append(环境)
        try:
            return 自身.函(*蟒蛇实参)
        except TypeError:
            raise 树枝错误("错误的形参数目被传递")
        
class 用户定义过程(过程):
    '''过程定义通过一个表达式'''
    def 应用(自身, 实参, 环境):
        '''将 自身 应用于环境里的实参值.
        应用一个用户定义过程求值全部表达式在物自体内'''
        新环境 = 自身.制作调用帧(实参, 环境)
        return 求值全部(自身.物自体, 新环境)
    
class 入_兰姆达过程(用户定义过程):
    '''一个过程定义通过入_兰姆达表达式或一个定义形式'''
    def __init__(自身, 形式们, 物自体, 环境):
        '''带有形式形参列表(一个树枝列表)的过程，
        其物自体是树枝列表, 其父母环境以帧环境开始'''
        自身.形式们 = 形式们
        自身.物自体 = 物自体
        自身.环境 = 环境

    def 制作调用帧(自身, 实参, 环境):
        '''制作一个帧,将我的形式形参与实参绑定, 一个树枝的值列表,
        以便在环境里求值词法作用域调用'''
        return 自身.环境.制作孩子帧(自身.形式们, 实参)
    
    def __str__(自身):
        return str(点对('入', 点对(自身.形式们, 自身.物自体)))
    
    def __repr__(自身):
        return '入_兰姆达过程({0}, {1}, {2})'.format(repr(自身.形式们), repr(自身.物自体), repr(自身.环境))
    
class 宏过程(入_兰姆达过程):
    '''宏: 一种特殊形式, 对其未求值操作范围进行操作,
    去创建一个表达式代替调用求值'''
    def 求值调用(自身, 操作范围, 环境):
        '''在我这进行宏调用求值, 操作范围是未求值的实际形参表达式,
        环境为结果扩展表达式的求值环境'''
        已应用 = 树枝应用(自身, 操作范围, 环境)
        return 树枝求值(完成求值(已应用), 环境)
    
def 加上原语(帧乎, 函与名称):
    for 名称, 函, 过程名 in 函与名称:
        帧乎.定义(名称, 原语过程(函, 名称=过程名))

#特殊形式
''' 下列 做_xxx_形式 函数的第一个实参都是一个特殊形式的 切尾 --- 
一个代表特殊形式的树枝列表, 不包含初始标识符号(若、入_兰姆达、引号 ...)
它的第二个实参是求值其形式的环境。'''

def 做定义形式(表达式乎, 环境):
    '''求值一个定义形式'''
    检查形式(表达式乎, 2)
    目标 = 表达式乎.第一
    if 树枝符号谓(目标):
        检查形式(表达式乎, 2, 2)
        值 = 树枝求值(表达式乎.第二.第一, 环境)
        环境.定义(目标, 值)
        return 目标
    elif isinstance(目标, 点对) and 树枝符号谓(目标.第一):
        形式们 = 目标.第二
        物自体 = 表达式乎.第二
        入_兰姆达过程乎 = 入_兰姆达过程(形式们, 物自体, 环境)
        环境.定义(目标.第一, 入_兰姆达过程乎)
        return 目标.第一
    else:
        差劲目标 = 目标.第一 if isinstance(目标, 点对) else 目标
        raise 树枝错误('非符号: {0}'.format(差劲目标))
    
def 做引号形式(表达式乎, 环境):
    '''求值一个引号形式'''
    检查形式(表达式乎, 1, 1)
    return 表达式乎.第一

def 做始形式(表达式乎, 环境):
    检查形式(表达式乎, 1)
    return 求值全部(表达式乎, 环境)

def 做入_兰姆达形式(表达式乎, 环境):
    检查形式(表达式乎, 2)
    形式们 = 表达式乎.第一
    检查形式们(形式们)
    物自体 = 表达式乎.第二
    return 入_兰姆达过程(形式们, 物自体, 环境)

def 做若形式(表达式乎, 环境):
    检查形式(表达式乎, 2, 3)
    if 树枝真谓(树枝求值(表达式乎.第一, 环境)):
        return 树枝求值(表达式乎.第二.第一, 环境, True)
    elif len(表达式乎) == 3:
        return 树枝求值(表达式乎.第二.第二.第一, 环境, True)
    
def 做与形式(表达式乎, 环境):
    if 表达式乎 is 无:
        return True
    elif 表达式乎.第二 is 无:
        return 树枝求值(表达式乎.第一, 环境, True)
    else:
        第一表达式 = 树枝求值(表达式乎.第一, 环境)
        if 树枝假谓(第一表达式):
            return False
        elif 树枝真谓(第一表达式):
            return 做与形式(表达式乎.第二, 环境)
        
def 做或形式(表达式乎, 环境):
    if 表达式乎 is 无:
        return False
    elif 表达式乎.第二 is 无:
        return 树枝求值(表达式乎.第一, 环境, True)
    else:
        第一表达式 = 树枝求值(表达式乎.第一, 环境)
        if 树枝假谓(第一表达式):
            return 做或形式(表达式乎.第二, 环境)
        else:
            return 第一表达式

def 做条件形式(表达式乎, 环境):
    while 表达式乎 is not 无:
        子句 = 表达式乎.第一
        检查形式(子句, 1)
        if 子句.第一 == '否则':
            测试 = True
            if 表达式乎.第二 != 无:
                raise 树枝错误('否则必须是最后')
        else:
            测试 = 树枝求值(子句.第一, 环境)
        if 树枝真谓(测试):
            if 子句.第二 is 无:
                return 测试 #当真谓词没有相应的结果子表达式时，返回谓词值
            else:
                return 求值全部(子句.第二, 环境) #如果条件情况的结果子表达式有多个表达式，则对全部表达式进行求值，并返回最后表达式的值
        表达式乎 = 表达式乎.第二            

def 做让形式(表达式乎, 环境):
    检查形式(表达式乎, 2)
    让环境 = 制作让帧(表达式乎.第一, 环境)
    return 求值全部(表达式乎.第二, 让环境)

def 制作让帧(绑定, 环境):
    '''为 环境 创建一个孩子帧，其中包含 绑定 内给出的定义。
    树枝列表 绑定 必须采用 让 表达式内的绑定列表形式: 每个项目必须是一个列表，
    其中包含一个符号和一个 树枝表达式'''
    if not 树枝列表谓(绑定):
        raise 树枝错误('差劲的绑定列表在让形式内')
    形式们, 值们 = 无, 无
    while 绑定 is not 无:
        检查形式(绑定.第一, 2, 2)
        值 = 树枝求值(绑定.第一.第二.第一, 环境)
        形式们 = 点对(绑定.第一.第一, 形式们)
        检查形式们(形式们)
        值们 = 点对(值, 值们)
        绑定 = 绑定.第二
    return 环境.制作孩子帧(形式们, 值们)

def 做定义宏(表达式们, 环境):
    检查形式(表达式们, 2)
    目标 = 表达式们.第一
    if isinstance(目标, 点对) and 树枝符号谓(目标.第一):
        形式们 = 目标.第二
        物自体 = 表达式们.第二
        宏过程乎 = 宏过程(形式们, 物自体, 环境)
        环境.定义(目标.第一, 宏过程乎)
        return 目标.第一
    else:
        差劲目标 = 目标.第一 if isinstance(目标, 点对) else 目标
        raise 树枝错误('非符号: {0}'.format(差劲目标))
    
特殊形式全局 = {
    '与' : 做与形式,
    '始' : 做始形式,
    '条件' : 做条件形式,
    '定义' : 做定义形式,
    '若' : 做若形式,
    '兰姆达' : 做入_兰姆达形式,
    '入' : 做入_兰姆达形式,
    '让' : 做让形式,
    '或' : 做或形式,
    '引号' : 做引号形式,
    '定义宏' : 做定义宏,
}

#检查 树枝 程序结构的实用方法

def 检查形式(表达式, 最小, 最大=float('inf')):
    if not 树枝列表谓(表达式):
        raise 树枝错误('差劲的形式表达式: ' + str(表达式))
    长度 = len(表达式)
    if 长度 < 最小:
        raise 树枝错误('太少操作范围在形式内')
    elif 长度 > 最大:
        raise 树枝错误('太多操作范围在形式内')
    
def 检查形式们(形式们):
    符号们 = set()
    def 检查与加上(符号):
        if not 树枝符号谓(符号):
            raise 树枝错误('非符号: {0}'.format(符号))
        if 符号 in 符号们:
            raise 树枝错误('副本符号: {0}'.format(符号))
        符号们.add(符号)

    while isinstance(形式们, 点对):
        检查与加上(形式们.第一)
        形式们 = 形式们.第二

def 检查过程(过程乎):
    '''检查那过程是一个有效的树枝过程'''
    if not 树枝过程谓(过程乎):
        raise 树枝错误('{0} 是不可调用: {1}'.format(type(过程乎).__name__.lower(), str(过程乎)))
    
#动态作用域
    
class 变异过程(用户定义过程):
    '''一个过程定义通过变异表达式,具有动态作用域'''
    def __init__(自身, 形式们, 物自体):
        自身.形式们 = 形式们
        自身.物自体 = 物自体

    def 制作调用帧(自身, 实参, 环境):
        return 环境.制作孩子帧(自身.形式们, 实参)
    
    def __str__(自身):
        return str(点对('变异', 点对(自身.形式们, 自身.物自体)))
    
    def __repr__(自身):
        return '变异过程({0}, {1})'.format(repr(自身.形式们), repr(自身.物自体))
    
def 做变异形式(表达式乎, 环境):
    检查形式(表达式乎, 2)
    形式们 = 表达式乎.第一
    检查形式们(形式们)
    物自体 = 表达式乎.第二
    return 变异过程(形式们, 物自体)

特殊形式全局['变异'] = 做变异形式

#流

class 承诺:
    def __init__(自身, 表达式乎, 环境):
        自身.表达式乎 = 表达式乎
        自身.环境 = 环境

    def 求值(自身):
        if 自身.表达式乎 is not None:
            自身.值 = 树枝求值(自身.表达式乎, 自身.环境.制作孩子帧(无, 无))
            自身.表达式乎 = None
        return 自身.值
    
    def __str__(自身):
        return '#[承诺 ({0}强行)]'.format('非 ' if 自身.表达式乎 is not None else '')
    
def 做延迟形式(表达式乎, 环境):
    检查形式(表达式乎, 1, 1)
    return 承诺(表达式乎.第一, 环境)

def 做构造流形式(表达式乎, 环境):
    检查形式(表达式乎, 2, 2)
    return 点对(树枝求值(表达式乎.第一, 环境), 做延迟形式(表达式乎.第二, 环境))

特殊形式全局['构造流'] = 做构造流形式
特殊形式全局['延迟'] = 做延迟形式

#尾递归

class 形实互换:
    def __init__(自身, 表达式, 环境):
        自身.表达式 = 表达式
        自身.环境 = 环境

def 完成求值(值):
    if isinstance(值, 形实互换):
        return 树枝求值(值.表达式, 值.环境)
    else:
        return 值
    
def 树枝优化求值(表达式, 环境, 尾部=False):
    if 树枝符号谓(表达式):
        return 环境.查找(表达式)
    elif 自身的求值(表达式):
        return 表达式
    
    if 尾部:
        return 形实互换(表达式, 环境)
    else:
        结果 = 形实互换(表达式, 环境)
    
    while isinstance(结果, 形实互换):
        表达式, 环境 = 结果.表达式, 结果.环境
        if not 树枝列表谓(表达式):
            raise 树枝错误('畸形列表: {0}'.format(str(表达式)))
        第一, 其余 = 表达式.第一, 表达式.第二
        if (树枝符号谓(第一) and 第一 in 特殊形式全局):
            结果 = 特殊形式全局[第一](其余, 环境)
        else:
            操作者 = 树枝优化求值(第一, 环境)
            检查过程(操作者)
            结果 = 操作者.求值调用(其余, 环境)
    return 结果

树枝求值 = 树枝优化求值  #应用尾调用优化

#额外过程

def 树枝映射(函, 列, 环境):
    检查类型(函, 树枝过程谓, 0, '映射')
    检查类型(列, 树枝列表谓, 1, '映射')
    return 列.map(lambda 甲: 完成求值(函.应用(点对(甲, 无), 环境)))

def 树枝滤镜(函, 列, 环境):
    检查类型(函, 树枝过程谓, 0, '滤镜')
    检查类型(列, 树枝列表谓, 1, '滤镜')
    头部, 当前 = 无, 无
    while 列 is not 无:
        项目, 列 = 列.第一, 列.第二
        if 完成求值(函.应用(点对(项目, 无), 环境)):
            if 头部 is 无:
                头部 = 点对(项目, 无)
                当前 = 头部
            else:
                当前.第二 = 点对(项目, 无)
                当前 = 当前.第二
    return 头部

def 树枝简化(函, 列, 环境):
    检查类型(函, 树枝过程谓, 0, '简化')
    检查类型(列, lambda 甲: 甲 is not 无, 1, '简化')
    检查类型(列, 树枝列表谓, 1, '简化')
    值, 列 = 列.第一, 列.第二
    while 列 is not 无:
        值 = 完成求值(函.应用(树枝列表(值, 列.第一), 环境))
        列 = 列.第二
    return 值

#输入/输出

def 读求值印环(下一行, 环境, 互动=False, 安静=False, 启动=False, 载入文件们=()):
    '''读与求值输入的,直到文件终或键盘中断'''
    if 启动:
        for 文件名 in 载入文件们:
            树枝载入(文件名, True, 环境)
    while True:
        try:
            源 = 下一行()
            while 源.更多在行上:
                表达式乎 = 树枝读(源)
                结果 = 树枝求值(表达式乎, 环境)
                if not 安静 and 结果 is not None:
                    print(结果)
        except (树枝错误, SyntaxError, ValueError, RuntimeError) as 错误:
            if (isinstance(错误, RuntimeError) and '超出最大递归深度' not in getattr(错误, '实参们')[0]):
                raise
            elif isinstance(错误, RuntimeError):
                print('错误: 超出最大递归深度')
            else:
                print('错误:', 错误)
        except KeyboardInterrupt:
            if not 启动:
                raise
            print('控制+C')
            print('键盘中断')
            if not 互动:
                return
        except EOFError:
            print('控制+D')
            return

def 树枝载入(*实参们):
    '''载入一个树枝源文件'''
    if not (2 <= len(实参们) <= 3):
        表达式乎 = 实参们[:-1]
        raise 树枝错误('"载入" 给定不正确实参数目: ' '{0}'.format(len(表达式乎)))
    符 = 实参们[0]
    安静 = 实参们[1] if len(实参们) > 2 else True
    环境 = 实参们[-1]
    if (树枝串谓(符)):
        符 = eval(符)
    检查类型(符, 树枝符号谓, 0, '载入')
    with 树枝打开(符) as 文件内:
        行们 = 文件内.readline()
    实参们 = (行们, None) if 安静 else (行们,)
    def 下一行():
        return 缓冲区行们(*实参们)
    
    读求值印环(下一行, 环境, 安静=安静)

def 树枝打开(文件名):
    try:
        return open(文件名)
    except IOError as 异常:
        if 文件名.endswith('.树枝'):
            raise 树枝错误(str(异常))
    try:
        return open(文件名 + '.树枝')
    except IOError as 异常:
        raise 树枝错误(str(异常))
    
def 创建全局帧():
    '''初始化与返回一个单帧环境和内置名一起'''
    环境 = 帧(None)
    环境.定义('求值', 原语过程(树枝求值, True, '求值'))
    环境.定义('应用', 原语过程(树枝应用, True, '应用'))
    环境.定义('载入', 原语过程(树枝载入, True, '载入'))
    环境.定义('过程?', 原语过程(树枝过程谓, False, '过程?'))
    环境.定义('映射', 原语过程(树枝映射, True, '映射'))
    环境.定义('滤镜', 原语过程(树枝滤镜, True, '滤镜'))
    环境.定义('简化', 原语过程(树枝简化, True, '简化'))
    环境.定义('未定义', None)
    加上原语(环境, 原语们全局)
    return 环境

@main
def 跑树枝(*实参值):
    import argparse
    解析器 = argparse.ArgumentParser(description='抄写自CS61A的scheme解释器')
    解析器.add_argument('-载入', '-i', action='store_true', help='跑文件交互')
    解析器.add_argument('文件', nargs='?', type=argparse.FileType('r'), default=None, help='树枝文件去跑')
    实参们 = 解析器.parse_args()

    下一行 = 缓冲区输入
    互动 = True
    载入文件们 = []

    if 实参们.文件 is not None:
        if 实参们.载入:
            载入文件们.append(getattr(实参们.文件, '名称'))
        else:
            行们 = 实参们.文件.readline()
            def 下一行():
                return 缓冲区行们(行们)
            互动 = False
    
    读求值印环(下一行, 创建全局帧(), 启动=True, 互动=互动, 载入文件们=载入文件们)
    海龟树枝单击退出()

