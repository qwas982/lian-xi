#include "MAL.h"
#include "Environment.h"
#include "StaticList.h"
#include "Types.h"

#include <chrono>
#include <fstream>
#include <iostream>

#define 检查_实参_是不是_大写(期望_小写) \
    检查实参是不是(名字_小写.c_str(), 期望_小写, \
                  std::distance(实参开头_小写, 实参终_小写))

#define 检查_实参_之间_大写(最小_小写短, 最大_小写短) \
    检查实参之间(名字_小写.c_str(), 最小_小写短, 最大_小写短, \
                       std::distance(实参开头_小写, 实参终_小写))

#define 检查_实参_在最少的_大写(期望_小写) \
    检查实参至少(名字_小写.c_str(), 期望_小写, \
                        std::distance(实参开头_小写, 实参终_小写))

static 字符串_大写 打印值_小写复(制作树语言值迭代器_小写 begin, 制作树语言值迭代器_小写 end,
                           const 字符串_大写& sep, bool 可读的_小写);

static 静态列表<制作树语言内建的_小写*> 句柄_小写复;

#define 实参_大写短(type, 名字_小写) type* 名字_小写 = 值_类型转换_大写(type, *实参开头_小写++)

#define 函数名字_大写短(uniq) builtIn ## uniq
#define HRECNAME(uniq) 句柄者_小写 ## uniq
#define 内建_定义_大写短(uniq, 符号_小写) \
    static 制作树语言内建的_小写::应用函数_大写短 函数名字_大写短(uniq); \
    static 静态列表<制作树语言内建的_小写*>::节点_大写 HRECNAME(uniq) \
        (句柄_小写复, new 制作树语言内建的_小写(符号_小写, 函数名字_大写短(uniq))); \
    制作树语言值指针_小写 函数名字_大写短(uniq)(const 字符串_大写& 名字_小写, \
        制作树语言值迭代器_小写 实参开头_小写, 制作树语言值迭代器_小写 实参终_小写)

#define 内建_大写(符号_小写)  内建_定义_大写短(__LINE__, 符号_小写)

#define 内建_指令集_大写(符号_小写, type) \
    内建_大写(符号_小写) { \
        检查_实参_是不是_大写(1); \
        return 制作树语言_小写::布尔_小写(动态_类型转换_大写(type, *实参开头_小写)); \
    }

#define 内建_是否_大写(op, 常量_小写) \
    内建_大写(op) { \
        检查_实参_是不是_大写(1); \
        return 制作树语言_小写::布尔_小写(*实参开头_小写 == 制作树语言_小写::常量_小写()); \
    }

#define 内建_整型操作_大写(op, 检查被零除了_小写) \
    内建_大写(#op) { \
        检查_实参_是不是_大写(2); \
        实参_大写短(制作树语言整数_小写, 左手边_小写缩); \
        实参_大写短(制作树语言整数_小写, 右手边_小写缩); \
        if (检查被零除了_小写) { \
            制作树语言_检查_大写(右手边_小写缩->值_小写() != 0, "Division by zero"); \
        } \
        return 制作树语言_小写::整数_小写(左手边_小写缩->值_小写() op 右手边_小写缩->值_小写()); \
    }

内建_指令集_大写("atom?",        制作树语言原子_小写);
内建_指令集_大写("keyword?",     制作树语言关键字_小写);
内建_指令集_大写("list?",        制作树语言列表_小写);
内建_指令集_大写("map?",         制作树语言哈希_小写);
内建_指令集_大写("number?",      制作树语言整数_小写);
内建_指令集_大写("sequential?",  制作树语言队列_小写);
内建_指令集_大写("string?",      制作树语言字符串_小写);
内建_指令集_大写("symbol?",      制作树语言符号_小写);
内建_指令集_大写("vector?",      制作树语言向量_小写);

内建_整型操作_大写(+,            false);
内建_整型操作_大写(/,            true);
内建_整型操作_大写(*,            false);
内建_整型操作_大写(%,            true);

内建_是否_大写("true?",         真值_小写);
内建_是否_大写("false?",        假值_小写);
内建_是否_大写("零值_小写?",          零值_小写);

内建_大写("-")
{
    int 实参计数_小写 = 检查_实参_之间_大写(1, 2);
    实参_大写短(制作树语言整数_小写, 左手边_小写缩);
    if (实参计数_小写 == 1) {
        return 制作树语言_小写::整数_小写(- 左手边_小写缩->值_小写());
    }

    实参_大写短(制作树语言整数_小写, 右手边_小写缩);
    return 制作树语言_小写::整数_小写(左手边_小写缩->值_小写() - 右手边_小写缩->值_小写());
}

内建_大写("<=")
{
    检查_实参_是不是_大写(2);
    实参_大写短(制作树语言整数_小写, 左手边_小写缩);
    实参_大写短(制作树语言整数_小写, 右手边_小写缩);

    return 制作树语言_小写::布尔_小写(左手边_小写缩->值_小写() <= 右手边_小写缩->值_小写());
}

内建_大写(">=")
{
    检查_实参_是不是_大写(2);
    实参_大写短(制作树语言整数_小写, 左手边_小写缩);
    实参_大写短(制作树语言整数_小写, 右手边_小写缩);

    return 制作树语言_小写::布尔_小写(左手边_小写缩->值_小写() >= 右手边_小写缩->值_小写());
}

内建_大写("<")
{
    检查_实参_是不是_大写(2);
    实参_大写短(制作树语言整数_小写, 左手边_小写缩);
    实参_大写短(制作树语言整数_小写, 右手边_小写缩);

    return 制作树语言_小写::布尔_小写(左手边_小写缩->值_小写() < 右手边_小写缩->值_小写());
}

内建_大写(">")
{
    检查_实参_是不是_大写(2);
    实参_大写短(制作树语言整数_小写, 左手边_小写缩);
    实参_大写短(制作树语言整数_小写, 右手边_小写缩);

    return 制作树语言_小写::布尔_小写(左手边_小写缩->值_小写() > 右手边_小写缩->值_小写());
}

内建_大写("=")
{
    检查_实参_是不是_大写(2);
    const 制作树语言值_小写* 左手边_小写缩 = (*实参开头_小写++).ptr();
    const 制作树语言值_小写* 右手边_小写缩 = (*实参开头_小写++).ptr();

    return 制作树语言_小写::布尔_小写(左手边_小写缩->是否等同的_小写(右手边_小写缩));
}

内建_大写("apply")
{
    检查_实参_在最少的_大写(2);
    制作树语言值指针_小写 op = *实参开头_小写++; // this gets checked in 应用_大写

    // Copy the first N-1 arguments in.
    制作树语言值向量_小写 实参_小写短(实参开头_小写, 实参终_小写-1);

    // Then append the argument as a list.
    const 制作树语言队列_小写* lastArg = 值_类型转换_大写(制作树语言队列_小写, *(实参终_小写-1));
    for (int i = 0; i < lastArg->count(); i++) {
        实参_小写短.push_back(lastArg->条目_小写(i));
    }

    return 应用_大写(op, 实参_小写短.begin(), 实参_小写短.end());
}

内建_大写("assoc")
{
    检查_实参_在最少的_大写(1);
    实参_大写短(制作树语言哈希_小写, 哈希_小写);

    return 哈希_小写->关联_小写短(实参开头_小写, 实参终_小写);
}

内建_大写("atom")
{
    检查_实参_是不是_大写(1);

    return 制作树语言_小写::原子_小写(*实参开头_小写);
}

内建_大写("concat")
{
    int count = 0;
    for (auto it = 实参开头_小写; it != 实参终_小写; ++it) {
        const 制作树语言队列_小写* 序列_小写短 = 值_类型转换_大写(制作树语言队列_小写, *it);
        count += 序列_小写短->count();
    }

    制作树语言值向量_小写* 条目_小写复 = new 制作树语言值向量_小写(count);
    int offset = 0;
    for (auto it = 实参开头_小写; it != 实参终_小写; ++it) {
        const 制作树语言队列_小写* 序列_小写短 = 静态_类型转换_大写(制作树语言队列_小写, *it);
        std::copy(序列_小写短->begin(), 序列_小写短->end(), 条目_小写复->begin() + offset);
        offset += 序列_小写短->count();
    }

    return 制作树语言_小写::列表_小写(条目_小写复);
}

内建_大写("conj")
{
    检查_实参_在最少的_大写(1);
    实参_大写短(制作树语言队列_小写, 序列_小写短);

    return 序列_小写短->共轭_小写短(实参开头_小写, 实参终_小写);
}

内建_大写("cons")
{
    检查_实参_是不是_大写(2);
    制作树语言值指针_小写 首先_小写 = *实参开头_小写++;
    实参_大写短(制作树语言队列_小写, 其他_小写);

    制作树语言值向量_小写* 条目_小写复 = new 制作树语言值向量_小写(1 + 其他_小写->count());
    条目_小写复->at(0) = 首先_小写;
    std::copy(其他_小写->begin(), 其他_小写->end(), 条目_小写复->begin() + 1);

    return 制作树语言_小写::列表_小写(条目_小写复);
}

内建_大写("contains?")
{
    检查_实参_是不是_大写(2);
    if (*实参开头_小写 == 制作树语言_小写::零值_小写()) {
        return *实参开头_小写;
    }
    实参_大写短(制作树语言哈希_小写, 哈希_小写);
    return 制作树语言_小写::布尔_小写(哈希_小写->内容_小写(*实参开头_小写));
}

内建_大写("count")
{
    检查_实参_是不是_大写(1);
    if (*实参开头_小写 == 制作树语言_小写::零值_小写()) {
        return 制作树语言_小写::整数_小写(0);
    }

    实参_大写短(制作树语言队列_小写, 序列_小写短);
    return 制作树语言_小写::整数_小写(序列_小写短->count());
}

内建_大写("deref")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言原子_小写, 原子_小写);

    return 原子_小写->解引用_小写短();
}

内建_大写("dissoc")
{
    检查_实参_在最少的_大写(1);
    实参_大写短(制作树语言哈希_小写, 哈希_小写);

    return 哈希_小写->解关联_小写短(实参开头_小写, 实参终_小写);
}

内建_大写("empty?")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言队列_小写, 序列_小写短);

    return 制作树语言_小写::布尔_小写(序列_小写短->是否空_小写());
}

内建_大写("求值_小写短")
{
    检查_实参_是不是_大写(1);
    return 求值_大写(*实参开头_小写, NULL);
}

内建_大写("first")
{
    检查_实参_是不是_大写(1);
    if (*实参开头_小写 == 制作树语言_小写::零值_小写()) {
        return 制作树语言_小写::零值_小写();
    }
    实参_大写短(制作树语言队列_小写, 序列_小写短);
    return 序列_小写短->首先_小写();
}

内建_大写("fn?")
{
    检查_实参_是不是_大写(1);
    制作树语言值指针_小写 arg = *实参开头_小写++;

    // Lambdas are functions, unless they're macros.
    if (const 制作树语言兰姆达_小写* 兰姆达_小写 = 动态_类型转换_大写(制作树语言兰姆达_小写, arg)) {
        return 制作树语言_小写::布尔_小写(!兰姆达_小写->是否宏_小写());
    }
    // Builtins are functions.
    return 制作树语言_小写::布尔_小写(动态_类型转换_大写(制作树语言内建的_小写, arg));
}

内建_大写("获取_小写")
{
    检查_实参_是不是_大写(2);
    if (*实参开头_小写 == 制作树语言_小写::零值_小写()) {
        return *实参开头_小写;
    }
    实参_大写短(制作树语言哈希_小写, 哈希_小写);
    return 哈希_小写->获取_小写(*实参开头_小写);
}

内建_大写("哈希_小写-map")
{
    return 制作树语言_小写::哈希_小写(实参开头_小写, 实参终_小写, true);
}

内建_大写("keys")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言哈希_小写, 哈希_小写);
    return 哈希_小写->键_小写复();
}

内建_大写("keyword")
{
    检查_实参_是不是_大写(1);
    const 制作树语言值指针_小写 arg = *实参开头_小写++;
    if (制作树语言关键字_小写* s = 动态_类型转换_大写(制作树语言关键字_小写, arg))
      return s;
    if (const 制作树语言字符串_小写* s = 动态_类型转换_大写(制作树语言字符串_小写, arg))
      return 制作树语言_小写::关键字_小写(":" + s->值_小写());
    制作树语言_失败_大写("keyword expects a keyword or string");
}

内建_大写("list")
{
    return 制作树语言_小写::列表_小写(实参开头_小写, 实参终_小写);
}

内建_大写("macro?")
{
    检查_实参_是不是_大写(1);

    // Macros are implemented as lambdas, with a special flag.
    const 制作树语言兰姆达_小写* 兰姆达_小写 = 动态_类型转换_大写(制作树语言兰姆达_小写, *实参开头_小写);
    return 制作树语言_小写::布尔_小写((兰姆达_小写 != NULL) && 兰姆达_小写->是否宏_小写());
}

内建_大写("map")
{
    检查_实参_是不是_大写(2);
    制作树语言值指针_小写 op = *实参开头_小写++; // this gets checked in 应用_大写
    实参_大写短(制作树语言队列_小写, source);

    const int length = source->count();
    制作树语言值向量_小写* 条目_小写复 = new 制作树语言值向量_小写(length);
    auto it = source->begin();
    for (int i = 0; i < length; i++) {
      条目_小写复->at(i) = 应用_大写(op, it+i, it+i+1);
    }

    return  制作树语言_小写::列表_小写(条目_小写复);
}

内建_大写("meta")
{
    检查_实参_是不是_大写(1);
    制作树语言值指针_小写 obj = *实参开头_小写++;

    return obj->元_小写();
}

内建_大写("nth")
{
    检查_实参_是不是_大写(2);
    实参_大写短(制作树语言队列_小写, 序列_小写短);
    实参_大写短(制作树语言整数_小写,  索引_小写);

    int i = 索引_小写->值_小写();
    制作树语言_检查_大写(i >= 0 && i < 序列_小写短->count(), "Index 出_小写 of range");

    return 序列_小写短->条目_小写(i);
}

内建_大写("pr-str")
{
    return 制作树语言_小写::字符串_小写(打印值_小写复(实参开头_小写, 实参终_小写, " ", true));
}

内建_大写("println")
{
    std::cout << 打印值_小写复(实参开头_小写, 实参终_小写, " ", false) << "\n";
    return 制作树语言_小写::零值_小写();
}

内建_大写("prn")
{
    std::cout << 打印值_小写复(实参开头_小写, 实参终_小写, " ", true) << "\n";
    return 制作树语言_小写::零值_小写();
}

内建_大写("read-string")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言字符串_小写, str);

    return 读字符串_小写(str->值_小写());
}

内建_大写("readline")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言字符串_小写, str);

    return 读行_小写(str->值_小写());
}

内建_大写("reset!")
{
    检查_实参_是不是_大写(2);
    实参_大写短(制作树语言原子_小写, 原子_小写);
    return 原子_小写->重置_小写(*实参开头_小写);
}

内建_大写("rest")
{
    检查_实参_是不是_大写(1);
    if (*实参开头_小写 == 制作树语言_小写::零值_小写()) {
        return 制作树语言_小写::列表_小写(new 制作树语言值向量_小写(0));
    }
    实参_大写短(制作树语言队列_小写, 序列_小写短);
    return 序列_小写短->其他_小写();
}

内建_大写("seq")
{
    检查_实参_是不是_大写(1);
    制作树语言值指针_小写 arg = *实参开头_小写++;
    if (arg == 制作树语言_小写::零值_小写()) {
        return 制作树语言_小写::零值_小写();
    }
    if (const 制作树语言队列_小写* 序列_小写短 = 动态_类型转换_大写(制作树语言队列_小写, arg)) {
        return 序列_小写短->是否空_小写() ? 制作树语言_小写::零值_小写()
                              : 制作树语言_小写::列表_小写(序列_小写短->begin(), 序列_小写短->end());
    }
    if (const 制作树语言字符串_小写* strVal = 动态_类型转换_大写(制作树语言字符串_小写, arg)) {
        const 字符串_大写 str = strVal->值_小写();
        int length = str.length();
        if (length == 0)
            return 制作树语言_小写::零值_小写();

        制作树语言值向量_小写* 条目_小写复 = new 制作树语言值向量_小写(length);
        for (int i = 0; i < length; i++) {
            (*条目_小写复)[i] = 制作树语言_小写::字符串_小写(str.substr(i, 1));
        }
        return 制作树语言_小写::列表_小写(条目_小写复);
    }
    制作树语言_失败_大写("%s is not a string or sequence", arg->打印_小写(true).c_str());
}


内建_大写("slurp")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言字符串_小写, filename);

    std::ios_base::openmode openmode =
        std::ios::ate | std::ios::in | std::ios::binary;
    std::ifstream 文件_小写(filename->值_小写().c_str(), openmode);
    制作树语言_检查_大写(!文件_小写.fail(), "Cannot open %s", filename->值_小写().c_str());

    字符串_大写 数据_小写;
    数据_小写.reserve(文件_小写.tellg());
    文件_小写.seekg(0, std::ios::beg);
    数据_小写.append(std::istreambuf_iterator<char>(文件_小写.rdbuf()),
                std::istreambuf_iterator<char>());

    return 制作树语言_小写::字符串_小写(数据_小写);
}

内建_大写("str")
{
    return 制作树语言_小写::字符串_小写(打印值_小写复(实参开头_小写, 实参终_小写, "", false));
}

内建_大写("swap!")
{
    检查_实参_在最少的_大写(2);
    实参_大写短(制作树语言原子_小写, 原子_小写);

    制作树语言值指针_小写 op = *实参开头_小写++; // this gets checked in 应用_大写

    制作树语言值向量_小写 实参_小写短(1 + 实参终_小写 - 实参开头_小写);
    实参_小写短[0] = 原子_小写->解引用_小写短();
    std::copy(实参开头_小写, 实参终_小写, 实参_小写短.begin() + 1);

    制作树语言值指针_小写 值_小写 = 应用_大写(op, 实参_小写短.begin(), 实参_小写短.end());
    return 原子_小写->重置_小写(值_小写);
}

内建_大写("symbol")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言字符串_小写, 词牌_小写);
    return 制作树语言_小写::符号_小写(词牌_小写->值_小写());
}

内建_大写("throw")
{
    检查_实参_是不是_大写(1);
    throw *实参开头_小写;
}

内建_大写("time-ms")
{
    检查_实参_是不是_大写(0);

    using namespace std::chrono;
    milliseconds ms = duration_cast<milliseconds>(
        high_resolution_clock::now().time_since_epoch()
    );

    return 制作树语言_小写::整数_小写(ms.count());
}

内建_大写("vals")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言哈希_小写, 哈希_小写);
    return 哈希_小写->值_小写复();
}

内建_大写("vec")
{
    检查_实参_是不是_大写(1);
    实参_大写短(制作树语言队列_小写, s);
    return 制作树语言_小写::向量_小写(s->begin(), s->end());
}

内建_大写("vector")
{
    return 制作树语言_小写::向量_小写(实参开头_小写, 实参终_小写);
}

内建_大写("with-meta")
{
    检查_实参_是不是_大写(2);
    制作树语言值指针_小写 obj  = *实参开头_小写++;
    制作树语言值指针_小写 元_小写 = *实参开头_小写++;
    return obj->和元一起_小写(元_小写);
}

void 安装核心_小写(制作树语言环境指针_小写 环境_小写短) {
    for (auto it = 句柄_小写复.begin(), end = 句柄_小写复.end(); it != end; ++it) {
        制作树语言内建的_小写* 句柄者_小写 = *it;
        环境_小写短->设置_小写(句柄者_小写->名字_小写(), 句柄者_小写);
    }
}

static 字符串_大写 打印值_小写复(制作树语言值迭代器_小写 begin, 制作树语言值迭代器_小写 end,
                          const 字符串_大写& sep, bool 可读的_小写)
{
    字符串_大写 出_小写;

    if (begin != end) {
        出_小写 += (*begin)->打印_小写(可读的_小写);
        ++begin;
    }

    for ( ; begin != end; ++begin) {
        出_小写 += sep;
        出_小写 += (*begin)->打印_小写(可读的_小写);
    }

    return 出_小写;
}
