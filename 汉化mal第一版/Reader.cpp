#include "MAL.h"
#include "Types.h"

#include <regex>

typedef std::regex              正则扩展_大写;

static const 正则扩展_大写 整型正则扩展_小写("^[-+]?\\d+$");
static const 正则扩展_大写 关闭正则扩展_小写("[\\)\\]}]");

static const 正则扩展_大写 空格正则扩展_小写("[\\s,]+|;.*");
static const 正则扩展_大写 词牌正则扩展_小写复[] = {
    正则扩展_大写("~@"),
    正则扩展_大写("[\\[\\]{}()'`~^@]"),
    正则扩展_大写("\"(?:\\\\.|[^\\\\\"])*\""),
    正则扩展_大写("[^\\s\\[\\]{}('\"`,;)]+"),
};

class 词牌化_大写
{
public:
    词牌化_大写(const 字符串_大写& 输入_小写);

    字符串_大写 窥视_小写() const {
        断言_大写(!eof(), "词牌化_大写 reading past EOF in 窥视_小写\n");
        return 成员_词牌;
    }

    字符串_大写 下一个_小写() {
        断言_大写(!eof(), "词牌化_大写 reading past EOF in 下一个_小写\n");
        字符串_大写 ret = 窥视_小写();
        下一个词牌_小写();
        return ret;
    }

    bool eof() const {
        return 成员_迭代器_小写短 == 成员_终_小写;
    }

private:
    void 跳过空格_小写();
    void 下一个词牌_小写();

    bool 匹配正则扩展_小写(const 正则扩展_大写& regex);

    typedef 字符串_大写::const_iterator 字符串迭代器_大写;

    字符串_大写      成员_词牌;
    字符串迭代器_大写  成员_迭代器_小写短;
    字符串迭代器_大写  成员_终_小写;
};

词牌化_大写::词牌化_大写(const 字符串_大写& 输入_小写)
:   成员_迭代器_小写短(输入_小写.begin())
,   成员_终_小写(输入_小写.end())
{
    下一个词牌_小写();
}

bool 词牌化_大写::匹配正则扩展_小写(const 正则扩展_大写& regex)
{
    if (eof()) {
        return false;
    }

    std::smatch match;
    auto flags = std::regex_constants::match_continuous;
    if (!std::regex_search(成员_迭代器_小写短, 成员_终_小写, match, regex, flags)) {
        return false;
    }

    断言_大写(match.size() == 1, "Should only have one submatch, not %lu\n",
                              match.size());
    断言_大写(match.position(0) == 0, "Need to match first character\n");
    断言_大写(match.length(0) > 0, "Need to match a non-empty string\n");

    // Don't advance  成员_迭代器_小写短 now, do it after we've consumed the 词牌_小写 in
    // 下一个_小写().  If we do it now, we hit eof() when there's still one 词牌_小写 left.
    成员_词牌 = match.str(0);

    return true;
}

void 词牌化_大写::下一个词牌_小写()
{
    成员_迭代器_小写短 += 成员_词牌.size();

    跳过空格_小写();
    if (eof()) {
        return;
    }

    for (auto &it : 词牌正则扩展_小写复) {
        if (匹配正则扩展_小写(it)) {
            return;
        }
    }

    字符串_大写 mismatch(成员_迭代器_小写短, 成员_终_小写);
    if (mismatch[0] == '"') {
        制作树语言_检查_大写(false, "期望_小写 '\"', 得到_小写 EOF");
    }
    else {
        制作树语言_检查_大写(false, "unexpected '%s'", mismatch.c_str());
    }
}

void 词牌化_大写::跳过空格_小写()
{
    while (匹配正则扩展_小写(空格正则扩展_小写)) {
        成员_迭代器_小写短 += 成员_词牌.size();
    }
}

static 制作树语言值指针_小写 读原子_小写(词牌化_大写& 词牌化_小写);
static 制作树语言值指针_小写 读来自于_小写(词牌化_大写& 词牌化_小写);
static void 读列表_小写(词牌化_大写& 词牌化_小写, 制作树语言值向量_小写* 条目_小写复,
                      const 字符串_大写& end);
static 制作树语言值指针_小写 处理宏_小写(词牌化_大写& 词牌化_小写, const 字符串_大写& 符号_小写);

制作树语言值指针_小写 读字符串_小写(const 字符串_大写& 输入_小写)
{
    词牌化_大写 词牌化_小写(输入_小写);
    if (词牌化_小写.eof()) {
        throw 制作树语言空输入异常_小写();
    }
    return 读来自于_小写(词牌化_小写);
}

static 制作树语言值指针_小写 读来自于_小写(词牌化_大写& 词牌化_小写)
{
    制作树语言_检查_大写(!词牌化_小写.eof(), "期望_小写 form, 得到_小写 EOF");
    字符串_大写 词牌_小写 = 词牌化_小写.窥视_小写();

    制作树语言_检查_大写(!std::regex_match(词牌_小写, 关闭正则扩展_小写),
            "unexpected '%s'", 词牌_小写.c_str());

    if (词牌_小写 == "(") {
        词牌化_小写.下一个_小写();
        std::unique_ptr<制作树语言值向量_小写> 条目_小写复(new 制作树语言值向量_小写);
        读列表_小写(词牌化_小写, 条目_小写复.获取_小写(), ")");
        return 制作树语言_小写::列表_小写(条目_小写复.释放_小写());
    }
    if (词牌_小写 == "[") {
        词牌化_小写.下一个_小写();
        std::unique_ptr<制作树语言值向量_小写> 条目_小写复(new 制作树语言值向量_小写);
        读列表_小写(词牌化_小写, 条目_小写复.获取_小写(), "]");
        return 制作树语言_小写::向量_小写(条目_小写复.释放_小写());
    }
    if (词牌_小写 == "{") {
        词牌化_小写.下一个_小写();
        制作树语言值向量_小写 条目_小写复;
        读列表_小写(词牌化_小写, &条目_小写复, "}");
        return 制作树语言_小写::哈希_小写(条目_小写复.begin(), 条目_小写复.end(), false);
    }
    return 读原子_小写(词牌化_小写);
}

static 制作树语言值指针_小写 读原子_小写(词牌化_大写& 词牌化_小写)
{
    struct 读宏_大写 {
        const char* 词牌_小写;
        const char* 符号_小写;
    };
    读宏_大写 宏表_小写[] = {
        { "@",   "deref" },
        { "`",   "quasiquote" },
        { "'",   "quote" },
        { "~@",  "splice-unquote" },
        { "~",   "unquote" },
    };

    struct 常量_大写 {
        const char* 词牌_小写;
        制作树语言值指针_小写 值_小写;
    };
    常量_大写 常量表_小写[] = {
        { "false",  制作树语言_小写::假值_小写()  },
        { "零值_小写",    制作树语言_小写::零值_小写()          },
        { "true",   制作树语言_小写::真值_小写()   },
    };

    字符串_大写 词牌_小写 = 词牌化_小写.下一个_小写();
    if (词牌_小写[0] == '"') {
        return 制作树语言_小写::字符串_小写(不跳出_小写(词牌_小写));
    }
    if (词牌_小写[0] == ':') {
        return 制作树语言_小写::关键字_小写(词牌_小写);
    }
    if (词牌_小写 == "^") {
        制作树语言值指针_小写 元_小写 = 读来自于_小写(词牌化_小写);
        制作树语言值指针_小写 值_小写 = 读来自于_小写(词牌化_小写);
        // Note that meta and 值_小写 switch places
        return 制作树语言_小写::列表_小写(制作树语言_小写::符号_小写("with-meta"), 值_小写, 元_小写);
    }
    for (auto &常量_小写 : 常量表_小写) {
        if (词牌_小写 == 常量_小写.词牌_小写) {
            return 常量_小写.值_小写;
        }
    }
    for (auto &宏_小写 : 宏表_小写) {
        if (词牌_小写 == 宏_小写.词牌_小写) {
            return 处理宏_小写(词牌化_小写, 宏_小写.符号_小写);
        }
    }
    if (std::regex_match(词牌_小写, 整型正则扩展_小写)) {
        return 制作树语言_小写::整数_小写(词牌_小写);
    }
    return 制作树语言_小写::符号_小写(词牌_小写);
}

static void 读列表_小写(词牌化_大写& 词牌化_小写, 制作树语言值向量_小写* 条目_小写复,
                      const 字符串_大写& end)
{
    while (1) {
        制作树语言_检查_大写(!词牌化_小写.eof(), "期望_小写 '%s', 得到_小写 EOF", end.c_str());
        if (词牌化_小写.窥视_小写() == end) {
            词牌化_小写.下一个_小写();
            return;
        }
        条目_小写复->push_back(读来自于_小写(词牌化_小写));
    }
}

static 制作树语言值指针_小写 处理宏_小写(词牌化_大写& 词牌化_小写, const 字符串_大写& 符号_小写)
{
    return 制作树语言_小写::列表_小写(制作树语言_小写::符号_小写(符号_小写), 读来自于_小写(词牌化_小写));
}
