#ifndef INCLUDE_TYPES_H
#define INCLUDE_TYPES_H

#include "MAL.h"

#include <exception>
#include <map>

class 制作树语言空输入异常_小写 : public std::exception { };

class 制作树语言值_小写 : public 引用计数_过去式 {
public:
    制作树语言值_小写() {
        追踪_对象_大写("Creating 制作树语言值_小写 %p\n", this);
    }
    制作树语言值_小写(制作树语言值指针_小写 元_小写) : 成员_元_小写(元_小写) {
        追踪_对象_大写("Creating 制作树语言值_小写 %p\n", this);
    }
    virtual ~制作树语言值_小写() {
        追踪_对象_大写("Destroying 制作树语言值_小写 %p\n", this);
    }

    制作树语言值指针_小写 和元一起_小写(制作树语言值指针_小写 元_小写) const;
    virtual 制作树语言值指针_小写 执行和元一起_小写(制作树语言值指针_小写 元_小写) const = 0;
    制作树语言值指针_小写 元_小写() const;

    bool 是否真_小写() const;

    bool 是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const;

    virtual 制作树语言值指针_小写 求值_小写短(制作树语言环境指针_小写 环境_小写短);

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const = 0;

protected:
    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const = 0;

    制作树语言值指针_小写 成员_元_小写;
};

template<class T>
T* value_cast(制作树语言值指针_小写 obj, const char* 类型名字_小写) {
    T* dest = dynamic_cast<T*>(obj.ptr());
    制作树语言_检查_大写(dest != NULL, "%s is not a %s",
              obj->打印_小写(true).c_str(), 类型名字_小写);
    return dest;
}

#define 值_类型转换_大写(类型_大写, 值_大写头)    value_cast<类型_大写>(值_大写头, #类型_大写)
#define 动态_类型转换_大写(类型_大写, 值_大写头)  (dynamic_cast<类型_大写*>((值_大写头).ptr()))
#define 静态_类型转换_大写(类型_大写, 值_大写头)   (static_cast<类型_大写*>((值_大写头).ptr()))

#define 和一起_元_大写(类型_大写) \
    virtual 制作树语言值指针_小写 执行和元一起_小写(制作树语言值指针_小写 元_小写) const { \
        return new 类型_大写(*this, 元_小写); \
    } \

class 制作树语言常量_小写 : public 制作树语言值_小写 {
public:
    制作树语言常量_小写(字符串_大写 名字_小写) : 成员_名字_小写(名字_小写) { }
    制作树语言常量_小写(const 制作树语言常量_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言值_小写(元_小写), 成员_名字_小写(that.成员_名字_小写) { }

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const { return 成员_名字_小写; }

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const {
        return this == 右手边_小写缩; // these are singletons
    }

    和一起_元_大写(制作树语言常量_小写);

private:
    const 字符串_大写 成员_名字_小写;
};

class 制作树语言整数_小写 : public 制作树语言值_小写 {
public:
    制作树语言整数_小写(int64_t 值_小写) : 成员_值_小写(值_小写) { }
    制作树语言整数_小写(const 制作树语言整数_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言值_小写(元_小写), 成员_值_小写(that.成员_值_小写) { }

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const {
        return std::to_string(成员_值_小写);
    }

    int64_t 值_小写() const { return 成员_值_小写; }

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const {
        return 成员_值_小写 == static_cast<const 制作树语言整数_小写*>(右手边_小写缩)->成员_值_小写;
    }

    和一起_元_大写(制作树语言整数_小写);

private:
    const int64_t 成员_值_小写;
};

class 制作树语言字符串基础_小写 : public 制作树语言值_小写 {
public:
    制作树语言字符串基础_小写(const 字符串_大写& 词牌_小写)
        : 成员_值_小写(词牌_小写) { }
    制作树语言字符串基础_小写(const 制作树语言字符串基础_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言值_小写(元_小写), 成员_值_小写(that.值_小写()) { }

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const { return 成员_值_小写; }

    字符串_大写 值_小写() const { return 成员_值_小写; }

private:
    const 字符串_大写 成员_值_小写;
};

class 制作树语言字符串_小写 : public 制作树语言字符串基础_小写 {
public:
    制作树语言字符串_小写(const 字符串_大写& 词牌_小写)
        : 制作树语言字符串基础_小写(词牌_小写) { }
    制作树语言字符串_小写(const 制作树语言字符串_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言字符串基础_小写(that, 元_小写) { }

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const;

    字符串_大写 已跳出的值_小写() const;

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const {
        return 值_小写() == static_cast<const 制作树语言字符串_小写*>(右手边_小写缩)->值_小写();
    }

    和一起_元_大写(制作树语言字符串_小写);
};

class 制作树语言关键字_小写 : public 制作树语言字符串基础_小写 {
public:
    制作树语言关键字_小写(const 字符串_大写& 词牌_小写)
        : 制作树语言字符串基础_小写(词牌_小写) { }
    制作树语言关键字_小写(const 制作树语言关键字_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言字符串基础_小写(that, 元_小写) { }

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const {
        return 值_小写() == static_cast<const 制作树语言关键字_小写*>(右手边_小写缩)->值_小写();
    }

    和一起_元_大写(制作树语言关键字_小写);
};

class 制作树语言符号_小写 : public 制作树语言字符串基础_小写 {
public:
    制作树语言符号_小写(const 字符串_大写& 词牌_小写)
        : 制作树语言字符串基础_小写(词牌_小写) { }
    制作树语言符号_小写(const 制作树语言符号_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言字符串基础_小写(that, 元_小写) { }

    virtual 制作树语言值指针_小写 求值_小写短(制作树语言环境指针_小写 环境_小写短);

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const {
        return 值_小写() == static_cast<const 制作树语言符号_小写*>(右手边_小写缩)->值_小写();
    }

    和一起_元_大写(制作树语言符号_小写);
};

class 制作树语言队列_小写 : public 制作树语言值_小写 {
public:
    制作树语言队列_小写(制作树语言值向量_小写* 条目_小写复);
    制作树语言队列_小写(制作树语言值迭代器_小写 begin, 制作树语言值迭代器_小写 end);
    制作树语言队列_小写(const 制作树语言队列_小写& that, 制作树语言值指针_小写 元_小写);
    virtual ~制作树语言队列_小写();

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const;

    制作树语言值向量_小写* 求值条目_小写复(制作树语言环境指针_小写 环境_小写短) const;
    int 计数_小写() const { return 成员_条目_小写复->size(); }
    bool 是否空_小写() const { return 成员_条目_小写复->empty(); }
    制作树语言值指针_小写 条目_小写(int 索引_小写) const { return (*成员_条目_小写复)[索引_小写]; }

    制作树语言值迭代器_小写 begin() const { return 成员_条目_小写复->begin(); }
    制作树语言值迭代器_小写 end()   const { return 成员_条目_小写复->end(); }

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const;

    virtual 制作树语言值指针_小写 共轭_小写短(制作树语言值迭代器_小写 实参开头_小写,
                              制作树语言值迭代器_小写 实参终_小写) const = 0;

    制作树语言值指针_小写 首先_小写() const;
    virtual 制作树语言值指针_小写 其他_小写() const;

private:
    制作树语言值向量_小写* const 成员_条目_小写复;
};

class 制作树语言列表_小写 : public 制作树语言队列_小写 {
public:
    制作树语言列表_小写(制作树语言值向量_小写* 条目_小写复) : 制作树语言队列_小写(条目_小写复) { }
    制作树语言列表_小写(制作树语言值迭代器_小写 begin, 制作树语言值迭代器_小写 end)
        : 制作树语言队列_小写(begin, end) { }
    制作树语言列表_小写(const 制作树语言列表_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言队列_小写(that, 元_小写) { }

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const;
    virtual 制作树语言值指针_小写 求值_小写短(制作树语言环境指针_小写 环境_小写短);

    virtual 制作树语言值指针_小写 共轭_小写短(制作树语言值迭代器_小写 实参开头_小写,
                             制作树语言值迭代器_小写 实参终_小写) const;

    和一起_元_大写(制作树语言列表_小写);
};

class 制作树语言向量_小写 : public 制作树语言队列_小写 {
public:
    制作树语言向量_小写(制作树语言值向量_小写* 条目_小写复) : 制作树语言队列_小写(条目_小写复) { }
    制作树语言向量_小写(制作树语言值迭代器_小写 begin, 制作树语言值迭代器_小写 end)
        : 制作树语言队列_小写(begin, end) { }
    制作树语言向量_小写(const 制作树语言向量_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言队列_小写(that, 元_小写) { }

    virtual 制作树语言值指针_小写 求值_小写短(制作树语言环境指针_小写 环境_小写短);
    virtual 字符串_大写 打印_小写(bool 可读的_小写) const;

    virtual 制作树语言值指针_小写 共轭_小写短(制作树语言值迭代器_小写 实参开头_小写,
                             制作树语言值迭代器_小写 实参终_小写) const;

    和一起_元_大写(制作树语言向量_小写);
};

class 制作树语言可应用的_小写 : public 制作树语言值_小写 {
public:
    制作树语言可应用的_小写() { }
    制作树语言可应用的_小写(制作树语言值指针_小写 元_小写) : 制作树语言值_小写(元_小写) { }

    virtual 制作树语言值指针_小写 应用_小写(制作树语言值迭代器_小写 实参开头_小写,
                               制作树语言值迭代器_小写 实参终_小写) const = 0;
};

class 制作树语言哈希_小写 : public 制作树语言值_小写 {
public:
    typedef std::map<字符串_大写, 制作树语言值指针_小写> 映射_大写;

    制作树语言哈希_小写(制作树语言值迭代器_小写 实参开头_小写, 制作树语言值迭代器_小写 实参终_小写, bool 是否已求值_小写);
    制作树语言哈希_小写(const 制作树语言哈希_小写::映射_大写& map);
    制作树语言哈希_小写(const 制作树语言哈希_小写& that, 制作树语言值指针_小写 元_小写)
    : 制作树语言值_小写(元_小写), 成员_映射_小写(that.成员_映射_小写), 成员_是否已求值_小写(that.成员_是否已求值_小写) { }

    制作树语言值指针_小写 关联_小写短(制作树语言值迭代器_小写 实参开头_小写, 制作树语言值迭代器_小写 实参终_小写) const;
    制作树语言值指针_小写 解关联_小写短(制作树语言值迭代器_小写 实参开头_小写, 制作树语言值迭代器_小写 实参终_小写) const;
    bool 内容_小写(制作树语言值指针_小写 键_小写单) const;
    制作树语言值指针_小写 求值_小写短(制作树语言环境指针_小写 环境_小写短);
    制作树语言值指针_小写 获取_小写(制作树语言值指针_小写 键_小写单) const;
    制作树语言值指针_小写 键_小写复() const;
    制作树语言值指针_小写 值_小写复() const;

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const;

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const;

    和一起_元_大写(制作树语言哈希_小写);

private:
    const 映射_大写 成员_映射_小写;
    const bool 成员_是否已求值_小写;
};

class 制作树语言内建的_小写 : public 制作树语言可应用的_小写 {
public:
    typedef 制作树语言值指针_小写 (应用函数_大写短)(const 字符串_大写& 名字_小写,
                                    制作树语言值迭代器_小写 实参开头_小写,
                                    制作树语言值迭代器_小写 实参终_小写);

    制作树语言内建的_小写(const 字符串_大写& 名字_小写, 应用函数_大写短* 句柄者_小写)
    : 成员_名字_小写(名字_小写), 成员_句柄者_小写(句柄者_小写) { }

    制作树语言内建的_小写(const 制作树语言内建的_小写& that, 制作树语言值指针_小写 元_小写)
    : 制作树语言可应用的_小写(元_小写), 成员_名字_小写(that.成员_名字_小写), 成员_句柄者_小写(that.成员_句柄者_小写) { }

    virtual 制作树语言值指针_小写 应用_小写(制作树语言值迭代器_小写 实参开头_小写,
                              制作树语言值迭代器_小写 实参终_小写) const;

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const {
        return 字符串打印_大写缩("#内建_小写-function(%s)", 成员_名字_小写.c_str());
    }

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const {
        return this == 右手边_小写缩; // these are singletons
    }

    字符串_大写 名字_小写() const { return 成员_名字_小写; }

    和一起_元_大写(制作树语言内建的_小写);

private:
    const 字符串_大写 成员_名字_小写;
    应用函数_大写短* 成员_句柄者_小写;
};

class 制作树语言兰姆达_小写 : public 制作树语言可应用的_小写 {
public:
    制作树语言兰姆达_小写(const 字符串向量_大写短& 绑定_小写复, 制作树语言值指针_小写 body, 制作树语言环境指针_小写 环境_小写短);
    制作树语言兰姆达_小写(const 制作树语言兰姆达_小写& that, 制作树语言值指针_小写 元_小写);
    制作树语言兰姆达_小写(const 制作树语言兰姆达_小写& that, bool 是否宏_小写);

    virtual 制作树语言值指针_小写 应用_小写(制作树语言值迭代器_小写 实参开头_小写,
                              制作树语言值迭代器_小写 实参终_小写) const;

    制作树语言值指针_小写 获取身体_小写() const { return 成员_身体_小写; }
    制作树语言环境指针_小写 制作环境_小写短(制作树语言值迭代器_小写 实参开头_小写, 制作树语言值迭代器_小写 实参终_小写) const;

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const {
        return this == 右手边_小写缩; // do we need to do a deep inspection?
    }

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const {
        return 字符串打印_大写缩("#user-%s(%p)", 成员_是否宏_小写 ? "macro" : "function", this);
    }

    bool 是否宏_小写() const { return 成员_是否宏_小写; }

    virtual 制作树语言值指针_小写 执行和元一起_小写(制作树语言值指针_小写 元_小写) const;

private:
    const 字符串向量_大写短   成员_绑定_小写复;
    const 制作树语言值指针_小写 成员_身体_小写;
    const 制作树语言环境指针_小写   成员_环境_小写短;
    const bool        成员_是否宏_小写;
};

class 制作树语言原子_小写 : public 制作树语言值_小写 {
public:
    制作树语言原子_小写(制作树语言值指针_小写 值_小写) : 成员_值_小写(值_小写) { }
    制作树语言原子_小写(const 制作树语言原子_小写& that, 制作树语言值指针_小写 元_小写)
        : 制作树语言值_小写(元_小写), 成员_值_小写(that.成员_值_小写) { }

    virtual bool 执行是否等同的_小写(const 制作树语言值_小写* 右手边_小写缩) const {
        return this->成员_值_小写->是否等同的_小写(右手边_小写缩);
    }

    virtual 字符串_大写 打印_小写(bool 可读的_小写) const {
        return "(atom " + 成员_值_小写->打印_小写(可读的_小写) + ")";
    };

    制作树语言值指针_小写 解引用_小写短() const { return 成员_值_小写; }

    制作树语言值指针_小写 重置_小写(制作树语言值指针_小写 值_小写) { return 成员_值_小写 = 值_小写; }

    和一起_元_大写(制作树语言原子_小写);

private:
    制作树语言值指针_小写 成员_值_小写;
};

namespace 制作树语言_小写 {
    制作树语言值指针_小写 原子_小写(制作树语言值指针_小写 值_小写);
    制作树语言值指针_小写 布尔_小写(bool 值_小写);
    制作树语言值指针_小写 内建_小写(const 字符串_大写& 名字_小写, 制作树语言内建的_小写::应用函数_大写短 句柄者_小写);
    制作树语言值指针_小写 假值_小写();
    制作树语言值指针_小写 哈希_小写(制作树语言值迭代器_小写 实参开头_小写, 制作树语言值迭代器_小写 实参终_小写,
                     bool 是否已求值_小写);
    制作树语言值指针_小写 哈希_小写(const 制作树语言哈希_小写::映射_大写& map);
    制作树语言值指针_小写 整数_小写(int64_t 值_小写);
    制作树语言值指针_小写 整数_小写(const 字符串_大写& 词牌_小写);
    制作树语言值指针_小写 关键字_小写(const 字符串_大写& 词牌_小写);
    制作树语言值指针_小写 兰姆达_小写(const 字符串向量_大写短&, 制作树语言值指针_小写, 制作树语言环境指针_小写);
    制作树语言值指针_小写 列表_小写(制作树语言值向量_小写* 条目_小写复);
    制作树语言值指针_小写 列表_小写(制作树语言值迭代器_小写 begin, 制作树语言值迭代器_小写 end);
    制作树语言值指针_小写 列表_小写(制作树语言值指针_小写 a);
    制作树语言值指针_小写 列表_小写(制作树语言值指针_小写 a, 制作树语言值指针_小写 b);
    制作树语言值指针_小写 列表_小写(制作树语言值指针_小写 a, 制作树语言值指针_小写 b, 制作树语言值指针_小写 c);
    制作树语言值指针_小写 宏_小写(const 制作树语言兰姆达_小写& 兰姆达_小写);
    制作树语言值指针_小写 零值_小写();
    制作树语言值指针_小写 字符串_小写(const 字符串_大写& 词牌_小写);
    制作树语言值指针_小写 符号_小写(const 字符串_大写& 词牌_小写);
    制作树语言值指针_小写 真值_小写();
    制作树语言值指针_小写 向量_小写(制作树语言值向量_小写* 条目_小写复);
    制作树语言值指针_小写 向量_小写(制作树语言值迭代器_小写 begin, 制作树语言值迭代器_小写 end);
};

#endif // INCLUDE_TYPES_H
