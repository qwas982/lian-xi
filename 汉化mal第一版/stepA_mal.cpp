#include "MAL.h"

#include "Environment.h"
#include "ReadLine.h"
#include "Types.h"

#include <iostream>
#include <memory>

制作树语言值指针_小写 读_大写(const 字符串_大写& 输入_小写);
字符串_大写 打印_大写(制作树语言值指针_小写 抽象句法树_小写);
static void 安装函数_小写复(制作树语言环境指针_小写 环境_小写短);
//  Installs functions, macros and constants implemented in MAL.

static void 制作实参值_小写(制作树语言环境指针_小写 环境_小写短, int 实参计数_小写缩, char* 实参值_小写缩[]);
static 字符串_大写 安全Rep_小写(const 字符串_大写& 输入_小写, 制作树语言环境指针_小写 环境_小写短);
static 制作树语言值指针_小写 准引号_小写(制作树语言值指针_小写 obj);
static 制作树语言值指针_小写 宏扩展_小写(制作树语言值指针_小写 obj, 制作树语言环境指针_小写 环境_小写短);

static ReadLine s_readLine("~/.制作树语言_小写-history");

static 制作树语言环境指针_小写 读求值打印环环境_小写短(new 制作树语言环境_小写);

int main(int 实参计数_小写缩, char* 实参值_小写缩[])
{
    字符串_大写 提示符_小写 = "user> ";
    字符串_大写 输入_小写;
    安装核心_小写(读求值打印环环境_小写短);
    安装函数_小写复(读求值打印环环境_小写短);
    制作实参值_小写(读求值打印环环境_小写短, 实参计数_小写缩 - 2, 实参值_小写缩 + 2);
    if (实参计数_小写缩 > 1) {
        字符串_大写 filename = 跳出_小写(实参值_小写缩[1]);
        安全Rep_小写(字符串打印_大写缩("(load-file %s)", filename.c_str()), 读求值打印环环境_小写短);
        return 0;
    }
    读求值印_小写("(println (str \"Mal [\" *host-language* \"]\"))", 读求值打印环环境_小写短);
    while (s_readLine.获取_小写(提示符_小写, 输入_小写)) {
        字符串_大写 出_小写 = 安全Rep_小写(输入_小写, 读求值打印环环境_小写短);
        if (出_小写.length() > 0)
            std::cout << 出_小写 << "\n";
    }
    return 0;
}

static 字符串_大写 安全Rep_小写(const 字符串_大写& 输入_小写, 制作树语言环境指针_小写 环境_小写短)
{
    try {
        return 读求值印_小写(输入_小写, 环境_小写短);
    }
    catch (制作树语言空输入异常_小写&) {
        return 字符串_大写();
    }
    catch (制作树语言值指针_小写& mv) {
        return "Error: " + mv->打印_小写(true);
    }
    catch (字符串_大写& s) {
        return "Error: " + s;
    };
}

static void 制作实参值_小写(制作树语言环境指针_小写 环境_小写短, int 实参计数_小写缩, char* 实参值_小写缩[])
{
    制作树语言值向量_小写* 实参_小写短 = new 制作树语言值向量_小写();
    for (int i = 0; i < 实参计数_小写缩; i++) {
        实参_小写短->push_back(制作树语言_小写::字符串_小写(实参值_小写缩[i]));
    }
    环境_小写短->设置_小写("*ARGV*", 制作树语言_小写::列表_小写(实参_小写短));
}

字符串_大写 读求值印_小写(const 字符串_大写& 输入_小写, 制作树语言环境指针_小写 环境_小写短)
{
    return 打印_大写(求值_大写(读_大写(输入_小写), 环境_小写短));
}

制作树语言值指针_小写 读_大写(const 字符串_大写& 输入_小写)
{
    return 读字符串_小写(输入_小写);
}

制作树语言值指针_小写 求值_大写(制作树语言值指针_小写 抽象句法树_小写, 制作树语言环境指针_小写 环境_小写短)
{
    if (!环境_小写短) {
        环境_小写短 = 读求值打印环环境_小写短;
    }
    while (1) {
        const 制作树语言列表_小写* 列表_小写 = 动态_类型转换_大写(制作树语言列表_小写, 抽象句法树_小写);
        if (!列表_小写 || (列表_小写->计数_小写() == 0)) {
            return 抽象句法树_小写->求值_小写短(环境_小写短);
        }

        抽象句法树_小写 = 宏扩展_小写(抽象句法树_小写, 环境_小写短);
        列表_小写 = 动态_类型转换_大写(制作树语言列表_小写, 抽象句法树_小写);
        if (!列表_小写 || (列表_小写->计数_小写() == 0)) {
            return 抽象句法树_小写->求值_小写短(环境_小写短);
        }

        // From here on down we are evaluating a non-empty 列表_小写.
        // First handle the special forms.
        if (const 制作树语言符号_小写* 符号_小写 = 动态_类型转换_大写(制作树语言符号_小写, 列表_小写->条目_小写(0))) {
            字符串_大写 特殊的_小写 = 符号_小写->值_小写();
            int 实参计数_小写 = 列表_小写->计数_小写() - 1;

            if (特殊的_小写 == "def!") {
                检查实参是不是("def!", 2, 实参计数_小写);
                const 制作树语言符号_小写* id = 值_类型转换_大写(制作树语言符号_小写, 列表_小写->条目_小写(1));
                return 环境_小写短->设置_小写(id->值_小写(), 求值_大写(列表_小写->条目_小写(2), 环境_小写短));
            }

            if (特殊的_小写 == "defmacro!") {
                检查实参是不是("defmacro!", 2, 实参计数_小写);

                const 制作树语言符号_小写* id = 值_类型转换_大写(制作树语言符号_小写, 列表_小写->条目_小写(1));
                制作树语言值指针_小写 body = 求值_大写(列表_小写->条目_小写(2), 环境_小写短);
                const 制作树语言兰姆达_小写* 兰姆达_小写 = 值_类型转换_大写(制作树语言兰姆达_小写, body);
                return 环境_小写短->设置_小写(id->值_小写(), 制作树语言_小写::宏_小写(*兰姆达_小写));
            }

            if (特殊的_小写 == "do") {
                检查实参至少("do", 1, 实参计数_小写);

                for (int i = 1; i < 实参计数_小写; i++) {
                    求值_大写(列表_小写->条目_小写(i), 环境_小写短);
                }
                抽象句法树_小写 = 列表_小写->条目_小写(实参计数_小写);
                continue; // TCO
            }

            if (特殊的_小写 == "fn*") {
                检查实参是不是("fn*", 2, 实参计数_小写);

                const 制作树语言队列_小写* 绑定_小写复 =
                    值_类型转换_大写(制作树语言队列_小写, 列表_小写->条目_小写(1));
                字符串向量_大写短 形参_小写短;
                for (int i = 0; i < 绑定_小写复->计数_小写(); i++) {
                    const 制作树语言符号_小写* sym =
                        值_类型转换_大写(制作树语言符号_小写, 绑定_小写复->条目_小写(i));
                    形参_小写短.push_back(sym->值_小写());
                }

                return 制作树语言_小写::兰姆达_小写(形参_小写短, 列表_小写->条目_小写(2), 环境_小写短);
            }

            if (特殊的_小写 == "if") {
                检查实参之间("if", 2, 3, 实参计数_小写);

                bool 是否真_小写 = 求值_大写(列表_小写->条目_小写(1), 环境_小写短)->是否真_小写();
                if (!是否真_小写 && (实参计数_小写 == 2)) {
                    return 制作树语言_小写::零值_小写();
                }
                抽象句法树_小写 = 列表_小写->条目_小写(是否真_小写 ? 2 : 3);
                continue; // TCO
            }

            if (特殊的_小写 == "let*") {
                检查实参是不是("let*", 2, 实参计数_小写);
                const 制作树语言队列_小写* 绑定_小写复 =
                    值_类型转换_大写(制作树语言队列_小写, 列表_小写->条目_小写(1));
                int 计数_小写 = 检查实参即使("let*", 绑定_小写复->计数_小写());
                制作树语言环境指针_小写 inner(new 制作树语言环境_小写(环境_小写短));
                for (int i = 0; i < 计数_小写; i += 2) {
                    const 制作树语言符号_小写* var =
                        值_类型转换_大写(制作树语言符号_小写, 绑定_小写复->条目_小写(i));
                    inner->设置_小写(var->值_小写(), 求值_大写(绑定_小写复->条目_小写(i+1), inner));
                }
                抽象句法树_小写 = 列表_小写->条目_小写(2);
                环境_小写短 = inner;
                continue; // TCO
            }

            if (特殊的_小写 == "macroexpand") {
                检查实参是不是("macroexpand", 1, 实参计数_小写);
                return 宏扩展_小写(列表_小写->条目_小写(1), 环境_小写短);
            }

            if (特殊的_小写 == "quasiquoteexpand") {
                检查实参是不是("quasiquote", 1, 实参计数_小写);
                return 准引号_小写(列表_小写->条目_小写(1));
            }

            if (特殊的_小写 == "quasiquote") {
                检查实参是不是("quasiquote", 1, 实参计数_小写);
                抽象句法树_小写 = 准引号_小写(列表_小写->条目_小写(1));
                continue; // TCO
            }

            if (特殊的_小写 == "quote") {
                检查实参是不是("quote", 1, 实参计数_小写);
                return 列表_小写->条目_小写(1);
            }

            if (特殊的_小写 == "try*") {
                制作树语言值指针_小写 tryBody = 列表_小写->条目_小写(1);

                if (实参计数_小写 == 1) {
                    抽象句法树_小写 = 求值_大写(tryBody, 环境_小写短);
                    continue; // TCO
                }
                检查实参是不是("try*", 2, 实参计数_小写);
                const 制作树语言列表_小写* catchBlock = 值_类型转换_大写(制作树语言列表_小写, 列表_小写->条目_小写(2));

                检查实参是不是("catch*", 2, catchBlock->计数_小写() - 1);
                制作树语言_检查_大写(值_类型转换_大写(制作树语言符号_小写,
                    catchBlock->条目_小写(0))->值_小写() == "catch*",
                    "catch block must begin with catch*");

                // We don't need excSym at this scope, but we want to check
                // that the catch block is valid always, not just in case of
                // an exception.
                const 制作树语言符号_小写* excSym =
                    值_类型转换_大写(制作树语言符号_小写, catchBlock->条目_小写(1));

                制作树语言值指针_小写 excVal;

                try {
                    抽象句法树_小写 = 求值_大写(tryBody, 环境_小写短);
                }
                catch(字符串_大写& s) {
                    excVal = 制作树语言_小写::字符串_小写(s);
                }
                catch (制作树语言空输入异常_小写&) {
                    // Not an error, continue as if we 得到_小写 零值_小写
                    抽象句法树_小写 = 制作树语言_小写::零值_小写();
                }
                catch(制作树语言值指针_小写& o) {
                    excVal = o;
                };

                if (excVal) {
                    // we 得到_小写 some exception
                    环境_小写短 = 制作树语言环境指针_小写(new 制作树语言环境_小写(环境_小写短));
                    环境_小写短->设置_小写(excSym->值_小写(), excVal);
                    抽象句法树_小写 = catchBlock->条目_小写(2);
                }
                continue; // TCO
            }
        }

        // Now we're left with the case of a regular 列表_小写 to be evaluated.
        std::unique_ptr<制作树语言值向量_小写> 条目_小写复(列表_小写->求值条目_小写复(环境_小写短));
        制作树语言值指针_小写 op = 条目_小写复->at(0);
        if (const 制作树语言兰姆达_小写* 兰姆达_小写 = 动态_类型转换_大写(制作树语言兰姆达_小写, op)) {
            抽象句法树_小写 = 兰姆达_小写->获取身体_小写();
            环境_小写短 = 兰姆达_小写->制作环境_小写短(条目_小写复->begin()+1, 条目_小写复->end());
            continue; // TCO
        }
        else {
            return 应用_大写(op, 条目_小写复->begin()+1, 条目_小写复->end());
        }
    }
}

字符串_大写 打印_大写(制作树语言值指针_小写 抽象句法树_小写)
{
    return 抽象句法树_小写->打印_小写(true);
}

制作树语言值指针_小写 应用_大写(制作树语言值指针_小写 op, 制作树语言值迭代器_小写 实参开头_小写, 制作树语言值迭代器_小写 实参终_小写)
{
    const 制作树语言可应用的_小写* 句柄者_小写 = 动态_类型转换_大写(制作树语言可应用的_小写, op);
    制作树语言_检查_大写(句柄者_小写 != NULL,
              "\"%s\" is not applicable", op->打印_小写(true).c_str());

    return 句柄者_小写->应用_小写(实参开头_小写, 实参终_小写);
}

static bool 是否符号_小写(制作树语言值指针_小写 obj, const 字符串_大写& text)
{
    const 制作树语言符号_小写* sym = 动态_类型转换_大写(制作树语言符号_小写, obj);
    return sym && (sym->值_小写() == text);
}

//  Return arg when 抽象句法树_小写 matches ('sym, arg), else NULL.
static 制作树语言值指针_小写 和开始一起_小写(const 制作树语言值指针_小写 抽象句法树_小写, const char* sym)
{
    const 制作树语言列表_小写* 列表_小写 = 动态_类型转换_大写(制作树语言列表_小写, 抽象句法树_小写);
    if (!列表_小写 || 列表_小写->是否空_小写() || !是否符号_小写(列表_小写->条目_小写(0), sym))
        return NULL;
    检查实参是不是(sym, 1, 列表_小写->计数_小写() - 1);
    return 列表_小写->条目_小写(1);
}

static 制作树语言值指针_小写 准引号_小写(制作树语言值指针_小写 obj)
{
    if (动态_类型转换_大写(制作树语言符号_小写, obj) || 动态_类型转换_大写(制作树语言哈希_小写, obj))
        return 制作树语言_小写::列表_小写(制作树语言_小写::符号_小写("quote"), obj);

    const 制作树语言队列_小写* 序列_小写短 = 动态_类型转换_大写(制作树语言队列_小写, obj);
    if (!序列_小写短)
        return obj;

    const 制作树语言值指针_小写 unquoted = 和开始一起_小写(obj, "unquote");
    if (unquoted)
        return unquoted;

    制作树语言值指针_小写 res = 制作树语言_小写::列表_小写(new 制作树语言值向量_小写(0));
    for (int i=序列_小写短->计数_小写()-1; 0<=i; i--) {
        const 制作树语言值指针_小写 元素_小写缩     = 序列_小写短->条目_小写(i);
        const 制作树语言值指针_小写 spl_unq = 和开始一起_小写(元素_小写缩, "splice-unquote");
        if (spl_unq)
            res = 制作树语言_小写::列表_小写(制作树语言_小写::符号_小写("concat"), spl_unq, res);
         else
            res = 制作树语言_小写::列表_小写(制作树语言_小写::符号_小写("cons"), 准引号_小写(元素_小写缩), res);
    }
    if (动态_类型转换_大写(制作树语言向量_小写, obj))
        res = 制作树语言_小写::列表_小写(制作树语言_小写::符号_小写("vec"), res);
    return res;
}

static const 制作树语言兰姆达_小写* 是否宏应用的_小写(制作树语言值指针_小写 obj, 制作树语言环境指针_小写 环境_小写短)
{
    const 制作树语言列表_小写* 序列_小写短 = 动态_类型转换_大写(制作树语言列表_小写, obj);
    if (序列_小写短 && !序列_小写短->是否空_小写()) {
        if (制作树语言符号_小写* sym = 动态_类型转换_大写(制作树语言符号_小写, 序列_小写短->条目_小写(0))) {
            if (制作树语言环境指针_小写 symEnv = 环境_小写短->找_小写(sym->值_小写())) {
                制作树语言值指针_小写 值_小写 = sym->求值_小写短(symEnv);
                if (制作树语言兰姆达_小写* 兰姆达_小写 = 动态_类型转换_大写(制作树语言兰姆达_小写, 值_小写)) {
                    return 兰姆达_小写->是否宏_小写() ? 兰姆达_小写 : NULL;
                }
            }
        }
    }
    return NULL;
}

static 制作树语言值指针_小写 宏扩展_小写(制作树语言值指针_小写 obj, 制作树语言环境指针_小写 环境_小写短)
{
    while (const 制作树语言兰姆达_小写* 宏_小写 = 是否宏应用的_小写(obj, 环境_小写短)) {
        const 制作树语言队列_小写* 序列_小写短 = 静态_类型转换_大写(制作树语言队列_小写, obj);
        obj = 宏_小写->应用_小写(序列_小写短->begin() + 1, 序列_小写短->end());
    }
    return obj;
}

static const char* 制作树语言函数表_小写[] = {
    "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))",
    "(def! not (fn* (cond) (if cond false true)))",
    "(def! load-file (fn* (filename) \
        (求值_小写短 (read-string (str \"(do \" (slurp filename) \"\nnil)\")))))",
    "(def! *host-language* \"C++\")",
};

static void 安装函数_小写复(制作树语言环境指针_小写 环境_小写短) {
    for (auto &function : 制作树语言函数表_小写) {
        读求值印_小写(function, 环境_小写短);
    }
}

// Added to keep the linker happy at step A
制作树语言值指针_小写 读行_小写(const 字符串_大写& 提示符_小写)
{
    字符串_大写 输入_小写;
    if (s_readLine.获取_小写(提示符_小写, 输入_小写)) {
        return 制作树语言_小写::字符串_小写(输入_小写);
    }
    return 制作树语言_小写::零值_小写();
}

