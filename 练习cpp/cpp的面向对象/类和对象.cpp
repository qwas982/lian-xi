#include <iostream>
using namespace std;

const double 派=3.141592653;

class 圆形{
    public: int 成员_半径; //属性
    double 圆的周长(){
        return 成员_半径*派*2;
    }
};

class 学生{
    public:
        void 设置名字(string 名字){
            成员_名字=名字;
        }

        void 设置身份(int 身份){
            成员_身份=身份;
        }

        void 秀学生(){
            cout<<"名字:"<<成员_名字<<" 身份:"<<成员_身份<<endl;
        }
    public:
        string 成员_名字;
        int 成员_身份;
};

//访问封装类的权限 公有 私有 保护
class 个人{
    public: string 成员_名字;
    protected: string 成员_车;
    private: int 成员_密码;
    public:
        void 函克(){
            成员_名字="张三"; 成员_车="单车"; 成员_密码=99999;
        }
};

int 封装的意义()
{
    圆形 具体的园; 具体的园.成员_半径=9;
    cout<<"圆的周长是;"<<具体的园.圆的周长()<<endl;

    //实例学生类
    学生 学子; 学子.设置名字("呼啦啦"); 学子.设置身份(999);
    学子.秀学生(); 

    个人 单个; 单个.成员_名字="李四"; //单个.成员_车="灵薄渡";
    //单个.成员_密码 = 111;

    system("pause");
    return 0;
}

class 类1{
    int 成员_甲; //默认私有权限,
};

struct 类2{
    int 成员_甲; //默认是公有权限,
};

int struct与class的区别(){
    //区别就是 结构 默认是公有权限 , 类 默认是私有权限,
    类1 实1; //实1.成员_甲=9; //报错, 私有权限不可访问,
    类2 实2; 实2.成员_甲=9; //公有权限甚至能 自动完成 提示,
    system("pause"); return 0;
}

class 个人1{
    public:
        void 设置名(string 名字){
            成员_名字 = 名字;
        }
        string 取名字(){
            return 成员_名字;
        }
        int 取年龄(){
            return 成员_年龄;
        }
        void 设置年龄(int 年龄){
            if(年龄<0 || 年龄>150){
                cout<<"长寿人"<<endl; return;
            } 成员_年龄 = 年龄;
        }
        void 设置爱者(string 爱者){
            成员_爱者= 爱者;
        }
    private:
        string 成员_名字; int 成员_年龄; string 成员_爱者;
};

int 成员属性设置为私有(){
    个人1 亻; 亻.设置名("张三"); cout<<"姓名:"<<亻.取名字()<<endl;
    亻.设置年龄(99); cout<<"年龄;"<<亻.取年龄()<<endl;
    亻.设置爱者("孟美岐"); //cout<<"爱者"<<亻.成员_爱者<<endl; //只写属性
    system("pause"); return 0;
}

class 个人3{
    public:
        个人3(){
            cout<<"个人3的构造函数"<<endl;
        }
        ~个人3(){
            cout<<"个人3的解构函数"<<endl;
        }
};

void 测试1(){
    个人3 亻;
}

int 构造和解构函数(){
    测试1(); system("pause"); return 0;
}

class 个人4{
    public:
        个人4(){
            cout<<"无参构造函数"<<endl;
        }
        个人4(int 甲){
            年龄 = 甲; cout<<"有参构造函数"<<endl;
        }
        个人4(const 个人4 &亻){
            年龄 = 亻.年龄; cout<<"复制构造函数"<<endl;
        }
        ~个人4(){
            cout<<"解构函数"<<endl;
        }
    public:
        int 年龄;
};

void 调用无参构造函数(){
    个人4 亻;
}

void 调用有参构造函数(){
    个人4 亻1(9); //括号法
    个人4 亻2();
    个人4 亻3 = 个人4(9); 个人4 亻4 = 个人4(亻3);
    个人4(9);
    个人4 亻5 = 9; 个人4 亻6  = 亻5; //隐式转换法
    //个人4 亻6(亻5);
}

int 构造函数的分类和调用(){
    调用无参构造函数(); 调用有参构造函数(); system("pause"); return 0;
}

class 个人5{
    public:
        个人5(){
            cout<<"无参构造函数"<<endl; 成员年龄=0;
        }
        个人5(int 年龄){
            cout<<"有参构造函数"<<endl; 成员年龄=年龄;
        }
        个人5(const 个人5 &亻){
            cout<<"复制构造函数"<<endl; 成员年龄= 亻.成员年龄;
        }
        ~个人5(){
            cout<<"解构函数"<<endl;
        }
    public:
        int 成员年龄;
};

void 已创建对象初始化新对象(){
    个人5 男人(99); 个人5 新男人(男人); 个人5 新男人1 =男人;
    个人5 新男人2; 新男人2 = 男人;
}

void 做事(个人5 亻1){}
void 值传递的方式给函数传值(){
    个人5 亻; 做事(亻);
}

个人5 做事1(){
    个人5 亻1; cout<<(int*)&亻1<<endl; return 亻1;
}
void 用值返回局部对象(){
    个人5 亻 = 做事1(); cout<<(int*)&亻<<endl;
}

int 复制构造函数调用时机(){
    已创建对象初始化新对象(); 值传递的方式给函数传值();
    用值返回局部对象();  system("pause"); return 0;
}

class 个人6{
    public:
        个人6(){
            cout<<"无参构造函数"<<endl;
        }
        个人6(int 甲){
            年龄 = 甲; cout<<"有参构造函数"<<endl;
        }
        个人6(const 个人6 &亻){
            年龄 = 亻.年龄; cout<<"复制构造函数"<<endl;
        }
        ~个人6(){
            cout<<"解构函数"<<endl;
        }
    public:
        int 年龄;
};

void 测试01(){
    个人6 亻1(19); 个人6 亻2(亻1); cout<<"亻2的年龄:"<<亻2.年龄<<endl;
}

void 测试02(){
    个人6 亻1; 个人6 亻2(9); 个人6 亻3(亻2); 
    个人6 亻4; 个人6 亻5(9); 个人6 亻6(亻5);
}

int 构造函数调用规则(){
    测试01(); 测试02(); system("pause"); return 0;
}

class 深浅{
    public:
        深浅(){
            cout<<"无参构造函数"<<endl;
        }
        深浅(int 年龄, int 高度){
            cout<<"有参构造函数"<<endl;
            成员_年龄 = 年龄;
            成员_高度 = new int(高度);
        }
        深浅(const 深浅 &匹){
            cout<<"拷贝构造函数"<<endl;
            成员_年龄 = 匹.成员_年龄;
            成员_高度 = new int(*匹.成员_高度);
        }
        ~深浅(){
            cout<<"析构函数"<<endl;
            if(成员_高度 != NULL){
                delete 成员_高度;
            }
        }
    public:
        int 成员_年龄; int* 成员_高度;
};

void 深浅测01(){
    深浅 匹1(19,90); 深浅 匹2(匹1);
    cout<<"匹1的年龄:"<<匹1.成员_年龄<<"身高:"<<*匹1.成员_高度<<endl;
    cout<<"匹2的年龄:"<<匹2.成员_年龄<<"身高:"<<*匹2.成员_高度<<endl;
}

int 浅拷贝和深拷贝(){
    深浅测01(); system("pause"); return 0;
}

class 初始化属性{
    private:
        int 成员_甲, 成员_丙, 成员_乙;
    public:
        //传统方式初始化
        /*初始化属性(int 甲,int 乙,int 丙){
            成员_甲=甲; 成员_乙=乙; 成员_丙=丙;
        }*/
        //初始化列表反思初始化
        初始化属性(int 甲,int 乙,int 丙):成员_甲(甲),成员_乙(乙),成员_丙(丙){}
        void 打印初始化属性(){
            cout<<"成员甲:"<<成员_甲<<endl;
            cout<<"成员乙:"<<成员_乙<<endl;
            cout<<"成员丙:"<<成员_丙<<endl;
        }
};

int 初始化列表(){
    初始化属性 初始(1,2,3); 初始.打印初始化属性(); system("pause"); return 0;
}

class 电话{
    public:
        string 成员_电话名;

        电话(string 名字){
            成员_电话名=名字; cout<<"电话构造函数"<<endl;
        }
        ~电话(){
            cout<<"电话析构函数"<<endl;
        }
};

class 对象成员{
    public:
    string 成员_名字; 电话 成员_电话;
    对象成员(string 名字,string 对名字):成员_名字(名字),成员_电话(对名字){
        cout<<"对象成员的构造函数"<<endl;
    }
    ~对象成员(){
        cout<<"对象成员的析构函数"<<endl;
    }
    void 玩游戏(){
        cout<<成员_名字<<"使用"<<成员_电话.成员_电话名<<"牌子"<<endl;
    }
};

void 对象成员测试01(){
    //构造顺序: 先调用对象成员的构造, 再调用本类构造. 析构则相反
    对象成员 皮("张三","苹果机"); 皮.玩游戏();
}

int 类对象作为类成员(){
    对象成员测试01(); system("pause"); return 0;
}

class 静态成员变量{
    public:
        static int 成员_甲;
    private:
        static int 成员_乙;
};
int 静态成员变量::成员_甲=9, 静态成员变量::成员_乙=99;

void 静态成员变量测试01(){
    静态成员变量 静1; 静1.成员_甲 = 999;
    cout<<"静1.成员_甲"<<静1.成员_甲<<endl;
    静态成员变量 静2; 静2.成员_甲 = 909;
    cout<<"静1.成员_甲"<<静1.成员_甲<<endl;
    cout<<"静2.成员_甲"<<静2.成员_甲<<endl;
    //通过类名
    cout<<"成员_甲"<<静态成员变量::成员_甲<<endl;
    //私有权限访问不了
    /*cout<<"成员_乙"<<静态成员变量::成员_乙<<endl;*/
}

class 静态成员函数{
    public:
        static int 成员_甲; int 成员_乙;
        static void 函克(){
            cout<<"函数调用"<<endl; 
            成员_甲=999; //成员_乙=900;
        }
    private:
        static void 函克1(){
            cout<<"函克1调用"<<endl;
        }
};
int 静态成员函数::成员_甲=98;

void 静态成员函数测试01(){
    静态成员函数 静1; 静1.函克();
    静态成员函数::函克();
    //静态成员函数::函克1();
}

int 静态成员(){
    静态成员变量测试01(); 
    静态成员函数测试01();  system("pause"); return 0;
}

int main()
{
    //封装的意义();
    //struct与class的区别();
    //成员属性设置为私有();
    //构造和解构函数();
    //构造函数的分类和调用();
    //复制构造函数调用时机();
    //构造函数调用规则();
    //浅拷贝和深拷贝();
    //初始化列表();
    //类对象作为类成员();
    静态成员();

    return 0;
}