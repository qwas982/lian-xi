/* 一个有时是最小的 FORTH 编译器和教程，用于 Linux / i386 系统。-*- asm -*-
	作者：Richard W.M. Jones <rich@annexia.org> http://annexia.org/forth
	这是公共领域的（见下面的公共领域发布声明）。
	$Id: jonesforth.S,v 1.47 2009-09-11 08:33:13 rich Exp $

    gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
*/

	.set JONES_VERSION,47
/*
    介绍 ----------------------------------------------------------------------

	FORTH是一种陌生的语言，大多数程序员对它的看法与Haskell、LISP等相同。
它是如此的陌生，以至于他们宁愿任何关于它的想法都消失，这样他们就可以继续写这些付费代码。 
但这是错误的，如果你关心编程，那么你至少应该了解所有这些语言。
即使你永远不会使用它们。

LISP是最终的高级语言，而且每十年都有来自LISP的功能被添加到更常见的语言中。 
但FORTH在某种程度上是低级编程的极致。 
开箱即用的它缺乏动态内存管理甚至是字符串等功能。 
事实上，在其原始水平上，它甚至缺乏IF语句和循环等基本概念。

那你为什么要学习 FORTH？
有几个很好的理由。
首先，FORTH 是最小的。
你真的可以用 2000 行代码写出一个完整的 FORTH。
我不只是指一个 FORTH 程序，我指的是一个完整的 FORTH 操作系统、环境和语言。
你可以在裸机上启动这样的 FORTH，它会提示你可以开始做有用的工作。
你在这里拥有的 FORTH 不是最小的，它使用 Linux 进程作为它的“基础 PC”（两者都是为了使它成为一个好的教程）。
完全理解系统是可能的。
谁能说他们完全了解 Linux 或 gcc 的工作原理？

其次，FORTH 有一个古怪的自举性质。
我的意思是，在编写了一些汇编来与硬件对话并实现一些原语之后，
所有语言和编译器的其余部分都是用 FORTH 本身编写的。
还记得我之前说过 FORTH 缺少 IF 语句和循环吗？
当然不是, 因为这样的语言没有用，
但我的观点是 IF 语句和循环是用 FORTH 本身编写的。

当然，这在其他语言中也很常见。
在这些语言中，我们称它们为 "库"。 
例如，在C语言中，"printf "是一个用C语言编写的库函数。 
但在FORTH中，这已经远远超出了单纯的库。 
你能想象用C语言写'if'吗？
这就引出了我的第三个理由：如果你能在FORTH中写'if'。
那么为什么要把自己限制在通常的if/while/for/switch结构中？ 
你想用一个结构来迭代数字列表中的每一个元素？ 
你可以把它添加到语言中。 
如果有一个操作符可以直接从配置文件中提取变量，并将其作为FORTH变量使用，那会怎么样？ 
或者在语言中加入类似Makefile的依赖性呢？在FORTH中没有问题。 
如何修改FORTH编译器以允许复杂的内联策略 -- 简单。 
这个概念在编程语言中并不常见。
但它有一个名称（实际上是两个名称）：“宏”（我的意思是 LISP 样式的宏，
不是蹩脚的 C 预处理器）和“领域特定语言”（DSL）。

本教程并不是要学习FORTH这种语言。 
如果你不熟悉FORTH的使用，我将向你指出一些你应该阅读的参考资料。 
本教程是关于如何编写FORTH的。 
事实上，在你了解FORTH的编写方法之前 
你就会对如何使用它有一个非常肤浅的理解。

因此，如果你不熟悉FORTH或者想复习一下，这里有一些在线的
参考资料，供大家阅读。

    http://en.wikipedia.org/wiki/Forth_%28programming_language%29

	http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm

	http://wiki.laptop.org/go/Forth_Lessons

	http://www.albany.net/~hello/simple.htm

	这里是另一篇 "为什么是FORTH？"的文章: http://www.jwdt.com/~paysan/why-forth.html

	在此对该FORTH进行讨论和批评: http://lambda-the-ultimate.org/node/2452

鸣谢----------------------------------------------------------------------

这段代码大量借鉴了 LINA FORTH (http://home.hccnet.nl/a.w.m.van.der.horst/lina.html) 的设计
阿尔伯特.范.德.霍斯特。
代码中的任何相似之处可能都不是偶然的。

这个 FORTH 的某些部分也基于 1992 年的 IOCCC 条目：
http://ftp.funet.fi/pub/doc/IOCCC/1992/buzzard.2.design。
当 IOCCC 条目的原作者 Sean Barrett 在 LtU 线程中发表评论时，我感到非常自豪
http://lambda-the-ultimate.org/node/2452#comment-36818 关于这个 FORTH。

最后，我要感谢（可能被遗忘了？）ARTIC FORTH 的作者，因为他们
这些年来，我仍然保留在原始盒式磁带上的原始程序一直困扰着我。
http://en.wikipedia.org/wiki/Artic_Software

公共区域----------------------------------------------------------------------

本人，本作品著作权人，特此将其发布到公有领域。 这适用于全世界。

如果这在法律上不可行，我授予任何实体出于任何目的使用本作品的权利，
没有任何条件，除非法律要求这些条件。

配置 ----------------------------------------------------------------------

让我们解决一些家务问题。 首先因为我需要画很多
ASCII艺术图来解释概念，最好的方法是使用一个窗口
使用固定宽度的字体，并且至少有这么宽：

 <------------------------------------------------------------------------------------------------------------------------>

	其次确保 TABS 设置为 8 个字符。
    下面应该是一条垂直线。
    如果没有，请整理您的标签。

		|
	        |
	    	|

	第三，我假设您的屏幕至少有 50 个字符高.

汇编 ----------------------------------------------------------------------

	如果你想实际运行这个FORTH，而不仅仅是阅读它。 
	你将需要在i386上使用Linux。  
	Linux是因为我没有在裸机上直接对硬件进行编程，而我本来可以这样做。 
	我选择了一个更简单的教程，假设 "硬件 "是一个具有一些基本系统调用的Linux进程（读、写和退出，仅此而已）。  
	之所以需要i386，是因为我必须为一个处理器编写汇编。 
	而i386是迄今为止最常见的。  
	(当然，当我说 "i386 "时，任何32位或64位x86处理器都可以。 我是在一个64位的AMD Opteron上编译的）。


再说一遍。
你将需要gcc和gas（GNU汇编器）来汇编这个文件。 
汇编和运行代码的命令（将此文件保存为 "jonesforth.S"）是:

gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
cat jonesforth.f - | ./jonesforth

如果你想运行你自己的 FORTH 程序，你可以这样做：

cat jonesforth.f myprog.f | ./jonesforth

如果你想加载你自己的 FORTH 代码然后继续读用户命令，你可以这样做：

cat jonesforth.f myfunctions.f - | ./jonesforth

汇编器 ----------------------------------------------------------------------

（你可以直接跳到下一节——
您无需能够阅读汇编程序即可遵循本教程）。

但是，如果您确实想阅读汇编代码，这里有一些关于 gas（GNU 汇编器）的说明：

(1) 寄存器名称以'%'为前缀，
所以 %eax 是 32 位 i386 累加器。
i386 上可用的寄存器有：%eax、%ebx、%ecx、%edx、%esi、%edi、%ebp 和 %esp，
而且大部分都有特殊用途。

(2) Add, mov, 等。
以SRC,DEST的形式接受参数。 
所以 mov %eax,%ecx 的意思是; 移动 %eax -> %ecx

(3) 常量的前缀是"$"。
你千万不要忘记它！ 
如果你忘记了，那么就会导致从内存中读取，所以:
	    mov 2,%eax      将数字2移到%eax中。
	    mov 2,%eax      从地址2读取32位字到%eax（即很可能是个错误）。

(4) gas对本地标号有一个古怪的句法。
其中'1f'（等）表示标号'1:' "向前"，'1b'（等）表示标号'1:' "向后"。 
注意，这些标号可能会被误认为是十六进制数字（例如，你可能会将1b与$0x1b混淆）。

(5) 'ja'是 "如果高于就跳"，'jb'为 "如果低于就跳"，'je'为 "如果相等就跳 "等等。

(6) gas有一个相当不错的. 宏句法。
我经常使用它们来使代码更短、更少重复。

对于阅读汇编程序的更多帮助。
在Linux提示符下执行 "info gas"。
现在，教程开始认真地进行。

字典 ----------------------------------------------------------------------

在FORTH中，你会知道。
函数被称为 "字"。
就像在其他语言中一样，它们有一个名字和一个定义。 
下面是两个FORTH字。

	: DOUBLE DUP + ; 				名字是 "DOUBLE"，定义是 "DUP +"
	: QUADRUPLE DOUBLE DOUBLE ; 	名称是 "QUADRUPLE"，定义是 "DOUBLE DOUBLE"

字，包括内置的字和程序员以后定义的字。
都存储在一个字典中，这个字典只是一个字典条目的链表。

<-----------字典条目（头部/首部）----------------------->
+----------------------+--------+----------+------------
| 链接指针              | 长度/  | 名称     | 定义
|        |     旗      |        |
+--- (4 字节) ----------+- 字节 -+- n 字节---+-----------

我稍后会谈到这个字的定义。
现在只看头部。
前 4 个字节是链接指针。
这指向字典中的前一个字，
或者，对于字典中的第一个字，它只是一个 NULL 指针。
然后是一个长度/旗字节。
字的长度最多为 31 个字符（使用 5 位）
前三位用于各种标志，我稍后会谈到。
接下来是名称本身，
在这个实现中，名称通过用零字节填充，四舍五入为 4 字节的倍数。
这只是为了确保定义从 32 位边界开始。

一个名为 最新的 的FORTH变量包含一个指向最近定义的字的指针。
换句话说，就是这个链表的头部。

DOUBLE和QUADRUPLE可能看起来像这样:

   指向前一个字的指针
   ^
   |
+--|------+---+---+---+---+---+---+---+---+------- ------ - - - -
| 链接    | 6 | D | O | U | B | L | E | 0 | （定义 ...）
+---------+---+---+---+---+---+---+---+---+------- ------ - - - -
       ^        长                          填充
    |
+---|------+---+---+---+---+---+---+---+---+---+--- +---+---+------------- - - - -
| 链接     | 9 | Q | U | A | D | R | U | P | L | E | 0 | 0 | （定义 ...）
+----------+---+---+---+---+---+---+---+---+---+--- +---+---+------------- - - - -
        ^       长                                        填充
        |
        |
    最新的

你应该能够从中看到如何实现在字典中寻找一个字的函数 
(只是沿着字典中的条目从 最新的 开始走，并与名称相匹配，
直到找到一个匹配字或在字典的末尾碰到 NULL 指针)。
将一个字添加到字典中 
(创建一个新的定义，把它的 链接 设为 最新的，并把 最新的 设为指向新字的位置）。 
我们将在后面看到用汇编代码精确地实现这些函数。

使用链表的一个有趣结果是您可以重新定义字，
一个字的较新定义会覆盖较旧的定义。
这是 FORTH 中的一个重要概念，因为它意味着任何字
可以用新定义覆盖，（甚至是 “内建” 或 “标准” 字）
要么增强它，
使其更快甚至禁用它。
然而，由于 FORTH 字的编译方式，
您将在下面了解，
使用旧定义的字将继续使用旧定义。
只有在新定义之后定义的字才使用新定义。

直接线程代码 ---------------------------------------------------------------

现在我们将进入理解 FORTH 的关键点，
所以去喝杯茶或咖啡，然后安顿下来。
公平地说，如果你不明白这一节，
那么你就不会“明白” FORTH 是如何工作的，
如果我没有很好地解释它，那将是我的失败。
所以，如果你看了这一节几遍后还不明白。
请给我发电子邮件（rich@annexia.org）。

让我们先谈谈 "线程代码 "的含义。 
想象一下，在一个古怪的C语言版本中，你只被允许调用没有参数的函数。 
(现在不要担心这样的语言会完全没有用处！）。 
因此，在我们这个古怪的C语言中，代码看起来像这样:

f ()
{
	a ();
	b ();
	c ();
}

等等。
一个函数，比如上面的“f”，如何由标准 C 编译器编译？
可能变成这样的汇编代码。
在右侧，我编写了实际的 i386 机器代码。

f:
	CALL a			E8 08 00 00 00
	CALL b			E8 1C 00 00 00
	CALL c			E8 2C 00 00 00
	; 暂时忽略函数的返回值

“E8”是“CALL”函数的 x86 机器码。
在计算机发展的前20年里，内存是非常昂贵的。
所以我们可能会担心重复的“E8”字节会浪费空间。
我们可以节省 20% 的代码大小（因此也节省了昂贵的内存）
通过将其压缩为：

08 00 00 00		只是函数地址，没有 CALL 前缀。
1C 00 00 00		
2C 00 00 00

在像最初运行FORTH的16位机器上，节省的费用甚至更大--33%。

[历史说明:
如果FORTH使用的执行模型在下面的段落中看起来很奇怪。
那么它的动机完全是为了节省早期计算机的内存。
现在，当我们的机器的L1缓存比早期计算机的总内存还要多时，这种代码压缩就不那么重要了。
但这个执行模型仍然有一些有用的特性]。

当然，这段代码不会再直接在CPU上运行了。 
相反，我们需要写一个解释器，接收每一组字节并调用它。

在i386机器上，我们可以相当容易地编写这个解释器。
只需要两条汇编指令就可以写成3个字节的机器代码。 
让我们在%esi寄存器中存储指向下一个要执行的字的指针:

	08 00 00 00	<- 我们现在正在执行这个。%esi 是_下一个_要执行的。
	%esi -> 1C 00 00 00
	2C 00 00 00

最重要的 i386 指令称为 LODSL（或在英特尔手册中称为 LODSW）。
它做了两件事。
首先，它将 %esi 处的内存读入累加器 (%eax)。
其次，它将 %esi 增加 4 个字节。
所以在 LODSL 之后，现在的情况是这样的：

	08 00 00 00	<- 我们还在执行这个
	1C 00 00 00	<- %eax 现在包含此地址 (0x0000001C)
	%esi -> 2C 00 00 00

现在我们只需要跳转到 %eax 中的地址。
这又是一条X86指令，即JMP *(%eax)。
跳转后，情况看起来是这样的：

	08 00 00 00
	1C 00 00 00	<- 现在我们正在执行这个子程序。
	%esi -> 2C 00 00 00

为了使其发挥作用。
每个子程序后面都有两条指令 "LODSL; JMP *(%eax)"
这条指令实际上是跳到下一个子程序。

这就给我们带来了第一段实际的代码!  嗯，这是一个宏。

*/

/* 下一个 宏. */
	.macro NEXT
	lodsl
	jmp *(%eax)
	.endm

/*	
该宏称为 NEXT。
这就是 FORTH 主义。
它扩展到这两个指令。

	我们编写的每个 FORTH 原语都必须以 NEXT 结束。
	想想看，这有点像一个返回。

	上面描述了所谓的直接线程代码。

总结一下：
我们把我们的函数调用压缩成一个地址列表
并使用一个有点神奇的宏来充当“跳转到列表中的下一个函数”。
我们还使用一个寄存器 (%esi) 作为一种指令指针，
指向列表中的下一个函数。

我将通过说一个 FORTH 定义来给你一个提示，例如：

: QUADRUPLE DOUBLE DOUBLE ;

实际编译
(几乎是这样，并不精确，但我们一会儿会看到为什么) 
到 DOUBLE 的函数地址列表，
DOUBLE 和一个称为 EXIT 的特殊函数来完成。

在这一点上。
真正有鹰眼的汇编专家正在说：“琼斯，你犯了一个错误！”。

我对 JMP *(%eax) 撒了谎。

间接线程代码 -------------------------------------------------------------------

事实证明，直接的线程代码是有趣的 
但只有当你想执行一个用汇编语言编写的函数列表时，才有意义。 
因此，只有当DOUBLE是一个汇编语言函数时，QUADRUPLE才能工作。 
在直接线程代码中，QUADRUPLE看起来像:

		+------------------+
		| DOUBLE的地址  --------------------> (汇编代码用于 double)
		+------------------+                    下一个
%esi ->	| DOUBLE的地址      |
		+------------------+

我们可以添加一个额外的间接，使我们能够运行用汇编语言编写的两个字,
(为速度而写的原语) 
以及用 FORTH 本身作为地址列表编写的字。

额外的间接是 JMP *(%eax) 中括号的原因。

让我们看看 QUADRUPLE 和 DOUBLE 在 FORTH 中的实际表现：

	        : QUADRUPLE DOUBLE DOUBLE ;

		+------------------+
		| 代码字            |		   : DOUBLE DUP + ;
		+------------------+
		| DOUBLE 的地址    ---------------> +------------------+
		+------------------+                | 代码字           |
		| DOUBLE 的地址     |		   +------------------+
		+------------------+	   	  | DUP 的地址   -------------->   +------------------+
		| EXIT 的地址	    |		   +------------------+            | 代码字      -------+
		+------------------+  %esi -> |    + 的地址     --------+	   +------------------+   |
						   +------------------+	   |	 | 汇编到         <-----+
						   | EXIT 的地址       |    |     | 实现  DUP      |
						   +------------------+	   |	  |	..	       |
									   |	   |    ..            |
									   |	   | 下一个             |
									   |	   +------------------+
									   |
									   +-----> +------------------+
										   | 代码字         -------+
										   +------------------+   |
										   | 汇编到         <------+
										   | 实现  +          |
										   | 	..            |
										   | 	..            |
										   | 下一个      	   |
										   +------------------+

这一部分，你可能需要额外一杯茶/咖啡/最喜欢的含咖啡因饮料。 改变的是,我在定义的开头添加了一个额外的指针。
在 FORTH 中，这有时被称为“代码字”。
代码字是一个指向解释器的指针，用于运行函数。 
对于用汇编语言编写的原语，
“解释器”只是指向实际的汇编代码本身。
他们不需要解释，他们只是运行。

在用FORTH编写的字中（如QUADRUPLE和DOUBLE）。
代码字指向一个解释器函数。

我很快就会向你展示解释器函数，
但让我们回顾一下我们的间接JMP *(%eax)和 "额外 "括号。 
以我们正在执行DOUBLE的情况为例，如图所示。
而DUP已经被调用。 
请注意，%esi指向+的地址。

DUP 的汇编代码最终会执行 NEXT。 那：

	(1) 将+的地址读入%eax 			%eax指向+的代码字。
	(2) 将%esi增加4
	(3) 跳转到间接的%eax，			跳转到+的代码字中的地址。
					即- 实现+的汇编代码

    	+------------------+
		| 代码字            |
		+------------------+
		| DOUBLE 的地址    ---------------> +------------------+
		+------------------+               | 代码字            |
		| DOUBLE 的地址     |		   +------------------+
		+------------------+	   	  | DUP 的地址   --------------> +------------------+
		| EXIT 的地址	    |		   +------------------+          | 代码字       -------+
		+------------------+	   	  | + 的地址     --------+	     +------------------+  |
						   +------------------+	   |	   | 汇编到    <-----+
				   %esi -> | EXIT 的地址       |    |      | 实现 DUP    |
						   +------------------+	   |	   |	..	    |
									   |	   |    ..            |
									   |	   | 下一个             |
									   |	   +------------------+
									   |
									   +-----> +------------------+
										   | 代码字         -------+
										   +------------------+   |
									现在，我们  | 汇编到          <-----+
									执行       | 实现 +            |
									这个 	   | 	..            |
									函数       | 	..            |
										   | 下一个      	   |
										   +------------------+


所以我希望我已经说服了你，下一个 大致上做了你所期望的事情。 
这是间接线程代码。

我略过了四件事。
我想知道您是否可以在不阅读它们的情况下猜出它们是什么？

	.
	.
	.

我列出的四件事是:
(1) "EXIT "是做什么的？ 
(2) 与(1)相关的是，你如何调用一个函数。
即：%esi如何开始时指向QUADRUPLE的一部分。
但随后又指向DOUBLE的一部分。
(3) FORTH 中所写字的代码字中包含什么内容？
(4) 如何编译一个函数, 除了调用其他函数之外，它会做任何事情,
即：一个包含数字的函数，如  : DOUBLE 2 * ;  ?

解释器和返回栈 ------------------------------------------------------------

在这些问题上，没有特定的顺序。
让我们来谈谈问题（3）和（2）。
解释器和返回栈。

FORTH 中定义的字需要一个代码字，它指向代码的小位，以便在生活中为它们提供“帮助之手”。
他们不需要太多，但它们确实需要一个所谓的 "解释器"。
尽管它并不真正以同样的方式 "解释"，例如。
Java字节码曾经被解释过（即-缓慢地）。 
这个解释器只是设置了一些机器寄存器，这样这个字就可以使用上面的间接线程模型全速执行。

当QUADRUPLE调用DOUBLE时，需要发生的一件事是，我们保存旧的%esi（"指令指针"）。
并创建一个新的，指向DOUBLE中的第一个字。
因为我们需要在DOUBLE结束时恢复旧的%esi 
(毕竟，这就像一个函数调用)。
我们将需要一个栈来存储这些 "返回地址"（%esi的旧值）。

正如你在背景文档中看到的那样。
FORTH有两个栈，一个是普通的参数栈。
和一个比较神秘的返回栈。 
但我们的返回栈只是我在前一段谈到的栈。
用来保存%esi，当从一个FORTH字调用另一个FORTH字时。

在这个FORTH中。
我们使用常规的栈指针(%esp)作为参数栈。
我们将使用i386的 "其他 "栈指针 
(%ebp，通常称为 "帧指针")
用于我们的返回栈。

我有两个宏，它们只是概括了使用%ebp作为返回栈的细节。
你可以使用它们，例如 "PUSHRSP %eax"（将%eax推到返回栈中）。
或 "POPRSP %ebx"（弹返回栈顶进到%ebx）。

*/

/* 处理返回栈的宏. */
	.macro PUSHRSP reg
	lea -4(%ebp),%ebp	// 将寄存器推到返回栈
	movl \reg,(%ebp)
	.endm

	.macro POPRSP reg
	mov (%ebp),\reg		// 弹返回栈顶到寄存器
	lea 4(%ebp),%ebp
	.endm

/*

有了这个，我们现在可以谈谈解释器了。

在 FORTH 中，解释器函数通常称为 DOCOL
（我认为它的意思是“DO COLON”，因为所有 FORTH 定义都以冒号开头，
如  ：DOUBLE DUP + ;

解释器"（它并不是真正的 "解释"）只需要将旧的%esi推到栈上，并将%esi设置为定义中的第一个字。 
还记得我们用JMP *(%eax)跳转到这个函数吗？ 
这样做的一个结果是，%eax包含了这个代码字的地址。
因此，只需将其加 4，我们就可以得到第一个数据字的地址。
最后在设置完 %esi 之后，它只执行 NEXT 导致第一个字运行。
*/

/* DOCOL - 解释器! */
	.text
	.align 4
DOCOL:
	PUSHRSP %esi		// 将 %esi 推入返回栈
	addl $4,%eax		// %eax 指向代码字,
	movl %eax,%esi		// 所以让 %esi 指向第一个数据字
	NEXT

/*

为了使这一点绝对清楚。
让我们看看DOCOL在从QUADRUPLE跳到DOUBLE时是如何工作的:

		QUADRUPLE:
		+------------------+
		| 代码字            |
		+------------------+		   DOUBLE:
		| DOUBLE 的地址    ---------------> +------------------+
		+------------------+       %eax -> | DOCOL 的地址      |
%esi ->	| DOUBLE 的地址     |		       +------------------+
		+------------------+	   	       | DUP 的地址       |
		| EXIT 的地址	   |		       +------------------+
		+------------------+               |  等等.           |

首先，对 DOUBLE 的调用, 调用 DOCOL（DOUBLE 的代码字）。
DOCOL 这样做：它将旧的 %esi 推入返回栈。
%eax 指向 DOUBLE 的代码字，
所以我们只需在它上面加4就可以得到新的%esi:

					QUADRUPLE:
					+------------------+
					| 代码字            |
					+------------------+		       DOUBLE:
					| DOUBLE 的地址   ---------------> +------------------+
					+------------------+      %eax ->  | DOCOL 的地址     |
返回栈顶部的指针 ->	 | DOUBLE 的地址     |	   + 4 =     +------------------+
					+------------------+	  %esi ->  | DUP 的地址       |
					| EXIT 的地址	    |		       +------------------+
					+------------------+               | 等等.            |

然后我们做NEXT。
并且由于线程代码的魔力，再次增加%esi并调用DUP。

好吧，这似乎是在工作。

这里有一个小问题。 
因为DOCOL是这个文件中实际定义的第一个汇编位 
(其他的只是宏）。
因为我通常用从地址 0 开始的文本段来编译这段代码，
DOCOL 的地址为 0。
所以如果你在反汇编代码，看到一个代码字为 0 的字，
你会立即知道这个字是用FORTH写的 
（它不是一个汇编器的原语） 
因此使用 DOCOL 作为解释器。

启动 ----------------------------------------------------------------------

现在让我们开始讨论具体细节。
当我们启动程序时，我们需要设置一些东西，比如返回堆栈。
但,只要我们能，我们就想跳入 FORTH 代码
(尽管许多 "早期 "的FORTH代码仍然需要写成汇编语言原语）。

这就是设置代码的作用。 
做一些小小的内务工作。
设置独立的返回栈 
(注：Linux已经给了我们普通的参数栈)。
然后立即跳转到一个名为QUIT的FORTH字。 
尽管它的名字叫QUIT，但它并没有退出任何东西。 
它重置了一些内部状态并开始读取和解释命令。
(之所以叫QUIT，是因为你可以在自己的FORTH代码中调用QUIT来 "退出 "你的程序，回到解释状态）。
*/

/* 汇编器入口点. */
	.text
	.globl _start
_start:
	cld
	mov %esp,var_S0					// 在FORTH变量S0中保存初始数据栈指针.
	mov $return_stack_top,%ebp 		// 初始化返回栈.
	call set_up_data_segment

	mov $cold_start,%esi			// 初始化解释器.
	NEXT							// 运行解释器!

	.section .rodata
cold_start:							// 没有代码字的高级代码.
	.int QUIT

/*
	内建字 ----------------------------------------------------------------------

还记得我们的字典条目（头部）吗？ 
让我们把它们与代码字 
和数据字放在一起，看看 : DOUBLE DUP + ; 在内存中的实际情况。

	  指向前一个字的指针
	   ^
	   |
	+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| 链接    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
	+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
           ^       长度                         填充  代码字      |
	   |							  V
	  链接在下一个字中			指向 DUP 的代码字

最初我们不能只写": DOUBLE DUP + ;" 
(即那个字面的字符串)
因为我们还没有任何东西可以读取这个字符串。
在空格处将其分割开来，解析每个字，等等。
因此，我们将不得不使用GNU汇编器的数据构造函数来定义内建字,
（如 .int、.byte、.string、.ascii 等——如果您不确定，请在 gas 信息页面中查找它们）。

漫长的道路将是:

	.int <链接到上一个字>
	.byte 6				// 长度
	.ascii "DOUBLE"		// 字符串
	.byte 0				// 填充
DOUBLE: .int DOCOL		// 代码字
	.int DUP			// 指向 DUP 代码字的指针
	.int PLUS			// 指向 + 代码字的指针
	.int EXIT			// 指向 EXIT 代码字的指针

这很快就会变得相当乏味。
所以我在这里定义了一个汇编器宏，这样我就可以直接写:

	defword "DOUBLE",6,,DOUBLE
	.int DUP,PLUS,EXIT

而我将得到完全相同的效果。

不要太担心这个宏的具体实现细节——它很复杂！
*/

/* 旗 - 这些将在稍后讨论. */
	.set F_IMMED,0x80
	.set F_HIDDEN,0x20
	.set F_LENMASK,0x1f	// 长度掩码

	// 链接的存储链
	.set link,0

	.macro defword name, namelen, flags=0, label
	.section .rodata
	.align 4
	.globl name_\label
name_\label :
	.int link		// 链接
	.set link,name_\label
	.byte \flags+\namelen	// 旗 + 长度字节
	.ascii "\name"		// 其名称
	.align 4		// 填充到下一个4字节边界
	.globl \label
\label :
	.int DOCOL		// 代码字 - 解释器
	// 列表中的字指向如下
	.endm

/*
同样地，我想要一种用汇编语言编写字的方法。 
在开始的时候会有很多这样的方法，因为。
在有足够的 "基础设施 "开始写 FORTH 字之前，一切都得从汇编开始。
但我也想在汇编语言中定义一些常见的 FORTH 字以提高速度，
即使我可以用 FORTH 来写它们。

这是 DUP 在内存中的样子：

 	指向前一个字的指针
	   ^
	   |
	+--|------+---+---+---+---+------------+
	| LINK    | 3 | D | U | P | code_DUP ---------------------> 指向用于编写DUP的汇编代码，该代码以NEXT结束。
	+---------+---+---+---+---+------------+		    
           ^       长度              代码字			    
	   |
	  下一个字中的 LINK

再一次。
为了简洁起见，我将写一个名为defcode的汇编宏。
和上面的defword一样。
不要担心这个宏的复杂细节。
*/

	.macro defcode name, namelen, flags=0, label
	.section .rodata
	.align 4
	.globl name_\label
name_\label :
	.int link		// 链接
	.set link,name_\label
	.byte \flags+\namelen	// 旗 + 长度字节
	.ascii "\name"		// 其名称
	.align 4		// 填充到下一个4字节边界
	.globl \label
\label :
	.int code_\label	// 代码字
	.text
	//.align 4
	.globl code_\label
code_\label :			// 汇编代码如下
	.endm

/*
	现在是一些简单的FORTH原语。 
为了提高速度，这些都是用汇编编写的。 
如果你了解i386汇编语言，那么就值得阅读这些内容。 
但如果你不懂汇编，你可以跳过这些细节。
*/

	defcode "DROP",4,,DROP
	pop %eax		// 丢栈顶
	NEXT

	defcode "SWAP",4,,SWAP
	pop %eax		// 交换栈顶两个元素
	pop %ebx
	push %eax
	push %ebx
	NEXT

	defcode "DUP",3,,DUP
	mov (%esp),%eax		// duplicate top of stack 重复栈顶
	push %eax
	NEXT

	defcode "OVER",4,,OVER
	mov 4(%esp),%eax	// 获取栈的第二个元素
	push %eax		// 并将其推到顶部
	NEXT

	defcode "ROT",3,,ROT
	pop %eax
	pop %ebx
	pop %ecx
	push %ebx
	push %eax
	push %ecx
	NEXT

	defcode "-ROT",4,,NROT
	pop %eax
	pop %ebx
	pop %ecx
	push %eax
	push %ecx
	push %ebx
	NEXT

	defcode "2DROP",5,,TWODROP // 丢弃栈顶两个元素
	pop %eax
	pop %eax
	NEXT

	defcode "2DUP",4,,TWODUP // duplicate top two elements of stack 复制栈顶两个元素
	mov (%esp),%eax
	mov 4(%esp),%ebx
	push %ebx
	push %eax
	NEXT

	defcode "2SWAP",5,,TWOSWAP // 交换栈顶的两对元素
	pop %eax
	pop %ebx
	pop %ecx
	pop %edx
	push %ebx
	push %eax
	push %edx
	push %ecx
	NEXT

	defcode "?DUP",4,,QDUP	// duplicate top of stack if non-zero 如果非零，则重复栈顶
	movl (%esp),%eax
	test %eax,%eax
	jz 1f
	push %eax
1:	NEXT

	defcode "1+",2,,INCR
	incl (%esp)		// 递增栈顶
	NEXT

	defcode "1-",2,,DECR
	decl (%esp)		// 递减栈顶
	NEXT

	defcode "4+",2,,INCR4
	addl $4,(%esp)		// 将 4 添加到栈顶
	NEXT

	defcode "4-",2,,DECR4
	subl $4,(%esp)		// 从栈顶减去 4
	NEXT

	defcode "+",1,,ADD
	pop %eax		// 获取栈顶
	addl %eax,(%esp)	// 并将其添加到栈上的下一个字
	NEXT

	defcode "-",1,,SUB
	pop %eax		// 获取栈顶
	subl %eax,(%esp)	// 并从栈上的下一个字中减去它
	NEXT

	defcode "*",1,,MUL
	pop %eax
	pop %ebx
	imull %ebx,%eax
	push %eax		// 忽略溢出
	NEXT

/*
	在这个 FORTH 中，
只有 /MOD 是原始的。
稍后我们将根据原语 /MOD 来定义 "/" 和 "MOD" 字。
i386 汇编指令 idiv 的设计同时保留了商和余数，这使其成为显而易见的选择。
*/

	defcode "/MOD",4,,DIVMOD
	xor %edx,%edx
	pop %ebx
	pop %eax
	idivl %ebx
	push %edx		// 推余数
	push %eax		// 推商
	NEXT

/*
	很多对比操作，如 =、<、> 等。

	ANS FORTH说，对比字应该返回所有（二进制）1表示TRUE，所有0表示FALSE。 
但这是一个奇怪的约定，所以这个FORTH打破了它，
返回更正常的（对C程序员来说...）1表示TRUE，0表示FALSE。
*/

defcode "=",1,,EQU	// 顶部的两个字是否相等？
	pop %eax
	pop %ebx
	cmp %ebx,%eax
	sete %al
	movzbl %al,%eax
	pushl %eax
	NEXT

defcode "<>",2,,NEQU	// 顶部的两个字是不相等的？
	pop %eax
	pop %ebx
	cmp %ebx,%eax
	setne %al
	movzbl %al,%eax
	pushl %eax
	NEXT

defcode "<",1,,LT
	pop %eax
	pop %ebx
	cmp %eax,%ebx
	setl %al
	movzbl %al,%eax
	pushl %eax
	NEXT

	defcode ">",1,,GT
	pop %eax
	pop %ebx
	cmp %eax,%ebx
	setg %al
	movzbl %al,%eax
	pushl %eax
	NEXT

	defcode "<=",2,,LE
	pop %eax
	pop %ebx
	cmp %eax,%ebx
	setle %al
	movzbl %al,%eax
	pushl %eax
	NEXT

	defcode ">=",2,,GE
	pop %eax
	pop %ebx
	cmp %eax,%ebx
	setge %al
	movzbl %al,%eax
	pushl %eax
	NEXT

defcode "0=",2,,ZEQU	// 栈顶等于0？
	pop %eax
	test %eax,%eax
	setz %al
	movzbl %al,%eax
	pushl %eax
	NEXT

defcode "0<>",3,,ZNEQU	// 栈顶不是0？
	pop %eax
	test %eax,%eax
	setnz %al
	movzbl %al,%eax
	pushl %eax
	NEXT

defcode "0<",2,,ZLT	// 与 0 的对比
	pop %eax
	test %eax,%eax
	setl %al
	movzbl %al,%eax
	pushl %eax
	NEXT

defcode "0>",2,,ZGT
	pop %eax
	test %eax,%eax
	setg %al
	movzbl %al,%eax
	pushl %eax
	NEXT

	defcode "0<=",3,,ZLE
	pop %eax
	test %eax,%eax
	setle %al
	movzbl %al,%eax
	pushl %eax
	NEXT

	defcode "0>=",3,,ZGE
	pop %eax
	test %eax,%eax
	setge %al
	movzbl %al,%eax
	pushl %eax
	NEXT

defcode "AND",3,,AND	// 按位 与
	pop %eax
	andl %eax,(%esp)
	NEXT

defcode "OR",2,,OR	// 按位 或
	pop %eax
	orl %eax,(%esp)
	NEXT

defcode "XOR",3,,XOR	// 按位 异或
	pop %eax
	xorl %eax,(%esp)
	NEXT

defcode "INVERT",6,,INVERT // 这是 FORTH 按位 “NOT” 函数（参见 NEGATE 和 NOT）
	notl (%esp)
	NEXT

/*
	返回来自第四的字 ----------------------------------------------------------------------

	是时候谈谈当我们退出一个函数时会发生什么。 
	在这个图中，QUADRUPLE调用了DOUBLE。
	并且DOUBLE即将退出 
	(看%esi指向的位置);

		QUADRUPLE
		+------------------+
		| 代码字           |
		+------------------+		   DOUBLE
		| DOUBLE的地址  ---------------> +------------------+
		+------------------+            | 代码字            |
		| DOUBLE的地址     |		   +------------------+
		+------------------+	      |  DUP 的地址       |
		| EXIT的地址       |		   +------------------+
		+------------------+	      |  +  的地址        |
						   +------------------+
					   %esi -> | EXIT的地址     |
						   +------------------+

	当 + 函数执行 NEXT 时会发生什么？
	好吧，下面的代码被执行。
*/
	defcode "EXIT",4,,EXIT
	POPRSP %esi		// 弹出返回栈进到 %esi
	NEXT

/*
EXIT得到了以前保存在返回栈中的%esi 
并把它放在%esi中。
所以在这之后（但仅在NEXT之前）我们得到:

QUADRUPLE
		+------------------+
		|    代码字         |
		+------------------+		   DOUBLE
		|    DOUBLE的地址  ---------------> +------------------+
		+------------------+               |    代码字         |
	%esi ->	| DOUBLE的地址  |		        +------------------+
		+------------------+	   	       |    DUP 的地址     |
		|    EXIT的地址	   |		        +------------------+
		+------------------+	   	       |     + 的地址      |
						   +------------------+
						   | EXIT的地址       |
						   +------------------+

而NEXT只是完成了工作，
嗯，在这种情况下只是再次调用DOUBLE :-)

字面 ----------------------------------------------------------------------

我之前 "略过 "的最后一点是 
如何处理那些除了调用其他函数之外还做任何事情的函数 
举例来说。
假设DOUBLE是这样定义的:

: DOUBLE 2 * ;

它做了同样的事情。
但由于它包含字面意义上的2，我们该如何编译它呢？ 
一种方法是建立一个名为 "2 "的函数（你必须用汇编器编写）。
但你需要为每一个你想使用的字面符号设置一个函数。

FORTH通过使用一个叫做LIT的特殊字来编译函数来解决这个问题:

	+---------------------------+-------+-------+-------+-------+-------+
	| (通常DOUBLE的头部)         | DOCOL | LIT   | 2     | *     | EXIT  |
	+---------------------------+-------+-------+-------+-------+-------+

LIT是以正常方式执行的。
但它接下来做的事情绝对不正常。 
它查看了%esi（现在指向数字2）。
抓取它，把它推到栈上。
然后操纵%esi，以跳过这个数字，就像它从未出现过一样。

最棒的是，整个抓取/操纵过程可以用一条单字节的i386指令完成。
我们的老朋友LODSL。 
与其说我在画更多的ASCII-art图，不如说我在画画。
看看你能不能找到LIT的工作原理:
*/

defcode "LIT",3,,LIT
	// %esi 指向下一个命令。
	//但在本例中，它指向下一个32位整数的字面。 把这个字面放入%eax，然后增加%esi。
	//在x86上，这是一个方便的单字节指令！（参考NEXT宏）。
	lodsl
	push %eax		// 将字面数字推到栈上
	NEXT

/*

内存 ----------------------------------------------------------------------

FORTH的重要意义在于它让你可以直接访问机器的最低层。 
在FORTH中，直接操纵内存是经常做的。
而这些都是直接操作的原始字。
*/

defcode "!",1,,STORE
	pop %ebx		// 地址到存储
	pop %eax		// 数据到存储那里
	mov %eax,(%ebx)		// 存储它
	NEXT

	defcode "@",1,,FETCH
	pop %ebx		// 地址到拾取
	mov (%ebx),%eax		// 拾取它
	push %eax		// 推值上到栈
	NEXT

	defcode "+!",2,,ADDSTORE
	pop %ebx		// 地址
	pop %eax		// 要加的数量
	addl %eax,(%ebx)	// 加上它
	NEXT

	defcode "-!",2,,SUBSTORE
	pop %ebx		// 地址
	pop %eax		// 要减去的数量
	subl %eax,(%ebx)	// 加上它
	NEXT

/*
	! 和 @（STORE和FETCH）存储32位字。 
	能够读写字节也很有用，所以我们也定义了标准字 C@ 和 C！。

	面向字节的操作只在允许它们的架构上工作（i386就是其中之一）。
 */

 defcode "C!",2,,STOREBYTE
	pop %ebx		// 地址到存储
	pop %eax		// 数据到存储那里
	movb %al,(%ebx)		// 存储它
	NEXT

	defcode "C@",2,,FETCHBYTE
	pop %ebx		// 地址到拾取
	xor %eax,%eax
	movb (%ebx),%al		// 拾取它
	push %eax		// 推值上到栈
	NEXT

/* C@C! 是一个有用的字节复制原语. */
	defcode "C@C!",4,,CCOPY
	movl 4(%esp),%ebx	// 源的地址
	movb (%ebx),%al		// 获取源的字符
	pop %edi		// 目的地址
	stosb			// 复制到目的地
	push %edi		// 递增目的地地址
	incl 4(%esp)		// 递增源的地址
	NEXT

/* and CMOVE 是一个块复制操作. */
	defcode "CMOVE",5,,CMOVE
	mov %esi,%edx		// 保留 %esi
	pop %ecx		// 长度
	pop %edi		// 目的地地址
	pop %esi		// 源地址
	rep movsb		// 复制源到目的地
	mov %edx,%esi		// 恢复 %esi
	NEXT

/*
	内建变量-----------------

	这些是一些内建变量和相关的标准FORTH字。
	其中，到目前为止，我们唯一讨论过的是LATEST，
	它指向FORTH字典中最后一个（最近定义的）字。 
	LATEST也是一个FORTH字，它将LATEST（变量）的地址推到栈上。
	所以你可以使用 @ 和 ！ 运算符来读或写它。 
	比如说.
	要打印LATEST的当前值（这可以适用于任何FORTH变量），
	你应该这样做:

	LATEST @ . CR

	为了使定义变量的时间更短。 
	我使用了一个叫做defvar的宏。 
	类似于上面的 defword 和 defcode。  
	(事实上，defvar宏使用defcode来做字典的头部）。

*/

	.macro defvar name, namelen, flags=0, label, initial=0
	defcode \name,\namelen,\flags,\label
	push $var_\name
	NEXT
	.data
	.align 4
var_\name :
	.int \initial
	.endm

/*
	内建变量是:

	STATE		解释器是在执行代码（0）还是在编译一个字（非零）？
	LATEST		指向字典中的最新（最近定义的）字。
	HERE		指向内存的下一个空闲字节。 编译时，被编译的字在这里。
	S0		存储参数栈顶的地址。
	BASE		当前用于打印和读取数字的基础。

*/

	defvar "STATE",5,,STATE
	defvar "HERE",4,,HERE
	defvar "LATEST",6,,LATEST,name_SYSCALL0 // SYSCALL0必须是内建字典中的最后一个。
	defvar "S0",2,,SZ
	defvar "BASE",4,,BASE,10

/*
内建常量 -------------------------

将一些常量暴露给FORTH也是很有用的。 
当字被执行时，它将一个常量值推到堆栈上。
内建常量是:

	VERSION		是这个FORTH的当前版本。
	R0		返回栈顶部的地址。
	DOCOL		指向DOCOL的指针。
	F_IMMED		IMMEDIATE旗的实际值。
	F_HIDDEN	HIDDEN旗的实际值。
	F_LENMASK	在flags/len字节中的长度掩码。

	SYS_*		以及各种Linux系统调用的数字代码（来自<asm/unistd.h>）。

*/
//#include <asm-i386/unistd.h>	// 你可能需要用这个来代替
#include <asm/unistd.h>

	.macro defconst name, namelen, flags=0, label, value
	defcode \name,\namelen,\flags,\label
	push $\value
	NEXT
	.endm

	defconst "VERSION",7,,VERSION,JONES_VERSION
	defconst "R0",2,,RZ,return_stack_top
	defconst "DOCOL",5,,__DOCOL,DOCOL
	defconst "F_IMMED",7,,__F_IMMED,F_IMMED
	defconst "F_HIDDEN",8,,__F_HIDDEN,F_HIDDEN
	defconst "F_LENMASK",9,,__F_LENMASK,F_LENMASK

	defconst "SYS_EXIT",8,,SYS_EXIT,__NR_exit
	defconst "SYS_OPEN",8,,SYS_OPEN,__NR_open
	defconst "SYS_CLOSE",9,,SYS_CLOSE,__NR_close
	defconst "SYS_READ",8,,SYS_READ,__NR_read
	defconst "SYS_WRITE",9,,SYS_WRITE,__NR_write
	defconst "SYS_CREAT",9,,SYS_CREAT,__NR_creat
	defconst "SYS_BRK",7,,SYS_BRK,__NR_brk

	defconst "O_RDONLY",8,,__O_RDONLY,0
	defconst "O_WRONLY",8,,__O_WRONLY,1
	defconst "O_RDWR",6,,__O_RDWR,2
	defconst "O_CREAT",7,,__O_CREAT,0100
	defconst "O_EXCL",6,,__O_EXCL,0200
	defconst "O_TRUNC",7,,__O_TRUNC,01000
	defconst "O_APPEND",8,,__O_APPEND,02000
	defconst "O_NONBLOCK",10,,__O_NONBLOCK,04000

/*
	返回栈 ----------------------------------------------------------------------

	这些字允许你访问返回栈。 
	回顾一下，寄存器%ebp总是指向返回栈的顶部。
*/

defcode ">R",2,,TOR
	pop %eax		// 弹出形参栈进到 %eax
	PUSHRSP %eax		// 推它到返回栈上
	NEXT

	defcode "R>",2,,FROMR
	POPRSP %eax		// 弹出返回栈到 %eax 上
	push %eax		// 并且推到形参栈上
	NEXT

	defcode "RSP@",4,,RSPFETCH
	push %ebp
	NEXT

	defcode "RSP!",4,,RSPSTORE
	pop %ebp
	NEXT

	defcode "RDROP",5,,RDROP
	addl $4,%ebp		// 弹出返回栈并扔掉
	NEXT

/*
	参数（数据）栈 / [形参栈]----------------------------------------------------------------------

	这些函数允许你操纵参数栈。 
	回顾一下，Linux为我们设置了参数栈。
	并通过%esp访问它。
*/

defcode "DSP@",4,,DSPFETCH
	mov %esp,%eax
	push %eax
	NEXT

	defcode "DSP!",4,,DSPSTORE
	pop %esp
	NEXT

/*
	输入和输出 ----------------------------

	这些是我们的第一个真正有意义的/复杂的FORTH原语。 
	我选择了用汇编器来编写它们。
	但令人惊讶的是，在 "真正的 "FORTH实现中，这些往往是用更基本的FORTH原语来写的。 
	我选择了避免这种做法，因为我认为这只会使实现变得模糊不清。 
	毕竟。
	你可能不了解汇编器，但你可以把它当作
	一个不透明的代码块，做它所说的事情。

	让我们先讨论一下输入。

	FORTH字KEY从stdin读取下一个字节 
	(并把它推到参数栈上）。
	因此，如果KEY被调用，并且有人按了空格键，
	那么数字32（空格的ASCII码）就会被推到栈上。

	在FORTH中，阅读代码和阅读输入是没有区别的。 
	我们可能是在阅读和编译代码，我们可能是在阅读要执行的字。
	我们可能会要求用户输入他们的名字 -- 最终都是通过KEY来实现的。

	KEY的实现使用一个一定大小的输入缓冲区 
	(定义在本文件的末尾）。 
	它调用Linux的read(2)系统调用来填充这个缓冲区，并使用几个变量来跟踪它在缓冲区中的位置。
	如果它的输入缓冲区用完了，它就会自动补上。 
	KEY做的另一件事是如果它检测到stdin已经关闭。
	它就会退出程序。
	这就是为什么当你点击^D时，FORTH系统会干净利落地退出。

    缓冲区			 缓冲顶部
	|				 |
	V				 V
	+-------------------------------+--------------------------------------+
	|     从stdin中读取输入 .......  |        缓冲区的未使用部分              |
	+-------------------------------+--------------------------------------+
	            ^
				|
		       钥匙(下一个要读的字符)

	<---------------------- 缓冲区_大小 (4096字节) -------------------------->
*/

defcode "KEY",3,,KEY
	call _KEY
	push %eax		// 推返回值到栈上
	NEXT
_KEY:
	mov (currkey),%ebx
	cmp (bufftop),%ebx
	jge 1f			// 用尽了输入缓冲区？
	xor %eax,%eax
	mov (%ebx),%al		// 从输入缓冲区获取下一个键
	inc %ebx
	mov %ebx,(currkey)	// 递增当前键
	ret

1:	// 输入用完了。使用read(2)从stdin中获取更多的输入。.
	xor %ebx,%ebx		// 第1个参数: stdin
	mov $buffer,%ecx	// 第2个参数：缓冲区
	mov %ecx,currkey
	mov $BUFFER_SIZE,%edx	// 第3个参数：最大长度
	mov $__NR_read,%eax	// syscall: 读
	int $0x80
	test %eax,%eax		// 如果 %eax <= 0，则退出.
	jbe 2f
	addl %eax,%ecx		// 缓冲区+%eax = bufftop
	mov %ecx,bufftop
	jmp _KEY

2:	// 错误或输入结束：退出程序.
	xor %ebx,%ebx
	mov $__NR_exit,%eax	// syscall：退出
	int $0x80

	.data
	.align 4
currkey:
	.int buffer		// 输入缓冲区中的当前位置（下一个要读的字符）。.
bufftop:
	.int buffer		// 输入缓冲区的最后有效数据+1.

/*
	相比之下。
	输出就简单多了。 
	FORTH的字EMIT写出一个字节到stdout。
	这个实现只是使用了写系统调用。 
	没有尝试对输出进行缓冲。
	但如果能增加它，将是一个很好的练习。
*/

defcode "EMIT",4,,EMIT
	pop %eax
	call _EMIT
	NEXT
_EMIT:
	mov $1,%ebx		// 第一参数：stdout

	// 写需要写的字节的地址
	mov %al,emit_scratch
	mov $emit_scratch,%ecx	// 第二参数：地址

	mov $1,%edx		// 第三参数: nbytes = 1

	mov $__NR_write,%eax	// 写系统调用
	int $0x80
	ret

	.data			// 注：更容易装入.data部分
emit_scratch:
	.space 1		// EMIT使用的划痕

/*
	回到输入，WORD是一个FORTH字，它读取输入的下一个完整字。

	它的具体做法是，首先跳过任何空白（空格、制表符、换行符等）。
然后，它调用KEY将字符读入一个内部缓冲区，直到读到一个空白。 
然后，它计算读到的字的长度，并将地址和长度作为
栈上的两个字（长度在栈的顶部）。

	请注意，WORD有一个单一的内部缓冲区，它每次都会重写 
(类似于C语言的静态字符串)。 
另外，注意到WORD的内部缓冲区只有32字节长，而且没有溢出检查。 
31字节正好是我们支持的FORTH字的最大长度。
而这正是WORD的用途：在编译和执行代码时读取FORTH字。 
返回的字符串不是以NUL为结尾的。

	开始地址+长度是FORTH中表示字符串的正常方式。
(而不是像C语言那样以ASCII的NUL字符结束)。
所以FORTH字符串可以包含任何字符，包括NUL，并且可以是任何长度.

	WORD不适合只读取字符串（如用户输入）。
因为上述所有的特殊性和局限性.

	注意，在执行时，你会看到。
	WORD FOO
	将 "FOO "和长度3放在栈上，但在编译时:
	: BAR WORD FOO ;
	是一个错误（或者至少它没有做你可能期望的事情）。  
	稍后我们将讨论编译和即时模式。 
	你就会明白为什么.
*/

defcode "WORD",4,,WORD
	call _WORD
	push %edi		// 推基本地址
	push %ecx		// 推长度
	NEXT

_WORD:
	/* 搜索第一个非空白字符。 同时跳过\注释。*/
1:
	call _KEY		// 获取下一个键，在%eax中返回
	cmpb $'\\',%al		// 评论的开始？
	je 3f			// 如果是，跳过评论
	cmpb $' ',%al
	jbe 1b			// 如果是，保持寻找

	/* 搜索字的结尾，边搜索边存储字符. */
	mov $word_buffer,%edi	// 指向返回缓冲区
2:
	stosb			// 将字符添加到返回缓冲区
	call _KEY		// 获取下一个键，在%al中返回
	cmpb $' ',%al		// 是空白？
	ja 2b			// 如果没有，保持循环

	/* 返回字（好吧，静态缓冲区）和长度. */
	sub $word_buffer,%edi
	mov %edi,%ecx		// 返回字的长度
	mov $word_buffer,%edi	// 返回字的地址
	ret

	/* 代码到跳过\注释至当前行末. */
3:
	call _KEY
	cmpb $'\n',%al		// 行结束了吗？
	jne 3b
	jmp 1b

	.data			/* NB：更容易装入.data部分 一个静态缓冲区，WORD在这里返回。 
					随后的调用会覆盖这个缓冲区。 
					最大字长为32个字符.*/
word_buffer:
	.space 32

/*
	除了读入字之外，我们还需要读入数字，为此我们使用了一个名为NUMBER的函数。 
这个函数解析一个数字字符串，比如由WORD返回的数字，并将数字推到参数栈上。

	该函数使用变量BASE作为转换的基数（radix）。
例如，如果BASE是2，那么我们期待一个二进制数。 
通常，BASE是10。

	如果该字以'-'字符开头，那么返回值为负数。

	如果字符串不能被解析为数字（或包含当前BASE以外的字符），那么我们需要返回一个错误提示。 
所以NUMBER实际上在栈中返回两个项目。
在栈的顶部，我们返回未转换的字符数 
(也就是说，如果是0，那么所有的字符都被转换了，所以没有错误）。 
栈顶的第二项是解析后的数字，如果有错误，则是一个部分值。
*/

defcode "NUMBER",6,,NUMBER
	pop %ecx		// 字符串的长度
	pop %edi		// 字符串的起始地址
	call _NUMBER
	push %eax		// 解析的数字
	push %ecx		// 未解析的字符数（0 = 无错误）。
	NEXT

_NUMBER:
	xor %eax,%eax
	xor %ebx,%ebx

	test %ecx,%ecx		// 试图解析一个零长度的字符串是一个错误。但会返回0。
	jz 5f

	movl var_BASE,%edx	// 获取 BASE (in %dl)

	// 检查第一个字符是否为'-'。.
	movb (%edi),%bl		// %bl = 字符串中的第一个字符
	inc %edi
	push %eax		// 推0到栈上
	cmpb $'-',%bl		// 负数？
	jnz 2f
	pop %eax
	push %ebx		// 推 <>0 到栈上，表示负数
	dec %ecx
	jnz 1f
	pop %ebx		// 错误：字符串只有'-'。
	movl $1,%ecx
	ret

	// 循环读取数字。
1:	imull %edx,%eax		// %eax *= BASE
	movb (%edi),%bl		// %bl = 字符串中的下一个字符
	inc %edi

	// 将0-9，A-Z转换为0-35的数字。
2:	subb $'0',%bl		// < '0'?
	jb 4f
	cmp $10,%bl		// <= '9'?
	jb 3f
	subb $17,%bl		// < 'A'? (17 is 'A'-'0')
	jb 4f
	addb $10,%bl

3:	cmp %dl,%bl		// >= BASE?
	jge 4f

	// 好吧，那就把它加到%eax里，然后循环。
	add %ebx,%eax
	dec %ecx
	jnz 1b

	// 如果第一个字符是'-'，则结果是负数（保存在栈上）。
4:	pop %ebx
	test %ebx,%ebx
	jz 5f
	neg %eax

5:	ret

/*
	字典查询 ----------------------------------------------------------------------

	我们正在建立关于FORTH代码如何编译的序幕，但首先我们需要更多的基础设施。

	FORTH字FIND接收一个字符串（由WORD解析的字，见上文） 
并在字典中查找它。 
它实际返回的是字典头部的地址。
如果它找到它，或者如果它没有找到，则返回 0。

	因此，如果DOUBLE在字典中被定义。
那么WORD DOUBLE FIND就会返回以下指针:

    指针指向这个
	|
	|
	V
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+

	另见 >CFA 和 >DFA。

	FIND不能找到被标记为HIDDEN的字典条目。 
	原因见下文。
*/

defcode "FIND",4,,FIND
	pop %ecx		// %ecx = 长度
	pop %edi		// %edi = 地址
	call _FIND
	push %eax		// %eax = 字典条目的地址（或NULL）。
	NEXT

_FIND:
	push %esi		// 保存%esi，这样我们可以在字符串对比中使用它。

	// 现在我们开始在字典中向后搜索这个字。
	mov var_LATEST,%edx	// LATEST 指向字典中最新字的名称头。
1:	test %edx,%edx		// NULL指针？（链表的末端）。
	je 4f

	// 对比预期的长度和该字的长度。
	// 请注意，如果在这个字上设置了F_HIDDEN标志。
	// 那么通过一点小技巧，这将不会选中这个字（长度会出现错误）。
	xor %eax,%eax
	movb 4(%edx),%al	// %al = 标志+长度字段
	andb $(F_HIDDEN|F_LENMASK),%al // %al = 名字长度
	cmpb %cl,%al		// 长度是一样的吗？
	jne 2f

	// 详细对比一下这些字符串。
	push %ecx		// 保存长度
	push %edi		// 保存地址（重复cmpsb将移动这个指针）。
	lea 5(%edx),%esi	// 我们要检查的字典字符串。
	repe cmpsb		// 对比一下字符串。
	pop %edi
	pop %ecx
	jne 2f			// 不一样的。

	// 字符串是一样的--返回%eax中的头指针
	pop %esi
	mov %edx,%eax
	ret

2:	mov (%edx),%edx		// 通过链接字段向后移动到前一个字
	jmp 1b			// ...和循环。

4:	// 未找到。
	pop %esi
	xor %eax,%eax		// 返回0表示未找到。
	ret

/*
	FIND返回字典的指针。
但在编译时我们需要代码字指针 
(回顾FORTH定义被编译成代码字指针的列表)。 
标准 FORTH 字 >CFA 将字典指针变成代码字指针。

	下面的例子显示了如下结果:

		WORD DOUBLE FIND >CFA

	FIND 返回一个指向这个
	|				>CFA 将其转换为一个指向这个
	|					   |
	V					   V
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
						   代码字

	注意:

	因为名字的长度不同，这不是简单的增量。

	在这个FORTH中，你不能轻易地将一个代码字指针转回一个字典条目指针。
但这在大多数 FORTH 实现中是不正确的，它们在定义中存储了一个回溯指针
(有明显的内存/复杂度代价)。 
他们这样做的原因是，为了快速反编译FORTH的定义，能够向后走（代码字->字典条目）是很有用的。

	CFA代表什么？ 我最好的猜测是 "Code Field Address 代码字段地址"。
*/

	defcode ">CFA",4,,TCFA
	pop %edi
	call _TCFA
	push %edi
	NEXT
_TCFA:
	xor %eax,%eax
	add $4,%edi		// 跳过链接指针。
	movb (%edi),%al		// 将flags+len加载到%al中。
	inc %edi		// 跳过flags+len字节。
	andb $F_LENMASK,%al	// 只是长度，而不是标志。
	add %eax,%edi		// 跳过这个名字。
	addl $3,%edi		// 代码字是4字节对齐的。
	andl $~3,%edi
	ret

/*
	与>CFA相关的是>DFA，它接收由FIND返回的字典条目地址，并返回一个指向第一个数据字段的指针。

	FIND返回一个指针，指向这个
	|				>CFA 将其转换为一个指向这个
	|					   |
	|					   |	>DFA 将其转换为一个指向这个
	|					   |		 |
	V					   V		 V
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
						   代码字

	(请关注FIG-FORTH / ciforth来源的人注意: 我的>DFA定义与他们的不同。
因为他们有一个额外的间接性）。

	你可以看到，>DFA在FORTH中很容易定义，只需在>CFA的结果上加4即可。
*/

defword ">DFA",4,,TDFA
	.int TCFA		// >CFA		(获取代码字段地址)
	.int INCR4		// 4+		(加4以获取下一个字)
	.int EXIT		// EXIT		(从FORTH字返回)

/*
	编译 ----------------------------------------------------------------------

	现在我们来谈谈FORTH是如何编译字的。 回顾一下，一个字的定义是这样的:

		: DOUBLE DUP + ;

	而我们必须将其转化为:

	  指向前一个字的指针
	   ^
	   |
	+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
	+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
           ^       len                         pad  代码字      |
	   |							  V
	  LATEST 指在这里				指向DUP的代码字

	有几个问题需要解决。 
	把字放在哪里？ 
	我们如何阅读字？ 
	我们如何定义字
	: (COLON) 与 ; (SEMICOLON)?

	FORTH相当优雅地解决了这个问题，正如你所期望的那样，它以一种非常低级的方式允许你改变编译器在你自己代码上的工作方式。

	FORTH有一个INTERPRET函数（这次是一个真正的解释器，不是DOCOL）
在一个循环中运行。
读取字（使用WORD），查找它们（使用FIND）。
把它们变成代码字指针（使用>CFA）并决定如何处理它们。

	它做什么取决于解释器的模式（在变量STATE中）。

	当STATE为零时，解释器只是在查找每个字时运行它们。 
这就是所谓的立即模式。

	当STATE为非零时，有趣的事情发生了--编译模式。 
在这种模式下，解释器将代码字指针附加到用户内存上 
(HERE变量指向用户内存的下一个空闲字节--见下面的DATA SEGMENT部分）。

	因此，你也许能看出我们如何定义 ：（COLON）。 总的计划是:

	(1) 使用WORD读取已定义函数名。

	(2) 构造字典条目 -- 仅头部 -- 在用户内存里:

    指向前一个字的指针（来自LATEST）。			+-- 之后，HERE指向这里，
	   ^							|   解释器将在这里开始附加代码字,
	   |							V   
	+--|------+---+---+---+---+---+---+---+---+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      |
	+---------+---+---+---+---+---+---+---+---+------------+
                   len                         pad  代码字

	(3) 设置LATEST指向新定义的字，......。

	(4) ......最重要的是在新的代码字后留下HERE的指向。 
		这是解释器将附加代码字的地方。

	(5) 将STATE设置为1。 
		这就进入了编译模式，因此解释器开始附加代码字到我们的部分形式的头部.

	运行后，我们的输入是这样的:

	: DOUBLE DUP + ;
	         ^
		 |
		由KEY返回的下一个字节将是DUP的'D'字符。

	所以解释器（现在它处于编译模式，所以我猜它实际上是编译器）读取 "DUP"。
	在字典中查找它，得到它的代码字指针，然后把它加到字典中。:

									     +-- 这里更新到指向这里.
									     |
									     V
	+---------+---+---+---+---+---+---+---+---+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        |
	+---------+---+---+---+---+---+---+---+---+------------+------------+
                   len                         pad  代码字

	接下来，我们读取+，获取代码字指针，并附加它:

											  +-- 这里更新到指向这里.
											  |
											  V
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
                   len                         pad  代码字

	问题是接下来会发生什么。 
	显然，我们不希望发生的是，我们读到"; "并编译它，并继续编译之后的每个字。

	在这一点上，FORTH使用了一个技巧。 
	记得字典定义中的长度字节不只是一个普通的长度字节，还可以包含标志。 
	其中一个标志被称为IMMEDIATE标志（在这段代码中为F_IMMED）。 
	如果字典中的一个字被标记为IMMEDIATE，那么解释器就会立即运行它_即使它处于编译模式_.

	这就是字 ;（SEMICOLON）的作用--作为一个在字典中被标记为IMMEDIATE的字 。

	它所做的就是将EXIT的代码字附加到当前的定义上，并切换到立即模式（将STATE设为0）。 
	稍后我们将看到 ; 的实际定义，我们将看到它实际上是一个非常简单的定义，声明为IMMEDIATE.

	在解释器读取 ; 并 "立即 "执行后，我们得到这样的结果:

	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
                   len                         pad  代码字					       ^
												       |
												      HERE
	STATE被设置为0.

	就这样，工作完成了，我们的新定义被编译了。
	而我们又回到了立即模式，只是读和执行字。
	也许包括调用测试我们的新字DOUBLE.

	这里面唯一的最后一个问题是，当我们的字在被编译的时候。
	它处于半完成的状态。 
	我们当然不希望DOUBLE在这段时间内以某种方式被调用。 
	有几种方法可以阻止这种情况的发生。
	但在FORTH中，我们所做的是在编译过程中用HIDDEN标志（在这段代码中为F_HIDDEN）来标记这个字。 
	这可以防止FIND找到它，从而在理论上阻止它被调用的任何机会.

	以上解释了编译 :（COLON）和 ;（SEMICOLON）的工作原理 
	稍后我将对它们进行定义。 
	 :(COLON) 函数可以通过把它写成两部分而变得更通用一些。 
	第一部分，称为CREATE，只做头部:

						   +-- 之后，HERE指在这里.
						   |
						   V
	+---------+---+---+---+---+---+---+---+---+
	| LINK    | 6 | D | O | U | B | L | E | 0 |
	+---------+---+---+---+---+---+---+---+---+
                   len                         pad

	和第二部分，实际定义的 :(COLON) ,
	调用CREATE并附加DOCOL代码字，所以留下了:

								+-- 之后，HERE指在这里.
								|
								V
	+---------+---+---+---+---+---+---+---+---+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      |
	+---------+---+---+---+---+---+---+---+---+------------+
                   len                         pad  代码字

	CREATE是一个标准的FORTH字，这种拆分的好处是我们可以重复使用它来创建其他类型的字 
	(不仅仅是包含代码的字，还有包含变量、常量和其他数据的字).
*/

	defcode "CREATE",6,,CREATE

	// 获取名称长度和地址.
	pop %ecx		// %ecx = 长度
	pop %ebx		// %ebx = 名称的地址

	// 链接指针.
	movl var_HERE,%edi	// %edi是头部的地址
	movl var_LATEST,%eax	// 获取链接指针
	stosl			// 并将其存储在头部处.

	// 字节长度和字本身.
	mov %cl,%al		// 获取长度.
	stosb			// 存储长度/标志字节.
	push %esi
	mov %ebx,%esi		// %esi = 字
	rep movsb		// 复制该字
	pop %esi
	addl $3,%edi		// 对齐到下一个4字节的边界.
	andl $~3,%edi

	// 更新 LATEST 与 HERE.
	movl var_HERE,%eax
	movl %eax,var_LATEST
	movl %edi,var_HERE
	NEXT

/*
	因为我想在FORTH中定义:(COLON)，而不是在汇编器中定义，所以我们需要多用几个FORTH字来使用.

	第一个是,(COMMA)，它是一个标准的FORTH字，将一个32位的整数附加到HERE所指向的用户内存上，并在HERE上加4。 所以,(COMMA)的作用是:

							HERE的前一个值
								 |
								 V
	+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 |             |  <data>    |
	+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
                   len                         pad		              ^
									      |
									HERE的新值

	而<data>是栈顶的任何32位整数。.

	,（COMMA）是编译时的一个相当基本的操作。 它用于将代码字附加到正在编译的当前字上.
*/

	defcode ",",1,,COMMA
	pop %eax		// 代码指针到存储.
	call _COMMA
	NEXT
_COMMA:
	movl var_HERE,%edi	// HERE
	stosl			// 存储它。
	movl %edi,var_HERE	// 更新 HERE (增量)
	ret

/*
	我们对 :(COLON) 和 ;(SEMICOLON) 的定义将需要在编译模式中切换。

	立即模式与编译模式的对比被存储在全局变量STATE中。
	通过更新这个变量，我们可以在两种模式之间切换.

	由于各种原因，以后可能会变得很明显。
	FORTH定义了两个标准字[ and ] (LBRAC and RBRAC) ，用于在不同的模式之间切换:

	字		汇编器		动作		效果
	[	LBRAC		STATE := 0	切换到立即模式.
	]	RBRAC		STATE := 1	切换到编译模式.

	[（LBRAC）是一个IMMEDIATE字。 
	原因如下: 如果我们处于编译模式，而解释器看到了 [ 那么它就会编译它而不是运行它。 
	我们将永远无法切换回立即模式！ 
	所以我们把这个字标记为IMMEDIATE，这样即使在编译模式下，这个字也会立即运行。
	将我们切换回立即模式.
*/

	defcode "[",1,F_IMMED,LBRAC
	xor %eax,%eax
	movl %eax,var_STATE	// 设置STATE为0.
	NEXT

	defcode "]",1,,RBRAC
	movl $1,var_STATE	// 设置STATE为1.
	NEXT

/*
	现在我们可以用CREATE定义 :（COLON） 。 
	它只是调用CREATE，附加上DOCOL（代码字）。
	设置HIDDEN字并进入编译模式.
*/

	defword ":",1,,COLON
	.int WORD		// 获取新字的名称
	.int CREATE		// CREATE 字典条目/头部
	.int LIT, DOCOL, COMMA	// 附加 DOCOL  (代码字).
	.int LATEST, FETCH, HIDDEN // 使这个字隐藏起来（定义见下文）.
	.int RBRAC		// 进入编译模式.
	.int EXIT		// 从函数中返回.

/*
	; (SEMICOLON) 也很优雅简单。 
	注意F_IMMED标志。
*/

	defword ";",1,F_IMMED,SEMICOLON
	.int LIT, EXIT, COMMA	// 附加EXIT（所以这个字会返回）.
	.int LATEST, FETCH, HIDDEN // 套索扣隐藏标志 -- 解除对该字的隐藏（定义见下文）.
	.int LBRAC		// 回到IMMEDIATE（立即）模式.
	.int EXIT		// 从该函数返回。

/*
	扩展编译器 ----------------------------------------------------------------------

	标记为IMMEDIATE（F_IMMED）的字并不只是供FORTH编译器使用。 
	你也可以定义你自己的IMMEDIATE字。
	这是扩展基本 FORTH 时的一个重要方面。
	因为它允许你扩展编译器本身。 
	gcc允许你这么做吗？

	标准的FORTH字，如IF、WHILE、. " 
	等都是作为基本编译器的扩展写的。
	并且都是IMMEDIATE字。

	IMMEDIATE字会在最近定义的字上套索扣F_IMMED（IMMEDIATE标志）。
	如果你在定义过程中调用它，则在当前字上。

	典型的用法是:

	: MYIMMEDWORD IMMEDIATE
		...definition...
	;

	但有些FORTH程序员却这样写:

	: MYIMMEDWORD
		...definition...
	; IMMEDIATE

	这两种用法是等同的, 一级近似.
*/

	defcode "IMMEDIATE",9,F_IMMED,IMMEDIATE
	movl var_LATEST,%edi	// LATEST 字.
	addl $4,%edi		// 指向名称/标志的字节.
	xorb $F_IMMED,(%edi)	// 套索扣 IMMED 位.
	NEXT

/*
	'addr HIDDEN' 拴牢addr处定义的字的隐藏标志（F_HIDDEN）。 
	要隐藏最近定义的字（在上面的 : 和 ; 定义中使用），你应该这样做:

		LATEST @ HIDDEN

	'HIDE word'在一个被命名为'word'上拴牢标志.

	设置这个标志可以阻止该字被FIND找到。
	所以可以用来制作 "private "字。 
	例如，若要把一个大的字拆成小的部分，你可以这样做:

		: SUB1 ... subword ... ;
		: SUB2 ... subword ... ;
		: SUB3 ... subword ... ;
		: MAIN ... 以下列方式定义  SUB1, SUB2, SUB3 ... ;
		HIDE SUB1
		HIDE SUB2
		HIDE SUB3

	在这之后，只有MAIN被 "导出 "或被程序的其他部分看到。
*/

	defcode "HIDDEN",6,,HIDDEN
	pop %edi		// 字典条目.
	addl $4,%edi		// 指向名称/标志的字节.
	xorb $F_HIDDEN,(%edi)	// 套索扣HIDDEN位.
	NEXT

	defword "HIDE",4,,HIDE
	.int WORD		// 获取这个字（在HIDE之后）.
	.int FIND		// 在字典中查找.
	.int HIDDEN		// 设置F_HIDDEN标志.
	.int EXIT		// 返回.

/*
	' (TICK)是一个标准的FORTH字，返回下一个字的代码字指针.

	通常的用法是:

	' FOO ,

	它将FOO的代码字附加到我们正在定义的字上（这只在编译后的代码中起作用）.

	你倾向于在IMMEDIATE字中使用 ' 。 
	例如，定义2的另一种方式（而且相当无用）可能是:

	: LIT2 IMMEDIATE
		' LIT ,		\ 将LIT附加到当前-正在-定义的-字上。
		2 ,		\ 将数字2添加到当前-正在-定义的-字中。
	;

	所以你可以做:

	: DOUBLE LIT2 * ;

	(如果你不了解LIT2是如何工作的，那么你应该复习一下关于编译字和立即模式的材料）.

	这个 ' 的定义使用了一个我从buzzard92那里复制的作弊器。 
	因此，它只能在编译的代码中工作。 
	我们可以在WORD、FIND、>CFA的基础上编写一个 ' 的版本，它也可以在立即模式下工作.
*/

	defcode "'",1,,TICK
	lodsl			// 获取下一个字的地址并跳过它。
	pushl %eax		// 把它推到栈上。
	NEXT

/*
	分支 ----------------------------------------------------------------------

	事实证明，为了定义循环构造、IF语句等，你只需要两个原语。

	BRANCH是一个无条件的分支。0BRANCH是一个条件分支 
	(它只在栈顶为零时才进行分支)。

	下图显示了BRANCH在一些假想的编译字中是如何工作的。 
	当BRANCH执行时，%esi开始指向偏移字段（与上面的LIT对比）。

	+---------------------+-------+---- - - ---+------------+------------+---- - - - ----+------------+
	| (Dictionary header) | DOCOL |            | BRANCH     | offset     | (skipped)     | word       |
	+---------------------+-------+---- - - ---+------------+-----|------+---- - - - ----+------------+
								   ^  |			      ^
								   |  |			      |
								   |  +-----------------------+
								  %esi添加到偏移中

	偏移被添加到%esi中，成为新的%esi，结果是，当NEXT运行时。
	在分支目标处继续执行。 负偏移的作用与预期相同。

	0BRANCH与此相同，只是分支有条件地发生。

	现在标准的FORTH字，如IF、THEN、ELSE、WHILE、REPEAT等，可以完全用FORTH实现。 
	它们是IMMEDIATE字，将BRANCH或0BRANCH的各种组合附加到当前已编译的字中。

	作为一个例子，代码像这样写:

		condition-code IF true-part THEN rest-code

	编译到:

		condition-code 0BRANCH OFFSET true-part rest-code
					  |		^
					  |		|
					  +-------------+
*/

	defcode "BRANCH",6,,BRANCH
	add (%esi),%esi		// 把偏移加到指令指针上
	NEXT

	defcode "0BRANCH",7,,ZBRANCH
	pop %eax
	test %eax,%eax		// 栈顶是零？
	jz code_BRANCH		// 若是，就跳回上面的分支函数
	lodsl			// 否则我们需要跳过偏移
	NEXT

/*
	字面字符串 ----------------------------------------------------------------------

	LITSTRING是用于实现 . " 和 S " 运算符（用FORTH编写）的一种原语。 
	请看后面对这些运算符的定义。

	TELL只是打印一个字符串。 
	在汇编中定义这个更有效，因为我们可以使它成为一个单一的Linux syscall。
*/

	defcode "LITSTRING",9,,LITSTRING
	lodsl			// 获取字符串的长度
	push %esi		// 推字符串的起始地址
	push %eax		// 把它推到栈上
	addl %eax,%esi		// 跳过经过的字符串
 	addl $3,%esi		// 但四舍五入到下一个4字节边界
	andl $~3,%esi
	NEXT

	defcode "TELL",4,,TELL
	mov $1,%ebx		// 第1个参数：stdout
	pop %edx		// 第3个参数：字符串的长度
	pop %ecx		// 第2个参数：字符串的地址
	mov $__NR_write,%eax	// 写入 syscall
	int $0x80
	NEXT

/*
	退出和解释 ----------------------------------------------------------------------

	QUIT是FORTH的第一个函数，几乎是在FORTH系统 "boots "后立即调用。
	如前所述，QUIT并不 "quit "任何东西。 
	它做了一些初始化工作（特别是清除了返回栈），并在一个循环中调用INTERPRET来解释命令。 
	它之所以被称为QUIT，是因为你可以从自己的FORTH字中调用它，以便 "quit "你的程序并在用户提示符下重新开始。

	INTERPRET是FORTH的解释器 
	("toploop"、"toplevel "或 "REPL "可能是一个更准确的描述--见：http://en.wikipedia.org/wiki/REPL)。
*/

	// QUIT必须不返回（即-不得调用EXIT）。
	defword "QUIT",4,,QUIT
	.int RZ,RSPSTORE	// R0 RSP！，清除返回栈
	.int INTERPRET		// 解释下一个字
	.int BRANCH,-8		// 和循环（无限期）。

/*
	这个解释器相当简单，
	但请记住，在FORTH中，
	你可以随时用一个更强大的解释器来覆盖它。
*/

	defcode "INTERPRET",9,,INTERPRET
	call _WORD		// 返回 %ecx = 长度, %edi = 字的指针。

	// 它在字典里吗？
	xor %eax,%eax
	movl %eax,interpret_is_lit // 不是一个字面的数字（反正还不是......）。
	call _FIND		// 返回 %eax = 指向头部的指针，若未找到则返回0。
	test %eax,%eax		// 找到了吗？
	jz 1f

	// 在字典里。 它是一个IMMEDIATE的代码字吗？
	mov %eax,%edi		// %edi = 字典条目
	movb 4(%edi),%al	// 获取 名称+标志。
	push %ax		// 暂时先保存起来。
	call _TCFA		// 将字典条目（在%edi内）转换为代码字指针。
	pop %ax
	andb $F_IMMED,%al	// 是否设置了IMMED标志？
	mov %edi,%eax
	jnz 4f			// 若是IMMED，直接跳到执行。

	jmp 2f

1:	// 字典中没有（不是一个字），所以假设它是一个字面数字。
	incl interpret_is_lit
	call _NUMBER		// 返回在 %eax 中解析出的数字，%ecx > 0 如果错误的话
	test %ecx,%ecx
	jnz 6f
	mov %eax,%ebx
	mov $LIT,%eax		// 这个字是LIT

2:	// 我们是在编译还是在执行？
	movl var_STATE,%edx
	test %edx,%edx
	jz 4f			// 如果执行则跳转。

	// 编译--只需将该字附加到当前的字典定义中。
	call _COMMA
	mov interpret_is_lit,%ecx // 这是一个字面意思吗？
	test %ecx,%ecx
	jz 3f
	mov %ebx,%eax		// 是的，所以LIT后面是一个数字。
	call _COMMA
3:	NEXT

4:	// 执行 - 运行它!
	mov interpret_is_lit,%ecx // 字面意思？
	test %ecx,%ecx		// 字面意思？
	jnz 5f

	//不是字面，现在就执行它。 这永远不会返回，但代码字最终会调用NEXT，这将重新进入QUIT的循环。
	jmp *(%eax)

5:	// 执行一个字面，也就是把它推到栈上。
	push %ebx
	NEXT

6:	// 解析错误（不是已知字或当前BASE中的数字）。
	// 打印一条错误信息，后面是最多40个字符的上下文。
	mov $2,%ebx		// 第1个参数：stderr
	mov $errmsg,%ecx	// 第2个参数：错误消息
	mov $errmsgend-errmsg,%edx // 第3个参数：字符串的长度
	mov $__NR_write,%eax	// 写 syscall
	int $0x80

	mov (currkey),%ecx	// 错误发生在currkey 位置之前
	mov %ecx,%edx
	sub $buffer,%edx	// %edx = currkey - 缓冲区 (currkey前的缓冲区长度)
	cmp $40,%edx		// 如果>40，则只打印40个字符
	jle 7f
	mov $40,%edx
7:	sub %edx,%ecx		// %ecx =要打印的开始区域，%edx =长度
	mov $__NR_write,%eax	// 写 syscall
	int $0x80

	mov $errmsgnl,%ecx	// 换行
	mov $1,%edx
	mov $__NR_write,%eax	// 写 syscall
	int $0x80

	NEXT

	.section .rodata
errmsg: .ascii "PARSE ERROR: "
errmsgend:
errmsgnl: .ascii "\n"

	.data			// 注：更容易装入.data部分
	.align 4
interpret_is_lit:
	.int 0			// 标志，用于记录是否读取一个字面

/*
	机会和结局 ----------------------------------------------------------------------

	CHAR将下面 字的第一个字符的ASCII码放在栈中。 
	例如，CHAR A将65放在栈中。

	EXECUTE是用来运行执行牌的。 详见FORTH代码中关于执行牌的讨论。

	SYSCALL0, SYSCALL1, SYSCALL2, SYSCALL3进行标准的Linux系统调用。 
	(参见<asm/unistd.h>中的系统调用号列表）。 
	顾名思义，这些形式需要0到3个syscall参数，加上系统调用号。

	在这个FORTH中，SYSCALL0必须是内置（汇编）字典的最后一个字，因为我们初始化LATEST变量指向它。 
	这意味着，如果你想扩展汇编部分，你必须在SYSCALL0之前放上新的字，否则就得改变LATEST的初始化方式。
*/

	defcode "CHAR",4,,CHAR
	call _WORD		// 返回 %ecx = 长度, %edi = 字的指针。
	xor %eax,%eax
	movb (%edi),%al		// 获取该字的第一个字符。
	push %eax		// 把它推到栈上。
	NEXT

	defcode "EXECUTE",7,,EXECUTE
	pop %eax		// 将 xt 放入%eax
	jmp *(%eax)		// 并跳转到它。
				// xt运行后，其NEXT将继续执行当前字。

	defcode "SYSCALL3",8,,SYSCALL3
	pop %eax		// 系统调用号码（见<asm/unistd.h>）。
	pop %ebx		// 第一个参数。
	pop %ecx		// 第二个参数
	pop %edx		// 第三个参数
	int $0x80
	push %eax		// 结果（-errno为负数）
	NEXT

	defcode "SYSCALL2",8,,SYSCALL2
	pop %eax		// 系统调用号码（见<asm/unistd.h>）。
	pop %ebx		// 第一个参数。
	pop %ecx		// 第二个参数
	int $0x80
	push %eax		// 结果（-errno为负数）
	NEXT

	defcode "SYSCALL1",8,,SYSCALL1
	pop %eax		// 系统调用号码（见<asm/unistd.h>）。
	pop %ebx		// 第一个参数。
	int $0x80
	push %eax		// 结果（-errno为负数）
	NEXT

	defcode "SYSCALL0",8,,SYSCALL0
	pop %eax		// 系统调用号码（见<asm/unistd.h>）。
	int $0x80
	push %eax		// 结果（-errno为负数）
	NEXT

/*
	数据段 ----------------------------------------------------------------------

	这里我们设置了Linux的数据段，用于用户定义，也可以称为 "数据段"、"用户内存 "或 "用户定义区"。 
	它是一个向上增长的内存区域，用来存储新定义的FORTH字和各种全局变量。

	它完全类似于C语言的堆，只是没有通用的 "malloc "和 "free"（但正如FORTH中的一切，编写这样的函数只是一个简单的编程事项）。 
	在正常使用中，数据段只是随着新的FORTH字的定义/添加而向上增长。

	GNU工具链有各种 "特性"，使数据段的设置比它真正需要的更复杂。 
	一个是GNU链接器，它插入了一个随机的 "build ID"段。 
	另一个是地址空间随机化，这意味着我们无法知道内核会选择将数据段放在哪里 (或者说是栈的事)。

	因此，编写这个set_up_data_segment汇编程序比它真正需要的要复杂一点。  
	我们使用brk(2)系统调用询问Linux内核认为数据段开始的位置，然后要求它保留一些初始空间（同样使用brk(2)）。

	你不需要担心这个代码。
*/

	.text
	.set INITIAL_DATA_SEGMENT_SIZE,65536
set_up_data_segment:
	xor %ebx,%ebx		// 调用 brk(0)
	movl $__NR_brk,%eax
	int $0x80
	movl %eax,var_HERE	// 初始化HERE，使其指向数据段的开头。
	addl $INITIAL_DATA_SEGMENT_SIZE,%eax	// 为初始数据段保留n个字节的内存。
	movl %eax,%ebx		// 调用 brk(HERE+INITIAL_DATA_SEGMENT_SIZE)
	movl $__NR_brk,%eax
	int $0x80
	ret

/*
	我们为返回静态和输入缓冲区（在读入文件和用户输入的文本时使用）分配静态缓冲区。
*/

	.set RETURN_STACK_SIZE,8192
	.set BUFFER_SIZE,4096

	.bss

/* FORTH返回栈. */
	.align 4096
return_stack:
	.space RETURN_STACK_SIZE
return_stack_top:		// 初始化返回栈的顶部

/* 当从文件或终端读取时，它被用作临时输入缓冲区。*/

	.align 4096
buffer:
	.space BUFFER_SIZE

/*
	FORTH代码的开始 ----------------------------------------------------------------------

	现在我们已经达到了FORTH系统运行和自我托管的阶段。 
	所有进一步的字都可以写成FORTH本身，包括像IF、THEN、. "等在大多数语言中被认为是相当基本的字。

	我曾经在汇编文件中附加了这个，但我厌倦了与gas的多行字符串句法作斗争。 
	所以现在它被放在一个单独的文件里，叫做jonesforth.f

	如果你还没有这个文件，请从http://annexia.org/forth 下载，以便继续学习这个教程。
*/

/* 结束jonesforth.S */