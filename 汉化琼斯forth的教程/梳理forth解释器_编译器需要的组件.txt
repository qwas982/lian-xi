梳理forth解释器/编译器需要的组件;

1,函数就是字,字就是函数,所以若很多函数聚集成库,那么很多字聚集成字典,
	函数(字)的形式为,  [冒号开始 函数名 定义/函数体 分号结束]  
	例如; [: 加 + ;] 当然, 你可以从汇编或机器码开始定义, 例如; [: 加 add ;] 或 [: 加 0010 ;]
	
	字典是一个链表, 用数据结构-链表 来存储字典里的字.
	使用一个字典指针,名为"最新的/最近的",去指向链表的头部,实现增删改查,索引等功能.
	
2,直接线程代码,是forth的一种执行模型,可以看做一种解释器里的虚拟机. 再简化描述,就是一个函数要调用另一个函数.
	它有几部分;
		当前正在执行的位置,
		一个指令指针 / 程序计数器, 指向下一条要执行的指令 / 程序之地址.
		一个预读/拾取的指令, 首先把指令指针/程序计数器的值存入一个寄存器, 
					   然后让指令指针/程序计数器增加或减少4~8字节(依据机器的位宽),用以指向再下一条要执行的指令 / 程序之地址,
		一个跳转指令, 将当前正在执行的位置, 跳转到上一步里那个寄存器里存储的位置,
	
	这四步是一个循环操作, 在每个函数(字)执行后都要操作, 用来跳转到下一个函数(字),
	在forth里被整合为一个宏, 它被称为NEXT---下一个,
	forth的原话是, 我们把函数调用压缩成一个地址列表, 并使用宏-下一个, 在列表之间跳转,
	还使用两个寄存器来存储指令, 一个存指令指针/程序计数器, 另一个存预读/拾取的指令.
	
	简化来说,直接线程代码的目的是, 直接执行用原语写的字(函数), 来达到最高效率. 所谓原语,就是用最原始、基元、原初、起源的基本操作整合的功能,
	在当前时代,当前语境下/上下文里,原语主要指机器码或汇编码. 当然你也可以用高级语言创造原语,就是执行速度可能不理想,
	
3,间接线程代码,这是forth的另一种执行模型,它除了可以完成直接线程代码的功能外,还可以 把已经用原语写好的字名(函数名)列表当做地址列表执行.
	这需要在forth字定义的开头,额外再增加一个指针,它被称之为"代码字",它与上文的"宏-下一个"都是forth专用术语之一,
	
	代码字是一个指向解释器本身的指针,用于运行函数(字).
	解释器在解释汇编码写的原语时,它只运行汇编码本身,无需解释, 而间接线程代码已经抽象了一层,所以需要解释,
	在用FORTH编写的字里(例如 加), 代码字指向一个解释器函数。
	解释器的具体功能在下一节中描述, 这里只说它在间接线程代码中的活动, 如何调用字名(函数名)列表里的字(函数), 因为已经抽象了,所以如何间接调用,
	现在假设字名列表里有[甲][乙]两个函数(字),
	甲如何调用乙,乙如何调用原语(比如说 加)?
		过程如下;
			当乙调用原语时,首先,指令指针/程序计数器指向 加 的地址,
			读取 加 的地址存入预读/拾取寄存器,(重点)让预读/拾取寄存器指向 加 的代码字, //前面说过,间接线程码会在每个forth字头部增加一个指针-代码字,
			然后让指令指针/程序计数器增加或减少4~8字节(依据机器的位宽),用以指向再下一条要执行的指令 / 程序之地址,
			跳转到预读/拾取寄存器内 加 的代码字内的地址,即-跳转到预读/拾取寄存器间接指向的地址,
				简化点说,就是寄存器存了一个地址,这个地址指向一个新的地址.  //你可以将"代码字"看做是一个变量,这个变量里存储一个指针,
			再简化就是;
				①寄存器1 ---> 存储加的地址,
				②加的地址 ---> 存入寄存器2,
				③寄存器1增+减-字节 ---> 指向下一条指令,
				④寄存器2 ---> 跳转到加的地址 ---> 跳转到代码字的地址,
	这看起来跟直接线程码有些相似,但这里多增加了一个指针,多进行了一层抽象,对象指向的对象,就不是直接的而是间接的了,
	
4,解释器和返回栈,
	当一个字需要调用另一个字时,这就像函数调用,forth的原话是这样的;
	"我们保存旧的%esi（'指令指针'），并创建一个指向DOUBLE中第一个字的新指针。
	因为我们需要在DOUBLE结束时恢复旧的%esi，我们将需要一个栈来存储这些 '返回地址'（%esi的旧值）。"
	
	也即是说,当发生字调用时,指令指针/程序计数器需要指向被调用字的地址,那调用字的地址需要有个地方存储,
	放寄存器可以,当寄存器容量不够咋办?于是只能在内存里开辟一个新的空间,forth创造一个新的操作数栈来存储调用字的地址,被称之为返回栈,
	前面直接线程码与间接线程码用的那个栈也是操作数栈,被称之为数据栈/参数栈,这是根据它们的功用不同而命名的.
	
	当调用字进行字调用的时候,需要先将自己的地址存储到返回栈里,也就是forth原话中的"指令指针esi寄存器"的值,
	因为进行字调用的时候,"指令指针esi寄存器"会被被调用字的地址占用/覆盖,这是在数据栈/参数栈执行字的时候必然发生的过程,
	当被调用字在数据栈/参数栈里执行完毕后,需要回到调用字那里,也就是返回,这时候只需读取先前放在返回栈里的调用字的地址即可恢复,
	
	这可能跟C语族的函数调用或ABI约定有些不一样,
	C语族被设计成调用者保存或被调用者保存都可以,C语族里的函数,每个函数都享用一个栈帧(操作数栈的副本),
	也就是说每个函数都有一个虚拟的栈,这样的话,究竟是设计成调用者保存还是被调用者保存,每个操作系统都有不同的约定,
	并且每种约定使用的寄存器和栈模型都不一样,
	而这在forth里根本不可能发生,forth栈语言这种两个栈的设计是一种哲学理念,它不管是在不同操作系统下,还是不同指令系统的CPU上,
	都完全保持两个栈的设计,调用约定/模式完全一样,只要有几个足够数目的通用寄存器,即可完成建立一套forth栈语言系统.
	
	到目前为止,一个forth系统必需的寄存器有;
		指令指针/程序计数器寄存器,
		数据栈/参数栈寄存器,
		返回栈寄存器,
		预读/拾取寄存器,
		...
		
	当然,这个列表里的寄存器可能还有若干个,待增加时,我会更新这个列表.
	
	据我所知,在64位时代,X86已经有16个通用寄存器,而ARM有31个,RISCV有32个. 当然,它们也有一些不通用的寄存器,可以用,但会降低可移植性,
	也就是说,只要使用这些通用寄存器来构建forth系统都是可以的,而无需受C语族调用约定的干扰.
	
	解释器是如何工作的呢?
		解释器实际是对线程码与返回栈的应用,因为会用到后两者的功能,
		forth里,把解释器称之为DOCOL, 它是英文 '做' 和 '冒号' 的简化组合字, 我认为直译为中文汉字的意思是; 执行/处理冒号,
		因为forth的字(函数)定义,都以冒号开始, 当然, 别的栈语言可能不是这样,也有别的形式,
		
		上面说了,解释器会用到前面的知识,
		首先让预读/拾取寄存器存入被调用字的代码字,也就是获取了被调用字的地址,
		当字调用发生时,解释器DOCOL指向被调用字的代码字, 这时解释器DOCOL需要保存调用字的指令指针/程序计数器寄存器的值,
		所以解释器DOCOL把调用字的指令指针/程序计数器寄存器的值推到返回栈上,
		之后,解释器DOCOL就可以指向被调用字的地址,也就是预读/拾取寄存器里存储的代码字的地址,
		到这里,就是发挥线程代码的功能了,
		前面说了线程码的执行过程,解释器DOCOL等待这里(被调用字)的线程码执行完,
		然后读取保存在返回栈里指令指针/程序计数器寄存器的值,回到调用字继续顺序执行.
			简化点说,这其实还是变量与指针的关系 与使用;
			我们可以把解释器DOCOL看做是一个变量,用来保存指针,而寄存器既能保存指针也能保存变量,
			因为寄存器被设计为既能保存立即数又能保存地址,不管那个硬件平台(CPU)都是这样的,
				①寄存器1 ---> 存储调用字的指令指针(代码字的地址)
				②寄存器1 ---> 把调用字的指令指针存入返回栈(寄存器3)
				③寄存器2 ---> 存储被调用字的代码字地址
				④寄存器1 ---> 读取或指向被调用字的代码字地址
				⑤寄存器2 ---> 增+减-字节 指向下一条指令,
					......
					发挥线程码
					......
				⑥寄存器1 ---> 读取返回栈里调用字的指令指针
					......
					返回后继续发挥线程码
					......
			<================================================================================>	
			这样说,或许还不够简化,我应该把上面forth系统必需的寄存器列表简化名字,
				指令指针/程序计数器寄存器, ---> 指寄
				数据栈/参数栈寄存器,		---> 参寄
				返回栈寄存器,			---> 返寄
				预读/拾取寄存器,			---> 预寄
			
			那么,上面解释器DOCOL的执行过程可以简化为;
				①指寄 --存-- 调用字的代码字地址
				②参寄 --存-- 指寄
				③返寄 --存-- 参寄
				④预寄 --存-- 被调用字的代码字地址
				⑤指寄 --存-- 预寄
				⑥预寄 --存-- 增+减-字节 指向下一条指令
						......
						发挥线程码
						......
				⑦指寄 --存-- 返寄
				⑧参寄 --存-- 指寄
						......
						返回后继续发挥线程码
						......
		我发现直接描述操纵寄存器步骤是最简洁的,但这样读者可能看不明白, 或许在后面加点注释吧,
		
5,开启.
	启动forth的时候, 建立独立的返回栈, 设置返回栈, 并立即跳转到名叫QUIT的forth字(函数),
	用它来重置forth系统内部的状态,并开始读取和解释命令,
	QUIT字可以在调用的时候从从某个状态退出,进入你想要的状态,比如退出读取,回到解释,反之亦然,
	
6,内建字,
	用结构构造内建字,
	使用创造forth的机床语言之功能,构造forth初始就有的一些字(函数),被称为内建字,
	参照教程里列出的一些内建字,
	
字调用了后,如何返回?
	从一个forth字返回,
		通过EXIT字(函数)实现从调用了后的字返回到调用之前的字,
	EXIT完成的就是字调用的尾部善后的工作,
	"EXIT获取我们之前保存在返回栈中的旧%esi，并将其放在%esi中"
	简化来说;
		指寄 --存-- 返寄
	
7,字面,
	如何处理纯字面量?
	forth使用一个叫LIT的字(函数),主要作用是,跳过字面量.
	具体过程如下;
		指寄 --存-- 字面量的地址
		参寄 --存-- 字面量
		指寄 --存-- 增+减-字节 指向下一条指令
		
8,内建变量,
	LATEST指向forth字典中最新的/最后的字,
	LATEST本身是一个forth字(函数),它将自身当做变量,并将变量的地址推到栈上,
		内建变量有;
			STATE	--	解释器是在执行代码（0）还是在编译一个字（非零）？
			LATEST	--	指向字典中的最新（最近定义的）字。
			HERE	--	指向内存的下一个空闲字节。 编译时，被编译的字在这里。
			S0		--	存储参数栈顶的地址。
			BASE	--	当前用于打印和读取数字的基础。
			
9,内建常量,
	常量也是一个字(函数),当这个字被执行时,它将一个常量值推到栈上,
		内建常量有;
			VERSION	 --	是这个FORTH的当前版本。
			R0		 --	返回栈顶部的地址。
			DOCOL	 --	指向DOCOL的指针。
			F_IMMED	 --	IMMEDIATE标志的实际值。
			F_HIDDEN --	HIDDEN标志的实际值。
			F_LENMASK -- 在flags/len字节中的长度掩码。

			SYS_*	--	以及各种Linux系统调用的数字代码（来自<asm/unistd.h>）。
			
		具体参见教程中的列表,

10,实现一些控制内存、返回栈、参数栈的内建字.

11,输入和输出,
	一些字(函数)到底是在创造forth的机床语言中写,还是在forth里写,见仁见智的选择.
	
	先说输入,
		FORTH字KEY从stdin中读取下一个字节（并将其推到参数栈中）。
		因此，如果KEY被调用，有人按了空格键，那么数字32（空格的ASCII码）就被推到栈上。
		在FORTH中，阅读代码和阅读输入是没有区别的。 
		我们可能是在阅读和编译代码，可能是在阅读要执行的字，可能是要求用户输入他们的名字--最终都是通过KEY来实现的。
		
		KEY字(函数)的实现;
			使用一个固定大小的缓冲区,
			调用操作系统的读取功能来存入这个缓冲区,
			KEY使用若干个变量去跟踪它在缓冲区里的位置,
			若缓冲区耗尽,KEY自动重新填充,
			
		具体实现细节,参照教程中的步骤,
		
	相比之下，输出就简单多了。 FORTH字EMIT写出一个字节到stdout。
	这个实现只是使用了写系统调用。 没有尝试对输出进行缓冲，
	
	对于输入,WORD是一个FORTH字，它读取输入的下一个完整字,
	WORD的用途：在编译和执行代码时读取FORTH字,
		它的具体做法是，首先跳过任何空白（空格、制表符、换行符等）。
		然后，它调用KEY将字符读入一个内部缓冲区，直到遇到一个空白。 
		然后，它计算读到的字的长度，并将地址和长度作为两个字返回到栈中（长度在栈的顶部）
		
		WORD内部有一个单一的缓冲区,每次使用都将覆盖,
		
	上面说的是forth如何读取字符串,读取数字的时候,使用NUMBER字(函数),
		这个函数解析一个数字字符串，比如由WORD返回的数字，并将数字推到参数栈上。
		
		该函数使用变量BASE作为转换的基数（radix），例如，如果BASE是2，那么我们期待一个二进制数字。 通常，BASE是10。
		如果该字以'-'字符开头，那么返回值为负数。
		如果字符串不能被解析为数字（或包含当前BASE以外的字符），那么我们需要返回一个错误提示。
		
		所以NUMBER实际上在栈中返回两个项目。
		在栈顶，我们返回未转换的字符数（即-如果是0，那么所有字符都被转换了，所以没有错误）。 
		栈顶的第二项是解析后的数字，如果有错误，则是一个部分值。
		
12,字典查询
	我们正在建立forth字如何编译的基础设施,
	FIND字接收一个由WORD解析的字变成字符串,并在字典里查找它,
	找到,返回字典条目的地址,未找到,返回0,
	
	FIND不能找到被标记为HIDDEN的字典条目, 另见 >CFA 和 >DFA.
	CFA代表什么？ 我最好的猜测是 "代码字段地址" / "Code Field Address"。
	那DFA最大的可能就是"字典字段地址",
	
	FIND返回一个字典指针, 而forth字(函数)定义被编译成代码字指针的列表, 所以在编译时我们需要代码字指针,
	forth字 >CFA 把字典指针转换为代码字指针.
	那么,简化描述就是;
		FIND字 ---> 返回字典条目的地址,
		>CFA   ---> 将字典条目地址 转换为 代码字地址,
	不要搞混了,指针在地址里指向某个方向,
	具体实现细节,参见教程里的汇编码过程.
		>DFA   ---> 在 >CFA 的基础上,获取下一个字的地址
					通过这个地址,获取下一个字,
					即-通过地址里的指针来指方向,
	
13,编译
	forth是如何编译字(函数)的? 字(函数)定义为如下形式;
		: 双 副本 + ;
	定义必须被转化为如下存储块,
		[链指针 最新指针 长度 双 填充 代码字 副本 + EXIT]
	那么,这产生了如下几个问题;
		一,新的字(函数)存储在哪里?
		二,要用的时候如何读取?
		三,如何定义 : (冒号) 与 ; (分号) ?  :（COLON）和 ;（SEMICOLON）
	forth的解决方案是,允许你改变编译器的工作状态,
	forth有一个INTERPRET函数(字),它是真正的解释器,
	它在一个循环中运行,用WORD读取字,用FIND查找字,用>CFA把字转换为代码字指针,并决定下一步如何处理,
	INTERPRET函数(字)要做什么,取决于解释器被设置为什么模式,这在变量STATE中设置,
		当STATE被设置为0时,解释器仅在查找每个字(函数)时运行它们,这被称为---立即模式,
		当STATE被设置为非0时,解释器将代码字指针追加到用户内存中,这被称为---编译模式, HERE变量指向用户内存的下一个空闲字节,
	那我们如何定义 : (冒号) 呢? 步骤如下,
		一,用WORD读取已定义字名(函数名).
		二,在用户内存里,仅构造字典条目的头部. HERE指向这里,解释器开始在这里追加代码字,
		三,设置LATEST指向新定义的字,
		四,重要的是,在新的代码字后留下HERE的指向,这是解释器将追加代码字的位置,
		五,把STATE设置为1,进入编译模式,解释器开始追加代码字到形式部分的头部,
			运行后,输入缓冲区里,由KEY返回的下一个字节将是 副本 的'副'字符,
			所以,当处于编译模式的解释器读取"副本"的时候, 就在字典里查找它,获取它的代码字指针,再追加它,
			下一步我们读取 + ,获取其代码字指针,并追加它,
			
	接下来,我们会读到 ; (分号),这会触发编译,并编译后面的一切,但我们不希望这样,那咋办,加入这几个组件,
		字典里的长度字节不是普通的长度字节,还包含 标志,标志里有一个IMMEDIATE的标志,在这里是F_IMMED,
	若字典里的字被标志为IMMEDIATE,解释器就会立即运行它,即使它处于编译模式下,这就是 ; (分号)字的功能,
		在字典里被标志为IMMEDIATE的字, ; (分号)将EXIT的代码字追加到当前的定义后,并把STATE设置为0切换回立即模式,
		在后面,我们将会看到 ; (分号) 的实际定义,很简单,它被声明为IMMEDIATE,
		这时,HERE变量指向当前定义下的EXIT位置,
		
	当字(函数)的新定义被编译了这工作完成后,我们回到了立即模式,可以读、执行、调用、测试这个新字(函数),
	这里的问题是,这个字(函数)被编译的时候,它还处于半成品状态,我们并不希望这个字在这段时间内以某种方式被调用,有几种方法可以阻止,
	不过在forth里,我们在编译过程中用HIDDEN来标志这个字,在这里是F_HIDDEN,
	这可以防止它被FIND找到,从而阻止它被调用的机会,
	
	以上解答了 : (冒号) 与 ; (分号) 的编译过程, 之后再说它们是如何定义的,
	
	通过把 : (冒号)字写成两部分,使其变得更通用,
		第一部分,用CREATE字来制作头部,
		第二部分,在实际定义 : (冒号) 时,调用CREATE字并追加DOCOL的代码字,
	拆分的好处是,我们可以重复使用CREATE字去创建其它类型的字,除了包含代码的字,还有包含变量、常量、其它数据、的字,
	
	若想在forth中定义 : (冒号) ,而不是在机床语言中定义,那还需要一些forth字原语充当基础设施,
		第一个是 , (逗号) 
		它将代码字追加到当前正在编译的字上,它也是一个forth字(函数),用于将一个32位整数追加到HERE指向的用户内存上,并让HERE加4,
		用户内存上的新数据,可以是栈顶的任意32位整数,
	若要定义 : (冒号) 与 ; (分号) ,将需要在全局变量STATE中,对比并切换状态,通过更新这个变量,在立即模式与编译模式之间切换,
	forth定义两个字, [ (左中括号) 与 ] (右中括号) 来切换模式,
		[ (左中括号)  ---  STATE = 0 ,切换到立即模式
		] (右中括号)  ---  STATE = 1 ,切换到编译模式
	[ (左中括号) 是一个IMMEDIATE字,原理如下;
		若处于编译模式时,解释器看到了 [ ,那就编译而不运行,这时无法切换回立即模式,
		所以将这个字标志为IMMEDIATE, 这样就算在编译模式下,也会切换回立即模式并立即运行这个字,
	现在可以用CREATE来定义 : (冒号) 了,
		定义时,调用CREATE,追加DOCOL这个代码字,设置HIDDEN这个字,之后进入编译模式,
	同样的方法也可以定义 ; (分号) ,注意加上F_IMMED标志,具体步骤参见教程.
	
14,扩展编译器
	forth编译器可以使用IMMEDIATE标志,在这里是F_IMMED.你自己也可以定义IMMEDIATE字,这是因为forth允许你扩展编译器本身,
	标准的forth字(函数) if while . " 等等,都是IMMEDIATE字,都是作为编译器扩展写的,
	通过在最近定义的字上切换F_IMMED(IMMEDIATE的标志),你若在定义的过程中调用它,IMMEDIATE则在当前的字上,
	用法与形式如下;
		: MYIMMEDWORD IMMEDIATE
			...definition...
		;

		但有些FORTH程序员却这样写:

		: MYIMMEDWORD
			...definition...
		; IMMEDIATE

		这两种用法等价.
		
	HIDDEN字:	'addr HIDDEN' 拴牢addr处定义的字的隐藏标志（F_HIDDEN）
				隐藏最近定义的字（在上面的 : 和 ; 定义中使用） ,例如; LATEST @ HIDDEN
	HIDE字:		'HIDE word'在一个被命名为'word'上拴牢标志.通过设置标志阻止这个字被FIND找到,
	 ' 字:		返回下一个字的代码字指针,它只能在编译的代码中工作,例如; ' 函数 ,
				它将 函数 的代码字追加到我们正在定义的字上（这只在编译后的代码中起作用）
	你倾向于在IMMEDIATE字中使用 ' .  例如，定义2的另一种方式（而且相当无用）可能是:
		: LIT2 IMMEDIATE
			' LIT ,		\ 将LIT追加到当前-正在-定义的-字上。
			2 ,			\ 将数字2添加到当前-正在-定义的-字中。
		;

	所以你可以这样:
		: DOUBLE LIT2 * ;
	我们可以在WORD、FIND、>CFA的基础上编写一个 ' 的版本，它也可以在立即模式下工作.
	
15,分支
	事实证明,你只需两个原语,即可定义循环结构,if语句,等等这类程序块.
	因为分支的本质就是跳转,只不过是,从哪里跳转到哪里的问题.
		BRANCH是一个无条件分支
		0BRANCH是一个有条件分支(它只在栈顶为0时才进行分支)
	BRANCH在字块里如何工作?
		当BRANCH执行时,指寄 开始指向偏移量,偏移量被添加到 指寄 里,成为新的 指寄,
		当NEXT执行时,在分支目标处继续执行,
	0BRANCH与之相同,但是分支发生有条件,
	
	现在标准的FORTH字，例如IF、THEN、ELSE、WHILE、REPEAT等，可以完全用FORTH实现,
	它们是IMMEDIATE字，将BRANCH或0BRANCH的各种组合追加到当前正在编译的字中,
		例如,这样的代码块;
			条件码 IF 真部分 THEN 其它代码
		将会编译到;
			条件码 0BRANCH 偏移 真部分 其它代码

字面字符串.
	LITSTRING字是用于实现 ." 与 S" 的原语,
	TELL字打印一个字符串,
	在机床语言中定义很有效,可以使它成为一个单一的系统调用,
	
退出和解释.
	QUIT字是forth系统开启后立即调用的第一个字(函数),它做了一些初始化工作,比如清除了返回栈,然后在一个循环中调用INTERPRET来解释命令,
	此过程被称之为QUIT是因为你能随时在自己写的forth字间调用它,让你灵活结束并重新开始,
	INTERPRET字是FORTH的解释器("toploop"、"toplevel "或 "REPL "可能是一个更准确的描述)
	INTERPRET字的实现过程很简单,参见教程里的汇编步骤,
	在forth里,你随时能用一个更强的解释器来覆盖它,
	
	CHAR字把列表里第一个字符的ASCII码推入栈里, 例如 CHAR A , 把65放在栈里. (注;这里演示ASCII字符编码, 其它编码类型也大同小异)
	EXECUTE字用于运行 执行牌 (execution tokens),这是个术语,搜索它去了解.
	
	SYSCALL0字, SYSCALL1字, SYSCALL2字, SYSCALL3字, 用于在32位Linux下进行系统调用,
	由于这个forth教程年代久远, 那么在当前系统和软件环境下, 可能需要实现新的系统调用语句.
	
数据段.
	为了存储用户定义的数据,比如你在进入forth系统后写的字(函数),我们必须要在当前的系统和软件环境下,设置一种数据段.
	这是一个向上增长的内存区域,用来存储新定义的forth字与各种全局变量,
	你也可以把它称之为"数据段"、"用户内存 "或 "用户定义区",
	
	它很像C语族的 堆 这个概念. 只是没有C语族的"malloc "和 "free"函数,但你完全可以用forth字实现这样的函数,
	在正常使用时，数据段只是随着新的FORTH字的定义/添加而向上增长,
	它是自动的,但你必须在机床语言中实现它,这可能取决于你当前使用的系统和编程语言是如何管理内存的.(编写的复杂性随之而定
	
/*
好了,我已经写完第一个文件的读书笔记, 就是对这个 .s 文件的学习, 这里注释和总结下,
首先,实现一个forth,需要用一个现有的编程语言来写,我把它称之为机床语言, 静态编译型的可能更好,
其次,这个 .s 文件里,实现的大多是为了构建forth系统所必须的基础原语,
有了原语,之后才能使用原语构造更高阶的一门程序语言的功能组件,
而forth这样的栈语言的优势,在这里就体现出来了,我曾说,栈语言应用了分治算法与递归算法的思想,
栈语言可以从机器码开始构建,直到超越人类语言,它可以构造原语来创造高阶的抽象,它通过抽象一层一层的原语,来实现更先进的编程语言功能,
重要的是,基础的原语与高阶的原语都是可以同时使用的,这就是分治思维和递归思维.

当然,这里的forth教程还很原始,我的理解也不是很到位,比如这里只是实现了程序在内存里存储和运算,
但并没实现与文件系统的交互,输入是直接读取美式键盘的,我发现了几个问题,
根据冯诺依曼结构,[逻辑运算 控制器 存储器 输入 输出],这个forth重点解决了控制器和存储器的功能,
逻辑运算直接使用了CPU的指令系统提供的指令,输入是直接读取ASCII字符编码的美式键盘,输出是直接把结果存储到内存里,没有处理输出设备的程序块,
因为像显示器 打印机 显卡这些概念,在forth那个年代根本没有,
forth也没有文件的概念,因为没有与文件系统对接,所以通过写一个源代码文件,再用编译器编译为机器码,这个过程,在forth里根本就不会发生,
我的猜测是,若要将forth程序永久保存到磁盘里,要不就是把内存里的forth系统复制为镜像存储到磁盘里,
要不就是当你用机床语言构建forth系统时,一开始就把从低阶抽象到高阶的所有原语全部实现放在内存里,
当然,我们也可以用forth这样的栈语言写一个与文件系统对接的函数,这样我们就可以从源码文件读取源码到内存里,
也可以把内存里的新写的源码保存到磁盘上,

还有一个问题是,若要在栈语言里实现中文汉字编程,输入输出相关的字符编码也得解决,因为forth只用ASCII字符编码和美式键盘,
我们要支持中文汉字的话,就得用Unicode字符编码和软键盘(即-输入法),用forth本身实现这两个中间件,然后与输入输出对接,
不知我设想得对不对,这可能需要实践去验证.

好了,总结得差不多了,之后再学习 .f 文件里的内容,这已经是forth程序了,因为已经用原语抽象一层了,
所以 .f 文件里都是forth语言的源码,

总的来看,这个 .s 文件建造了一台虚拟的计算机,或者说 语言虚拟机 ,但又与传统的C语族的语言虚拟机不一样,
forth虚拟机用到的好多功能,以及构造这些功能的概念都与C语族迥异,
或许这就是栈语言的特别之处和魅力吧,

栈语言的真正居所,专用CPU? 指令集抽象?
现在想这些可能还太远了,
*/

教程里说,完成上面的步骤和内建字与原语,即可实现forth系统运行与自我托管的基本需求,
进一步的功能和一门编程语言必须的其余组件,将用forth语言本身来写,而非机床语言,

好,现在开始第二部分的学习,

大多都是定义函数,参照教程即可,

说下控制结构的细节,
			条件 IF 真部分 THEN 其余的
		将会编译到;
			条件 0BRANCH 偏移 真部分 其余的
	其中,偏移是 '其余的' 的偏移量.
	
			条件 IF 真部分 ELSE 假部分 THEN
		将会编译到;
			条件 0BRANCH 偏移 真部分 BRANCH 偏移2 假部分 其余的
	其中,偏移是 '假部分' 的偏移量, 偏移2是 '其余的' 的偏移量
	
	IF是一个IMMEDIATE字,它编译了0BRANCH, 后面跟一个偏移量的假动作,并把0BRANCH的地址推到栈上,
	当我们之后看到THEN时,我们从栈中弹出该地址,计算偏移量,并回填偏移量,
	
			BEGIN 循环部分 条件 UNTIL
		将会编译到;
			循环部分 条件 0BRANCH 偏移
	其中,偏移指向 '循环部分' ,
			BEGIN 循环部分 AGAIN
		将会编译到;
			循环部分 BRANCH 偏移
	其中,偏移指向 '循环部分' ,
			BEGIN 条件 WHILE 循环部分 REPEAT
		将会编译到;
			条件 0BRANCH 偏移2 循环部分 BRANCH 偏移
	其中,偏移指向 '条件' ,偏移2指向整段代码之后
	
栈备注.
	forth使用( ... )进行注释,
	我们可以用( ... -- ... )来显示一个字对参数栈的影响,
	示例;
		( n -- )		表示该字从参数栈中消耗一个整数（n）。
		( b a -- c )	表示该字使用了两个整数（a和b，其中a在栈顶）,并返回一个单一的整数（c）。						
		( -- )			表示该字对栈没有影响
		
打印数字/号码.
	forth字 . (点) 是很重要的,它取栈顶数字并打印,
		U.R	( u width -- )		打印一个无符号的数字，填充到一定的宽度。
		U.	( u -- )			它打印出一个无符号的数字
		.R	( n width -- )		它打印一个有符号的数字，填充到一定的宽度。
	例如:
		-123 6 .R
	将会打印出这些字符:
		<space> <space> - 1 2 3
		
	. 和 朋友 的另一个问题是，他们服从变量BASE中的当前基数。BASE可以是2到36范围内的任何东西

	当我们定义 .&c 的时候，我们也可以定义 .S ，这是一个有用的调试工具。 
	这个字可以从顶到底打印出当前的栈（非破坏性的）。
	FORTH字 .S 打印出栈的内容。 它并不改变栈的内容。在调试时非常有用。
	
	
后面大多都是对forth一些预加载字(函数)的介绍,更像是编程语言使用手册,
