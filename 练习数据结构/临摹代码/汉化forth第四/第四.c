#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "第四.h"

int 检查空白(char 检){
	return (检 == ' ' || 检 == '\t' || 检 == '\n');
}

char *解析字(){
	char *现在;
	while(检查空白(*文本指针)){
		文本指针++;
	}
	现在 = 文本指针;
	while(!检查空白(*文本指针) && (*文本指针) != '\0'){
		文本指针++;
	}
	if(*文本指针 == '\0'){
		return 现在;
	}
	*文本指针 = '\0';
	文本指针++;
	return 现在;
}

字 *创建(char *名字,函数指针 函指){
	字 *小字 = (字 *)malloc(sizeof(字));
	小字->代码指针 = 函指;

	小字->名字 = (char *)malloc(strlen(名字) + 1);
	strcpy(小字->名字,名字);

	小字->字参数列表 = NULL;
	小字->旗 = 隐藏字;
	return 小字;
}

void 做过(字 *小字,字 **列表,int 数量){
	if(数量 != 0){
		小字->字参数列表 = (字 **)malloc(数量);
		memcpy(小字->字参数列表,列表,数量);
	}else{
		小字->字参数列表 = 列表;
	}
	小字->旗 = 揭露字;
}

字 *定义核心字(char *名字,函数指针 函指){
	字 *小字 = 创建(名字,函指);
	小字->旗 = 隐藏字;
	return 小字;
}

void 冒号字(){
	返回栈指针++;
	*返回栈指针 = (细胞)指令指针;
	指令指针 = (*指令指针)->字参数列表 - 1;
	打印("[调试]进入字程序 \n")
}

void 常量字(){
	数据栈推入((细胞)((*指令指针)->字参数列表));
}

void 变量字(){
	数据栈推入((细胞)*指令指针);
}

字典 *字典初始化(){
	字典 *星字典 = (字典 *)malloc(sizeof(字典));
	星字典->大小 = 0;
	星字典->头部 = NULL;
	return 星字典;
}

int 字典指令下一个(字典 *星字典,字 *星字){
	星字->链接 =星字典->头部;
	星字典->头部 = 星字;
	星字典->大小++;
	return 0;
}

字 *字典搜索名字(字典 *星字典,char *名字){
	字 *小字 = 星字典->头部;
	while((小字 != NULL && strcmp(小字->名字,名字))
		|| (小字 != NULL && !strcmp(小字->名字,名字) && 小字->旗 == 隐藏字)){
		小字 = 小字->链接;
	}
	return 小字;
}

void 字典摧毁字(字 *星字){
	free(星字->名字);
	if(星字->代码指针 == 冒号字){
		free(星字->字参数列表);
	}
	free(星字);
}

int 字典余留之后(字典 *星字典,char *名字){
	字 *小字 = 字典搜索名字(星字典,名字);
	字 *删除小字;
	if(小字 == NULL){
		printf("%s :\n\t 找不到! \n",名字 );
	}else{
		if(小字->字参数列表 == NULL){
			printf("\t 核心字无法删除 \n");
			return 0;
		}
		do{
			删除小字 = 星字典->头部;
			星字典->头部 = 星字典->头部->链接;
			字典摧毁字(删除小字);
			星字典->大小--;
		}while(删除小字 != 小字);
		return 1;
	}
	return 0;
}

void 解释机(){
	字 **指令指针终 = 指令指针;
	指令指针 = 指令指针头部;
	while(指令指针 != 指令指针终){
		打印("[调试]解释执行> %s \n",(*指令指针)->名字)
		(*指令指针)->代码指针();
		++指令指针;
	}
	指令指针头部 = 指令指针;
}

int 是否号码(char *串){
	if(*串 == '-'){
		串++;
	}
	while(*串 != 0){
		if(!isdigit((细胞)*串)){
			return 0;
		}
		串++;
	}
	return 1;
}

int 找(字典 *星字典,char *名字){
	字 *字指针;
	字指针 = 字典搜索名字(星字典,名字);
	if(!strcmp(":",名字) || !strcmp("]",名字)){
		状态 = 编译;
	}
	if(状态 == 编译){
		if(字指针 == NULL){
			if(!是否号码(名字)){
				return 0;
			}else{
				打印("[调试]成功找到数字%s \n",名字)
				指令指针推入(字典搜索名字(星字典,"(列)"),指令指针头部);
				指令指针推入((字*)(细胞)(atoi(名字)),指令指针头部);
				return 1;
			}
		}else if(字指针->旗 == 立即字){
			打印("[调试]执行立即字 %s \n",名字)
			if(字指针->字参数列表 != NULL){
				入解释器();
				指令指针推入(字指针,指令指针头部);
				解释机();
				出解释器();
			}else{
				字指针->代码指针();
			}
		}else{
			打印("[调试]成功编译 %s 字 \n",名字)
			指令指针推入(字指针,指令指针头部);
		}
	}else if(状态 == 解释){
		if(字指针 == NULL){
			if(!是否号码(名字)){
				return 0;
			}else{
				打印("[调试]数据栈推入 %s \n",名字)
				数据栈推入((细胞)(atoi(名字)));
				return 1;
			}
		}else{
			打印("[调试]成功找到 %s 字 \n",名字)
			指令指针推入(字指针,指令指针头部);
			解释机();
		}
	}
	return 1;
}

void 空栈(){
	数据栈指针 = 数据栈 - 1;
	返回栈指针 = 返回栈 - 1;
}

void 栈错误(int 数量){
	switch(数量){
		case 1:
			printf("栈下溢 \n");
			break;
		case 2:
			printf("栈溢出 \n");
			break;
	}
	exit(0);
}

void 指令指针推入(字 *小字,字 **列表){
	if(指令指针 >= 列表 + 缓冲长){
		栈错误(2);
	}
	*指令指针 = 小字;
	指令指针++;
}

void 数据栈推入(细胞 数量){
	if(数据栈指针 >= 数据栈 + 栈长 - 1){
		栈错误(2);
	}
	数据栈指针++;
	*数据栈指针 = 数量;
}

void 返回栈推入(细胞 数量){
	if(返回栈指针 >= 返回栈 + 栈长 - 1){
		栈错误(2);
	}
	返回栈指针++;
	*返回栈指针 = 数量;
}

细胞 数据栈弹出(){
	if(数据栈指针 <= 数据栈 - 1){
		栈错误(1);
	}
	数据栈指针--;
	return *(数据栈指针 + 1);
}

细胞 返回栈弹出(){
	if(返回栈指针 <= 返回栈 - 1){
		栈错误(1);
	}
	返回栈指针--;
	return *(返回栈指针 + 1);
}

细胞 数据栈顶端(){
	if(数据栈指针 <= 数据栈 -1){
		栈错误(1);
	}
	return *数据栈指针;
}

细胞 返回栈顶端(){
	if(返回栈指针 <= 返回栈 - 1){
		栈错误(1);
	}
	return *返回栈指针;
}

void 字面值(){
	指令指针++;
	数据栈推入((细胞)*指令指针);
	打印("[调试]数 %ld 压入数据栈 \n",(细胞)*指令指针)
}

void 弹数据栈(){
	printf("%ld \n",数据栈弹出());
}

void 再见(){
	exit(1);
}

void 返(){
	指令指针 = (字 **)(返回栈弹出());
	打印("[调试]从子程序返回 \n")
}

void 深(){
	数据栈推入((细胞)(数据栈指针 - 数据栈 + 1));
}

void 加(){
	数据栈推入(数据栈弹出() + 数据栈弹出());
}

void 减(){
	细胞 数栈 = 数据栈弹出();
	数据栈推入(数据栈弹出() - 数栈);
}

void 乘(){
	数据栈推入(数据栈弹出() * 数据栈弹出());
}

void 除(){
	细胞 数栈 = 数据栈弹出();
	数据栈推入(数据栈弹出() / 数栈);
}

void 滴落(){
	数据栈弹出();
}

void 展现数据栈(){
	printf("<%ld> \n",(细胞)(数据栈指针 - 数据栈 + 1));
	细胞 *甲 = 数据栈;
	for(;甲<=数据栈指针;甲++){
		printf("%ld \n",*甲);
	}
	printf("\n");
}

void 摘取(){
	细胞 子 = 数据栈弹出();
	if(数据栈指针 - 子 + 1 <= 数据栈 - 1){
		栈错误(1);
	}
	数据栈推入(*(数据栈指针 - 子 + 1));
}

void 卷动(){
	细胞 子 = 数据栈弹出();
	if(数据栈指针 - 子 + 1 <= 数据栈 - 1){
		栈错误(1);
	}
	细胞 丁子 = *(数据栈指针 - 子 + 1);
	for(;子 > 1;子--){
		*(数据栈指针 - 子 + 1) = *(数据栈指针 - 子 + 2);
	}
	数据栈弹出();
	数据栈推入(丁子);
}

void 入变量(){
	字 *针 = (字 *)(数据栈弹出());
	针->字参数列表 = (字 **)数据栈弹出();
}

void 出变量(){
	字 *针 = (字 *)(数据栈弹出());
	数据栈推入((细胞)(针->字参数列表));
}

void 等于(){
	if(数据栈弹出() == 数据栈弹出()){
		数据栈推入(-1);
	}else{
		数据栈推入(0);
	}
}

void 不等于(){
	if(数据栈弹出() != 数据栈弹出()){
		数据栈推入(-1);
	}else{
		数据栈推入(0);
	}
}

void 大于(){
	细胞 丁 = 数据栈弹出();
	if(数据栈弹出 > 丁){
		数据栈推入(-1);
	}else{
		数据栈推入(0);
	}
}

void 小于(){
	细胞 丁 = 数据栈弹出();
	if(数据栈弹出 < 丁){
		数据栈推入(-1);
	}else{
		数据栈推入(0);
	}
}

void 若分支(){
	if(数据栈弹出() == 0){
		指令指针 = 指令指针 + (细胞)(*(指令指针 + 1));
	}else{
		指令指针++;
	}
}

void 分支(){
	指令指针 = 指令指针 + (细胞)(*(指令指针 + 1));
}

void 做事(){
	细胞 索引 = 数据栈弹出();
	细胞 限界 = 数据栈弹出();
	if(限界 <= 索引){
		指令指针 = 指令指针 + (细胞)(*(指令指针 + 1));
	}else{
		指令指针++;
		索引++;
		返回栈推入(索引);
		返回栈推入(限界);
	}
}

void 环(){
	指令指针 = 指令指针 - (细胞)(*(指令指针 + 1));
	数据栈推入(返回栈弹出());
	数据栈推入(返回栈弹出());
}

void 去返回栈(){
	返回栈推入(数据栈弹出());
}

void 返回栈去(){
	数据栈推入(返回栈弹出());
}

void 返回栈顶端出(){
	数据栈推入(返回栈顶端());
}

void 发射(){
	putchar((char)(数据栈弹出()));
}

void 字复数(){
	字 *小字 = 第四字典->头部;
	while(小字 != NULL){
		printf("%s \n",小字->名字);
		小字 = 小字->链接;
	}
	printf("\n");
}

void 立即数(){
	第四字典->头部->旗 = 立即字;
}

void 推入数据栈字执行地址(){
	当前文本 = 解析字();
	数据栈推入((细胞)字典搜索名字(第四字典,当前文本));
}

void 编译字参数列表(){
	指令指针++;
	字 **终端 = 指令指针;
	字 *字指针 = *指令指针;
	字 **指令指针完毕 = (字 **)返回栈弹出();
	指令指针 = (字 **)返回栈弹出();
	if(字指针->字参数列表 != NULL){
		字 **针 = 字指针->字参数列表;
		字 *终 = 字典搜索名字(第四字典,"返");
		for(;*针 != 终;针++){
			指令指针推入(*针,第四字典->字参数列表临时);
		}
	}else{
		打印("[调试]编译核心字 %s \n",字指针->名字)
		指令指针推入((字 *)字指针,第四字典->字参数列表临时);
	}
	返回栈推入((细胞)指令指针);
	返回栈推入((细胞)指令指针完毕);
	指令指针 = 终端;
}

void 编译栈顶数(){
	字 **终端 = 指令指针;
	字 **指令指针完毕 = (字 **)返回栈弹出();
	指令指针 = (字 **)返回栈弹出();
	细胞 号码 = 数据栈弹出();
	打印("[调试]编译栈顶数 %ld \n",号码)
	指令指针推入((字 *)号码,第四字典->字参数列表临时);
	返回栈推入((细胞)指令指针);
	返回栈推入((细胞)指令指针完毕);
	指令指针 = 终端;
}

void 入解释器(){
	状态 = 解释;
	指令指针头部 = 指令指针列表;
	返回栈推入((细胞)指令指针);
	指令指针 = 指令指针头部;
}

void 出解释器(){
	指令指针头部 = 第四字典->字参数列表临时;
	指令指针 = (字 **)返回栈弹出();
	状态 = 编译;
}

void 我自己的(){
	指令指针推入(第四字典->头部,指令指针头部);
}

void 定义冒号字(){
	指令指针头部 = 第四字典->字参数列表临时;
	指令指针 = 指令指针头部;
	当前文本 = 解析字();
	字典指令下一个(第四字典,创建(当前文本,冒号字));
}

void 终冒号字(){
	指令指针推入(字典搜索名字(第四字典,"返"),指令指针头部);
	int 数量 = (细胞)指令指针 - (细胞)指令指针头部;
	做过(第四字典->头部,指令指针头部,数量);
	if(调试){
		printf("[调试]指令指针列表> ");
		字 **针 = 指令指针头部;
		for(;针 < 指令指针;针++){
			printf("%ld \n",(细胞)(*针));
		}
		printf("\n");
		展现数据栈();
	}
	指令指针头部 = 指令指针列表;
	指令指针 = 指令指针头部;
	状态 = 解释;
}

void 若(){
	指令指针推入(字典搜索名字(第四字典,"?分支"),指令指针头部);
	返回栈推入((细胞)指令指针);
	指令指针推入((字 *)0,指令指针头部);
}

void 否则(){
	指令指针推入(字典搜索名字(第四字典,"分支"),指令指针头部);
	字 **否则指针 = 指令指针;
	字 **若指针 = (字 **)(返回栈弹出());
	返回栈推入((细胞)否则指针);
	*若指针 = (字 *)(指令指针 - 若指针 + 1);
	指令指针推入((字 *)0,指令指针头部);
}

void 那么(){
	字 **分支指针 = (字 **)(返回栈弹出());
	*分支指针 = (字 *)(指令指针 - 分支指针);
}

void 流程做(){
	指令指针推入(字典搜索名字(第四字典,"(做)"),指令指针头部);
	返回栈推入((细胞)指令指针);
	指令指针推入((字 *)0,指令指针头部);
}

void 流程环(){
	指令指针推入(字典搜索名字(第四字典,"(环)"),指令指针头部);
	字 **做指针 = (字 **)(返回栈弹出());
	*做指针 = (字 *)(指令指针 - 做指针 + 1);
	指令指针推入((字 *)(指令指针 - 做指针 + 1),指令指针头部);
}

void 瞧(){
	当前文本 = 解析字();
	字 *字指针 = 字典搜索名字(第四字典,当前文本);
	if(字指针 == NULL){
		printf("%s :\n\t",当前文本);
		if(字指针->代码指针 == 冒号字){
			字 **针 = 字指针->字参数列表;
			字 *终 = 字典搜索名字(第四字典,"返");
			字 *字典指针 = 第四字典->头部;
			for(;*针 != 终;针++){
				while(字典指针 != NULL && 字典指针 != *针){
					字典指针 = 字典指针->链接;
				}
				if(字典指针 != NULL){
					printf("%s \n",(*针)->名字);
				}else{
					printf("%ld \n",(细胞)(*针));
				}
				字典指针 = 第四字典->头部;
			}
			printf(";");
			if(字指针->旗 == 立即字){
				printf("立即数 \n");
			}else{
				printf("\n");
			}
		}else{
			printf("%s\n",字指针->名字);
		}
	}
}

void 遗忘(){
	当前文本 = 解析字();
	字典余留之后(第四字典,当前文本);
}

void 变量(){
	当前文本 = 解析字();
	字典指令下一个(第四字典,创建(当前文本,变量字));
	做过(第四字典->头部,(字 **)0,0);
}

void 常量(){
	当前文本 = 解析字();
	字典指令下一个(第四字典,创建(当前文本,常量字));
	做过(第四字典->头部,(字 **)数据栈弹出(),0);
}

void 载入(){
	当前文本 = 解析字();
	载入文件(当前文本);
}

void 解释器(){
	状态 = 解释;
	文本指针 = 第四文本;
	指令指针头部 = 指令指针列表;
	指令指针 = 指令指针头部;

	while(*(当前文本 = 解析字()) != '\0'){
		if(!strcmp(".\"",当前文本)){
			打印("[调试]编译字符串 \n")
			char 临时串[缓冲长];
			while(*文本指针 != '\"'){
				sprintf(临时串,"%ld",(细胞)(*文本指针));
				找(第四字典,临时串);
				找(第四字典,"发射");
				文本指针++;
			}
			文本指针++;
		}else if(!strcmp("(",当前文本)){
			while(*文本指针 != ')'){
				文本指针++;
			}
			文本指针++;
		}else if(!找(第四字典,当前文本)){
			printf("[%s]? \n",当前文本);
			空栈();
			指令指针 = 指令指针头部;
			return;
		}
	}
}

int 载入文件(char *文件路径){
	FILE *fp;
	char 检;
	int 甲 = 0;
	int 冒号旗 = 假;
	if((fp = fopen(文件路径,"r")) == NULL){
		printf("打不开 %s \n",文件路径);
		return 0;
	}
	do{
		检 = getc(fp);
		if((检 != '\n' && 检 != EOF)
			|| (检 == '\n' && 冒号旗 == 真)){
			if(检 == ':'){
				冒号旗 = 真;
			}else if(检 == ';'){
				冒号旗 = 假;
			}
			第四文本[甲] = 检;
			甲++;
		}else if((检 == '\n' && 冒号旗 == 假)
			|| 检 == EOF){
			第四文本[甲] = '\0';
			解释器();
			甲 = 0;
		}
	}while(检 != EOF);
	
	fclose(fp);
	return 1;
}

int main(int 参计数,char *参矢量[]){
	空栈();
	指令指针头部 = 指令指针列表;
	指令指针 = 指令指针头部;
	第四字典 = 字典初始化();

	字典指令下一个(第四字典,定义核心字("(字面值)",字面值));
	字典指令下一个(第四字典,定义核心字(".",弹数据栈));
	字典指令下一个(第四字典,定义核心字("再见",再见));
	字典指令下一个(第四字典,定义核心字("返",返));
	字典指令下一个(第四字典,定义核心字("深",深));
	字典指令下一个(第四字典,定义核心字("+",加));
	字典指令下一个(第四字典,定义核心字("-",减));
	字典指令下一个(第四字典,定义核心字("*",乘));
	字典指令下一个(第四字典,定义核心字("/",除));
	字典指令下一个(第四字典,定义核心字("滴落",滴落));
	字典指令下一个(第四字典,定义核心字(".栈",展现数据栈));
	字典指令下一个(第四字典,定义核心字("摘取",摘取));
	字典指令下一个(第四字典,定义核心字("卷动",卷动));
	字典指令下一个(第四字典,定义核心字("!",入变量));
	字典指令下一个(第四字典,定义核心字("@",出变量));
	字典指令下一个(第四字典,定义核心字("=",等于));
	字典指令下一个(第四字典,定义核心字("!=",不等于));
	字典指令下一个(第四字典,定义核心字(">",大于));
	字典指令下一个(第四字典,定义核心字("<",小于));
	字典指令下一个(第四字典,定义核心字("?分支",若分支));
	字典指令下一个(第四字典,定义核心字("分支",分支));
	字典指令下一个(第四字典,定义核心字("(做事)",做事));
	字典指令下一个(第四字典,定义核心字("(环)",环));
	字典指令下一个(第四字典,定义核心字(">返",去返回栈));
	字典指令下一个(第四字典,定义核心字("返>",返回栈去));
	字典指令下一个(第四字典,定义核心字("返@",返回栈顶端出));
	字典指令下一个(第四字典,定义核心字("发射",发射));
	字典指令下一个(第四字典,定义核心字("字复数",字复数));
	字典指令下一个(第四字典,定义核心字("立即数",立即数));
	字典指令下一个(第四字典,定义核心字("编译器",编译字参数列表));
	字典指令下一个(第四字典,定义核心字(",",编译栈顶数));
	字典指令下一个(第四字典,定义核心字("'",推入数据栈字执行地址));

	字典指令下一个(第四字典,定义核心字("[",入解释器));立即数();
	字典指令下一个(第四字典,定义核心字("]",出解释器));立即数();
	字典指令下一个(第四字典,定义核心字("我自己的",我自己的));立即数();
	字典指令下一个(第四字典,定义核心字(":",定义冒号字));立即数();
	字典指令下一个(第四字典,定义核心字(";",终冒号字));立即数();
	字典指令下一个(第四字典,定义核心字("若",若));立即数();
	字典指令下一个(第四字典,定义核心字("否则",否则));立即数();
	字典指令下一个(第四字典,定义核心字("那么",那么));立即数();
	字典指令下一个(第四字典,定义核心字("做",流程做));立即数();
	字典指令下一个(第四字典,定义核心字("环",流程环));立即数();
	字典指令下一个(第四字典,定义核心字("瞧",瞧));立即数();
	字典指令下一个(第四字典,定义核心字("遗忘",遗忘));立即数();
	字典指令下一个(第四字典,定义核心字("变量",变量));立即数();
	字典指令下一个(第四字典,定义核心字("常量",常量));立即数();
	字典指令下一个(第四字典,定义核心字("载入",载入));立即数();

	for(;参计数 > 1;参计数--){
		载入文件(*++参矢量);
	}

	while(1){
		printf(">>>");
		gets(第四文本);
		解释器();
	}
	return 0;
}