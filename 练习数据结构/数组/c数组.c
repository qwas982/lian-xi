#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include "c数组.h"

void 交换(c数组 *数组,int 位置1,int 位置2);

c数组 *取c数组(int 大小){
	c数组 *数组 = (c数组 *)malloc(sizeof(c数组));
	数组 -> 数组 = (int *)malloc(sizeof(int) *大小);
	数组 -> 大小 = 大小;
	int 甲;
	for(甲 = 0;甲 < 大小;甲++){
		数组 -> 数组[甲] = 0;
	}
	return 数组;
}

int 插入值c数组(c数组 *数组,int 位置,int 值){
	if(位置 >= 0 && 位置 < 数组 -> 大小){
		if(数组 -> 数组[位置] == 0){
			数组 -> 数组[位置] =值;
			return 成功;
		}else{
			return 位置初始;
		}
	}
	return 无效位置;
}

int 移除值c数组(c数组 *数组,int 位置){
	if(位置 >= 0 && 位置 < 数组 -> 大小){
		if(数组 -> 数组[位置] != 0){
			数组 -> 数组[位置] = 0;
		}else{
			return 位置空;
		}
	}
	return 无效位置;
}

int 推值c数组(c数组 *数组,int 值){
	int 甲;
	int 好的 = 0;
	for(甲 = 0;甲 < 数组 -> 大小;甲++){
		if(数组 -> 数组[甲] == 0){
			数组 -> 数组[甲] = 值;
			好的 = 1;
			break;
		}
	}
	if(好的 == 1){
		return 成功;
	}else{
		return 数组满;
	}
}

int 更新值c数组(c数组 *数组,int 位置,int 值){
	if(位置 >= 0 && 位置 < 数组 -> 大小){
		if(数组 -> 数组[位置] != 0){

		}else{
			return 位置不初始;
		}
	}
	return 无效位置;
}

int 擦除c数组(c数组 *数组){
	int 甲;
	for(甲 = 0;甲 < 数组 -> 大小;甲++){
		数组 -> 数组[甲] = 0;
	}
	return 0;
}

int 切换值c数组(c数组 *数组,int 位置1,int 位置2){
	if(位置1 >= 0 && 位置1 < 数组 -> 大小 && 位置2 >= 0 && 位置2 < 数组 -> 大小){
		int 临时 = 数组 -> 数组[位置1];
		数组 -> 数组[位置1] = 数组 -> 数组[位置2];
		数组 -> 数组[位置2] = 临时;
	}
	return 无效位置; 
}

int 逆向c数组(c数组 *数组){
	int 甲;
	for(甲 = 0;甲 < 数组 -> 大小 / 2;甲++){
		交换(数组,甲,数组 -> 大小 - 甲 - 1);
	}
	return 成功;
}

int 显示c数组(c数组 *数组){
	int 甲;
	printf("\n c数组 \n");
	for(甲 = 0;甲 < 数组 -> 大小;甲++){
		printf("%d",数组 -> 数组[甲]);
	}
	printf("\n");
	return 0;
}

int 混合排序c数组(c数组 *数组){
	srand(time(NULL) * 数组 -> 大小);
	int 甲;
	int 总共 = 数组 -> 大小 * 100;
	for(甲 = 0;甲 < 总共;甲++){
		交换(数组,rand() % 数组 -> 大小, rand() % 数组 -> 大小);
	}
	return 0;
}

c数组 *取复制c数组(c数组 *小数组){
	c数组 *数组 = (c数组 *)malloc(sizeof(c数组));
	数组 -> 数组 = (int *)malloc(sizeof(int)* 小数组 -> 大小);
	数组 -> 大小 = 小数组 -> 大小;
	int 甲;
	for(甲 = 0;甲 < 小数组 -> 大小;甲++){
		数组 -> 数组[甲] = 小数组 -> 数组[甲];
	}
	return 数组;
}

void 交换(c数组 *数组,int 位置1,int 位置2){
	int 临时 = 数组 -> 数组[位置1];
	数组 -> 数组[位置1] = 数组 -> 数组[位置2];
	数组 -> 数组[位置2] = 临时;
}

int 冒泡排序c数组(c数组 *数组){
	int 甲,乙;
	for(甲 = 0;甲 < 数组 -> 大小 - 1;甲++){
		for(乙 = 0;乙 < 数组 -> 大小 - 甲 - 1;乙++){
			if(数组 -> 数组[乙] > 数组 -> 数组[乙 + 1]){
				交换(数组,乙,乙 + 1);
			}
		}
	}
	return 0;
}

int 选择排序c数组(c数组 *数组){
	int 甲,乙,最小;
	for(甲 = 0;甲 < 数组 -> 大小 -1;甲++){
		最小 = 甲;
		for(乙 = 甲 + 1;乙 < 数组 -> 大小;乙++){
			if(数组 -> 数组[乙] < 数组 -> 数组[最小]){
				最小 = 乙;
			}
		}
		交换(数组,最小,甲);
	}
	return 0;
}

int 插入排序c数组(c数组 *数组){
	int 甲, 乙, 号码;
	for(甲 = 1;甲 < 数组 -> 大小;甲++){
		号码 = 数组 -> 数组[甲];
		乙 = 甲 - 1;
		while(乙 >= 0 && 数组 -> 数组[乙] > 号码){
			数组 -> 数组[乙 + 1] = 数组 -> 数组[乙];
			乙--;
		}
		数组 -> 数组[乙 + 1] = 号码;
	}
	return 0;
}

int 值杂狗支撑c数组(c数组 *数组,int 值){
	int 甲, 总共 = 0;
	for(甲 = 0;甲 < 数组 -> 大小;甲++){
		if(数组 -> 数组[甲] == 值){
			总共++;
		}
	}
	return 总共;
}

c数组 *值位置c数组(c数组 *数组,int 值){
	int 甲, 乙 = 0;
	int 总共 = 值杂狗支撑c数组(数组,值);
	c数组 *结果数组 = 取c数组(总共);
	for(甲 = 0;甲 < 数组 -> 大小;甲++){
		if(数组 -> 数组[甲] == 值){
			结果数组 -> 数组[乙] = 甲;
			乙++;
		}
	}
	return 结果数组;
}

int 找最小c数组(c数组 *数组){
	int 甲;
	int 最小 = 数组 -> 数组[0];
	for(甲 = 1;甲 < 数组 -> 大小;甲++){
		if(数组 -> 数组[甲] < 最小){
			最小 = 数组 -> 数组[甲];
		}
	}
	return 最小;
}

int 找最大c数组(c数组 *数组){
	int 甲;
	int 最大 = 数组 -> 数组[0];
	for(甲 = 1;甲 < 数组 -> 大小;甲++){
		if(数组 -> 数组[甲] > 最大){
			最大 = 数组 -> 数组[甲];
		}
	}
	return 最大;
}