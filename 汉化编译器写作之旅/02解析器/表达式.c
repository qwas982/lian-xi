#include "定义.h"
#include "数据.h"
#include "声明.h"

//解析表达式
//解析一个基元因子与返回一个抽象句法树节点代表它
static struct 抽象句法树节点 *基元(void){
	struct 抽象句法树节点 *个数;
	//为一个 整型字面 牌,制作一个叶抽象句法树节点为它
	//还要扫描下一个牌.另外,一个句法错误为任意其它牌类型.
	switch (大牌.牌){
		case 牌名_整型字面:
			个数 = 制作抽象句法树叶(抽象_整型字面,大牌.整型值);
			扫描(&大牌);
			return (个数);
		default:
			fprintf(stderr,"句法错误在行 %d\n",行);
			exit(1);
	}
}
//转换一个牌进到一个抽象句法树操作
int 算术操作(int 牌){
	switch (牌){
		case 牌名_加:
			return (抽象_加法);
		case 牌名_减:
			return (抽象_减法);
		case 牌名_星:
			return (抽象_乘法);
		case 牌名_斜杠:
			return (抽象_除法);
		default:
			fprintf(stderr,"未知牌在 算术操作()内 在行 %d\n",行);
			exit(1);
	}
}
//返回一个抽象句法树的树哪个的根是个二元操作
struct 抽象句法树节点 *二元表达式(void){
	struct 抽象句法树节点 *个数,*左,*右;
	int 节点类型;
	//取左边的整数字面.
	//拾取下一个牌在同一时间.
	左 = 基元();

	//若左边无牌,返回仅左节点
	if(大牌.牌 == 牌名_文件终)
		return (左);

	//转换此牌进到一个节点类型
	节点类型 = 算术操作(大牌.牌);

	//取下一个牌进入
	扫描(&大牌);

	//递归地取此右手边树
	右 = 二元表达式();

	//现在建造一棵树和子树一起
	个数 = 制作抽象句法树节点(节点类型,左,右,0);
	return (个数);
}