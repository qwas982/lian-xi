#include "定义.h"
#include "数据.h"
#include "声明.h"

//解析表达式和完全递归下降一起,
//解析一个基元因子与返回
//一个抽象句法树节点代表它.
static struct 抽象句法树节点 *基元(void){
	struct 抽象句法树节点 *个数;

	//为 整型字面 牌,为它制作一个叶抽象句法树节点,
	//与扫描下一个牌,另外,一个句法错误为任意其它牌类型,
	switch(大牌.牌){
		case 牌名_整型字面:
			个数 = 制作抽象句法树叶(抽象_整型字面,大牌.整型值);
			扫描(&大牌);
			return (个数);
		default:
			fprintf(stderr,"句法错误在行 %d,牌 %d\n",行,大牌.牌);
			exit(1);
	}
}

//转换一个二元操作牌进到一个抽象句法树操作.
static int 算术操作(int 牌){
	switch(牌){
		case 牌名_加:
			return (抽象_加法);
		case 牌名_减:
			return (抽象_减法);
		case 牌名_星:
			return (抽象_乘法);
		case 牌名_斜杠:
			return (抽象_除法);
		default:
			fprintf(stderr,"句法错误在行 %d,牌 %d\n",行,牌);
			exit(1);
	}
}

struct 抽象句法树节点 *加法性_表达式(void);

//返回一个抽象句法树的树,其根是'*'或'/'二元操作,
struct 抽象句法树节点 *乘法性_表达式(void){
	struct 抽象句法树节点 *左,*右;
	int 牌类型;

	//取其整数字面在其左,
	//拾取其下一个牌在同时,
	左 = 基元();

	//若左无牌,仅返回其左节点,
	牌类型 = 大牌.牌;
	if(牌类型 == 牌名_文件终)
		return (左);

	//其牌是一个'*'或'/'就循环
	while((牌类型 == 牌名_星) || (牌类型 == 牌名_斜杠)){
		//拾取其下一个整数字面
		扫描(&大牌);
		右 = 基元();

		//加入这个和其左整数字面一起
		左 = 制作抽象句法树节点(算术操作(牌类型),左,右,0);

		//更新其当前牌的细节
		//若左无牌,仅返回其左节点,
		牌类型 = 大牌.牌;
		if(牌类型 == 牌名_文件终)
			break;
	}

	//返回无论什么树我们有已创建,
	return (左);
}

//返回一个抽象句法树的树,其根是'+'或'-'二元操作,
struct 抽象句法树节点 *加法性_表达式(void){
	struct 抽象句法树节点 *左,*右;
	int 牌类型;

	//取其左子树位于比我们更高优先级,
	左 = 乘法性_表达式();

	//若左无牌,仅返回其左节点,
	牌类型 = 大牌.牌;
	if(牌类型 == 牌名_文件终)
		return (左);

	//缓存其 '+'或'-'牌类型,
	//循环工作在我们等级优先级的牌上,
	while(1){
		//拾取其下一个整数字面
		扫描(&大牌);

		//取其右子树位于比我们高的优先级处,
		右 = 乘法性_表达式();

		//加入其俩子树和我们的低优先级操作一起,
		左 = 制作抽象句法树节点(算术操作(牌类型),左,右,0);

		//取其下一个牌位于我们的优先级
		牌类型 = 大牌.牌;
		if(牌类型 == 牌名_文件终)
			break;
	}

	//返回无论什么树我们有已创建,
	return (左);
}

struct 抽象句法树节点 *二元表达式(int 个数){
	return (加法性_表达式());
}