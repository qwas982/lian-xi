/**
 * 数据结构.c
 * WebAssembly 核心数据结构操作实现
 */

#include <stdlib.h>
#include <string.h>
#include "数据结构.h"

/* ==================== 栈值操作 ==================== */

结构_栈值 创建栈值(uint8_t 值类型, 联合体_值 值) {
    结构_栈值 栈值;
    栈值.值类型 = 值类型;
    栈值.值 = 值;
    return 栈值;
}

结构_栈值 创建栈值_整数32(int32_t 值) {
    结构_栈值 栈值;
    栈值.值类型 = 值类型_整数32;
    栈值.值.整数32 = 值;
    return 栈值;
}

结构_栈值 创建栈值_整数64(int64_t 值) {
    结构_栈值 栈值;
    栈值.值类型 = 值类型_整数64;
    栈值.值.整数64 = 值;
    return 栈值;
}

结构_栈值 创建栈值_单精度浮点(float 值) {
    结构_栈值 栈值;
    栈值.值类型 = 值类型_单精度浮点;
    栈值.值.单精度浮点 = 值;
    return 栈值;
}

结构_栈值 创建栈值_双精度浮点(double 值) {
    结构_栈值 栈值;
    栈值.值类型 = 值类型_双精度浮点;
    栈值.值.双精度浮点 = 值;
    return 栈值;
}

/* ==================== 模块操作 ==================== */

结构_模块* 创建模块(uint8_t* 字节码, uint32_t 字节数) {
    结构_模块* 模块 = (结构_模块*)malloc(sizeof(结构_模块));
    if (模块 == NULL) {
        return NULL;
    }
    
    /* 清零 */
    memset(模块, 0, sizeof(结构_模块));
    
    /* 复制字节码 */
    模块->字节码 = (uint8_t*)malloc(字节数);
    if (模块->字节码 == NULL) {
        free(模块);
        return NULL;
    }
    memcpy(模块->字节码, 字节码, 字节数);
    模块->字节数 = 字节数;
    
    /* 初始化默认值 */
    模块->起始函数索引 = -1;
    模块->操作数栈指针 = -1;
    模块->帧指针 = -1;
    模块->块栈指针 = -1;
    
    /* 设置默认栈大小 */
    模块->操作数栈大小 = 默认操作数栈大小;
    模块->调用栈大小 = 默认调用栈大小;
    模块->块栈大小 = 默认块栈大小;
    模块->分支表大小 = 默认分支表大小;
    
    return 模块;
}

void 销毁模块(结构_模块* 模块) {
    uint32_t i;
    
    if (模块 == NULL) {
        return;
    }
    
    /* 释放字节码 */
    if (模块->字节码 != NULL) {
        free(模块->字节码);
    }
    
    /* 释放类型列表 */
    if (模块->类型列表 != NULL) {
        for (i = 0; i < 模块->类型数; i++) {
            if (模块->类型列表[i].参数类型 != NULL) {
                free(模块->类型列表[i].参数类型);
            }
            if (模块->类型列表[i].返回类型 != NULL) {
                free(模块->类型列表[i].返回类型);
            }
        }
        free(模块->类型列表);
    }
    
    /* 释放函数列表 */
    if (模块->函数列表 != NULL) {
        for (i = 0; i < 模块->函数数; i++) {
            if (模块->函数列表[i].局部变量类型 != NULL) {
                free(模块->函数列表[i].局部变量类型);
            }
        }
        free(模块->函数列表);
    }
    
    /* 释放表 */
    if (模块->表 != NULL) {
        销毁表(模块->表);
    }
    
    /* 释放内存 */
    if (模块->内存 != NULL) {
        销毁内存(模块->内存);
    }
    
    /* 释放全局变量列表 */
    if (模块->全局变量列表 != NULL) {
        free(模块->全局变量列表);
    }
    
    /* 释放导出列表 */
    if (模块->导出列表 != NULL) {
        for (i = 0; i < 模块->导出项数; i++) {
            if (模块->导出列表[i].名称 != NULL) {
                free(模块->导出列表[i].名称);
            }
        }
        free(模块->导出列表);
    }
    
    /* 释放数据段列表 */
    if (模块->数据段列表 != NULL) {
        for (i = 0; i < 模块->数据段数; i++) {
            if (模块->数据段列表[i].数据 != NULL) {
                free(模块->数据段列表[i].数据);
            }
        }
        free(模块->数据段列表);
    }
    
    /* 释放元素段列表 */
    if (模块->元素段列表 != NULL) {
        for (i = 0; i < 模块->元素段数; i++) {
            if (模块->元素段列表[i].函数索引列表 != NULL) {
                free(模块->元素段列表[i].函数索引列表);
            }
        }
        free(模块->元素段列表);
    }
    
    /* 释放导入列表 */
    if (模块->导入列表 != NULL) {
        for (i = 0; i < 模块->导入项数; i++) {
            if (模块->导入列表[i].模块名 != NULL) {
                free(模块->导入列表[i].模块名);
            }
            if (模块->导入列表[i].字段名 != NULL) {
                free(模块->导入列表[i].字段名);
            }
        }
        free(模块->导入列表);
    }
    
    /* 释放运行时栈 */
    if (模块->操作数栈 != NULL) {
        free(模块->操作数栈);
    }
    if (模块->调用栈 != NULL) {
        free(模块->调用栈);
    }
    if (模块->块栈 != NULL) {
        free(模块->块栈);
    }
    if (模块->分支表 != NULL) {
        free(模块->分支表);
    }
    
    free(模块);
}

int 初始化模块运行时(结构_模块* 模块) {
    /* 分配操作数栈 */
    模块->操作数栈 = (结构_栈值*)malloc(sizeof(结构_栈值) * 模块->操作数栈大小);
    if (模块->操作数栈 == NULL) {
        return 错误码_内存不足;
    }
    
    /* 分配调用栈 */
    模块->调用栈 = (结构_栈帧*)malloc(sizeof(结构_栈帧) * 模块->调用栈大小);
    if (模块->调用栈 == NULL) {
        return 错误码_内存不足;
    }
    
    /* 分配块栈 */
    模块->块栈 = (结构_控制块*)malloc(sizeof(结构_控制块) * 模块->块栈大小);
    if (模块->块栈 == NULL) {
        return 错误码_内存不足;
    }
    
    /* 分配分支表 */
    模块->分支表 = (uint32_t*)malloc(sizeof(uint32_t) * 模块->分支表大小);
    if (模块->分支表 == NULL) {
        return 错误码_内存不足;
    }
    
    /* 重置栈指针 */
    模块->操作数栈指针 = -1;
    模块->帧指针 = -1;
    模块->块栈指针 = -1;
    模块->程序计数器 = 0;
    
    return 错误码_成功;
}

/* ==================== 操作数栈操作 ==================== */

int 压入操作数(结构_模块* 模块, 结构_栈值 值) {
    if (模块->操作数栈指针 + 1 >= (int32_t)模块->操作数栈大小) {
        return 错误码_栈溢出;
    }
    
    模块->操作数栈指针++;
    模块->操作数栈[模块->操作数栈指针] = 值;
    return 错误码_成功;
}

int 弹出操作数(结构_模块* 模块, 结构_栈值* 输出) {
    if (模块->操作数栈指针 < 0) {
        return 错误码_栈下溢;
    }
    
    *输出 = 模块->操作数栈[模块->操作数栈指针];
    模块->操作数栈指针--;
    return 错误码_成功;
}

int 查看栈顶(结构_模块* 模块, 结构_栈值* 输出) {
    if (模块->操作数栈指针 < 0) {
        return 错误码_栈下溢;
    }
    
    *输出 = 模块->操作数栈[模块->操作数栈指针];
    return 错误码_成功;
}

int 查看栈顶偏移(结构_模块* 模块, int32_t 偏移, 结构_栈值* 输出) {
    int32_t 索引 = 模块->操作数栈指针 - 偏移;
    
    if (索引 < 0) {
        return 错误码_栈下溢;
    }
    
    *输出 = 模块->操作数栈[索引];
    return 错误码_成功;
}

/* ==================== 调用栈操作 ==================== */

int 压入帧(结构_模块* 模块, 结构_栈帧 帧) {
    if (模块->帧指针 + 1 >= (int32_t)模块->调用栈大小) {
        return 错误码_调用栈溢出;
    }
    
    模块->帧指针++;
    模块->调用栈[模块->帧指针] = 帧;
    return 错误码_成功;
}

int 弹出帧(结构_模块* 模块, 结构_栈帧* 输出) {
    if (模块->帧指针 < 0) {
        return 错误码_调用栈下溢;
    }
    
    *输出 = 模块->调用栈[模块->帧指针];
    模块->帧指针--;
    return 错误码_成功;
}

结构_栈帧* 获取当前帧(结构_模块* 模块) {
    if (模块->帧指针 < 0) {
        return NULL;
    }
    return &(模块->调用栈[模块->帧指针]);
}

/* ==================== 块栈操作 ==================== */

int 压入块(结构_模块* 模块, 结构_控制块 块) {
    if (模块->块栈指针 + 1 >= (int32_t)模块->块栈大小) {
        return 错误码_块栈溢出;
    }
    
    模块->块栈指针++;
    模块->块栈[模块->块栈指针] = 块;
    return 错误码_成功;
}

int 弹出块(结构_模块* 模块, 结构_控制块* 输出) {
    if (模块->块栈指针 < 0) {
        return 错误码_块栈下溢;
    }
    
    *输出 = 模块->块栈[模块->块栈指针];
    模块->块栈指针--;
    return 错误码_成功;
}

结构_控制块* 获取当前块(结构_模块* 模块) {
    if (模块->块栈指针 < 0) {
        return NULL;
    }
    return &(模块->块栈[模块->块栈指针]);
}

/* ==================== 内存操作 ==================== */

结构_内存* 创建内存(uint32_t 初始页数, uint32_t 最大页数) {
    结构_内存* 内存 = (结构_内存*)malloc(sizeof(结构_内存));
    if (内存 == NULL) {
        return NULL;
    }
    
    内存->初始页数 = 初始页数;
    内存->最大页数 = 最大页数;
    内存->当前页数 = 初始页数;
    内存->数据大小 = 初始页数 * 每页字节数;
    
    内存->数据 = (uint8_t*)malloc(内存->数据大小);
    if (内存->数据 == NULL) {
        free(内存);
        return NULL;
    }
    
    memset(内存->数据, 0, 内存->数据大小);
    return 内存;
}

void 销毁内存(结构_内存* 内存) {
    if (内存 == NULL) {
        return;
    }
    
    if (内存->数据 != NULL) {
        free(内存->数据);
    }
    
    free(内存);
}

int 内存增长(结构_内存* 内存, uint32_t 增量页数) {
    uint32_t 新页数;
    uint32_t 新大小;
    uint8_t* 新数据;
    
    新页数 = 内存->当前页数 + 增量页数;
    
    /* 检查最大页数限制 */
    if (新页数 > 内存->最大页数) {
        return -1;
    }
    
    新大小 = 新页数 * 每页字节数;
    新数据 = (uint8_t*)realloc(内存->数据, 新大小);
    
    if (新数据 == NULL) {
        return -1;
    }
    
    /* 清零新分配的内存 */
    memset(新数据 + 内存->数据大小, 0, 新大小 - 内存->数据大小);
    
    内存->数据 = 新数据;
    内存->当前页数 = 新页数;
    内存->数据大小 = 新大小;
    
    return 0;
}

/* ==================== 表操作 ==================== */

结构_表* 创建表(uint32_t 初始大小, uint32_t 最大大小) {
    结构_表* 表 = (结构_表*)malloc(sizeof(结构_表));
    if (表 == NULL) {
        return NULL;
    }
    
    表->初始大小 = 初始大小;
    表->最大大小 = 最大大小;
    表->当前大小 = 初始大小;
    
    表->元素 = (uint32_t*)malloc(sizeof(uint32_t) * 初始大小);
    if (表->元素 == NULL) {
        free(表);
        return NULL;
    }
    
    /* 初始化为无效索引 */
    memset(表->元素, 0xFF, sizeof(uint32_t) * 初始大小);
    
    return 表;
}

void 销毁表(结构_表* 表) {
    if (表 == NULL) {
        return;
    }
    
    if (表->元素 != NULL) {
        free(表->元素);
    }
    
    free(表);
}

/* ==================== 字节码读取 ==================== */

uint8_t 读取字节(结构_模块* 模块) {
    uint8_t 字节;
    
    if (模块->程序计数器 >= 模块->字节数) {
        return 0;
    }
    
    字节 = 模块->字节码[模块->程序计数器];
    模块->程序计数器++;
    return 字节;
}

int32_t 读取有符号32位(结构_模块* 模块) {
    int32_t 值;
    
    if (模块->程序计数器 + 4 > 模块->字节数) {
        return 0;
    }
    
    /* 小端序读取 */
    值 = (int32_t)(模块->字节码[模块->程序计数器] |
                   (模块->字节码[模块->程序计数器 + 1] << 8) |
                   (模块->字节码[模块->程序计数器 + 2] << 16) |
                   (模块->字节码[模块->程序计数器 + 3] << 24));
    
    模块->程序计数器 += 4;
    return 值;
}

uint32_t 读取无符号32位(结构_模块* 模块) {
    return (uint32_t)读取有符号32位(模块);
}

int64_t 读取有符号64位(结构_模块* 模块) {
    int64_t 值;
    uint32_t 低32位, 高32位;
    
    if (模块->程序计数器 + 8 > 模块->字节数) {
        return 0;
    }
    
    /* 小端序读取 */
    低32位 = (uint32_t)(模块->字节码[模块->程序计数器] |
                       (模块->字节码[模块->程序计数器 + 1] << 8) |
                       (模块->字节码[模块->程序计数器 + 2] << 16) |
                       (模块->字节码[模块->程序计数器 + 3] << 24));
    
    高32位 = (uint32_t)(模块->字节码[模块->程序计数器 + 4] |
                       (模块->字节码[模块->程序计数器 + 5] << 8) |
                       (模块->字节码[模块->程序计数器 + 6] << 16) |
                       (模块->字节码[模块->程序计数器 + 7] << 24));
    
    值 = ((int64_t)高32位 << 32) | (int64_t)低32位;
    
    模块->程序计数器 += 8;
    return 值;
}

float 读取单精度浮点(结构_模块* 模块) {
    union {
        uint32_t 整数;
        float 浮点;
    } 转换;
    
    转换.整数 = 读取无符号32位(模块);
    return 转换.浮点;
}

double 读取双精度浮点(结构_模块* 模块) {
    union {
        uint64_t 整数;
        double 浮点;
    } 转换;
    
    转换.整数 = (uint64_t)读取有符号64位(模块);
    return 转换.浮点;
}
