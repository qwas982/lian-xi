/**
 * 模块加载器.c
 * WebAssembly 模块加载器实现
 * 解析Wasm二进制格式
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "模块加载器.h"
#include "工具函数.h"

/* 模块加载器上下文 */
struct 加载器上下文 {
    uint8_t* 字节码;
    uint32_t 字节数;
    uint32_t 偏移;
    结构_模块* 模块;
};

typedef struct 加载器上下文 加载器上下文;

/* 内部函数声明 */
static int 验证头部(加载器上下文* 上下文);
static int 解析段(加载器上下文* 上下文);
static int 解析类型段(加载器上下文* 上下文);
static int 解析导入段(加载器上下文* 上下文);
static int 解析函数段(加载器上下文* 上下文);
static int 解析表段(加载器上下文* 上下文);
static int 解析内存段(加载器上下文* 上下文);
static int 解析全局段(加载器上下文* 上下文);
static int 解析导出段(加载器上下文* 上下文);
static int 解析起始段(加载器上下文* 上下文);
static int 解析元素段(加载器上下文* 上下文);
static int 解析代码段(加载器上下文* 上下文);
static int 解析数据段(加载器上下文* 上下文);
static int32_t 解析初始化表达式(加载器上下文* 上下文);

static uint8_t 读取字节(加载器上下文* 上下文);
static uint32_t 读取字符串(加载器上下文* 上下文, char** 输出);
static uint8_t 读取值类型(加载器上下文* 上下文);

/* ==================== 主加载函数 ==================== */

结构_模块* 加载模块(uint8_t* 字节码, uint32_t 字节数) {
    加载器上下文 上下文;
    结构_模块* 模块;
    int 结果;
    
    /* 创建模块 */
    模块 = 创建模块(字节码, 字节数);
    if (模块 == NULL) {
        return NULL;
    }
    
    /* 初始化上下文 */
    上下文.字节码 = 模块->字节码;
    上下文.字节数 = 模块->字节数;
    上下文.偏移 = 0;
    上下文.模块 = 模块;
    
    /* 验证头部 */
    结果 = 验证头部(&上下文);
    if (结果 != 错误码_成功) {
        销毁模块(模块);
        return NULL;
    }
    
    /* 解析各个段 */
    while (上下文.偏移 < 上下文.字节数) {
        结果 = 解析段(&上下文);
        if (结果 != 错误码_成功) {
            销毁模块(模块);
            return NULL;
        }
    }
    
    /* 初始化运行时 */
    结果 = 初始化模块运行时(模块);
    if (结果 != 错误码_成功) {
        销毁模块(模块);
        return NULL;
    }
    
    return 模块;
}

结构_模块* 从文件加载模块(const char* 文件路径) {
    FILE* 文件;
    uint8_t* 字节码;
    uint32_t 字节数;
    结构_模块* 模块;
    
    文件 = fopen(文件路径, "rb");
    if (文件 == NULL) {
        return NULL;
    }
    
    /* 获取文件大小 */
    fseek(文件, 0, SEEK_END);
    字节数 = (uint32_t)ftell(文件);
    fseek(文件, 0, SEEK_SET);
    
    /* 分配内存 */
    字节码 = (uint8_t*)malloc(字节数);
    if (字节码 == NULL) {
        fclose(文件);
        return NULL;
    }
    
    /* 读取文件 */
    if (fread(字节码, 1, 字节数, 文件) != 字节数) {
        free(字节码);
        fclose(文件);
        return NULL;
    }
    
    fclose(文件);
    
    /* 加载模块 */
    模块 = 加载模块(字节码, 字节数);
    
    /* 释放临时字节码（模块已复制） */
    free(字节码);
    
    return 模块;
}

/* ==================== 内部函数实现 ==================== */

static int 验证头部(加载器上下文* 上下文) {
    /* 检查魔数: 0x00 0x61 0x73 0x6D ("\0asm") */
    if (上下文.偏移 + 8 > 上下文.字节数) {
        return 错误码_无效魔数;
    }
    
    if (上下文.字节码[0] != WASM魔数_0 ||
        上下文.字节码[1] != WASM魔数_1 ||
        上下文.字节码[2] != WASM魔数_2 ||
        上下文.字节码[3] != WASM魔数_3) {
        return 错误码_无效魔数;
    }
    
    /* 检查版本: 1 */
    if (读取小端32位(&上下文.字节码[4]) != WASM版本) {
        return 错误码_无效版本;
    }
    
    上下文.偏移 = 8;
    return 错误码_成功;
}

static int 解析段(加载器上下文* 上下文) {
    uint8_t 段类型;
    uint32_t 段长度;
    uint32_t 段结束;
    int 结果;
    
    /* 读取段类型 */
    段类型 = 读取字节(上下文);
    
    /* 读取段长度 */
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &段长度);
    段结束 = 上下文.偏移 + 段长度;
    
    switch (段类型) {
        case 段类型_自定义段:
            /* 跳过自定义段 */
            上下文.偏移 = 段结束;
            结果 = 错误码_成功;
            break;
        case 段类型_类型段:
            结果 = 解析类型段(上下文);
            break;
        case 段类型_导入段:
            结果 = 解析导入段(上下文);
            break;
        case 段类型_函数段:
            结果 = 解析函数段(上下文);
            break;
        case 段类型_表段:
            结果 = 解析表段(上下文);
            break;
        case 段类型_内存段:
            结果 = 解析内存段(上下文);
            break;
        case 段类型_全局段:
            结果 = 解析全局段(上下文);
            break;
        case 段类型_导出段:
            结果 = 解析导出段(上下文);
            break;
        case 段类型_起始段:
            结果 = 解析起始段(上下文);
            break;
        case 段类型_元素段:
            结果 = 解析元素段(上下文);
            break;
        case 段类型_代码段:
            结果 = 解析代码段(上下文);
            break;
        case 段类型_数据段:
            结果 = 解析数据段(上下文);
            break;
        default:
            return 错误码_无效段;
    }
    
    /* 确保偏移正确 */
    上下文.偏移 = 段结束;
    return 结果;
}

static int 解析类型段(加载器上下文* 上下文) {
    uint32_t 类型数;
    uint32_t i, j;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &类型数);
    
    上下文.模块->类型数 = 类型数;
    上下文.模块->类型列表 = (结构_函数类型*)malloc(sizeof(结构_函数类型) * 类型数);
    if (上下文.模块->类型列表 == NULL) {
        return 错误码_内存不足;
    }
    
    for (i = 0; i < 类型数; i++) {
        uint8_t 形式;
        uint32_t 参数数, 返回数;
        
        /* 检查形式 (必须是0x60) */
        形式 = 读取字节(上下文);
        if (形式 != 0x60) {
            return 错误码_无效类型;
        }
        
        /* 读取参数类型 */
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &参数数);
        上下文.模块->类型列表[i].参数数 = 参数数;
        上下文.模块->类型列表[i].参数类型 = (uint8_t*)malloc(参数数);
        if (参数数 > 0 && 上下文.模块->类型列表[i].参数类型 == NULL) {
            return 错误码_内存不足;
        }
        for (j = 0; j < 参数数; j++) {
            上下文.模块->类型列表[i].参数类型[j] = 读取值类型(上下文);
        }
        
        /* 读取返回类型 */
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &返回数);
        上下文.模块->类型列表[i].返回数 = 返回数;
        上下文.模块->类型列表[i].返回类型 = (uint8_t*)malloc(返回数);
        if (返回数 > 0 && 上下文.模块->类型列表[i].返回类型 == NULL) {
            return 错误码_内存不足;
        }
        for (j = 0; j < 返回数; j++) {
            上下文.模块->类型列表[i].返回类型[j] = 读取值类型(上下文);
        }
    }
    
    return 错误码_成功;
}

static int 解析导入段(加载器上下文* 上下文) {
    uint32_t 导入数;
    uint32_t i;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &导入数);
    
    上下文.模块->导入项数 = 导入数;
    上下文.模块->导入列表 = (结构_导入项*)malloc(sizeof(结构_导入项) * 导入数);
    if (上下文.模块->导入列表 == NULL) {
        return 错误码_内存不足;
    }
    
    for (i = 0; i < 导入数; i++) {
        uint8_t 导入类型;
        
        /* 读取模块名和字段名 */
        上下文.偏移 = 读取字符串(上下文, &上下文.模块->导入列表[i].模块名);
        上下文.偏移 = 读取字符串(上下文, &上下文.模块->导入列表[i].字段名);
        
        /* 读取导入类型 */
        导入类型 = 读取字节(上下文);
        上下文.模块->导入列表[i].导入类型 = 导入类型;
        
        switch (导入类型) {
            case 导出类型_函数导出:
                上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, 
                    &上下文.模块->导入列表[i].索引);
                上下文.模块->导入函数数++;
                break;
            case 导出类型_表导出:
                /* 跳过元素类型 */
                读取字节(上下文);
                /* 读取限制 */
                {
                    uint8_t 标志 = 读取字节(上下文);
                    uint32_t 初始大小, 最大大小;
                    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &初始大小);
                    if (标志 != 0) {
                        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &最大大小);
                    } else {
                        最大大小 = 初始大小;
                    }
                    上下文.模块->表 = 创建表(初始大小, 最大大小);
                }
                break;
            case 导出类型_内存导出:
                /* 读取限制 */
                {
                    uint8_t 标志 = 读取字节(上下文);
                    uint32_t 初始页数, 最大页数;
                    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &初始页数);
                    if (标志 != 0) {
                        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &最大页数);
                    } else {
                        最大页数 = 初始页数;
                    }
                    上下文.模块->内存 = 创建内存(初始页数, 最大页数);
                }
                break;
            case 导出类型_全局导出:
                /* 读取值类型和可变性 */
                {
                    uint8_t 值类型 = 读取值类型(上下文);
                    uint8_t 可变性 = 读取字节(上下文);
                    /* 全局初始化将在全局段处理 */
                    上下文.模块->导入列表[i].索引 = 值类型;
                }
                break;
        }
    }
    
    return 错误码_成功;
}

static int 解析函数段(加载器上下文* 上下文) {
    uint32_t 函数数;
    uint32_t i;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &函数数);
    
    上下文.模块->函数数 = 函数数;
    上下文.模块->函数列表 = (结构_函数*)malloc(sizeof(结构_函数) * 函数数);
    if (上下文.模块->函数列表 == NULL) {
        return 错误码_内存不足;
    }
    memset(上下文.模块->函数列表, 0, sizeof(结构_函数) * 函数数);
    
    for (i = 0; i < 函数数; i++) {
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, 
            &上下文.模块->函数列表[i].类型索引);
    }
    
    return 错误码_成功;
}

static int 解析表段(加载器上下文* 上下文) {
    uint32_t 表数;
    uint32_t i;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &表数);
    
    for (i = 0; i < 表数; i++) {
        uint8_t 元素类型, 标志;
        uint32_t 初始大小, 最大大小;
        
        元素类型 = 读取字节(上下文);
        标志 = 读取字节(上下文);
        
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &初始大小);
        if (标志 != 0) {
            上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &最大大小);
        } else {
            最大大小 = 初始大小;
        }
        
        上下文.模块->表 = 创建表(初始大小, 最大大小);
    }
    
    return 错误码_成功;
}

static int 解析内存段(加载器上下文* 上下文) {
    uint32_t 内存数;
    uint32_t i;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &内存数);
    
    for (i = 0; i < 内存数; i++) {
        uint8_t 标志;
        uint32_t 初始页数, 最大页数;
        
        标志 = 读取字节(上下文);
        
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &初始页数);
        if (标志 != 0) {
            上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &最大页数);
        } else {
            最大页数 = 初始页数;
        }
        
        上下文.模块->内存 = 创建内存(初始页数, 最大页数);
    }
    
    return 错误码_成功;
}

static int 解析全局段(加载器上下文* 上下文) {
    uint32_t 全局数;
    uint32_t i;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &全局数);
    
    上下文.模块->全局变量数 = 全局数;
    上下文.模块->全局变量列表 = (结构_全局变量*)malloc(sizeof(结构_全局变量) * 全局数);
    if (上下文.模块->全局变量列表 == NULL) {
        return 错误码_内存不足;
    }
    
    for (i = 0; i < 全局数; i++) {
        uint8_t 值类型, 可变性;
        int32_t 初始值;
        
        值类型 = 读取值类型(上下文);
        可变性 = 读取字节(上下文);
        
        上下文.模块->全局变量列表[i].值类型 = 值类型;
        上下文.模块->全局变量列表[i].可变 = 可变性;
        
        /* 解析初始化表达式 */
        初始值 = 解析初始化表达式(上下文);
        上下文.模块->全局变量列表[i].值.整数32 = 初始值;
    }
    
    return 错误码_成功;
}

static int 解析导出段(加载器上下文* 上下文) {
    uint32_t 导出数;
    uint32_t i;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &导出数);
    
    上下文.模块->导出项数 = 导出数;
    上下文.模块->导出列表 = (结构_导出项*)malloc(sizeof(结构_导出项) * 导出数);
    if (上下文.模块->导出列表 == NULL) {
        return 错误码_内存不足;
    }
    
    for (i = 0; i < 导出数; i++) {
        上下文.偏移 = 读取字符串(上下文, &上下文.模块->导出列表[i].名称);
        上下文.模块->导出列表[i].导出类型 = 读取字节(上下文);
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, 
            &上下文.模块->导出列表[i].索引);
    }
    
    return 错误码_成功;
}

static int 解析起始段(加载器上下文* 上下文) {
    uint32_t 函数索引;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &函数索引);
    上下文.模块->起始函数索引 = (int32_t)函数索引;
    
    return 错误码_成功;
}

static int 解析元素段(加载器上下文* 上下文) {
    uint32_t 元素数;
    uint32_t i, j;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &元素数);
    
    上下文.模块->元素段数 = 元素数;
    上下文.模块->元素段列表 = (结构_元素段*)malloc(sizeof(结构_元素段) * 元素数);
    if (上下文.模块->元素段列表 == NULL) {
        return 错误码_内存不足;
    }
    
    for (i = 0; i < 元素数; i++) {
        uint32_t 表索引;
        int32_t 偏移量;
        uint32_t 函数数;
        
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &表索引);
        偏移量 = 解析初始化表达式(上下文);
        
        上下文.模块->元素段列表[i].表索引 = 表索引;
        上下文.模块->元素段列表[i].偏移量 = (uint32_t)偏移量;
        
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &函数数);
        上下文.模块->元素段列表[i].函数数 = 函数数;
        
        上下文.模块->元素段列表[i].函数索引列表 = (uint32_t*)malloc(sizeof(uint32_t) * 函数数);
        if (函数数 > 0 && 上下文.模块->元素段列表[i].函数索引列表 == NULL) {
            return 错误码_内存不足;
        }
        
        for (j = 0; j < 函数数; j++) {
            上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, 
                &上下文.模块->元素段列表[i].函数索引列表[j]);
        }
    }
    
    return 错误码_成功;
}

static int 解析代码段(加载器上下文* 上下文) {
    uint32_t 函数体数;
    uint32_t i, j;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &函数体数);
    
    for (i = 0; i < 函数体数; i++) {
        uint32_t 函数体大小;
        uint32_t 函数体起始, 函数体结束;
        uint32_t 局部变量组数;
        uint32_t 局部变量偏移;
        uint32_t 总局部变量数 = 0;
        
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &函数体大小);
        函数体起始 = 上下文.偏移;
        函数体结束 = 函数体起始 + 函数体大小;
        
        /* 解析局部变量声明 */
        局部变量偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &局部变量组数);
        
        /* 计算总局部变量数 */
        for (j = 0; j < 局部变量组数; j++) {
            uint32_t 计数;
            局部变量偏移 = 解码无符号32位(上下文.字节码, 局部变量偏移, &计数);
            /* 跳过类型字节 */
            局部变量偏移++;
            总局部变量数 += 计数;
        }
        
        /* 分配局部变量类型数组 */
        上下文.模块->函数列表[i].局部变量数 = 总局部变量数;
        上下文.模块->函数列表[i].局部变量类型 = (uint8_t*)malloc(总局部变量数);
        if (总局部变量数 > 0 && 上下文.模块->函数列表[i].局部变量类型 == NULL) {
            return 错误码_内存不足;
        }
        
        /* 重新解析局部变量类型 */
        局部变量偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &局部变量组数);
        总局部变量数 = 0;
        for (j = 0; j < 局部变量组数; j++) {
            uint32_t 计数;
            uint8_t 类型;
            uint32_t k;
            
            局部变量偏移 = 解码无符号32位(上下文.字节码, 局部变量偏移, &计数);
            类型 = 上下文.字节码[局部变量偏移++];
            
            for (k = 0; k < 计数; k++) {
                上下文.模块->函数列表[i].局部变量类型[总局部变量数++] = 类型;
            }
        }
        
        /* 设置代码范围 */
        上下文.模块->函数列表[i].代码起始 = 局部变量偏移;
        上下文.模块->函数列表[i].代码结束 = 函数体结束;
        上下文.模块->函数列表[i].函数体 = &上下文.字节码[局部变量偏移];
        
        /* 跳转到下一个函数体 */
        上下文.偏移 = 函数体结束;
    }
    
    return 错误码_成功;
}

static int 解析数据段(加载器上下文* 上下文) {
    uint32_t 数据段数;
    uint32_t i;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &数据段数);
    
    上下文.模块->数据段数 = 数据段数;
    上下文.模块->数据段列表 = (结构_数据段*)malloc(sizeof(结构_数据段) * 数据段数);
    if (上下文.模块->数据段列表 == NULL) {
        return 错误码_内存不足;
    }
    
    for (i = 0; i < 数据段数; i++) {
        uint32_t 内存索引;
        int32_t 偏移量;
        uint32_t 数据长度;
        
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &内存索引);
        偏移量 = 解析初始化表达式(上下文);
        
        上下文.模块->数据段列表[i].内存索引 = 内存索引;
        上下文.模块->数据段列表[i].偏移量 = (uint32_t)偏移量;
        
        上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &数据长度);
        上下文.模块->数据段列表[i].数据长度 = 数据长度;
        
        上下文.模块->数据段列表[i].数据 = (uint8_t*)malloc(数据长度);
        if (数据长度 > 0 && 上下文.模块->数据段列表[i].数据 == NULL) {
            return 错误码_内存不足;
        }
        
        memcpy(上下文.模块->数据段列表[i].数据, &上下文.字节码[上下文.偏移], 数据长度);
        上下文.偏移 += 数据长度;
    }
    
    return 错误码_成功;
}

static int32_t 解析初始化表达式(加载器上下文* 上下文) {
    uint8_t 操作码;
    int32_t 值 = 0;
    
    操作码 = 读取字节(上下文);
    
    switch (操作码) {
        case 操作码_常量32位: /* i32.const */
            上下文.偏移 = 解码有符号32位(上下文.字节码, 上下文.偏移, &值);
            break;
        case 操作码_常量64位: /* i64.const */
            {
                int64_t 值64;
                上下文.偏移 = 解码有符号64位(上下文.字节码, 上下文.偏移, &值64);
                值 = (int32_t)值64;
            }
            break;
        case 操作码_常量单精度浮点: /* f32.const */
            上下文.偏移 += 4;
            break;
        case 操作码_常量双精度浮点: /* f64.const */
            上下文.偏移 += 8;
            break;
        case 0x23: /* global.get */
            {
                uint32_t 全局索引;
                上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &全局索引);
                if (全局索引 < 上下文.模块->全局变量数) {
                    值 = 上下文.模块->全局变量列表[全局索引].值.整数32;
                }
            }
            break;
        default:
            /* 未知操作码 */
            break;
    }
    
    /* 跳过 end 标记 */
    读取字节(上下文);
    
    return 值;
}

/* ==================== 辅助函数 ==================== */

static uint8_t 读取字节(加载器上下文* 上下文) {
    if (上下文.偏移 >= 上下文.字节数) {
        return 0;
    }
    return 上下文.字节码[上下文.偏移++];
}

static uint32_t 读取字符串(加载器上下文* 上下文, char** 输出) {
    uint32_t 长度;
    
    上下文.偏移 = 解码无符号32位(上下文.字节码, 上下文.偏移, &长度);
    
    *输出 = (char*)malloc(长度 + 1);
    if (*输出 != NULL) {
        memcpy(*输出, &上下文.字节码[上下文.偏移], 长度);
        (*输出)[长度] = '\0';
    }
    
    return 上下文.偏移 + 长度;
}

static uint8_t 读取值类型(加载器上下文* 上下文) {
    return 读取字节(上下文);
}
