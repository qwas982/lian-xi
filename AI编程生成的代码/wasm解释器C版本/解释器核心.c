/**
 * 解释器核心.c
 * WebAssembly 解释器核心实现
 * 指令执行引擎
 */

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "解释器核心.h"
#include "工具函数.h"

/* 内部函数声明 */
static int 压入块(结构_解释器* 解释器, uint8_t 块类型, uint32_t 起始地址, 
                   uint32_t 结束地址, uint32_t 否则地址, int 是循环);
static int 弹出块(结构_解释器* 解释器, 结构_控制块* 输出);
static int 执行分支(结构_解释器* 解释器, uint32_t 标签索引);
static int 执行返回(结构_解释器* 解释器);
static int 设置调用(结构_解释器* 解释器, uint32_t 函数索引);

/* 指令执行函数 */
static int 执行控制流(结构_解释器* 解释器, uint8_t 操作码);
static int 执行变量访问(结构_解释器* 解释器, uint8_t 操作码);
static int 执行内存操作(结构_解释器* 解释器, uint8_t 操作码);
static int 执行常量(结构_解释器* 解释器, uint8_t 操作码);
static int 执行整数32比较(结构_解释器* 解释器, uint8_t 操作码);
static int 执行整数64比较(结构_解释器* 解释器, uint8_t 操作码);
static int 执行整数32运算(结构_解释器* 解释器, uint8_t 操作码);
static int 执行整数64运算(结构_解释器* 解释器, uint8_t 操作码);
static int 执行浮点32比较(结构_解释器* 解释器, uint8_t 操作码);
static int 执行浮点64比较(结构_解释器* 解释器, uint8_t 操作码);
static int 执行浮点32一元运算(结构_解释器* 解释器, uint8_t 操作码);
static int 执行浮点64一元运算(结构_解释器* 解释器, uint8_t 操作码);
static int 执行浮点32二元运算(结构_解释器* 解释器, uint8_t 操作码);
static int 执行浮点64二元运算(结构_解释器* 解释器, uint8_t 操作码);
static int 执行类型转换(结构_解释器* 解释器, uint8_t 操作码);
static int 执行符号扩展(结构_解释器* 解释器, uint8_t 操作码);

/* ==================== 解释器生命周期 ==================== */

结构_解释器* 创建解释器(结构_模块* 模块) {
    结构_解释器* 解释器 = (结构_解释器*)malloc(sizeof(结构_解释器));
    if (解释器 == NULL) {
        return NULL;
    }
    
    解释器->模块 = 模块;
    解释器->运行中 = 0;
    解释器->调试模式 = 0;
    
    return 解释器;
}

void 销毁解释器(结构_解释器* 解释器) {
    if (解释器 != NULL) {
        free(解释器);
    }
}

/* ==================== 函数调用 ==================== */

int 调用函数(结构_解释器* 解释器, uint32_t 函数索引, 
             结构_栈值* 参数, uint32_t 参数数, 结构_栈值* 返回值) {
    结构_模块* 模块 = 解释器->模块;
    结构_函数* 函数;
    结构_函数类型* 函数类型;
    结构_栈帧 帧;
    uint32_t i;
    int 结果;
    
    if (函数索引 >= 模块->函数数) {
        return 错误码_无效操作码;
    }
    
    函数 = &模块->函数列表[函数索引];
    函数类型 = &模块->类型列表[函数->类型索引];
    
    /* 检查参数数量 */
    if (参数数 != 函数类型->参数数) {
        return 错误码_解析错误;
    }
    
    /* 压入参数 */
    for (i = 0; i < 参数数; i++) {
        结果 = 压入操作数(module, 参数[i]);
        if (结果 != 错误码_成功) {
            return 结果;
        }
    }
    
    /* 设置调用 */
    结果 = 设置调用(解释器, 函数索引);
    if (结果 != 错误码_成功) {
        return 结果;
    }
    
    /* 执行函数 */
    结果 = 执行循环(解释器);
    if (结果 != 错误码_成功) {
        return 结果;
    }
    
    /* 获取返回值 */
    if (函数类型->返回数 > 0 && 返回值 != NULL) {
        结果 = 查看栈顶(module, 返回值);
        if (结果 != 错误码_成功) {
            return 结果;
        }
    }
    
    return 错误码_成功;
}

static int 设置调用(结构_解释器* 解释器, uint32_t 函数索引) {
    结构_模块* 模块 = 解释器->模块;
    结构_函数* 函数 = &模块->函数列表[函数索引];
    结构_函数类型* 函数类型 = &模块->类型列表[函数->类型索引];
    结构_栈帧 帧;
    uint32_t i;
    int 结果;
    
    /* 计算局部变量基址 */
    帧.函数索引 = 函数索引;
    帧.返回地址 = 模块->程序计数器;
    帧.局部变量基址 = 模块->操作数栈指针 - 函数类型->参数数 + 1;
    帧.操作数栈基址 = 帧.局部变量基址;
    帧.块栈基址 = 模块->块栈指针 + 1;
    帧.调用者模块 = module;
    
    /* 压入帧 */
    结果 = 压入帧(module, 帧);
    if (结果 != 错误码_成功) {
        return 结果;
    }
    
    /* 设置程序计数器 */
    模块->程序计数器 = 函数->代码起始;
    
    /* 为局部变量分配空间 */
    for (i = 0; i < 函数->局部变量数; i++) {
        结构_栈值 零值;
        零值.值类型 = 函数->局部变量类型[i];
        零值.值.整数32 = 0;
        结果 = 压入操作数(module, 零值);
        if (结果 != 错误码_成功) {
            return 结果;
        }
    }
    
    return 错误码_成功;
}

/* ==================== 执行循环 ==================== */

int 执行循环(结构_解释器* 解释器) {
    结构_模块* 模块 = 解释器->模块;
    int 结果 = 错误码_成功;
    
    解释器->运行中 = 1;
    
    while (解释器->运行中 && 结果 == 错误码_成功) {
        uint8_t 操作码;
        
        /* 检查程序计数器 */
        if (模块->程序计数器 >= 模块->字节数) {
            break;
        }
        
        /* 读取操作码 */
        操作码 = 读取字节(module);
        
        /* 执行指令 */
        结果 = 执行指令(解释器, 操作码);
    }
    
    return 结果;
}

int 执行指令(结构_解释器* 解释器, uint8_t 操作码) {
    /* 根据操作码分发 */
    switch (操作码) {
        /* 控制流指令 */
        case 操作码_不可达:
        case 操作码_空操作:
        case 操作码_块开始:
        case 操作码_循环开始:
        case 操作码_条件分支:
        case 操作码_否则分支:
        case 操作码_结束标记:
        case 操作码_分支:
        case 操作码_条件分支表:
        case 操作码_返回:
            return 执行控制流(解释器, 操作码);
        
        /* 参数指令 */
        case 操作码_丢弃:
        case 操作码_选择:
            return 执行控制流(解释器, 操作码);
        
        /* 变量访问指令 */
        case 操作码_局部变量读取:
        case 操作码_局部变量写入:
        case 操作码_局部变量读取32:
        case 操作码_全局变量读取:
        case 操作码_全局变量写入:
            return 执行变量访问(解释器, 操作码);
        
        /* 内存操作指令 */
        case 操作码_内存读取32位:
        case 操作码_内存读取64位:
        case 操作码_内存读取单精度浮点:
        case 操作码_内存读取双精度浮点:
        case 操作码_内存读取8位有符号扩展32:
        case 操作码_内存读取8位无符号扩展32:
        case 操作码_内存读取16位有符号扩展32:
        case 操作码_内存读取16位无符号扩展32:
        case 操作码_内存读取8位有符号扩展64:
        case 操作码_内存读取8位无符号扩展64:
        case 操作码_内存读取16位有符号扩展64:
        case 操作码_内存读取16位无符号扩展64:
        case 操作码_内存读取32位有符号扩展64:
        case 操作码_内存读取32位无符号扩展64:
        case 操作码_内存写入32位:
        case 操作码_内存写入64位:
        case 操作码_内存写入单精度浮点:
        case 操作码_内存写入双精度浮点:
        case 操作码_内存写入8位32:
        case 操作码_内存写入16位32:
        case 操作码_内存写入8位64:
        case 操作码_内存写入16位64:
        case 操作码_内存写入32位64:
        case 操作码_内存大小:
        case 操作码_内存增长:
            return 执行内存操作(解释器, 操作码);
        
        /* 常量指令 */
        case 操作码_常量32位:
        case 操作码_常量64位:
        case 操作码_常量单精度浮点:
        case 操作码_常量双精度浮点:
            return 执行常量(解释器, 操作码);
        
        /* 整数32比较指令 */
        case 操作码_等于零判断32:
        case 操作码_等于判断32:
        case 操作码_不等于判断32:
        case 操作码_小于有符号32:
        case 操作码_小于无符号32:
        case 操作码_大于有符号32:
        case 操作码_大于无符号32:
        case 操作码_小于等于有符号32:
        case 操作码_小于等于无符号32:
        case 操作码_大于等于有符号32:
        case 操作码_大于等于无符号32:
            return 执行整数32比较(解释器, 操作码);
        
        /* 整数64比较指令 */
        case 操作码_等于零判断64:
        case 操作码_等于判断64:
        case 操作码_不等于判断64:
        case 操作码_小于有符号64:
        case 操作码_小于无符号64:
        case 操作码_大于有符号64:
        case 操作码_大于无符号64:
        case 操作码_小于等于有符号64:
        case 操作码_小于等于无符号64:
        case 操作码_大于等于有符号64:
        case 操作码_大于等于无符号64:
            return 执行整数64比较(解释器, 操作码);
        
        /* 整数32运算指令 */
        case 操作码_加法32:
        case 操作码_减法32:
        case 操作码_乘法32:
        case 操作码_除法有符号32:
        case 操作码_除法无符号32:
        case 操作码_取余有符号32:
        case 操作码_取余无符号32:
        case 操作码_与运算32:
        case 操作码_或运算32:
        case 操作码_异或运算32:
        case 操作码_左移32:
        case 操作码_右移有符号32:
        case 操作码_右移无符号32:
        case 操作码_循环左移32:
        case 操作码_循环右移32:
            return 执行整数32运算(解释器, 操作码);
        
        /* 整数64运算指令 */
        case 操作码_加法64:
        case 操作码_减法64:
        case 操作码_乘法64:
        case 操作码_除法有符号64:
        case 操作码_除法无符号64:
        case 操作码_取余有符号64:
        case 操作码_取余无符号64:
        case 操作码_与运算64:
        case 操作码_或运算64:
        case 操作码_异或运算64:
        case 操作码_左移64:
        case 操作码_右移有符号64:
        case 操作码_右移无符号64:
        case 操作码_循环左移64:
        case 操作码_循环右移64:
            return 执行整数64运算(解释器, 操作码);
        
        /* 浮点32比较指令 */
        case 操作码_等于判断单精度:
        case 操作码_不等于判断单精度:
        case 操作码_小于单精度:
        case 操作码_大于单精度:
        case 操作码_小于等于单精度:
        case 操作码_大于等于单精度:
            return 执行浮点32比较(解释器, 操作码);
        
        /* 浮点64比较指令 */
        case 操作码_等于判断双精度:
        case 操作码_不等于判断双精度:
        case 操作码_小于双精度:
        case 操作码_大于双精度:
        case 操作码_小于等于双精度:
        case 操作码_大于等于双精度:
            return 执行浮点64比较(解释器, 操作码);
        
        /* 浮点32一元运算 */
        case 操作码_取绝对值单精度:
        case 操作码_取负单精度:
        case 操作码_向上取整单精度:
        case 操作码_向下取整单精度:
        case 操作码_向零取整单精度:
        case 操作码_平方根单精度:
            return 执行浮点32一元运算(解释器, 操作码);
        
        /* 浮点64一元运算 */
        case 操作码_取绝对值双精度:
        case 操作码_取负双精度:
        case 操作码_向上取整双精度:
        case 操作码_向下取整双精度:
        case 操作码_向零取整双精度:
        case 操作码_平方根双精度:
            return 执行浮点64一元运算(解释器, 操作码);
        
        /* 浮点32二元运算 */
        case 操作码_加法单精度:
        case 操作码_减法单精度:
        case 操作码_乘法单精度:
        case 操作码_除法单精度:
        case 操作码_取最小值单精度:
        case 操作码_取最大值单精度:
        case 操作码_复制符号单精度:
            return 执行浮点32二元运算(解释器, 操作码);
        
        /* 浮点64二元运算 */
        case 操作码_加法双精度:
        case 操作码_减法双精度:
        case 操作码_乘法双精度:
        case 操作码_除法双精度:
        case 操作码_取最小值双精度:
        case 操作码_取最大值双精度:
        case 操作码_复制符号双精度:
            return 执行浮点64二元运算(解释器, 操作码);
        
        /* 类型转换指令 */
        case 操作码_截断32位有符号:
        case 操作码_截断32位无符号:
        case 操作码_截断64位有符号32:
        case 操作码_截断64位无符号32:
        case 操作码_浮点转32位有符号:
        case 操作码_浮点转32位无符号:
        case 操作码_双精度转32位有符号:
        case 操作码_双精度转32位无符号:
        case 操作码_截断饱和32位有符号:
        case 操作码_截断饱和32位无符号:
        case 操作码_扩展有符号64:
        case 操作码_扩展无符号64:
        case 操作码_截断64位有符号64:
        case 操作码_截断64位无符号64:
        case 操作码_浮点转64位有符号:
        case 操作码_浮点转64位无符号:
        case 操作码_双精度转64位有符号:
        case 操作码_双精度转64位无符号:
        case 操作码_截断饱和64位有符号:
        case 操作码_截断饱和64位无符号:
        case 操作码_转换32位有符号单精度:
        case 操作码_转换32位无符号单精度:
        case 操作码_转换64位有符号单精度:
        case 操作码_转换64位无符号单精度:
        case 操作码_双精度转单精度:
        case 操作码_转换32位有符号双精度:
        case 操作码_转换32位无符号双精度:
        case 操作码_转换64位有符号双精度:
        case 操作码_转换64位无符号双精度:
        case 操作码_单精度转双精度:
            return 执行类型转换(解释器, 操作码);
        
        /* 符号扩展指令 */
        case 操作码_扩展8位有符号32:
        case 操作码_扩展16位有符号32:
        case 操作码_扩展8位有符号64:
        case 操作码_扩展16位有符号64:
        case 操作码_扩展32位有符号64:
            return 执行符号扩展(解释器, 操作码);
        
        default:
            return 错误码_无效操作码;
    }
}

/* ==================== 控制流指令 ==================== */

static int 执行控制流(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    
    switch (操作码) {
        case 操作码_不可达:
            return 错误码_不可达代码;
        
        case 操作码_空操作:
            /* 什么都不做 */
            return 错误码_成功;
        
        case 操作码_块开始: {
            uint8_t 块类型 = 读取字节(module);
            uint32_t 当前地址 = module->程序计数器 - 1;
            return 压入块(解释器, 块类型, 当前地址, 0, 0xFFFFFFFF, 0);
        }
        
        case 操作码_循环开始: {
            uint8_t 块类型 = 读取字节(module);
            uint32_t 当前地址 = module->程序计数器 - 1;
            return 压入块(解释器, 块类型, 当前地址, 0, 0xFFFFFFFF, 1);
        }
        
        case 操作码_条件分支: {
            uint8_t 块类型 = 读取字节(module);
            结构_栈值 条件;
            int 结果;
            
            结果 = 弹出操作数(module, &条件);
            if (结果 != 错误码_成功) return 结果;
            
            result = 压入块(解释器, 块类型, module->程序计数器 - 1, 0, 0xFFFFFFFF, 0);
            if (结果 != 错误码_成功) return 结果;
            
            if (条件.值.整数32 == 0) {
                /* 跳过到else或end */
                int 深度 = 1;
                while (深度 > 0 && module->程序计数器 < module->字节数) {
                    uint8_t 字节 = 读取字节(module);
                    if (字节 == 操作码_条件分支) {
                        深度++;
                    } else if (字节 == 操作码_否则分支) {
                        if (深度 == 1) {
                            module->块栈[module->块栈指针].否则地址 = module->程序计数器;
                            break;
                        }
                    } else if (字节 == 操作码_结束标记) {
                        深度--;
                    }
                }
            }
            return 错误码_成功;
        }
        
        case 操作码_否则分支: {
            /* 跳过到end */
            int 深度 = 1;
            while (深度 > 0 && module->程序计数器 < module->字节数) {
                uint8_t 字节 = 读取字节(module);
                if (字节 == 操作码_块开始 || 字节 == 操作码_循环开始 || 字节 == 操作码_条件分支) {
                    深度++;
                } else if (字节 == 操作码_结束标记) {
                    深度--;
                }
            }
            return 错误码_成功;
        }
        
        case 操作码_结束标记: {
            结构_控制块 块;
            
            if (module->块栈指针 >= 0) {
                return 弹出块(解释器, &块);
            } else {
                /* 函数结束 */
                if (module->帧指针 >= 0) {
                    int 结果 = 执行返回(解释器);
                    if (module->帧指针 < 0) {
                        解释器->运行中 = 0;
                    }
                    return 结果;
                } else {
                    解释器->运行中 = 0;
                    return 错误码_成功;
                }
            }
        }
        
        case 操作码_分支: {
            uint32_t 标签索引;
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &标签索引);
            return 执行分支(解释器, 标签索引);
        }
        
        case 操作码_条件分支表: {
            uint32_t 标签数, i;
            结构_栈值 索引值;
            int 结果;
            
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &标签数);
            
            /* 读取标签列表 */
            for (i = 0; i < 标签数; i++) {
                uint32_t 标签;
                module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &标签);
            }
            
            /* 读取默认标签 */
            uint32_t 默认标签;
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &默认标签);
            
            /* 弹出索引 */
            结果 = 弹出操作数(module, &索引值);
            if (结果 != 错误码_成功) return 结果;
            
            /* 执行分支 */
            if ((uint32_t)索引值.值.整数32 < 标签数) {
                /* 使用对应标签 - 简化处理，实际应该重新解析 */
                return 执行分支(解释器, 默认标签);
            } else {
                return 执行分支(解释器, 默认标签);
            }
        }
        
        case 操作码_返回:
            return 执行返回(解释器);
        
        case 操作码_丢弃: {
            结构_栈值 值;
            return 弹出操作数(module, &值);
        }
        
        case 操作码_选择: {
            结构_栈值 条件, 值2, 值1, 结果值;
            int 结果;
            
            结果 = 弹出操作数(module, &条件);
            if (结果 != 错误码_成功) return 结果;
            
            结果 = 弹出操作数(module, &值2);
            if (结果 != 错误码_成功) return 结果;
            
            结果 = 弹出操作数(module, &值1);
            if (结果 != 错误码_成功) return 结果;
            
            if (条件.值.整数32 != 0) {
                结果值 = 值1;
            } else {
                结果值 = 值2;
            }
            
            return 压入操作数(module, 结果值);
        }
        
        default:
            return 错误码_无效操作码;
    }
}

/* ==================== 块操作 ==================== */

static int 压入块(结构_解释器* 解释器, uint8_t 块类型, uint32_t 起始地址, 
                   uint32_t 结束地址, uint32_t 否则地址, int 是循环) {
    结构_模块* 模块 = 解释器->模块;
    结构_控制块 块;
    
    块.块类型 = 块类型;
    块.返回类型 = 获取块返回类型(块类型);
    块.起始地址 = 起始地址;
    块.结束地址 = 结束地址;
    块.否则地址 = 否则地址;
    块.是循环 = 是循环;
    
    return 压入块(module, 块);
}

static int 弹出块(结构_解释器* 解释器, 结构_控制块* 输出) {
    return 弹出块(解释器->模块, 输出);
}

static int 执行分支(结构_解释器* 解释器, uint32_t 标签索引) {
    结构_模块* 模块 = 解释器->模块;
    结构_控制块* 目标块;
    int32_t 目标索引;
    int i;
    
    /* 弹出块直到目标块 */
    for (i = 0; i < (int)标签索引 && module->块栈指针 >= 0; i++) {
        结构_控制块 块;
        弹出块(解释器, &块);
    }
    
    if (module->块栈指针 < 0) {
        return 错误码_块栈下溢;
    }
    
    目标块 = &module->块栈[module->块栈指针];
    
    if (目标块->是循环) {
        /* 循环：跳转到循环开始 */
        module->程序计数器 = 目标块->起始地址 + 2; /* 跳过块类型 */
    } else {
        /* 块：跳转到块结束 */
        /* 简化处理：继续执行直到end */
    }
    
    return 错误码_成功;
}

static int 执行返回(结构_解释器* 解释器) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈帧 帧;
    结构_函数* 函数;
    结构_函数类型* 函数类型;
    结构_栈值 返回值;
    int 结果;
    
    if (module->帧指针 < 0) {
        return 错误码_调用栈下溢;
    }
    
    /* 弹出帧 */
    结果 = 弹出帧(module, &帧);
    if (结果 != 错误码_成功) return 结果;
    
    /* 获取函数信息 */
    函数 = &module->函数列表[帧.函数索引];
    函数类型 = &module->类型列表[函数->类型索引];
    
    /* 保存返回值 */
    if (函数类型->返回数 > 0) {
        结果 = 弹出操作数(module, &返回值);
        if (结果 != 错误码_成功) return 结果;
    }
    
    /* 恢复操作数栈 */
    module->操作数栈指针 = 帧.操作数栈基址 - 1;
    
    /* 压入返回值 */
    if (函数类型->返回数 > 0) {
        结果 = 压入操作数(module, 返回值);
        if (结果 != 错误码_成功) return 结果;
    }
    
    /* 恢复程序计数器 */
    module->程序计数器 = 帧.返回地址;
    
    return 错误码_成功;
}

/* ==================== 变量访问指令 ==================== */

static int 执行变量访问(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈帧* 帧;
    uint32_t 索引;
    int 结果;
    
    帧 = 获取当前帧(module);
    if (帧 == NULL) {
        return 错误码_调用栈下溢;
    }
    
    switch (操作码) {
        case 操作码_局部变量读取:
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &索引);
            {
                结构_栈值 值 = module->操作数栈[帧->局部变量基址 + 索引];
                return 压入操作数(module, 值);
            }
        
        case 操作码_局部变量写入:
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &索引);
            {
                结构_栈值 值;
                结果 = 弹出操作数(module, &值);
                if (结果 != 错误码_成功) return 结果;
                module->操作数栈[帧->局部变量基址 + 索引] = 值;
                return 错误码_成功;
            }
        
        case 操作码_局部变量读取32: /* local.tee */
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &索引);
            {
                结构_栈值 值;
                结果 = 查看栈顶(module, &值);
                if (结果 != 错误码_成功) return 结果;
                module->操作数栈[帧->局部变量基址 + 索引] = 值;
                return 错误码_成功;
            }
        
        case 操作码_全局变量读取:
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &索引);
            if (索引 >= module->全局变量数) {
                return 错误码_内存访问越界;
            }
            {
                结构_栈值 值;
                值.值类型 = module->全局变量列表[索引].值类型;
                值.值 = module->全局变量列表[索引].值;
                return 压入操作数(module, 值);
            }
        
        case 操作码_全局变量写入:
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &索引);
            if (索引 >= module->全局变量数) {
                return 错误码_内存访问越界;
            }
            {
                结构_栈值 值;
                结果 = 弹出操作数(module, &值);
                if (结果 != 错误码_成功) return 结果;
                module->全局变量列表[索引].值 = 值.值;
                return 错误码_成功;
            }
        
        default:
            return 错误码_无效操作码;
    }
}

/* ==================== 内存操作指令 ==================== */

static int 执行内存操作(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    uint32_t 对齐, 偏移;
    结构_栈值 地址值, 值;
    int 结果;
    uint32_t 地址;
    
    if (module->内存 == NULL) {
        return 错误码_内存访问越界;
    }
    
    switch (操作码) {
        case 操作码_内存大小:
            读取字节(module); /* 跳过0x00 */
            {
                结构_栈值 结果值;
                结果值.值类型 = 值类型_整数32;
                结果值.值.整数32 = module->内存->当前页数;
                return 压入操作数(module, 结果值);
            }
        
        case 操作码_内存增长:
            读取字节(module); /* 跳过0x00 */
            {
                结构_栈值 增量值, 结果值;
                结果 = 弹出操作数(module, &增量值);
                if (结果 != 错误码_成功) return 结果;
                
                结果值.值类型 = 值类型_整数32;
                结果值.值.整数32 = 内存增长(module->内存, 增量值.值.整数32);
                return 压入操作数(module, 结果值);
            }
        
        default:
            /* 读取对齐和偏移 */
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &对齐);
            module->程序计数器 = 解码无符号32位(module->字节码, module->程序计数器, &偏移);
            
            /* 读取地址 */
            结果 = 弹出操作数(module, &地址值);
            if (结果 != 错误码_成功) return 结果;
            
            地址 = (uint32_t)(地址值.值.整数32 + 偏移);
            
            /* 内存读取 */
            if (操作码 >= 操作码_内存读取32位 && 操作码 <= 操作码_内存读取32位无符号扩展64) {
                if (地址 + 8 > module->内存->数据大小) {
                    return 错误码_内存访问越界;
                }
                
                值.值类型 = 值类型_整数32;
                
                switch (操作码) {
                    case 操作码_内存读取32位:
                        值.值.整数32 = (int32_t)读取小端32位(&module->内存->数据[地址]);
                        break;
                    case 操作码_内存读取8位有符号扩展32:
                        值.值.整数32 = (int8_t)module->内存->数据[地址];
                        break;
                    case 操作码_内存读取8位无符号扩展32:
                        值.值.整数32 = module->内存->数据[地址];
                        break;
                    case 操作码_内存读取16位有符号扩展32:
                        值.值.整数32 = (int16_t)读取小端16位(&module->内存->数据[地址]);
                        break;
                    case 操作码_内存读取16位无符号扩展32:
                        值.值.整数32 = 读取小端16位(&module->内存->数据[地址]);
                        break;
                    default:
                        return 错误码_未实现;
                }
                
                return 压入操作数(module, 值);
            }
            
            /* 内存写入 */
            if (操作码 >= 操作码_内存写入32位 && 操作码 <= 操作码_内存写入32位64) {
                结果 = 弹出操作数(module, &值);
                if (结果 != 错误码_成功) return 结果;
                
                if (地址 + 8 > module->内存->数据大小) {
                    return 错误码_内存访问越界;
                }
                
                switch (操作码) {
                    case 操作码_内存写入32位:
                        写入小端32位(&module->内存->数据[地址], (uint32_t)值.值.整数32);
                        break;
                    case 操作码_内存写入8位32:
                        module->内存->数据[地址] = (uint8_t)(值.值.整数32 & 0xFF);
                        break;
                    case 操作码_内存写入16位32:
                        写入小端16位(&module->内存->数据[地址], (uint16_t)(值.值.整数32 & 0xFFFF));
                        break;
                    default:
                        return 错误码_未实现;
                }
                
                return 错误码_成功;
            }
            
            return 错误码_未实现;
    }
}

/* ==================== 常量指令 ==================== */

static int 执行常量(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 值;
    
    switch (操作码) {
        case 操作码_常量32位: {
            int32_t 整数32;
            module->程序计数器 = 解码有符号32位(module->字节码, module->程序计数器, &整数32);
            值.值类型 = 值类型_整数32;
            值.值.整数32 = 整数32;
            return 压入操作数(module, 值);
        }
        
        case 操作码_常量64位: {
            int64_t 整数64;
            module->程序计数器 = 解码有符号64位(module->字节码, module->程序计数器, &整数64);
            值.值类型 = 值类型_整数64;
            值.值.整数64 = 整数64;
            return 压入操作数(module, 值);
        }
        
        case 操作码_常量单精度浮点:
            值.值类型 = 值类型_单精度浮点;
            值.值.单精度浮点 = 读取单精度浮点(module);
            return 压入操作数(module, 值);
        
        case 操作码_常量双精度浮点:
            值.值类型 = 值类型_双精度浮点;
            值.值.双精度浮点 = 读取双精度浮点(module);
            return 压入操作数(module, 值);
        
        default:
            return 错误码_无效操作码;
    }
}

/* ==================== 整数比较指令 ==================== */

static int 执行整数32比较(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 左值, 右值, 结果值;
    int 结果;
    int32_t 有符号左, 有符号右;
    uint32_t 无符号左, 无符号右;
    int 比较结果 = 0;
    
    结果值.值类型 = 值类型_整数32;
    
    if (操作码 == 操作码_等于零判断32) {
        结果 = 弹出操作数(module, &左值);
        if (结果 != 错误码_成功) return 结果;
        
        比较结果 = (左值.值.整数32 == 0) ? 1 : 0;
    } else {
        结果 = 弹出操作数(module, &右值);
        if (结果 != 错误码_成功) return 结果;
        
        结果 = 弹出操作数(module, &左值);
        if (结果 != 错误码_成功) return 结果;
        
        有符号左 = 左值.值.整数32;
        有符号右 = 右值.值.整数32;
        无符号左 = (uint32_t)左值.值.整数32;
        无符号右 = (uint32_t)右值.值.整数32;
        
        switch (操作码) {
            case 操作码_等于判断32:
                比较结果 = (有符号左 == 有符号右) ? 1 : 0;
                break;
            case 操作码_不等于判断32:
                比较结果 = (有符号左 != 有符号右) ? 1 : 0;
                break;
            case 操作码_小于有符号32:
                比较结果 = (有符号左 < 有符号右) ? 1 : 0;
                break;
            case 操作码_小于无符号32:
                比较结果 = (无符号左 < 无符号右) ? 1 : 0;
                break;
            case 操作码_大于有符号32:
                比较结果 = (有符号左 > 有符号右) ? 1 : 0;
                break;
            case 操作码_大于无符号32:
                比较结果 = (无符号左 > 无符号右) ? 1 : 0;
                break;
            case 操作码_小于等于有符号32:
                比较结果 = (有符号左 <= 有符号右) ? 1 : 0;
                break;
            case 操作码_小于等于无符号32:
                比较结果 = (无符号左 <= 无符号右) ? 1 : 0;
                break;
            case 操作码_大于等于有符号32:
                比较结果 = (有符号左 >= 有符号右) ? 1 : 0;
                break;
            case 操作码_大于等于无符号32:
                比较结果 = (无符号左 >= 无符号右) ? 1 : 0;
                break;
            default:
                return 错误码_无效操作码;
        }
    }
    
    结果值.值.整数32 = 比较结果;
    return 压入操作数(module, 结果值);
}

static int 执行整数64比较(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 左值, 右值, 结果值;
    int 结果;
    int64_t 有符号左, 有符号右;
    uint64_t 无符号左, 无符号右;
    int 比较结果 = 0;
    
    结果值.值类型 = 值类型_整数32;
    
    if (操作码 == 操作码_等于零判断64) {
        结果 = 弹出操作数(module, &左值);
        if (结果 != 错误码_成功) return 结果;
        
        比较结果 = (左值.值.整数64 == 0) ? 1 : 0;
    } else {
        结果 = 弹出操作数(module, &右值);
        if (结果 != 错误码_成功) return 结果;
        
        结果 = 弹出操作数(module, &左值);
        if (结果 != 错误码_成功) return 结果;
        
        有符号左 = 左值.值.整数64;
        有符号右 = 右值.值.整数64;
        无符号左 = (uint64_t)左值.值.整数64;
        无符号右 = (uint64_t)右值.值.整数64;
        
        switch (操作码) {
            case 操作码_等于判断64:
                比较结果 = (有符号左 == 有符号右) ? 1 : 0;
                break;
            case 操作码_不等于判断64:
                比较结果 = (有符号左 != 有符号右) ? 1 : 0;
                break;
            case 操作码_小于有符号64:
                比较结果 = (有符号左 < 有符号右) ? 1 : 0;
                break;
            case 操作码_小于无符号64:
                比较结果 = (无符号左 < 无符号右) ? 1 : 0;
                break;
            case 操作码_大于有符号64:
                比较结果 = (有符号左 > 有符号右) ? 1 : 0;
                break;
            case 操作码_大于无符号64:
                比较结果 = (无符号左 > 无符号右) ? 1 : 0;
                break;
            case 操作码_小于等于有符号64:
                比较结果 = (有符号左 <= 有符号右) ? 1 : 0;
                break;
            case 操作码_小于等于无符号64:
                比较结果 = (无符号左 <= 无符号右) ? 1 : 0;
                break;
            case 操作码_大于等于有符号64:
                比较结果 = (有符号左 >= 有符号右) ? 1 : 0;
                break;
            case 操作码_大于等于无符号64:
                比较结果 = (无符号左 >= 无符号右) ? 1 : 0;
                break;
            default:
                return 错误码_无效操作码;
        }
    }
    
    结果值.值.整数32 = 比较结果;
    return 压入操作数(module, 结果值);
}

/* ==================== 整数运算指令 ==================== */

static int 执行整数32运算(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 左值, 右值, 结果值;
    int 结果;
    uint32_t 无符号左, 无符号右, 无符号结果;
    int32_t 有符号左, 有符号右;
    
    结果 = 弹出操作数(module, &右值);
    if (结果 != 错误码_成功) return 结果;
    
    结果 = 弹出操作数(module, &左值);
    if (结果 != 错误码_成功) return 结果;
    
    无符号左 = (uint32_t)左值.值.整数32;
    无符号右 = (uint32_t)右值.值.整数32;
    有符号左 = 左值.值.整数32;
    有符号右 = 右值.值.整数32;
    
    结果值.值类型 = 值类型_整数32;
    
    switch (操作码) {
        case 操作码_加法32:
            结果值.值.整数32 = (int32_t)(无符号左 + 无符号右);
            break;
        case 操作码_减法32:
            结果值.值.整数32 = (int32_t)(无符号左 - 无符号右);
            break;
        case 操作码_乘法32:
            结果值.值.整数32 = (int32_t)(无符号左 * 无符号右);
            break;
        case 操作码_除法有符号32:
            if (有符号右 == 0) return 错误码_除零错误;
            结果值.值.整数32 = 有符号左 / 有符号右;
            break;
        case 操作码_除法无符号32:
            if (无符号右 == 0) return 错误码_除零错误;
            结果值.值.整数32 = (int32_t)(无符号左 / 无符号右);
            break;
        case 操作码_取余有符号32:
            if (有符号右 == 0) return 错误码_除零错误;
            结果值.值.整数32 = 有符号左 % 有符号右;
            break;
        case 操作码_取余无符号32:
            if (无符号右 == 0) return 错误码_除零错误;
            结果值.值.整数32 = (int32_t)(无符号左 % 无符号右);
            break;
        case 操作码_与运算32:
            结果值.值.整数32 = (int32_t)(无符号左 & 无符号右);
            break;
        case 操作码_或运算32:
            结果值.值.整数32 = (int32_t)(无符号左 | 无符号右);
            break;
        case 操作码_异或运算32:
            结果值.值.整数32 = (int32_t)(无符号左 ^ 无符号右);
            break;
        case 操作码_左移32:
            结果值.值.整数32 = (int32_t)(无符号左 << (无符号右 & 0x1F));
            break;
        case 操作码_右移有符号32:
            结果值.值.整数32 = 有符号左 >> (无符号右 & 0x1F);
            break;
        case 操作码_右移无符号32:
            结果值.值.整数32 = (int32_t)(无符号左 >> (无符号右 & 0x1F));
            break;
        case 操作码_循环左移32: {
            uint32_t 位移 = 无符号右 & 0x1F;
            结果值.值.整数32 = (int32_t)((无符号左 << 位移) | (无符号左 >> (32 - 位移)));
            break;
        }
        case 操作码_循环右移32: {
            uint32_t 位移 = 无符号右 & 0x1F;
            结果值.值.整数32 = (int32_t)((无符号左 >> 位移) | (无符号左 << (32 - 位移)));
            break;
        }
        default:
            return 错误码_无效操作码;
    }
    
    return 压入操作数(module, 结果值);
}

static int 执行整数64运算(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 左值, 右值, 结果值;
    int 结果;
    uint64_t 无符号左, 无符号右;
    int64_t 有符号左, 有符号右;
    
    结果 = 弹出操作数(module, &右值);
    if (结果 != 错误码_成功) return 结果;
    
    结果 = 弹出操作数(module, &左值);
    if (结果 != 错误码_成功) return 结果;
    
    无符号左 = (uint64_t)左值.值.整数64;
    无符号右 = (uint64_t)右值.值.整数64;
    有符号左 = 左值.值.整数64;
    有符号右 = 右值.值.整数64;
    
    结果值.值类型 = 值类型_整数64;
    
    switch (操作码) {
        case 操作码_加法64:
            结果值.值.整数64 = (int64_t)(无符号左 + 无符号右);
            break;
        case 操作码_减法64:
            结果值.值.整数64 = (int64_t)(无符号左 - 无符号右);
            break;
        case 操作码_乘法64:
            结果值.值.整数64 = (int64_t)(无符号左 * 无符号右);
            break;
        case 操作码_除法有符号64:
            if (有符号右 == 0) return 错误码_除零错误;
            结果值.值.整数64 = 有符号左 / 有符号右;
            break;
        case 操作码_除法无符号64:
            if (无符号右 == 0) return 错误码_除零错误;
            结果值.值.整数64 = (int64_t)(无符号左 / 无符号右);
            break;
        case 操作码_取余有符号64:
            if (有符号右 == 0) return 错误码_除零错误;
            结果值.值.整数64 = 有符号左 % 有符号右;
            break;
        case 操作码_取余无符号64:
            if (无符号右 == 0) return 错误码_除零错误;
            结果值.值.整数64 = (int64_t)(无符号左 % 无符号右);
            break;
        case 操作码_与运算64:
            结果值.值.整数64 = (int64_t)(无符号左 & 无符号右);
            break;
        case 操作码_或运算64:
            结果值.值.整数64 = (int64_t)(无符号左 | 无符号右);
            break;
        case 操作码_异或运算64:
            结果值.值.整数64 = (int64_t)(无符号左 ^ 无符号右);
            break;
        case 操作码_左移64:
            结果值.值.整数64 = (int64_t)(无符号左 << (无符号右 & 0x3F));
            break;
        case 操作码_右移有符号64:
            结果值.值.整数64 = 有符号左 >> (无符号右 & 0x3F);
            break;
        case 操作码_右移无符号64:
            结果值.值.整数64 = (int64_t)(无符号左 >> (无符号右 & 0x3F));
            break;
        case 操作码_循环左移64: {
            uint32_t 位移 = (uint32_t)(无符号右 & 0x3F);
            结果值.值.整数64 = (int64_t)((无符号左 << 位移) | (无符号左 >> (64 - 位移)));
            break;
        }
        case 操作码_循环右移64: {
            uint32_t 位移 = (uint32_t)(无符号右 & 0x3F);
            结果值.值.整数64 = (int64_t)((无符号左 >> 位移) | (无符号左 << (64 - 位移)));
            break;
        }
        default:
            return 错误码_无效操作码;
    }
    
    return 压入操作数(module, 结果值);
}

/* ==================== 浮点比较指令 ==================== */

static int 执行浮点32比较(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 左值, 右值, 结果值;
    int 结果;
    float 左浮点, 右浮点;
    int 比较结果 = 0;
    
    结果 = 弹出操作数(module, &右值);
    if (结果 != 错误码_成功) return 结果;
    
    结果 = 弹出操作数(module, &左值);
    if (结果 != 错误码_成功) return 结果;
    
    左浮点 = 左值.值.单精度浮点;
    右浮点 = 右值.值.单精度浮点;
    
    结果值.值类型 = 值类型_整数32;
    
    switch (操作码) {
        case 操作码_等于判断单精度:
            比较结果 = (左浮点 == 右浮点) ? 1 : 0;
            break;
        case 操作码_不等于判断单精度:
            比较结果 = (左浮点 != 右浮点) ? 1 : 0;
            break;
        case 操作码_小于单精度:
            比较结果 = (左浮点 < 右浮点) ? 1 : 0;
            break;
        case 操作码_大于单精度:
            比较结果 = (左浮点 > 右浮点) ? 1 : 0;
            break;
        case 操作码_小于等于单精度:
            比较结果 = (左浮点 <= 右浮点) ? 1 : 0;
            break;
        case 操作码_大于等于单精度:
            比较结果 = (左浮点 >= 右浮点) ? 1 : 0;
            break;
        default:
            return 错误码_无效操作码;
    }
    
    结果值.值.整数32 = 比较结果;
    return 压入操作数(module, 结果值);
}

static int 执行浮点64比较(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 左值, 右值, 结果值;
    int 结果;
    double 左浮点, 右浮点;
    int 比较结果 = 0;
    
    结果 = 弹出操作数(module, &右值);
    if (结果 != 错误码_成功) return 结果;
    
    结果 = 弹出操作数(module, &左值);
    if (结果 != 错误码_成功) return 结果;
    
    左浮点 = 左值.值.双精度浮点;
    右浮点 = 右值.值.双精度浮点;
    
    结果值.值类型 = 值类型_整数32;
    
    switch (操作码) {
        case 操作码_等于判断双精度:
            比较结果 = (左浮点 == 右浮点) ? 1 : 0;
            break;
        case 操作码_不等于判断双精度:
            比较结果 = (左浮点 != 右浮点) ? 1 : 0;
            break;
        case 操作码_小于双精度:
            比较结果 = (左浮点 < 右浮点) ? 1 : 0;
            break;
        case 操作码_大于双精度:
            比较结果 = (左浮点 > 右浮点) ? 1 : 0;
            break;
        case 操作码_小于等于双精度:
            比较结果 = (左浮点 <= 右浮点) ? 1 : 0;
            break;
        case 操作码_大于等于双精度:
            比较结果 = (左浮点 >= 右浮点) ? 1 : 0;
            break;
        default:
            return 错误码_无效操作码;
    }
    
    结果值.值.整数32 = 比较结果;
    return 压入操作数(module, 结果值);
}

/* ==================== 浮点一元运算 ==================== */

static int 执行浮点32一元运算(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 值, 结果值;
    int 结果;
    
    结果 = 弹出操作数(module, &值);
    if (结果 != 错误码_成功) return 结果;
    
    结果值.值类型 = 值类型_单精度浮点;
    
    switch (操作码) {
        case 操作码_取绝对值单精度:
            结果值.值.单精度浮点 = fabsf(值.值.单精度浮点);
            break;
        case 操作码_取负单精度:
            结果值.值.单精度浮点 = -值.值.单精度浮点;
            break;
        case 操作码_向上取整单精度:
            结果值.值.单精度浮点 = ceilf(值.值.单精度浮点);
            break;
        case 操作码_向下取整单精度:
            结果值.值.单精度浮点 = floorf(值.值.单精度浮点);
            break;
        case 操作码_向零取整单精度:
            结果值.值.单精度浮点 = truncf(值.值.单精度浮点);
            break;
        case 操作码_平方根单精度:
            结果值.值.单精度浮点 = sqrtf(值.值.单精度浮点);
            break;
        default:
            return 错误码_无效操作码;
    }
    
    return 压入操作数(module, 结果值);
}

static int 执行浮点64一元运算(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 值, 结果值;
    int 结果;
    
    结果 = 弹出操作数(module, &值);
    if (结果 != 错误码_成功) return 结果;
    
    结果值.值类型 = 值类型_双精度浮点;
    
    switch (操作码) {
        case 操作码_取绝对值双精度:
            结果值.值.双精度浮点 = fabs(值.值.双精度浮点);
            break;
        case 操作码_取负双精度:
            结果值.值.双精度浮点 = -值.值.双精度浮点;
            break;
        case 操作码_向上取整双精度:
            结果值.值.双精度浮点 = ceil(值.值.双精度浮点);
            break;
        case 操作码_向下取整双精度:
            结果值.值.双精度浮点 = floor(值.值.双精度浮点);
            break;
        case 操作码_向零取整双精度:
            结果值.值.双精度浮点 = trunc(值.值.双精度浮点);
            break;
        case 操作码_平方根双精度:
            结果值.值.双精度浮点 = sqrt(值.值.双精度浮点);
            break;
        default:
            return 错误码_无效操作码;
    }
    
    return 压入操作数(module, 结果值);
}

/* ==================== 浮点二元运算 ==================== */

static int 执行浮点32二元运算(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 左值, 右值, 结果值;
    int 结果;
    
    结果 = 弹出操作数(module, &右值);
    if (结果 != 错误码_成功) return 结果;
    
    结果 = 弹出操作数(module, &左值);
    if (结果 != 错误码_成功) return 结果;
    
    结果值.值类型 = 值类型_单精度浮点;
    
    switch (操作码) {
        case 操作码_加法单精度:
            结果值.值.单精度浮点 = 左值.值.单精度浮点 + 右值.值.单精度浮点;
            break;
        case 操作码_减法单精度:
            结果值.值.单精度浮点 = 左值.值.单精度浮点 - 右值.值.单精度浮点;
            break;
        case 操作码_乘法单精度:
            结果值.值.单精度浮点 = 左值.值.单精度浮点 * 右值.值.单精度浮点;
            break;
        case 操作码_除法单精度:
            结果值.值.单精度浮点 = 左值.值.单精度浮点 / 右值.值.单精度浮点;
            break;
        case 操作码_取最小值单精度:
            结果值.值.单精度浮点 = 单精度最小值(左值.值.单精度浮点, 右值.值.单精度浮点);
            break;
        case 操作码_取最大值单精度:
            结果值.值.单精度浮点 = 单精度最大值(左值.值.单精度浮点, 右值.值.单精度浮点);
            break;
        case 操作码_复制符号单精度:
            结果值.值.单精度浮点 = 复制单精度符号(左值.值.单精度浮点, 右值.值.单精度浮点);
            break;
        default:
            return 错误码_无效操作码;
    }
    
    return 压入操作数(module, 结果值);
}

static int 执行浮点64二元运算(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 左值, 右值, 结果值;
    int 结果;
    
    结果 = 弹出操作数(module, &右值);
    if (结果 != 错误码_成功) return 结果;
    
    结果 = 弹出操作数(module, &左值);
    if (结果 != 错误码_成功) return 结果;
    
    结果值.值类型 = 值类型_双精度浮点;
    
    switch (操作码) {
        case 操作码_加法双精度:
            结果值.值.双精度浮点 = 左值.值.双精度浮点 + 右值.值.双精度浮点;
            break;
        case 操作码_减法双精度:
            结果值.值.双精度浮点 = 左值.值.双精度浮点 - 右值.值.双精度浮点;
            break;
        case 操作码_乘法双精度:
            结果值.值.双精度浮点 = 左值.值.双精度浮点 * 右值.值.双精度浮点;
            break;
        case 操作码_除法双精度:
            结果值.值.双精度浮点 = 左值.值.双精度浮点 / 右值.值.双精度浮点;
            break;
        case 操作码_取最小值双精度:
            结果值.值.双精度浮点 = 双精度最小值(左值.值.双精度浮点, 右值.值.双精度浮点);
            break;
        case 操作码_取最大值双精度:
            结果值.值.双精度浮点 = 双精度最大值(左值.值.双精度浮点, 右值.值.双精度浮点);
            break;
        case 操作码_复制符号双精度:
            结果值.值.双精度浮点 = 复制双精度符号(左值.值.双精度浮点, 右值.值.双精度浮点);
            break;
        default:
            return 错误码_无效操作码;
    }
    
    return 压入操作数(module, 结果值);
}

/* ==================== 类型转换指令 ==================== */

static int 执行类型转换(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 值, 结果值;
    int 结果;
    
    结果 = 弹出操作数(module, &值);
    if (结果 != 错误码_成功) return 结果;
    
    switch (操作码) {
        /* i32 转换 */
        case 操作码_扩展有符号64:
            结果值.值类型 = 值类型_整数64;
            结果值.值.整数64 = (int64_t)值.值.整数32;
            return 压入操作数(module, 结果值);
        
        case 操作码_扩展无符号64:
            结果值.值类型 = 值类型_整数64;
            结果值.值.整数64 = (int64_t)(uint32_t)值.值.整数32;
            return 压入操作数(module, 结果值);
        
        case 操作码_转换32位有符号单精度:
            结果值.值类型 = 值类型_单精度浮点;
            结果值.值.单精度浮点 = (float)值.值.整数32;
            return 压入操作数(module, 结果值);
        
        case 操作码_转换32位无符号单精度:
            结果值.值类型 = 值类型_单精度浮点;
            结果值.值.单精度浮点 = (float)(uint32_t)值.值.整数32;
            return 压入操作数(module, 结果值);
        
        case 操作码_转换32位有符号双精度:
            结果值.值类型 = 值类型_双精度浮点;
            结果值.值.双精度浮点 = (double)值.值.整数32;
            return 压入操作数(module, 结果值);
        
        case 操作码_转换32位无符号双精度:
            结果值.值类型 = 值类型_双精度浮点;
            结果值.值.双精度浮点 = (double)(uint32_t)值.值.整数32;
            return 压入操作数(module, 结果值);
        
        /* i64 转换 */
        case 操作码_转换64位有符号单精度:
            结果值.值类型 = 值类型_单精度浮点;
            结果值.值.单精度浮点 = (float)值.值.整数64;
            return 压入操作数(module, 结果值);
        
        case 操作码_转换64位无符号单精度:
            结果值.值类型 = 值类型_单精度浮点;
            结果值.值.单精度浮点 = (float)(uint64_t)值.值.整数64;
            return 压入操作数(module, 结果值);
        
        case 操作码_转换64位有符号双精度:
            结果值.值类型 = 值类型_双精度浮点;
            结果值.值.双精度浮点 = (double)值.值.整数64;
            return 压入操作数(module, 结果值);
        
        case 操作码_转换64位无符号双精度:
            结果值.值类型 = 值类型_双精度浮点;
            结果值.值.双精度浮点 = (double)(uint64_t)值.值.整数64;
            return 压入操作数(module, 结果值);
        
        /* f32 转换 */
        case 操作码_截断32位有符号:
            结果值.值类型 = 值类型_整数32;
            结果 = 单精度转32位有符号(值.值.单精度浮点, &结果值.值.整数32);
            if (结果 != 错误码_成功) return 结果;
            return 压入操作数(module, 结果值);
        
        case 操作码_截断32位无符号:
            结果值.值类型 = 值类型_整数32;
            结果 = 单精度转32位无符号(值.值.单精度浮点, (uint32_t*)&结果值.值.整数32);
            if (结果 != 错误码_成功) return 结果;
            return 压入操作数(module, 结果值);
        
        case 操作码_双精度转单精度:
            结果值.值类型 = 值类型_单精度浮点;
            结果值.值.单精度浮点 = (float)值.值.双精度浮点;
            return 压入操作数(module, 结果值);
        
        /* f64 转换 */
        case 操作码_截断64位有符号32:
            结果值.值类型 = 值类型_整数32;
            结果 = 双精度转32位有符号(值.值.双精度浮点, &结果值.值.整数32);
            if (结果 != 错误码_成功) return 结果;
            return 压入操作数(module, 结果值);
        
        case 操作码_截断64位无符号32:
            结果值.值类型 = 值类型_整数32;
            结果 = 双精度转32位无符号(值.值.双精度浮点, (uint32_t*)&结果值.值.整数32);
            if (结果 != 错误码_成功) return 结果;
            return 压入操作数(module, 结果值);
        
        case 操作码_截断64位有符号64:
            结果值.值类型 = 值类型_整数64;
            结果 = 双精度转64位有符号(值.值.双精度浮点, &结果值.值.整数64);
            if (结果 != 错误码_成功) return 结果;
            return 压入操作数(module, 结果值);
        
        case 操作码_截断64位无符号64:
            结果值.值类型 = 值类型_整数64;
            结果 = 双精度转64位无符号(值.值.双精度浮点, (uint64_t*)&结果值.值.整数64);
            if (结果 != 错误码_成功) return 结果;
            return 压入操作数(module, 结果值);
        
        case 操作码_单精度转双精度:
            结果值.值类型 = 值类型_双精度浮点;
            结果值.值.双精度浮点 = (double)值.值.单精度浮点;
            return 压入操作数(module, 结果值);
        
        /* 饱和截断 */
        case 操作码_截断饱和32位有符号:
            结果值.值类型 = 值类型_整数32;
            结果值.值.整数32 = 截断饱和32位有符号(值.值.双精度浮点);
            return 压入操作数(module, 结果值);
        
        case 操作码_截断饱和32位无符号:
            结果值.值类型 = 值类型_整数32;
            结果值.值.整数32 = (int32_t)截断饱和32位无符号(值.值.双精度浮点);
            return 压入操作数(module, 结果值);
        
        case 操作码_截断饱和64位有符号:
            结果值.值类型 = 值类型_整数64;
            结果值.值.整数64 = 截断饱和64位有符号(值.值.双精度浮点);
            return 压入操作数(module, 结果值);
        
        case 操作码_截断饱和64位无符号:
            结果值.值类型 = 值类型_整数64;
            结果值.值.整数64 = (int64_t)截断饱和64位无符号(值.值.双精度浮点);
            return 压入操作数(module, 结果值);
        
        default:
            return 错误码_未实现;
    }
}

/* ==================== 符号扩展指令 ==================== */

static int 执行符号扩展(结构_解释器* 解释器, uint8_t 操作码) {
    结构_模块* 模块 = 解释器->模块;
    结构_栈值 值, 结果值;
    int 结果;
    
    结果 = 弹出操作数(module, &值);
    if (结果 != 错误码_成功) return 结果;
    
    switch (操作码) {
        case 操作码_扩展8位有符号32:
            结果值.值类型 = 值类型_整数32;
            结果值.值.整数32 = (int32_t)(int8_t)(值.值.整数32 & 0xFF);
            return 压入操作数(module, 结果值);
        
        case 操作码_扩展16位有符号32:
            结果值.值类型 = 值类型_整数32;
            结果值.值.整数32 = (int32_t)(int16_t)(值.值.整数32 & 0xFFFF);
            return 压入操作数(module, 结果值);
        
        case 操作码_扩展8位有符号64:
            结果值.值类型 = 值类型_整数64;
            结果值.值.整数64 = (int64_t)(int8_t)(值.值.整数64 & 0xFF);
            return 压入操作数(module, 结果值);
        
        case 操作码_扩展16位有符号64:
            结果值.值类型 = 值类型_整数64;
            结果值.值.整数64 = (int64_t)(int16_t)(值.值.整数64 & 0xFFFF);
            return 压入操作数(module, 结果值);
        
        case 操作码_扩展32位有符号64:
            结果值.值类型 = 值类型_整数64;
            结果值.值.整数64 = (int64_t)(int32_t)(值.值.整数64 & 0xFFFFFFFF);
            return 压入操作数(module, 结果值);
        
        default:
            return 错误码_无效操作码;
    }
}
