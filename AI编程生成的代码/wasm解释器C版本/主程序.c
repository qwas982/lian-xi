/* 主程序.c - WebAssembly解释器入口和测试 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "类型定义.h"
#include "枚举定义.h"
#include "数据结构.h"
#include "工具函数.h"
#include "模块加载器.h"
#include "解释器核心.h"

/* ========== 工具函数 ========== */

/* 打印用法信息 */
static void 打印用法(const char* 程序名) {
    printf("用法: %s <wasm文件> [选项]\n", 程序名);
    printf("\n选项:\n");
    printf("  --函数 <索引>    调用指定索引的函数(默认: 0)\n");
    printf("  --参数 <值>      传递整数参数(可多次使用)\n");
    printf("  --浮点参数 <值>  传递浮点参数(可多次使用)\n");
    printf("  --信息           仅显示模块信息\n");
    printf("  --测试           运行内置测试\n");
    printf("  --帮助           显示此帮助信息\n");
}

/* 打印模块信息 */
static void 打印模块信息(const 结构_模块* 模块) {
    uint32_t i;
    
    printf("========== WebAssembly模块信息 ==========\n\n");
    
    /* 类型段 */
    printf("类型段: %u 个函数类型\n", 模块->类型数);
    for (i = 0; i < 模块->类型数; i++) {
        uint32_t j;
        const 结构_函数类型* 类型 = &模块->类型列表[i];
        printf("  [%u] (%u) -> (%u)\n", i, 
               类型->参数数, 类型->返回数);
        if (类型->参数数 > 0) {
            printf("      参数: ");
            for (j = 0; j < 类型->参数数; j++) {
                printf("0x%02x ", 类型->参数类型[j]);
            }
            printf("\n");
        }
        if (类型->返回数 > 0) {
            printf("      返回: ");
            for (j = 0; j < 类型->返回数; j++) {
                printf("0x%02x ", 类型->返回类型[j]);
            }
            printf("\n");
        }
    }
    
    /* 函数段 */
    printf("\n函数段: %u 个函数\n", 模块->函数数);
    
    /* 内存段 */
    if (模块->内存 != NULL) {
        printf("\n内存段: 1 个内存\n");
        printf("  初始: %u页, 最大: %u页, 当前: %u页\n", 
               模块->内存->初始页数, 模块->内存->最大页数, 模块->内存->当前页数);
    }
    
    /* 全局段 */
    printf("\n全局段: %u 个全局变量\n", 模块->全局变量数);
    for (i = 0; i < 模块->全局变量数; i++) {
        const 结构_全局变量* 全局 = &模块->全局变量列表[i];
        printf("  [%u] 类型: 0x%02x, 可变: %s\n", 
               i, 全局->值类型, 全局->可变 ? "是" : "否");
    }
    
    /* 导出段 */
    printf("\n导出段: %u 个导出\n", 模块->导出项数);
    for (i = 0; i < 模块->导出项数; i++) {
        const 结构_导出项* 导出 = &模块->导出列表[i];
        const char* 类型名;
        switch (导出->导出类型) {
            case 导出类型_函数: 类型名 = "函数"; break;
            case 导出类型_表: 类型名 = "表"; break;
            case 导出类型_内存: 类型名 = "内存"; break;
            case 导出类型_全局: 类型名 = "全局"; break;
            default: 类型名 = "未知"; break;
        }
        printf("  [%u] \"%s\" -> %s[%u]\n", 
               i, 导出->名称, 类型名, 导出->索引);
    }
    
    /* 数据段 */
    printf("\n数据段: %u 个数据段\n", 模块->数据段数);
    for (i = 0; i < 模块->数据段数; i++) {
        const 结构_数据段* 数据 = &模块->数据段列表[i];
        printf("  [%u] 内存索引: %u, 偏移量: %u, 大小: %u字节\n",
               i, 数据->内存索引, 数据->偏移量, 数据->数据长度);
    }
    
    printf("\n========================================\n");
}

/* 打印栈值 */
static void 打印栈值(const 结构_栈值* 值) {
    switch (值->值类型) {
        case 值类型_整数32:
            printf("i32: %d (0x%08x)\n", 值->值.整数32, 值->值.整数32);
            break;
        case 值类型_整数64:
            printf("i64: %lld (0x%016llx)\n", 
                   (long long)值->值.整数64, (unsigned long long)值->值.整数64);
            break;
        case 值类型_浮点32:
            printf("f32: %f\n", 值->值.浮点32);
            break;
        case 值类型_浮点64:
            printf("f64: %lf\n", 值->值.浮点64);
            break;
        default:
            printf("未知类型: 0x%02x\n", 值->值类型);
            break;
    }
}

/* ========== 测试函数 ========== */

/* 创建简单的测试Wasm模块 (计算阶乘) */
static uint8_t* 创建阶乘测试模块(size_t* 大小) {
    /* 这是一个简单的阶乘函数的Wasm二进制:
     * (module
     *   (func $fac (param i32) (result i32)
     *     local.get 0
     *     i32.const 1
     *     i32.le_s
     *     if (result i32)
     *       i32.const 1
     *     else
     *       local.get 0
     *       local.get 0
     *       i32.const 1
     *       i32.sub
     *       call $fac
     *       i32.mul
     *     end)
     *   (export "fac" (func $fac))
     * )
     */
    static const uint8_t 阶乘模块[] = {
        /* Wasm魔数和版本 */
        0x00, 0x61, 0x73, 0x6d,  /* magic */
        0x01, 0x00, 0x00, 0x00,  /* version 1 */
        
        /* 类型段 */
        0x01,                    /* 段ID: 类型 */
        0x06,                    /* 段大小 */
        0x01,                    /* 1个类型 */
        0x60,                    /* 函数类型 */
        0x01, 0x7f,              /* 1个i32参数 */
        0x01, 0x7f,              /* 1个i32返回 */
        
        /* 函数段 */
        0x03,                    /* 段ID: 函数 */
        0x02,                    /* 段大小 */
        0x01,                    /* 1个函数 */
        0x00,                    /* 类型索引0 */
        
        /* 导出段 */
        0x07,                    /* 段ID: 导出 */
        0x07,                    /* 段大小 */
        0x01,                    /* 1个导出 */
        0x03,                    /* 名称长度 */
        0x66, 0x61, 0x63,        /* "fac" */
        0x00,                    /* 导出类型: 函数 */
        0x00,                    /* 函数索引0 */
        
        /* 代码段 */
        0x0a,                    /* 段ID: 代码 */
        0x1a,                    /* 段大小 */
        0x01,                    /* 1个函数体 */
        0x18,                    /* 函数体大小 */
        0x00,                    /* 本地变量数量 */
        /* 函数体 */
        0x20, 0x00,              /* local.get 0 */
        0x41, 0x01,              /* i32.const 1 */
        0x4c,                    /* i32.le_s */
        0x04, 0x7f,              /* if (result i32) */
        0x41, 0x01,              /* i32.const 1 */
        0x05,                    /* else */
        0x20, 0x00,              /* local.get 0 */
        0x20, 0x00,              /* local.get 0 */
        0x41, 0x01,              /* i32.const 1 */
        0x6b,                    /* i32.sub */
        0x10, 0x00,              /* call 0 */
        0x6c,                    /* i32.mul */
        0x0b,                    /* end */
        0x0b                     /* end */
    };
    
    uint8_t* 缓冲区 = (uint8_t*)malloc(sizeof(阶乘模块));
    if (缓冲区) {
        memcpy(缓冲区, 阶乘模块, sizeof(阶乘模块));
        *大小 = sizeof(阶乘模块);
    }
    return 缓冲区;
}

/* 创建简单的加法测试模块 */
static uint8_t* 创建加法测试模块(size_t* 大小) {
    /* (module
     *   (func $add (param i32 i32) (result i32)
     *     local.get 0
     *     local.get 1
     *     i32.add)
     *   (export "add" (func $add))
     * )
     */
    static const uint8_t 加法模块[] = {
        /* Wasm魔数和版本 */
        0x00, 0x61, 0x73, 0x6d,
        0x01, 0x00, 0x00, 0x00,
        
        /* 类型段 */
        0x01, 0x07,
        0x01,                    /* 1个类型 */
        0x60,                    /* 函数类型 */
        0x02, 0x7f, 0x7f,        /* 2个i32参数 */
        0x01, 0x7f,              /* 1个i32返回 */
        
        /* 函数段 */
        0x03, 0x02,
        0x01, 0x00,
        
        /* 导出段 */
        0x07, 0x07,
        0x01,
        0x03, 0x61, 0x64, 0x64,  /* "add" */
        0x00, 0x00,
        
        /* 代码段 */
        0x0a, 0x09,
        0x01, 0x07,
        0x00,                    /* 无本地变量 */
        0x20, 0x00,              /* local.get 0 */
        0x20, 0x01,              /* local.get 1 */
        0x6a,                    /* i32.add */
        0x0b                     /* end */
    };
    
    uint8_t* 缓冲区 = (uint8_t*)malloc(sizeof(加法模块));
    if (缓冲区) {
        memcpy(缓冲区, 加法模块, sizeof(加法模块));
        *大小 = sizeof(加法模块);
    }
    return 缓冲区;
}

/* 运行内置测试 */
static int 运行内置测试(void) {
    int 结果;
    uint8_t* 模块数据;
    size_t 模块大小;
    结构_模块* 模块;
    结构_解释器* 解释器;
    结构_栈值 参数[2];
    结构_栈值 返回值;
    
    printf("\n========== 运行内置测试 ==========\n\n");
    
    /* 测试1: 加法函数 */
    printf("测试1: 加法函数 (2 + 3)\n");
    模块数据 = 创建加法测试模块(&模块大小);
    if (!模块数据) {
        printf("错误: 无法创建测试模块\n");
        return -1;
    }
    
    模块 = 加载模块(模块数据, (uint32_t)模块大小);
    free(模块数据);
    
    if (!模块) {
        printf("错误: 模块加载失败\n");
        return -1;
    }
    
    解释器 = 创建解释器(模块);
    if (!解释器) {
        销毁模块(模块);
        return -1;
    }
    
    /* 设置参数: 2 + 3 */
    参数[0].值类型 = 值类型_整数32;
    参数[0].值.整数32 = 2;
    参数[1].值类型 = 值类型_整数32;
    参数[1].值.整数32 = 3;
    
    结果 = 调用函数(解释器, 0, 参数, 2, &返回值);
    
    if (结果 == 0) {
        printf("结果: ");
        打印栈值(&返回值);
        if (返回值.值.整数32 == 5) {
            printf("✓ 测试通过!\n\n");
        } else {
            printf("✗ 测试失败! 期望: 5\n\n");
        }
    } else {
        printf("错误: 函数调用失败 (错误码: %d)\n\n", 结果);
    }
    
    销毁解释器(解释器);
    销毁模块(模块);
    
    /* 测试2: 阶乘函数 */
    printf("测试2: 阶乘函数 (5!)\n");
    模块数据 = 创建阶乘测试模块(&模块大小);
    if (!模块数据) {
        printf("错误: 无法创建测试模块\n");
        return -1;
    }
    
    模块 = 加载模块(模块数据, (uint32_t)模块大小);
    free(模块数据);
    
    if (!模块) {
        printf("错误: 模块加载失败\n");
        return -1;
    }
    
    解释器 = 创建解释器(模块);
    if (!解释器) {
        销毁模块(模块);
        return -1;
    }
    
    /* 计算 5! */
    参数[0].值类型 = 值类型_整数32;
    参数[0].值.整数32 = 5;
    
    结果 = 调用函数(解释器, 0, 参数, 1, &返回值);
    
    if (结果 == 0) {
        printf("结果: ");
        打印栈值(&返回值);
        if (返回值.值.整数32 == 120) {
            printf("✓ 测试通过!\n\n");
        } else {
            printf("✗ 测试失败! 期望: 120\n\n");
        }
    } else {
        printf("错误: 函数调用失败 (错误码: %d)\n\n", 结果);
    }
    
    销毁解释器(解释器);
    销毁模块(模块);
    
    printf("========== 测试完成 ==========\n");
    
    return 0;
}

/* ========== 主函数 ========== */

int main(int 参数数量, char* 参数值[]) {
    const char* 文件路径 = NULL;
    uint32_t 函数索引 = 0;
    int 仅信息 = 0;
    int 运行测试 = 0;
    int i;
    
    结构_栈值 参数[16];
    uint32_t 参数计数 = 0;
    
    /* 解析命令行参数 */
    for (i = 1; i < 参数数量; i++) {
        if (strcmp(参数值[i], "--帮助") == 0 || strcmp(参数值[i], "-h") == 0) {
            打印用法(参数值[0]);
            return 0;
        } else if (strcmp(参数值[i], "--测试") == 0) {
            运行测试 = 1;
        } else if (strcmp(参数值[i], "--信息") == 0) {
            仅信息 = 1;
        } else if (strcmp(参数值[i], "--函数") == 0) {
            if (i + 1 < 参数数量) {
                函数索引 = (uint32_t)atoi(参数值[++i]);
            }
        } else if (strcmp(参数值[i], "--参数") == 0) {
            if (i + 1 < 参数数量 && 参数计数 < 16) {
                参数[参数计数].值类型 = 值类型_整数32;
                参数[参数计数].值.整数32 = atoi(参数值[++i]);
                参数计数++;
            }
        } else if (strcmp(参数值[i], "--浮点参数") == 0) {
            if (i + 1 < 参数数量 && 参数计数 < 16) {
                参数[参数计数].值类型 = 值类型_浮点64;
                参数[参数计数].值.浮点64 = atof(参数值[++i]);
                参数计数++;
            }
        } else if (文件路径 == NULL && 参数值[i][0] != '-') {
            文件路径 = 参数值[i];
        }
    }
    
    /* 运行内置测试 */
    if (运行测试) {
        return 运行内置测试();
    }
    
    /* 检查文件路径 */
    if (文件路径 == NULL) {
        printf("错误: 未指定Wasm文件\n\n");
        打印用法(参数值[0]);
        return 1;
    }
    
    /* 读取Wasm文件 */
    {
        FILE* 文件 = fopen(文件路径, "rb");
        uint8_t* 文件数据 = NULL;
        size_t 文件大小 = 0;
        结构_模块* 模块 = NULL;
        int 结果;
        
        if (!文件) {
            printf("错误: 无法打开文件: %s\n", 文件路径);
            return 1;
        }
        
        /* 获取文件大小 */
        fseek(文件, 0, SEEK_END);
        文件大小 = (size_t)ftell(文件);
        fseek(文件, 0, SEEK_SET);
        
        if (文件大小 == 0) {
            printf("错误: 文件为空\n");
            fclose(文件);
            return 1;
        }
        
        /* 读取文件内容 */
        文件数据 = (uint8_t*)malloc(文件大小);
        if (!文件数据) {
            printf("错误: 内存分配失败\n");
            fclose(文件);
            return 1;
        }
        
        if (fread(文件数据, 1, 文件大小, 文件) != 文件大小) {
            printf("错误: 文件读取失败\n");
            free(文件数据);
            fclose(文件);
            return 1;
        }
        
        fclose(文件);
        
        /* 加载模块 */
        模块 = 加载模块(文件数据, (uint32_t)文件大小);
        free(文件数据);
        
        if (!模块) {
            printf("错误: 模块加载失败\n");
            return 1;
        }
        
        /* 打印模块信息 */
        打印模块信息(模块);
        
        /* 如果仅需要信息,则退出 */
        if (仅信息) {
            销毁模块(模块);
            return 0;
        }
        
        /* 创建解释器并执行函数 */
        {
            结构_解释器* 解释器 = 创建解释器(模块);
            结构_栈值 返回值;
            
            if (!解释器) {
                printf("错误: 无法创建解释器\n");
                销毁模块(模块);
                return 1;
            }
            
            printf("调用函数[%u]...\n", 函数索引);
            
            结果 = 调用函数(解释器, 函数索引, 参数计数 > 0 ? 参数 : NULL, 参数计数, &返回值);
            
            if (结果 == 0) {
                printf("\n返回值: ");
                打印栈值(&返回值);
            } else {
                printf("错误: 函数执行失败 (错误码: %d)\n", 结果);
            }
            
            销毁解释器(解释器);
        }
        
        销毁模块(模块);
    }
    
    return 0;
}
