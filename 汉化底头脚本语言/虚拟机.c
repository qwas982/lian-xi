#include <stdlib.h>

#include "底头.h"

// 初始化虚拟机
void 初始虚拟机(虚拟机大写 *虚机针) {
    // 记录已经分配的内存总和
    虚机针->已分配字节们 = 0;
    // 当前词法分析器初始化为 NULL
    虚机针->当前词法器 = NULL;
    // 指向所有已分配对象链表的首节点，用于垃圾回收
    虚机针->全部对象们 = NULL;
    // 初始化模块集合
    虚机针->全部模块们 = 新对象映射(虚机针);
    // 初始化类的方法集合
    字符串大写缓冲区初始化大写(&虚机针->全部方法名们);
}

// 新建虚拟机
虚拟机大写 *新虚拟机() {
    // 为虚拟机申请内存，返回一个指针指向虚拟机
    虚拟机大写 *虚机针 = (虚拟机大写 *)malloc(sizeof(虚拟机大写));

    // 申请内存失败
    if (虚机针 == NULL) {
        内存_错误大写("分配虚拟机失败!");
    }

    // 调用 初始虚拟机 对虚拟机进行初始化
    初始虚拟机(虚机针);
    // 编译核心模块
    建造核心(虚机针);
    return 虚机针;
}

// 释放虚拟机
void 自由虚拟机(虚拟机大写 *虚机针) {
    断言大写(虚机针->全部方法名们.计数 > 0, "虚拟机已经被自由了!");

    // 释放所有的对象（都存放在链表中）
    对象头部大写 *对象头部 = 虚机针->全部对象们;
    while (对象头部 != NULL) {
        // 释放之前先备份下一个结点地址
        对象头部大写 *下一个 = 对象头部->下一个;
        自由对象(虚机针, 对象头部);
        对象头部 = 下一个;
    }

    字符串大写缓冲区清除大写(虚机针, &虚机针->全部方法名们);
    反分配大写(虚机针, 虚机针);
}

// 确保栈的容量及数据有效
// 需要的槽们 表示栈最少具有的容量，如果当前栈容量 栈容量 大于需要的栈数量，则直接返回即可
void 确保栈(虚拟机大写 *虚机针, 对象线程大写 *对象线程, uint32_t 需要的槽们) {
    if (对象线程->栈容量 > 需要的槽们) {
        return;
    }

    // 向上取最接近的2次幂 找出大于等于 v 的最小的 2 次幂
    // 即容量的值需要是 2 的倍数
    uint32_t 新栈容量 = 向上取最接近的2次幂(需要的槽们);

    // 先将栈底记录下来，用来后面判断是否原地扩容
    // 背景知识：
    // 内存管理系统为了满足 realloc 这种扩容分配，会在所分配的空间上预留一部分空间以满足将来的原地扩容。
    // 如果扩容的增量大小还在预留的空间内，则原地扩容；
    // 如果扩容的大小大于预留的空间，则会重新找一块更大且连续的空间，同时将原内存空间的数据拷贝过去，并返回新分配的内存起始地址（不会继续利用之前的预留空间，否则会破坏虚拟地址的连续性）
    // 整个过程是内存管理系统自动完成的，不需要用户干涉
    // 但是这种开辟新空间的做法，会导致地址变化，相关指针就要更新为新地址，即如果该指针涉及原内存块，就需要调整该指针的值，确保指向正确的位置
    值大写 *旧栈 = 对象线程->栈;

    // 扩大容量，申请内存，memManager 会返回新分配的内存起始地址，会被转成 值大写 类型，起始地址被保存到 值大写 结构体的 num 属性中
    对象线程->栈 = (值大写 *)内存管理器(虚机针, 对象线程->栈, 对象线程->栈容量 * sizeof(值大写), 新栈容量 * sizeof(值大写));
    对象线程->栈容量 = 新栈容量;

    // 申请内存后，将现在的栈底和之前保存的栈底做比较，如果相等则是原地扩容（即预留空间可以满足扩容的增量），否则就是重新开辟了一块内存空间
    long 偏移 = 对象线程->栈 - 旧栈;

    // 如果是重新开辟一块内存空间，并将原来的数据拷贝到新空间中，
    // 就需要调整原指针的值，确保指向正确的位置
    if (偏移 != 0) {
        // 1.调整各个函数帧栈中的起始地址
        uint32_t 索引了 = 0;
        while (索引了 < 对象线程->已用帧数目) {
            对象线程->帧们[索引了].栈起始 += 偏移;
            索引了++;
        }

        // 2.调整自由变量 上值 中 本地变量指针 (用于指向对应的自由变量 上值)
        对象上值大写 *上值 = 对象线程->打开上值们;
        while (上值 != NULL) {
            上值->本地变量指针 += 偏移;
            上值 = 上值->下一个;
        }

        // 3.调整 “大栈” 的栈顶 栈指针
        对象线程->栈指针 += 偏移;
    }
}

// 背景知识：
// 线程就是函数的容器，线程对象提供了一个 “大栈”，在线程中运行的多个函数会共享这个 “大栈”，各自使用其中一部分作为该函数闭包的运行时栈
// 线程就是任务调度器，会提供一个帧栈数组 frames，为每个函数闭包分配一个帧栈 frame（包括3个部分：1.运行时栈    2.待运行的指令流    3.当前运行的指令地址 ip）
// 其中运行时栈就是使用 值大写 数组来模拟，关于 值大写 请参考其结构定义部分

// 为线程 对象线程 中运行的闭包函数 对象闭包 准备帧栈 Frame，即闭包（函数或方法）的运行资源，包括如下：
// 1.运行时栈    2.待运行的指令流    3.当前运行的指令地址 指令指针_
inline static void 创建帧(虚拟机大写 *虚机针, 对象线程大写 *对象线程, 对象闭包大写 *对象闭包, int 实参数) {
    // 如果当前使用的 frame 数量（算上这次使用的一个）大于 frame 的总容量，则将总容量扩大二倍
    if (对象线程->已用帧数目 + 1 > 对象线程->帧容量) {
        uint32_t 新容量 = 对象线程->帧容量 * 2;

        // 扩大容量，申请内存，memManager 会返回新分配的内存起始地址，会被转成 帧大写 类型，起始地址被保存到 帧大写 中的 栈起始 中的 num 属性中
        对象线程->帧们 = (帧大写 *)内存管理器(虚机针, 对象线程->帧们, 对象线程->帧容量 * sizeof(帧大写), 新容量 * sizeof(帧大写));
        对象线程->帧容量 = 新容量;
    }

    // 先计算目前 “大栈” 的大小：栈顶地址 - 栈底地址
    uint32_t 栈槽们 = (uint32_t)(对象线程->栈指针 - 对象线程->栈);
    // 再加上函数/方法执行时需要的最大的栈数，就是创建这次帧栈需要的栈的总大小
    uint32_t 需要的槽们 = 栈槽们 + 对象闭包->函->最大栈槽已用数目;
    // 确保栈的容量及数据有效
    确保栈(虚机针, 对象线程, 需要的槽们);

    // 为线程 对象线程 中运行的闭包函数 对象闭包 准备帧栈 帧大写
    // 第三个参数是被调用函数的帧栈在整个 “大栈” 中的起始地址
    // 减去参数个数，是为了函数闭包 对象闭包 可以访问到栈中自己的参数（TODO: 暂未搞懂，后续回填）
    预备帧(对象线程, 对象闭包, 对象线程->栈指针 - 实参数);
}

// 背景知识：
// 内层函数在引用外层函数中的局部变量，该局部变量对内层函数来说，就是自由变量 upvalue，其中又分为 open 上值 和 closed 上值
// open 上值 是其指针 上值->本地变量指针 所指向的局部变量未被回收，仍在运行时栈中的 上值
// closed 上值 是其指针 上值->本地变量指针 所指向的局部变量已经被回收，不在运行时栈的 上值
// 例如：当外层函数执行完闭，会将其在运行时栈的内存回收掉，其中就包括了局部变量，如果此局部变量被内层函数引用，且该内层函数又被外部使用时，
// 此时，就会将指针 上值->本地变量指针 指向的运行时栈中的局部变量的值，保存到 上值->已关闭上值 变量中，
// 同时将指针 上值->本地变量指针 改为指向 上值->closedUpvalue，这个过程就是 open 上值 转变为 closed 上值 的过程，也就是关闭自由变量的操作
// 从而确保了就是被内层函数引用的局部变量在运行时栈中被回收了，内层函数仍可通过 上值->已关闭上值 访问该局部变量的值。

// 注意：如果某个外层函数执行完，在运行时栈的内存被回收了，其作用域以及其内嵌更深的作用域的局部变量都应该被回收，而作用域越深的变量在运行时栈中的地址就会越大，
// （因为先调用外层函数，然后调用内层函数，所以外层函数的局部变量会先压入运行时栈，内层函数居后，而越后压入，地址也就越大）
// 所以只需要将指针 上值->本地变量指针 的值（被内层函数引用的局部变量的地址）大于某个值（例如 lastSlot）的所有 上值 都执行自由变量操作即可
// （upvalue 是以链表的形式保存，其中 对象线程->打开上值们 就是指向本线程中 “已经打开过的 upvalue” 的链表的首节点）

// 关闭自由变量 upvalue（注：满足其指针 上值->本地变量指针 大于 最后槽 的自由变量）
static void 已关闭上值(对象线程大写 *对象线程, 值大写 *最后槽) {
    对象上值大写 *上值 = 对象线程->打开上值们;
    // 注意：在自由变量 上值 链表创建的时候，就保证了是按照 上值->本地变量指针 的值降序排序的，首节点的自由变量的 本地变量指针 最大
    while (上值 != NULL && 上值->本地变量指针 >= 最后槽) {
        // 将指针 上值->本地变量指针 指向的运行时栈中的局部变量的值，保存到 上值->已关闭上值 变量中
        上值->已关闭上值 = *(上值->本地变量指针);
        // 将指针 上值->本地变量指针 改为指向 上值->已关闭上值
        上值->本地变量指针 = &(上值->已关闭上值);
        // 获取自由变量 上值 链表中下一个自由变量 上值
        上值 = 上值->下一个;
    }
    对象线程->打开上值们 = 上值;
}

// 创建线程中已经打开过的 上值 的链表
// 指针 本地变量指针 就是指向运行时栈中的局部变量，按照 本地变量指针 的值倒序插入到该链表
static 对象上值大写 *创建打开上值(虚拟机大写 *虚机针, 对象线程大写 *对象线程, 值大写 *本地变量指针) {
    // 如果 对象线程->打开上值们 链表还未创建，则创建链表，首节点为基于参数 本地变量指针 的 上值
    if (对象线程->打开上值们 == NULL) {
        对象线程->打开上值们 = 新对象上值(虚机针, 本地变量指针);
        return 对象线程->打开上值们;
    }

    // 否则从前到后遍历链表，找到合适的位置插入新的 上值
    对象上值大写 *前一个上值 = NULL;
    对象上值大写 *上值 = 对象线程->打开上值们;

    // 因为  上值 链表已经默认按照 上值->本地变量指针 的值倒序排列，
    // 所以只要 上值->本地变量指针 > localVarPtr，就继续向后遍历，直到不满足 上值->本地变量指针 > 本地变量指针 为止
    while (上值 != NULL && 上值->本地变量指针 > 本地变量指针) {
        前一个上值 = 上值;
        上值 = 上值->下一个;
    }

    // 如果之前插入了该 upvalue，直接返回即可
    if (上值 != NULL && 上值->本地变量指针 == 本地变量指针) {
        return 上值;
    }

    // 否则就创建一个新的 upvalue，并插入到 上值 链表中
    对象上值大写 *新上值 = 新对象上值(虚机针, 本地变量指针);

    if (前一个上值 == NULL) {
        // 如果 前一个上值 仍为 NULL，说明上面的 while 循环没有执行，也就是说参数 本地变量指针 大于首节点 对象线程->打开上值们 的 本地变量指针
        // 所以需要将基于参数 本地变量指针 的 上值 设置为首节点
        对象线程->打开上值们 = 新上值;
    } else {
        // 否则就在 前一个上值 和 上值 之间插入基于参数 本地变量指针 的 上值
        前一个上值->下一个 = 新上值;
    }
    新上值->下一个 = 上值;
    return 新上值;
}

// 校验基类合法性
// 类名的值 为子类类名，fieldNum 为子类的实例属性数量，superClassValue 为基类
static void 有效的超级类(虚拟机大写 *虚机针, 值大写 类名的值, uint32_t 字段数目, 值大写 超级类的值) {
    // 首先确保 超级类 类型是 类
    if (!值是否类大写(超级类的值)) {
        对象字符串大写 *类名字符串 = 值到对象串大写(类名的值);
        跑_错误大写("类 \"%s\" 的超级类不是一个有效类!", 类名字符串->值.起始);
    }

    类大写 *超级类 = 值到类大写(超级类的值);

    // 基类不能是内建类
    if (超级类 == 虚机针->字符串类 ||
        超级类 == 虚机针->映射类 ||
        超级类 == 虚机针->范围类 ||
        超级类 == 虚机针->列表类 ||
        超级类 == 虚机针->空指针类 ||
        超级类 == 虚机针->布尔类 ||
        超级类 == 虚机针->数目类 ||
        超级类 == 虚机针->函类 ||
        超级类 == 虚机针->线程类) {
        跑_错误大写("超级类不能是一个内建类!");
    }

    // 因为子类也会继承父类的实例属性，所以 子类本身的实例属性数量 + 基类的实例属性数量 不能超过 最大字段数目了大写
    if (超级类->字段数目了 + 字段数目 > 最大字段数目了大写) {
        跑_错误大写("包括超级超越的字段数 %d!", 最大字段数目了大写);
    }
}

// 修正部分指令的操作数
static void 补丁操作范围(类大写 *类, 对象函大写 *函) {
    int 指令指针_ = 0;
    操作码枚举大写 操作码乎;

    while (真) {
        // 从头开始遍历字节码中的所有操作码
        // 指向操作数的第一个字节（操作数占用的字节数可能是 0个、1个、4个 等）
        操作码乎 = (操作码枚举大写)函->指令流.数据们[指令指针_++];

        switch (操作码乎) {
            case 操作码之_载入字段:
            case 操作码之_存储字段:
            case 操作码之_载入这个字段:
            case 操作码之_存储这个字段: {
                // 子类的实例属性数量 = 子类本身的实例属性数量 + 基类本身的实例属性数量
                // 当编译子类时，基类可能还未编译，所以需要等到编译阶段完全结束后，
                // 在子类本身的实例属性数量的基础上在加上基类本身的实例属性数量
                // 该操作数表示子类的实例属性数量，只有一个字节
                函->指令流.数据们[指令指针_++] += 类->超级类->字段数目了;
                break;
            }

            case 操作码之_超级0:
            case 操作码之_超级1:
            case 操作码之_超级2:
            case 操作码之_超级3:
            case 操作码之_超级4:
            case 操作码之_超级5:
            case 操作码之_超级6:
            case 操作码之_超级7:
            case 操作码之_超级8:
            case 操作码之_超级9:
            case 操作码之_超级10:
            case 操作码之_超级11:
            case 操作码之_超级12:
            case 操作码之_超级13:
            case 操作码之_超级14:
            case 操作码之_超级15:
            case 操作码之_超级16: {
                // 操作码 OPCODE_SUPER x 用于调用基类的方法的
                // 其操作数有 4 个字节，其中前两个字节存储 基类方法在基类中的索引 methodIndex，即 super.方法[方法索引] 表示基类的方法
                // 后两个字节存储 基类在常量表中的索引 superClassIndex，即 常量们[超级类索引] 表示基类

                // 相关指令在 emitCallBySignature 函数中写入，当时考虑到基类还没有编译，所以暂时使用 值型_空指针大写 代替基类插入到常量表中，
                // 并将 值型_空指针大写 在常量表中的索引 作为 后两个字节的操作数，即基类在在常量表中的索引
                // 所以只需要将常量表中的 值型_空指针大写 替换回基类即可，无需修改表示索引的操作数

                // 先跳过操作数的前两个字节（用于存储 基类方法在基类中的索引 methodIndex）
                指令指针_ += 2;

                // 计算操作数的后两个字节所保存的值，即基类在常量表中的索引（采用大端字节序，即表示高位地址的值保存在低地址字节中）
                uint32_t 超级类索引 = (函->指令流.数据们[指令指针_] << 8) | 函->指令流.数据们[指令指针_ + 1];
                // 将常量表中索引为 超级类索引 的值替换成真正的基类
                函->常量们.数据们[超级类索引] = 对象到值大写(类->超级类);

                // 再跳过操作数的后两个字节（用于存储 基类在常量表中的索引 superClassIndex），指向下一个操作码
                指令指针_ += 2;
                break;
            }

            case 操作码之_创建闭包: {
                // 操作码 操作码之_创建闭包 的操作数为：前两个字节（用于存储待创建闭包的函数在常量表中索引）+ 不定字节数（用于存储形式为 {上值 是否是直接编译外层单元的局部变量，upvalue 在直接外层编译单元的索引} 的成对信息）
                // 具体细节请参考函数 endCompileUnit 中的注释

                // 计算操作数的前两个字节所保存的值，即待创建闭包的函数在常量表中索引（采用大端字节序，即表示高位地址的值保存在低地址字节中）
                uint32_t 函索引 = (函->指令流.数据们[指令指针_] << 8) | 函->指令流.数据们[指令指针_ + 1];
                // 从常量表中获取到该函数，递归调用 补丁操作范围 修正该函数的指令流（即字节码）中部分指令的操作数
                补丁操作范围(类, 值到对象函大写(函->常量们.数据们[函索引]));

                // 跳过 操作码之_创建闭包 的操作数，指向下一个操作码
                // 通过 获取操作范围们的字节们 获取到某个操作码 操作码之_创建闭包 的操作数占用的字节数
                指令指针_ += 获取操作范围们的字节们(函->指令流.数据们, 函->常量们.数据们, 指令指针_ - 1);
                break;
            }

            case 操作码之_终:
                // 遇到操作码 OPCODE_END，表示字节码已经结束，直接退出即可
                return;

            default:
                // 其他字节码不需要修正操作数，直接跳过指向下一个操作码即可
                // 通过 获取操作范围们的字节们 获取到某个操作码的操作数占用的字节数，直接跳过即可
                指令指针_ += 获取操作范围们的字节们(函->指令流.数据们, 函->常量们.数据们, 指令指针_ - 1);
                break;
        }
    }
}

// 背景知识：
// 各类自己的 方法们 数组和 虚机针->全部方法名们 长度保持一致，进而 虚机针->全部方法名们 中的方法名和各个类的 方法们 数组对应方法体的索引值相等，
// 这样就可以通过相同的索引获取到方法体或者方法名
// 然而 虚机针->全部方法名们 只有一个，但会对应多个类，所以各个类的 方法们 数组中的方法体数量必然会小于 虚机针->全部方法名们 中的方法名数量
// 为了保证一样长度，就需要将各个类的 方法们 数组中无用的索引处用空占位填充

// 修正方法对应指令流中的操作数且绑定方法到指定类上
static void 绑方法与补丁(虚拟机大写 *虚机针, 操作码枚举大写 操作码乎, 类大写 *类, uint32_t 方法索引, 值大写 方法值) {
    // 类的静态方法由【类的 meta 类】的 方法们 数组来存储
    // 类的实例方法由【类本身】的 方法们 数组来存储
    if (操作码乎 == 操作码之_静止方法) {
        // 类->对象头部.类 为 类 的 meta 类
        类 = 类->对象头部.类指针;
    }

    // 创建要绑定的方法 方法
    方法大写 方法;
    方法.类型 = 方法类型_脚本;
    方法.对象了 = 值到对象闭包大写(方法值);

    // 修正方法对应指令流中的操作数
    补丁操作范围(类, 方法.对象了->函);

    // 然后绑定方法到指定类上
    // 即将 方法 插入到 类->方法们.数据们 数组中，索引为 方法索引
    // 类->方法们.数据们[方法索引] = 方法
    绑方法(虚机针, 类, 方法索引, 方法);
}

// 背景知识：
// 线程中的 “大栈” 被在其中运行的所有函数闭包的运行时栈所占用，各自分一块作为自己的运行时栈，各分块不重合，但互相接壤
// “大栈” 的栈底是 对象线程大写->stack，栈顶是 对象线程大写->esp，而线程中各个闭包函数自己的运行时栈的栈底是 栈起始
// 栈起始 记录了本运行时栈在 “大栈” 中的起始地址

// 执行指令
虚拟机结果大写 执行指令(虚拟机大写 *虚机针, register 对象线程大写 *当前线程) {
    虚机针->当前线程 = 当前线程;  // 当前正在执行的线程
    register 帧大写 *当前帧;   // 当前帧栈 frame
    register 值大写 *栈起始; // 当前帧栈 frame 对应的运行时栈的起始地址（栈底）
    register uint8_t *指令指针_;       // 程序计数器，用于存储即将执行的下一条指令在指令流中的地址
    register 对象函大写 *函;         // 当前运行的函数对应的指令流
    操作码枚举大写 操作码乎;              // 代执行指令的操作码

// 定义操作运行时栈的宏
// 栈指针 指针指向的是栈中下一个可写入数据的 slot，即栈顶的后一个 slot
#define 推大写(值) (*当前线程->栈指针++ = 值) // 压入栈顶
#define 弹大写() (*(--当前线程->栈指针)) // 弹出栈顶，并获得栈顶的数据
#define 落下大写() (当前线程->栈指针--) // 丢弃栈顶，即回收栈顶空间
#define 窥大写() (*(当前线程->栈指针 - 1)) // 获得栈顶数据（不改变栈顶指针 esp）
#define 窥大写2() (*(当前线程->栈指针 - 2)) // 获得次栈顶数据（不改变栈顶指针 esp）

// 定义读取指令流的宏
#define 读_字节大写() (*指令指针_++) // 从指令流中读取 1 个字节
#define 读_短大写() (指令指针_ += 2, (uint16_t)(((指令指针_[-2] << 8) | 指令指针_[-1]))) // 从指令流中读取 2 个字节，采用大端字节序（即数据的高字节在低地址，低字节在高地址）

// 帧栈 frame 就是函数的执行环境，每调用一个函数就要为其准备一个帧栈 frame
// 下面的宏 存储_当前帧大写 和 载入_当前帧大写 就是用于指令单元（函数或方法）的帧栈 frame 的切换

// 备份当前帧栈 frame 对应的指令流进度指针 ip，以便后面重新回到该帧栈时，能够从之前指令流执行的位置继续执行
#define 存储_当前帧大写() 当前帧->指令指针 = 指令指针_

// 加载 当前线程->帧们 中最新的帧栈 frame
// 帧们 是数组，索引从 0 开始，所以 已用帧数目 - 1
#define 载入_当前帧大写()                                        \
    当前帧 = &当前线程->帧们[当前线程->已用帧数目 - 1]; \
    栈起始 = 当前帧->栈起始;                          \
    指令指针_ = 当前帧->指令指针;                                          \
    函 = 当前帧->闭包->函;

    载入_当前帧大写()
// 环起始 标号作用：当执行完一条指令后，会直接 goto 到此标号，以减少 CPU 跳出各分支的消耗，以提升虚拟机速度
环起始:
    // 读入指令流中的操作码
    操作码乎 = 读_字节大写();
    switch (操作码乎) {
        case 操作码之_弹:
            //【弹出栈顶】
            落下大写();
            goto 环起始;

        case 操作码之_推空指针:
            //【将 null 压入到运行时栈顶】
            推大写(值型到值大写(值型_空指针大写));
            goto 环起始;

        case 操作码之_推真:
            //【将 真 压入到运行时栈顶】
            推大写(值型到值大写(值型_真大写));
            goto 环起始;

        case 操作码之_推假:
            //【将 false 压入到运行时栈顶】
            推大写(值型到值大写(值型_假大写));
            goto 环起始;

        case 操作码之_载入常量:
            //【将常量的值压入到运行时栈顶】
            // 操作数为常量在常量表 常量们 中的索引，占 2 个字节
            推大写(函->常量们.数据们[读_短大写()]);
            goto 环起始;

        case 操作码之_载入这个字段: {
            //【将类的实例属性的值加载到栈顶】
            // 操作数是该属性在 对象实例->字段们 数组中的索引，占 1 个字节
            uint8_t 字段索引 = 读_字节大写();

            // 既然是加载实例属性，那么位于运行时栈底 栈起始[0] 应该是实例对象，否则报错
            断言大写(值是否对象实例大写(栈起始[0]), "方法接收器应该是对象实例.");
            对象实例大写 *对象实例 = 值到对象实例大写(栈起始[0]);
            断言大写(字段索引 < 对象实例->对象头部.类指针->字段数目了, "出界限字段!");

            推大写(对象实例->字段们[字段索引]);
            goto 环起始;
        }

        case 操作码之_载入本地变量:
            //【将局部变量在运行时栈的值压入到运行时栈顶】
            // 操作数为局部变量在运行时栈中的索引，占 1 个字节
            // 注意：cu->localVars 只是保存局部变量的名，局部变量的值是保存在运行时栈中的
            推大写(栈起始[读_字节大写()]);
            goto 环起始;

        case 操作码之_存储本地变量:
            //【将运行时栈顶的值保存为局部变量的值，即将运行时栈顶的值写入到运行时栈中局部变量的相应位置】
            // 操作数为局部变量在运行时栈中的索引，占 1 个字节
            // 注意：cu->localVars 只是保存局部变量的名，局部变量的值是保存在运行时栈中的
            栈起始[读_字节大写()] = 窥大写();
            goto 环起始;

        case 操作码之_调用0:
        case 操作码之_调用1:
        case 操作码之_调用2:
        case 操作码之_调用3:
        case 操作码之_调用4:
        case 操作码之_调用5:
        case 操作码之_调用6:
        case 操作码之_调用7:
        case 操作码之_调用8:
        case 操作码之_调用9:
        case 操作码之_调用10:
        case 操作码之_调用11:
        case 操作码之_调用12:
        case 操作码之_调用13:
        case 操作码之_调用14:
        case 操作码之_调用15:
        case 操作码之_调用16: {
            类大写 *类;   // 方法所属类
            int 索引;      // 方法在 类->方法们 缓冲区中的索引
            方法大写 *方法; // 方法
            值大写 *实参们;    // 方法参数
            int 实参数;     // 方法参数个数

            // 方法参数个数
            实参数 = 操作码乎 - 操作码之_调用0 + 1;

            // 在调用方法之前，会提前将参数压入到运行时栈中，压入顺序是先压入前面的参数
            // 因此 当前线程->栈指针 - 实参数 指向的是第 0 个参数
            实参们 = 当前线程->栈指针 - 实参数;

            // 分两种情况：
            // 如果 OPCODE_CALLx 调用的是类的静态方法，则第一个参数 实参们[0] 是类，通过 获取对象的类 函数获取的就是该类的 meta 类
            // 如果 OPCODE_CALLx 调用的是类的静态方法，则第一个参数 实参们[0] 是实例对象，通过 获取对象的类 函数获取的就是该实例对象所属的类
            类 = 获取对象的类(虚机针, 实参们[0]);

            // 操作数是方法在 类->方法们 缓冲区中的索引，占 2 个字节
            索引 = 读_短大写();

            // 从 类->方法们 缓冲区取出方法
            方法 = &类->方法们.数据们[索引];

            // 如果方法不存在，则报错
            if ((uint32_t)索引 > 类->方法们.计数 || 方法->类型 == 方法类型_没有) {
                跑_错误大写("方法 \"%s\" 没找到!", 虚机针->全部方法名们.数据们[索引].串);
            }
            switch (方法->类型) {
                // 用 C 实现的原生方法
                case 方法类型_原语:
                    // 执行原生方法
                    if (方法->原语函(虚机针, 实参们)) {
                        // 如果返回结果为 true，说明原生方法执行正常，则回收该方法参数在运行时栈的空间
                        // 实参数 减 1 是为了避免回收第一个参数 实参们[0]
                        // 因为被调用的方法用 实参们[0] 存储返回值，并由于主调方和被调方的运行时栈接壤，
                        // 所以主调方才能在自己的栈顶（即此处的 实参们[0]）获取被调用方法的执行结果
                        // 注意：args[0] 所在的 slot 就是 栈起始[0]，即本方法运行时栈的起始
                        当前线程->栈指针 -= 实参数 - 1;
                    } else {
                        // 如果返回结果为 false，则有两种情况：
                        // 1. 方法执行出错，无法运行下去（例如 primThreadAbort 使线程报错或无错退出）
                        // 2. 被调用的方法调用 Thread.yield（该方法返回 false），主动交出使用权，让下一个线程运行
                        // 总结来说就是切换线程

                        // 首先备份当前帧栈 frame 对应的指令流进度指针 ip，以便后面重新回到该帧栈时，能够从之前指令流执行的位置继续执行
                        存储_当前帧大写();

                        // 如果 当前线程->错误对象 不为空，说明是第 1 种情况--方法执行出错，导致切换线程的
                        if (!值是否空指针大写(当前线程->错误对象)) {
                            // 直接报错
                            if (值是否对象串大写(当前线程->错误对象)) {
                                对象字符串大写 *错了 = 值到对象串大写(当前线程->错误对象);
                                printf("%s", 错了->值.起始);
                            }
                            // 并将该方法的错误返回值（位于第一个参数 实参们[0] 中，即运行时栈顶），置为 NULL
                            窥大写() = 值型到值大写(值型_空指针大写);
                        }

                        // 如果 虚机针->当前线程 为 NULL，说明没有待执行的线程了，因此虚拟机执行完毕
                        if (虚机针->当前线程 == NULL) {
                            return 虚拟机结果成功大写;
                        }

                        // 切换到下一个线程
                        当前线程 = 虚机针->当前线程;

                        // 加载 当前线程->帧们 中最新的帧栈 frame
                        载入_当前帧大写()
                    }
                    break;

                    // 用脚本语言实现的方法
                case 方法类型_脚本:
                    // 备份当前帧栈 frame 对应的指令流进度指针 指令指针_
                    存储_当前帧大写();
                    // 为线程 对象线程 中运行的函数闭包 对象闭包 准备帧栈 Frame，即闭包（函数或方法）的运行资源
                    // 该函数执行完之后，该函数创建的帧栈就是 当前线程->帧们 中最新的帧栈
                    创建帧(虚机针, 当前线程, (对象闭包大写 *)方法->对象了, 实参数);
                    // 加载 当前线程->帧们 中最新的帧栈 frame
                    载入_当前帧大写()
                    break;

                    // 关于函数对象的调用方法，用于实现函数重载，如 fun1.call()
                case 方法类型_函调用:
                    // 该类型的方法，实例对象本身就是待调用的函数（即第一个参数 实参们[0] 就是待调用的函数闭包）
                    断言大写(值是否对象闭包大写(实参们[0]), "实例必须是一个闭包!");
                    // 备份当前帧栈 frame 对应的指令流进度指针 指令指针_
                    存储_当前帧大写();
                    // 为线程 对象线程 中运行的函数闭包 对象闭包 准备帧栈 Frame，即闭包（函数或方法）的运行资源
                    // 该函数执行完之后，该函数创建的帧栈就是 当前线程->帧们 中最新的帧栈
                    // 注意：该类型的方法，实例对象本身就是待调用的函数（即第一个参数 实参们[0] 就是待调用的函数闭包）
                    创建帧(虚机针, 当前线程, 值到对象闭包大写(实参们[0]), 实参数);
                    // 加载 当前线程->帧们 中最新的帧栈 frame
                    载入_当前帧大写()
                    break;

                default:
                    不可达大写()
            }

            goto 环起始;
        }

        case 操作码之_超级0:
        case 操作码之_超级1:
        case 操作码之_超级2:
        case 操作码之_超级3:
        case 操作码之_超级4:
        case 操作码之_超级5:
        case 操作码之_超级6:
        case 操作码之_超级7:
        case 操作码之_超级8:
        case 操作码之_超级9:
        case 操作码之_超级10:
        case 操作码之_超级11:
        case 操作码之_超级12:
        case 操作码之_超级13:
        case 操作码之_超级14:
        case 操作码之_超级15:
        case 操作码之_超级16: {
            类大写 *类;   // 方法所属类
            int 索引;      // 方法在 类->方法们 缓冲区中的索引
            方法大写 *方法; // 方法
            值大写 *实参们;    // 方法参数
            int 实参数;     // 方法参数个数

            // 方法参数个数
            实参数 = 操作码乎 - 操作码之_超级0 + 1;

            // 在调用方法之前，会提前将参数压入到运行时栈中，压入顺序是先压入前面的参数
            // 因此 当前线程->栈指针 - 实参数 指向的是第 0 个参数
            实参们 = 当前线程->栈指针 - 实参数;

            // 背景知识：
            // OPCODE_SUPER x 的操作数有两个：
            // 第 1 个是方法在基类 超级类 中 方法们 的索引，即 超级类.方法们[方法索引]，占 2 个字节
            // 第 2 个是基类 超级类 在常量表 常量们 中的索引，即 常量们[超级类索引]，占 2 个字节
            // 先读入 2 个字节作为方法在基类中的索引
            索引 = 读_短大写();

            // 再读入 2 个字节作为基类在常量表中的索引
            uint16_t 超级类索引 = 读_短大写();

            // 然后从常量表中取出该基类
            类 = 值到类大写(函->常量们.数据们[超级类索引]);

            // 最后从基类的 方法们 即 类->方法们 缓冲区中取出方法
            方法 = &类->方法们.数据们[索引];

            // 如果方法不存在，则报错
            if ((uint32_t)索引 > 类->方法们.计数 || 方法->类型 == 方法类型_没有) {
                跑_错误大写("方法 \"%s\" 没找到!", 虚机针->全部方法名们.数据们[索引].串);
            }
            switch (方法->类型) {
                // 用 C 实现的原生方法
                case 方法类型_原语:
                    // 执行原生方法
                    if (方法->原语函(虚机针, 实参们)) {
                        // 如果返回结果为 true，说明原生方法执行正常，则回收该方法参数在运行时栈的空间
                        // 实参数 减 1 是为了避免回收第一个参数 实参们[0]
                        // 因为被调用的方法用 实参们[0] 存储返回值，并由于主调方和被调方的运行时栈接壤，
                        // 所以主调方才能在自己的栈顶（即此处的 实参们[0]）获取被调用方法的执行结果
                        // 注意：args[0] 所在的 slot 就是 栈起始[0]，即本方法运行时栈的起始
                        当前线程->栈指针 -= 实参数 - 1;
                    } else {
                        // 如果返回结果为 false，则有两种情况：
                        // 1. 方法执行出错，无法运行下去（例如 primThreadAbort 使线程报错或无错退出）
                        // 2. 被调用的方法调用 Thread.yield（该方法返回 false），主动交出使用权，让下一个线程运行
                        // 总结来说就是切换线程

                        // 首先备份当前帧栈 frame 对应的指令流进度指针 ip，以便后面重新回到该帧栈时，能够从之前指令流执行的位置继续执行
                        存储_当前帧大写();

                        // 如果 当前线程->错误对象 不为空，说明是第 1 种情况--方法执行出错，导致切换线程的
                        if (!值是否空指针大写(当前线程->错误对象)) {
                            // 直接报错
                            if (值是否对象串大写(当前线程->错误对象)) {
                                对象字符串大写 *错了 = 值到对象串大写(当前线程->错误对象);
                                printf("%s", 错了->值.起始);
                            }
                            // 并将该方法的错误返回值（位于第一个参数 实参们[0] 中，即运行时栈顶），置为 NULL
                            窥大写() = 值型到值大写(值型_空指针大写);
                        }

                        // 如果 虚机针->当前线程 为 NULL，说明没有待执行的线程了，因此虚拟机执行完毕
                        if (虚机针->当前线程 == NULL) {
                            return 虚拟机结果成功大写;
                        }

                        // 切换到下一个线程
                        当前线程 = 虚机针->当前线程;

                        // 加载 当前线程->帧们 中最新的帧栈 frame
                        载入_当前帧大写()
                    }
                    break;

                    // 用脚本语言实现的方法
                case 方法类型_脚本:
                    // 备份当前帧栈 frame 对应的指令流进度指针 指令指针_
                    存储_当前帧大写();
                    // 为线程 对象线程 中运行的函数闭包 对象闭包 准备帧栈 Frame，即闭包（函数或方法）的运行资源
                    // 该函数执行完之后，该函数创建的帧栈就是 当前线程->帧们 中最新的帧栈
                    创建帧(虚机针, 当前线程, (对象闭包大写 *)方法->对象了, 实参数);
                    // 加载 当前线程->帧们 中最新的帧栈 frame
                    载入_当前帧大写()
                    break;

                    // 关于函数对象的调用方法，用于实现函数重载，如 fun1.call()
                case 方法类型_函调用:
                    // 该类型的方法，实例对象本身就是待调用的函数（即第一个参数 实参们[0] 就是待调用的函数闭包）
                    断言大写(值是否对象闭包大写(实参们[0]), "实例必须是一个闭包!");
                    // 备份当前帧栈 frame 对应的指令流进度指针 指令指针_
                    存储_当前帧大写();
                    // 为线程 对象线程 中运行的函数闭包 对象闭包 准备帧栈 Frame，即闭包（函数或方法）的运行资源
                    // 该函数执行完之后，该函数创建的帧栈就是 当前线程->帧们 中最新的帧栈
                    // 注意：该类型的方法，实例对象本身就是待调用的函数（即第一个参数 实参们[0] 就是待调用的函数闭包）
                    创建帧(虚机针, 当前线程, 值到对象闭包大写(实参们[0]), 实参数);
                    // 加载 当前线程->帧们 中最新的帧栈 frame
                    载入_当前帧大写()
                    break;

                default:
                    不可达大写()
            }

            goto 环起始;
        }

        case 操作码之_载入上值:
            //【将自由变量的值（即指针 上值->本地变量指针 指向的局部变量的值）压入到运行时栈顶】
            // 操作数为自由变量在 上值们 数组中的索引，占 1 个字节
            推大写(*(当前帧->闭包->上值们[读_字节大写()]->本地变量指针));
            goto 环起始;

        case 操作码之_存储上值:
            //【将运行时栈顶的值保存为自由变量的值（即指针 上值->本地变量指针 指向的局部变量的值）】
            // 操作数为自由变量在 上值们 数组中的索引，占 1 个字节
            *(当前帧->闭包->上值们[读_字节大写()]->本地变量指针) = 窥大写();
            goto 环起始;

        case 操作码之_载入模块变量:
            //【将模块变量的值压入到运行时栈顶】
            // 操作数为模块变量在 模块变量值 缓冲区中的索引，占 2 个字节
            推大写(函->模块->模块变量值.数据们[读_短大写()]);
            goto 环起始;

        case 操作码之_存储模块变量:
            //【将运行时栈顶的值保存为模块变量的值】
            // 操作数为模块变量在 模块变量值 缓冲区中的索引，占 2 个字节
            函->模块->模块变量值.数据们[读_短大写()] = 窥大写();
            goto 环起始;

        case 操作码之_存储这个字段: {
            //【将运行时栈顶的值保存为 this 实例对象的属性值】
            // 操作数为该属性在实例对象 字段们 数组中的索引，占 1 个字节
            // 此时运行时栈底（即第 0 个 slot）的值就是实例对象，属性值就是存储在实例对象的 字段们 数组中

            uint8_t 字段索引 = 读_字节大写();

            // 此时运行时栈底（即第 0 个 slot）的值应该是实例对象，否则报错
            断言大写(值是否对象实例大写(栈起始[0]), "接收器应该是实例!");

            对象实例大写 *对象实例 = 值到对象实例大写(栈起始[0]);

            // 属性索引 应该小于 该实例对象所属的类的实例属性个数，否则报错
            断言大写(字段索引 < 对象实例->对象头部.类指针->字段数目了, "出界限字段!");

            // 从栈顶获取属性值后，写入到实例对象的 字段们 数组中
            对象实例->字段们[字段索引] = 窥大写();
            goto 环起始;
        }

        case 操作码之_载入字段: {
            //【将实例对象的属性值压入到运行时栈顶】
            // 操作数为该属性在实例对象 字段们 数组中的索引，占 1 个字节
            // 此时运行时栈顶应该是实例对象（在执行该指令之前，会先执行压入实例对象到栈顶的指令）
            uint8_t 字段索引 = 读_字节大写();

            值大写 接收器 = 弹大写();

            // 此时运行时栈顶应该是实例对象，否则报错
            断言大写(值是否对象实例大写(接收器), "接收器应该是实例!");

            对象实例大写 *对象实例 = 值到对象实例大写(接收器);

            // 属性索引 应该小于 该实例对象所属的类的实例属性个数，否则报错
            断言大写(字段索引 < 对象实例->对象头部.类指针->字段数目了, "出界限字段!");

            推大写(对象实例->字段们[字段索引]);
            goto 环起始;
        }

        case 操作码之_存储字段: {
            //【将运行时栈顶的值保存为实例对象的属性值】
            // 操作数为该属性在实例对象 字段们 数组中的索引，占 1 个字节
            // 此时运行时栈顶应该是实例对象，次栈顶为属性值
            uint8_t 字段索引 = 读_字节大写();

            值大写 接收器 = 弹大写();

            // 此时运行时栈顶应该是实例对象，否则报错
            断言大写(值是否对象实例大写(接收器), "接收器应该是实例!");

            对象实例大写 *对象实例 = 值到对象实例大写(接收器);

            // 属性索引 应该小于 该实例对象所属的类的实例属性个数，否则报错
            断言大写(字段索引 < 对象实例->对象头部.类指针->字段数目了, "出界限字段!");

            // 将次栈顶的值保存为实例对象的属性值
            对象实例->字段们[字段索引] = 窥大写();
            goto 环起始;
        }

        case 操作码之_跳: {
            //【指向即将执行的下一条指令的程序计数器 指令指针_ 向前跳，偏移量为 offset】
            // 操作数为偏移量 offset，占 2 个字节
            int16_t 偏移 = 读_短大写();
            // 偏移量必须为正数
            断言大写(偏移 > 0, "操作码之_跳的操作范围必须是正数!");
            指令指针_ += 偏移;
            goto 环起始;
        }

        case 操作码之_环: {
            //【程序计数器 指令指针_ 向回跳，偏移量为 offset】
            // 操作数为偏移量 offset，占 2 个字节
            int16_t 偏移 = 读_短大写();
            // 偏移量必须为正数
            断言大写(偏移 > 0, "操作码之_环的操作范围必须是正数!");
            指令指针_ -= 偏移;
            goto 环起始;
        }

        case 操作码之_跳若假: {
            //【如果栈顶的值（即条件）为 false，则程序计数器 指令指针_ 向前跳，偏移量为 offset】
            // 操作数为偏移量 offset，占 2 个字节
            int16_t 偏移 = 读_短大写();
            // 偏移量必须为正数
            断言大写(偏移 > 0, "操作码之_跳若假的操作范围必须是正数!");

            值大写 条件 = 弹大写();

            if (值是否假大写(条件) || 值是否空指针大写(条件)) {
                指令指针_ += 偏移;
            }
            goto 环起始;
        }

        case 操作码之_与: {
            //【如果栈顶的值（即条件）为 false，则程序计数器 指令指针_ 向前跳，偏移量为 offset，否则不跳】
            // 主要针对逻辑与运算，即 A && B，如果 A 为 true，则执行 B，否则就跳过 B，执行后面的代码
            // 操作数为偏移量 offset，占 2 个字节
            int16_t 偏移 = 读_短大写();
            // 偏移量必须为正数
            断言大写(偏移 > 0, "操作码之_与的操作范围必须是正数!");

            值大写 条件 = 窥大写();

            if (值是否假大写(条件) || 值是否空指针大写(条件)) {
                // 如果 条件 为 false，则不再计算 and 的右操作数，即跳过 and 的右操作数对应的指令流
                指令指针_ += 偏移;
            } else {
                // 否则仍需计算 and 的右操作数，丢弃栈顶的条件即可
                落下大写();
            }
            goto 环起始;
        }

        case 操作码之_或: {
            //【如果栈顶的值（即条件）为 true，则程序计数器 指令指针_ 向前跳，偏移量为 offset，否则不跳】
            // 主要针对逻辑与运算，即 A || B，如果 A 为 false，则执行 B，否则就跳过 B，执行后面的代码
            // 操作数为偏移量 offset，占 2 个字节
            int16_t 偏移 = 读_短大写();
            // 偏移量必须为正数
            断言大写(偏移 > 0, "操作码之_或'的操作范围必须是正数!");

            值大写 条件 = 窥大写();

            if (值是否假大写(条件) || 值是否空指针大写(条件)) {
                // 如果 条件 为 false，则仍需计算 or 的右操作数，丢弃栈顶的条件即可
                落下大写();
            } else {
                // 否则不再计算 or 的右操作数，即跳过 or 的右操作数对应的指令流
                指令指针_ += 偏移;
            }
            goto 环起始;
        }

        case 操作码之_关闭上值:
            // 【将自由变量中满足 **指向的局部变量在栈中的地址** 大于 **当前栈顶地址** 的自由变量 关闭】
            // 此时栈顶的值 *(当前线程->栈指针 - 1) 就是某个局部变量，对应有一个自由变量 上值 的 本地变量指针 指向这个局部变量
            // 现在是将所有自由变量中 满足 指向的局部变量在运行时栈中的地址 大于 栈顶的这个局部变量的地址 的自由变量关闭
            // 关闭是指在局部变量在运行时栈的空间被回收之前，将值保存到 上值->已关闭上值 中，然后将 上值->本地变量指针 转而指向 上值->已关闭上值
            // 目的是为了在局部变量在运行时栈的空间被回收之后，仍可以从 上值->已关闭上值 中访问到该局部变量的值
            // 因为自由变量就是指那些被内层函数所引用的外层函数的局部变量，在外层函数执行完被回收之后，内层函数可能没有被回收，仍需要访问所引用的外层函数的局部变量
            已关闭上值(当前线程, 当前线程->栈指针 - 1);
            // 将栈顶的局部变量丢弃
            落下大写();
            goto 环起始;

        case 操作码之_构造: {
            //【基于栈底的类创建实例对象，并存储到栈底】
            // 执行该指令时，栈底 栈起始[0] 应该是一个类（执行该指令之前，先执行 CREATE_CLASS 创建类并存储到栈底 栈起始[0]）
            断言大写(值是否类大写(栈起始[0]), "栈起始[0] 应该是一个操作码之_构造的类!");

            // 基于该类创建实例对象
            对象实例大写 *对象实例 = 新对象实例(虚机针, 值到类大写(栈起始[0]));

            // 将创建的实例对象存储到栈底 栈起始[0]
            栈起始[0] = 对象到值大写(对象实例);
            goto 环起始;
        }

        case 操作码之_返回: {
            //【结束函数的运行，并将栈顶的值作为返回值】
            // 通过 弹大写 从栈顶获取函数的执行结果，并作为返回值
            值大写 返的值 = 弹大写();

            // 已用帧数目 自减 1，结束该函数对应的帧栈 frame
            当前线程->已用帧数目--;

            // 关闭该函数对应的运行时栈中的自由变量 upvalue（即被内层函数引用的局部变量）（关闭自由变量具体和作用请看上面 CLOSE_UPVALUE 操作码的注释）
            已关闭上值(当前线程, 栈起始);

            // 如果 已用帧数目 减 1 后为 0，说明该线程 不再执行函数 或者 所有的函数调用都返回了，直接结束该线程即可
            if (当前线程->已用帧数目 == 0) {
                // 如果 调用者 为空，则说明该线程不是由另一个线程调用的，直接结束
                if (当前线程->调用者 == NULL) {
                    // 将返回值 返的值 放在 “大栈” 栈底 栈[0]
                    当前线程->栈[0] = 返的值;
                    // 然后将 “大栈” 的 栈指针 设置成 “大栈” 栈底加 1（注：esp 指针指向的是栈中下一个可写入数据的 slot，即栈顶的后一个 slot）
                    // 即回收除了栈底 栈[0] 之外的其余 “大栈” 空间
                    当前线程->栈指针 = 当前线程->栈 + 1;
                    // 宣告虚拟机成功执行结束
                    return 虚拟机结果成功大写;
                }

                // 如果 调用者 不为空，则说明该线程是由另一个线程调用的，就将控制权交给调用方
                //（调用一个线程时候，会在被调用线程的 调用者 记录主调用方线程）
                // 获取主调用方线程
                对象线程大写 *调用者线程 = 当前线程->调用者;
                // 将当前线程变量改为主调用方线程
                当前线程 = 调用者线程;
                虚机针->当前线程 = 调用者线程;

                // 将被调用方线程的返回值保存到主调用方线程的栈顶
                // （注：esp 指针指向的是栈中下一个可写入数据的 slot，即栈顶的后一个 slot）
                当前线程->栈指针[-1] = 返的值;
            } else {
                // 如果 已用帧数目 减 1 后不为 0，说明该线程中的函数调用链尚未返回到最上层函数
                // 需要将本函数的返回值（从函数运行时栈顶获取的值）放在函数运行时栈底 栈起始[0]
                // 这样调用方才能在它的运行时栈顶获取到该函数的返回值（调用方和被调用方的运行时栈是接壤的，被调用方的运行时栈在调用方的运行时栈之上）
                栈起始[0] = 返的值;
                // 然后将 “大栈” 的 栈指针 设置成函数运行时栈底 栈起始[0] 的后一个 slot（注：esp 指针指向的是栈中下一个可写入数据的 slot，即栈顶的后一个 slot）
                // 也就是将除了函数返回值所在的 slot--栈起始[0] 之外，该函数的所有的 slot 均回收掉（包括函数的参数）
                当前线程->栈指针 = 栈起始 + 1;
            }
            载入_当前帧大写()
            goto 环起始;
        }

        case 操作码之_创建类: {
            //【创建子类】
            // 此时操作数为子类的实例属性个数，栈顶的值为基类（本次创建的类需要继承的类），次栈顶的值为子类名
            uint32_t 字段数目 = 读_字节大写();
            值大写 超级类 = 窥大写();
            值大写 类名 = 窥大写2();

            // 保存子类名的次栈顶空间暂时保留，后面创建类会直接用到该空间
            // 回收保存基类的栈顶空间，此时上面的次栈顶就变成了栈顶
            落下大写();

            // 创建子类之前，先校验基类的合法性
            有效的超级类(虚机针, 类名, 字段数目, 超级类);

            // 调用 新类 创建子类
            类大写 *类 = 新类(虚机针, 值到对象串大写(类名), 字段数目, 值到类大写(超级类));

            // 将创建的子类存储到函数运行时栈底 栈起始[0]
            // 因此时并没有实际应用运行时栈（例如在栈中分配局部变量的空间或压入函数的参数）
            // 所以此时的栈底就是栈顶，也就是说栈底 栈起始[0] 就是之前保存子类名的次栈顶空间
            栈起始[0] = 对象到值大写(类);
            goto 环起始;
        }

        case 操作码之_实例方法:
        case 操作码之_静止方法: {
            //【将实例方法/静态方法绑定到指定类上】
            // 操作数为待绑定的方法名在 虚机针->全部方法名们 数组中的索引
            // 栈顶的值为待绑定的类，次栈顶的值为待绑定的方法体

            // 待绑定的方法名在 虚机针->全部方法名们 数组中的索引
            uint32_t 方法名索引 = 读_短大写();
            // 待绑定的类
            类大写 *类 = 值到类大写(窥大写());
            // 待绑定的方法体（是执行 CREATE_CLOSURE 对应指令后，生成方法体并压入到栈中）
            值大写 方法 = 窥大写2();

            // 将实例方法/静态方法绑定到指定类上
            绑方法与补丁(虚机针, 操作码乎, 类, 方法名索引, 方法);

            // 回收栈顶和次栈顶的空间
            落下大写();
            落下大写();
            goto 环起始;
        }

        case 操作码之_创建闭包: {
            //【创建函数闭包】
            // 操作数包含两部分：1. 待创建闭包的函数在常量表中的索引（占两个字节） 2. 函数所引用的自由变量数 *  {是否封闭的本地变量, 索引}
            // 其中 是否封闭的本地变量 表示 上值 是否是直接外层编译单元中的局部变量
            // 如果是，则 索引 表示的是此 上值 在直接外层编译单元的局部变量在该编译单元运行时栈的索引
            // 如果不是，则 索引 表示的是此 上值 在直接外层编译单元的 上值 的索引

            // 在执行该指令之前，待创建闭包的函数已经添加进了常量表（endCompileUnit 函数完成的），直接从常量表中取出该函数
            对象函大写 *对象函 = 值到对象函大写(函->常量们.数据们[读_短大写()]);

            // 基于该函数创建闭包
            对象闭包大写 *对象闭包 = 新对象闭包(虚机针, 对象函);

            // 将上面创建好的闭包压入到运行时栈顶
            推大写(对象到值大写(对象闭包));

            // 然后将该函数引用的自由变量添加到该函数闭包的 上值们 数组中
            uint32_t 索引了 = 0;
            while (索引了 < 对象函->上值数目) {
                uint8_t 是否封闭的本地变量 = 读_字节大写();
                uint8_t 索引 = 读_字节大写();

                // 是否封闭的本地变量 表示 上值 是否是直接外层编译单元中的局部变量
                // 如果是，则 索引 表示的是此 上值 在直接外层编译单元的局部变量在该编译单元运行时栈的索引
                // 如果不是，则 索引 表示的是此 上值 在直接外层编译单元的 上值 的索引
                if (是否封闭的本地变量) {
                    // 如果 是否封闭的本地变量 为 true，则表示该函数引用的是直接外层函数的局部变量，index 值表示是该局部变量在直接外层函数中局部变量数组中的索引
                    // 则需要先基于该局部变量创建自由变量，然后添加该自由变量到该函数闭包的 上值们 数组中
                    // 此时 索引 表示该局部变量在直接外层函数的运行时栈中的索引，也就是现在正在执行的函数--直接外层函数
                    // 所以 当前函数（即直接外层函数）的运行时栈底内存地址 + 索引 = 该局部变量内存地址，即 当前帧->栈起始 + 索引
                    对象闭包->上值们[索引了] = 创建打开上值(虚机针, 当前线程, 当前帧->栈起始 + 索引);
                } else {
                    // 如果 是否封闭的本地变量 为 false，则表示该函数引用的不是直接外层函数的局部变量，而是更外层函数中的局部变量，
                    // 对于直接外层函数来说，该变量也是自由变量
                    // 也就是说，无论内层函数引用的 上值 指向的是哪一个外层函数的局部变量，
                    // 内层函数和该外层函数之间的所有中间层函数都会将该局部变量作为自己的自由变量 上值 ，存储到中间层函数自己的 compileUnit->上值们 数组中
                    // 所以可以直接从直接外层函数的自由变量数组获取即可
                    // 当前就是在执行直接外层函数，所以 当前帧->闭包->上值们 就是直接外层函数的自由变量数组
                    对象闭包->上值们[索引了] = 当前帧->闭包->上值们[索引];
                }

                索引了++;
            }

            goto 环起始;
        }

        case 操作码之_终:
            不可达大写()

        default:
            不可达大写()
    }
    不可达大写()

#undef 推大写
#undef 弹大写
#undef 落下大写
#undef 窥大写
#undef 窥大写2
#undef 读_字节大写
#undef 读_短大写
#undef 存储_当前帧大写
#undef 载入_当前帧大写
}


//*************垃圾回收.c********************

// 释放 对象 自身及其占用的内存
void 自由对象(虚拟机大写 *虚机针, 对象头部大写 *对象) {
    // 根据对象类型分别处理
    switch (对象->类型) {
        case 对类_类大写:
            方法大写缓冲区清除大写(虚机针, &((类大写 *)对象)->方法们);
            break;

        case 对类_线程大写: {
            对象线程大写 *对象线程 = (对象线程大写 *)对象;
            反分配大写(虚机针, 对象线程->帧们);
            反分配大写(虚机针, 对象线程->栈);
            break;
        }

        case 对类_函数大写: {
            对象函大写 *函了 = (对象函大写 *)对象;
            值大写缓冲区清除大写(虚机针, &函了->常量们);
            字节大写缓冲区清除大写(虚机针, &函了->指令流);
            break;
        }

        case 对类_列表大写:
            值大写缓冲区清除大写(虚机针, &((对象列表大写 *)对象)->元素们);
            break;

        case 对类_映射大写:
            反分配大写(虚机针, ((对象映射大写 *)对象)->条目们);
            break;

        case 对类_模块大写:
            字符串大写缓冲区清除大写(虚机针, &((对象模块大写 *)对象)->模块变量名);
            值大写缓冲区清除大写(虚机针, &((对象模块大写 *)对象)->模块变量值);
            break;

        case 对类_字符串大写:
        case 对类_范围大写:
        case 对类_闭包大写:
        case 对类_实例大写:
        case 对类_上值大写:
            break;
    }

    // 最后再释放自己
    反分配大写(虚机针, 对象);
}