#include <string.h>
#if 调试大写
#include "调试.h"
#endif

#include "底头.h"


// 定义编译单元的结构
// 注：编译单元就是指令流，例如函数、类的方法等独立的指令流都是编译单元
struct 编译单元 {
    // 所编译的函数，用于存储编译单元的指令
    对象函大写 *函;

    // 编译单元中局部变量的集合
    本地变量大写 本地变量们[最大本地变量数目了大写];

    // 已经分配的局部变量个数
    uint32_t 本地变量数目了;

    // 本层函数索所引用的 upvalue 的集合
    上值大写 上值们[最大上值数目了大写];

    // 表示正在编译的代码所在的作用域
    // 注：-1 表示模块作用域，0 表示最外层，1 以上表示相应的嵌套层
    int 作用域深度;

    // 表示该编译单元内所有指令对运行时栈的最终影响
    // 注：函数或方法运行时需要运行时栈，栈的大小不仅受参数个数和局部变量个数影响，指令也可能会操作栈（压栈/弹栈）
    uint32_t 栈槽数目了;

    // 当前正在编译的循环层
    环大写 *当前环;

    // 用于记录正在编译的类的编译信息，便于语法检查
    类书保持大写 *封闭的类BK;

    // 包含该编译单元的编译单元，即直接外层编译单元
    struct 编译单元 *封闭的单元;

    // 当前词法解析器
    // 注：每个模块都有一个单独的词法分析器
    词法器大写 *当前词法器;
};

// 将 opcode 对运行时栈大小的影响定义到数组 opCodeSlotsUsed 中
#define 操作码槽们大写(操作的码, 效果) 效果,

// 通过上面对 OPCODE_SLOTS 的宏定义，可以获取到加了操作码对运行时栈大小的影响
// 例如 OPCODE_SLOTS(LOAD_CONSTANT, 1) 返回的是 1，也即是说执行 LOAD_CONSTANT 操作码后会使运行时栈增加一个 slot
// 然后将这些指令对运行时栈大小的影响集合，定义到 opCodeSlotsUsed 数组中
// 之所以后面又将宏定义 OPCODE_SLOTS 取消定义，是因为其他地方也需要自定义 OPCODE_SLOTS 宏的逻辑，来获取不同的数据
static const int 操作码槽们已用[] = {
#include "操作码.inc"
};
#undef 操作码槽们大写

// 按照所处作用域类型划分变量类型
typedef enum {
    变量作用域_无效大写,
    变量作用域_本地大写,   // 局部变量
    变量作用域_上值大写, // upvalue 变量
    变量作用域_模块大写   // 模块变量
} 变量作用域类型大写;

// 变量结构体，用于内部变量查找
typedef struct
{
    变量作用域类型大写 作用域类型; // 变量类型
    int 索引;              // 指向变量
} 变量大写;

// 定义操作符的绑定权值，即优先级
// 从上到下优先级递增
typedef enum {
    绑力量_没有大写,      // 无绑定能力
    绑力量_最低的大写,    // 最低绑定能力
    绑力量_赋值大写,    // =
    绑力量_条件大写, // ?:
    绑力量_逻辑或大写,  // ||
    绑力量_逻辑与大写, // &&
    绑力量_等于大写,     // == !=
    绑力量_是大写,        // is
    绑力量_对比大写,       // < > <= >=
    绑力量_位或大写,    // |
    绑力量_位与大写,   // &
    绑力量_位移大写, // << >>
    绑力量_范围大写,     // ..
    绑力量_术语大写,      // + -
    绑力量_因子大写,    // * / %
    绑力量_一元大写,     // - ! ~
    绑力量_调用大写,      // . () []
    绑力量_最高大写    // 最高绑定能力
} 绑力量大写;

// 函数指针，用于指向各种符号的 空指针外延 和 左外延 方法
typedef void (*外延函)(编译单元大写 *编单针, 布尔 能分配);

// 函数指针，用于指向类的方法（方法会用方法签名作为 ID）
typedef void (*方法签名函)(编译单元大写 *编单针, 签名大写 *签名);

// 符号绑定规则
typedef struct
{
    const char *身份也;               // 符号的字符串
    绑力量大写 左绑力量;                // 左绑定权值，不关心左操作数的符号该值为 0
    外延函 空指针外延;             // 字面量、变量、前缀运算符等不关心左操作数的 牌大写 调用该方法
    外延函 左外延;             // 中缀运算符等关心左操作数的 牌大写 调用该方法
    方法签名函 方法签名了; // 表示该符号在类中被视为一个方法，所以为其生成一个方法签名，语义分析中涉及方法签名生成指令
} 符号绑规则大写;

static uint32_t 加上常量(编译单元大写 *编单针, 值大写 常量);
static void 表达式(编译单元大写 *编单针, 绑力量大写 右绑力量);
static void 编译程序(编译单元大写 *编单针);
static void 中缀操作者(编译单元大写 *编单针, 布尔 能分配 未使用大写);
static void 一元操作者(编译单元大写 *编单针, 布尔 能分配 未使用大写);
static void 编译语句(编译单元大写 *编单针);

// 初始化编译单元 编译单元大写
// enclosingUnit 表示直接外层编译单元
// 是否方法 表示是否是类的方法
static void 初始编译单元(词法器大写 *词法器, 编译单元大写 *编单针, 编译单元大写 *封闭的单元, 布尔 是否方法) {
    词法器->当前编译单元 = 编单针;
    编单针->当前词法器 = 词法器;
    编单针->封闭的单元 = 封闭的单元;
    编单针->当前环 = NULL;
    编单针->封闭的类BK = NULL;

    // 三种情况：1. 模块中直接定义一级函数  2. 内层函数  3. 内层方法（即类的方法）

    // enclosingUnit == NULL 说明没有直接外层单元，即当前处在模块的编译单元，也就是正在编译模块
    if (封闭的单元 == NULL) {
        // 1. 模块中直接定义一级函数，即没有外层函数
        // 当前作用域就是模块作用域
        // 因为编译代码是从上到下从外到内的顺序，即从模块作用域开始，而模块作用域值为 -1
        编单针->作用域深度 = -1;
        // 模块作用域中没有局部变量
        编单针->本地变量数目了 = 0;
    } else {
        // 3. 内层方法（即类的方法）
        if (是否方法) {
            // 如果是类的方法，默认设定隐式 this 为第 0 个局部变量（this 指向的即对象实例对象）
            编单针->本地变量们[0].名称 = "这个";
            编单针->本地变量们[0].长度 = 4;
        } else {
            // 2. 内层函数
            // 为了和类的方法保持统一，会空出第 0 个局部变量
            编单针->本地变量们[0].名称 = NULL;
            编单针->本地变量们[0].长度 = 0;
        }

        // 第 0 个局部变量比较特殊，作用域设置为模块级别
        编单针->本地变量们[0].作用域深度 = -1;
        // 该变量不可能是 upvalue，因内层函数不可能引用上层的 this 对象，this 只能暴露给本层对象
        编单针->本地变量们[0].是否上值 = 假;

        // 第 0 个局部变量已经被分配了，因此初始化为 1
        编单针->本地变量数目了 = 1;

        // 函数或方法只会在第 0 层局部变量出现
        编单针->作用域深度 = 0;
    }

    // 对于基于栈的虚拟机，局部变量是保存在运行时栈的
    // 因此初始化运行时栈时，其大小等于局部变量的大小
    编单针->栈槽数目了 = 编单针->本地变量数目了;

    // 新建 objFn 对象，用于存储编译单元的指令流
    编单针->函 = 新对象函(编单针->当前词法器->虚机针, 编单针->当前词法器->当前模块, 编单针->本地变量数目了);
}

// 向函数的指令流中写入 1 字节，返回其索引
static int 写字节(编译单元大写 *编单针, int 字节) {
#if 调试大写
    // 调试状态时，还需要额外在 fn->调试->行号 中写入当前 token 所在行号，方便调试
    整型大写缓冲区添加大写(编单针->当前词法器->虚机针, &编单针->函->调试->行号, 编单针->当前词法器->前一个牌.行号);
#endif

    字节大写缓冲区添加大写(编单针->当前词法器->虚机针, &编单针->函->指令流, (uint8_t)字节);
    return 编单针->函->指令流.计数 - 1;
}

// 向函数的指令流中写入操作码
static void 写操作码(编译单元大写 *编单针, 操作码枚举大写 操作的码) {
    写字节(编单针, 操作的码);
    // 计算该编译单元需要用到的运行时栈总大小
    // opCode 为操作符集合对应的枚举数据，值为对应的索引值
    // 而 opCodeSlotsUsed 也是基于操作符集合生成的数组
    // 因此可以通过索引值找到操作符对应的该操作符执行后对运行时栈大小的影响
    编单针->栈槽数目了 += 操作码槽们已用[操作的码];
    // 如果计算的累计需要运行时栈大小大于当前最大运行时栈使用大小，则更新当前运行时栈使用大小
    // 注意：这里记录的是运行过程中使用 slot 数量最多的情况，即记录栈使用过程中的峰值
    // 因为指令对栈大小的影响有正有负，stackSlotNum 运行到最后可能为 0
    // 但运行过程中对栈的使用量不可能为 0
    if (编单针->栈槽数目了 > 编单针->函->最大栈槽已用数目) {
        编单针->函->最大栈槽已用数目 = 编单针->栈槽数目了;
    }
}

// 写入 1 个字节的操作数
static int 写字节操作范围(编译单元大写 *编单针, int 操作范围) {
    return 写字节(编单针, 操作范围);
}

// 写入 2 个字节的操作数
// 按照大端字节序写入参数，低地址写高位，高地址写低位
inline static void 写短操作范围(编译单元大写 *编单针, int 操作范围) {
    写字节(编单针, (操作范围 >> 8) & 0xff); // 先取高 8 位的值，也就是高地址的字节
    写字节(编单针, 操作范围 & 0xff);        // 后取低 8 位的值，也就是低地址的字节
}

// 写入操作数为 1 字节大小的指令
static int 写操作码字节操作范围(编译单元大写 *编单针, 操作码枚举大写 操作的码, int 操作范围) {
    // 1. 写操作码
    写操作码(编单针, 操作的码);
    // 2. 写操作数
    return 写字节操作范围(编单针, 操作范围);
}

// 写入操作数为 2 字节大小的指令
static void 写操作码短操作范围(编译单元大写 *编单针, 操作码枚举大写 操作的码, int 操作范围) {
    // 1. 写操作码
    写操作码(编单针, 操作的码);
    // 2. 写操作数
    写短操作范围(编单针, 操作范围);
}

// 获取 指令指针 所指向的操作码的操作数占用的字节数
uint32_t 获取操作范围们的字节们(const 字节大写 *指令流, 值大写 *常量们, int 指令指针) {
    switch ((操作码枚举大写)指令流[指令指针]) {
        case 操作码之_构造:
        case 操作码之_返回:
        case 操作码之_终:
        case 操作码之_关闭上值:
        case 操作码之_推空指针:
        case 操作码之_推假:
        case 操作码之_推真:
        case 操作码之_弹:
            return 0;

        case 操作码之_创建类:
        case 操作码之_载入这个字段:
        case 操作码之_存储这个字段:
        case 操作码之_载入字段:
        case 操作码之_存储字段:
        case 操作码之_载入本地变量:
        case 操作码之_存储本地变量:
        case 操作码之_载入上值:
        case 操作码之_存储上值:
            return 1;

        case 操作码之_调用0:
        case 操作码之_调用1:
        case 操作码之_调用2:
        case 操作码之_调用3:
        case 操作码之_调用4:
        case 操作码之_调用5:
        case 操作码之_调用6:
        case 操作码之_调用7:
        case 操作码之_调用8:
        case 操作码之_调用9:
        case 操作码之_调用10:
        case 操作码之_调用11:
        case 操作码之_调用12:
        case 操作码之_调用13:
        case 操作码之_调用14:
        case 操作码之_调用15:
        case 操作码之_调用16:
        case 操作码之_载入常量:
        case 操作码之_载入模块变量:
        case 操作码之_存储模块变量:
        case 操作码之_环:
        case 操作码之_跳:
        case 操作码之_跳若假:
        case 操作码之_与:
        case 操作码之_或:
        case 操作码之_实例方法:
        case 操作码之_静止方法:
            return 2;

        case 操作码之_超级0:
        case 操作码之_超级1:
        case 操作码之_超级2:
        case 操作码之_超级3:
        case 操作码之_超级4:
        case 操作码之_超级5:
        case 操作码之_超级6:
        case 操作码之_超级7:
        case 操作码之_超级8:
        case 操作码之_超级9:
        case 操作码之_超级10:
        case 操作码之_超级11:
        case 操作码之_超级12:
        case 操作码之_超级13:
        case 操作码之_超级14:
        case 操作码之_超级15:
        case 操作码之_超级16:
            // OPCODE_SUPER x 的操作数是分别由 写操作码短操作范围
            // 和 写短操作范围 写入的,共 1 个操作码和 4 个字节的操作数
            return 4;

        case 操作码之_创建闭包: {
            // 操作码 操作码之_创建闭包 的操作数是待创建闭包的函数在常量表中的索引，占 2 个字节

            // 但当虚拟机执行该命令时，已经在直接外层编译单元了，是没办法直到内层函数 upvalue 数组 编单针->upvalues 中哪些是直接外层编译单元的局部变量，哪些是直接外层编译单元的 upvalue
            // 只有知道，才能在运行时栈找到对应的值，所以需要将 是直接外层编译单元的局部变量还是 upvalue 信息记录下来
            // 这里就直接写入了直接外层编译单元的指令流 编单针->enclosingUnit->fn->指令流 中
            // 按照 {upvalue 是否是直接编译外层单元的局部变量，upvalue 在直接外层编译单元的索引} 成对信息写入的（占两个字节），该逻辑在 终编译单元 函数中

            // 所以最终操作数的字节数为 2 + 上值数目 * 2

            // 按照大端字节序，其中 指令流[指令指针 + 1] 为操作数中的低位地址端，保存的是索引的高 8 位
            // 指令流[指令指针 + 2] 为操作数中的高位地址端，保存的是索引的低 8 位，下面就是基于两个字节的操作数的值计算出函数在常量表中的索引值
            uint32_t 函索引 = (指令流[指令指针 + 1] << 8) | 指令流[指令指针 + 2];

            return 2 + (值到对象函大写(常量们[函索引]))->上值数目 * 2;
        }

        default:
            不可达大写()
    }
}

// 向编译单元中 fn->常量们 中添加常量，并返回索引
static uint32_t 加上常量(编译单元大写 *编单针, 值大写 常量) {
    值大写缓冲区添加大写(编单针->当前词法器->虚机针, &编单针->函->常量们, 常量);
    return 编单针->函->常量们.计数 - 1;
}

// 生成【加载常量到常量表，并将常量压入到运行时栈顶】的指令
static void 发射载入常量(编译单元大写 *编单针, 值大写 常量) {
    // 1. 将常量通过 加上常量 加载到常量表，并获取其在常量表中的索引 索引
    int 索引 = 加上常量(编单针, 常量);
    // 2. 生成【将常量压入到运行时栈顶】的指令
    写操作码短操作范围(编单针, 操作码之_载入常量, 索引);
}

// 将方法的签名对象转化成字符串
static uint32_t 签名到字符串(签名大写 *签名, char *缓冲了) {
    uint32_t 位置了 = 0;

    // 将方法签名中的方法名 xxx 复制到 buf 中
    memcpy(缓冲了 + 位置了, 签名->名称, 签名->长度);
    位置了 += 签名->长度;

    switch (签名->类型) {
        // getter 方法无参数，形式是： xxx
        case 签名_获取者大写:
            break;
        // setter 方法只有一个参数，形式是：xxx=(_)
        case 签名_集者大写: {
            缓冲了[位置了++] = '=';
            缓冲了[位置了++] = '(';
            缓冲了[位置了++] = '_';
            缓冲了[位置了++] = ')';
            break;
        }
        // 构造函数和普通方法形式是：xxx(_,...)
        case 签名_构造大写:
        case 签名_方法大写: {
            缓冲了[位置了++] = '(';
            uint32_t 索引了 = 0;
            while (索引了 < 签名->实参数目了) {
                缓冲了[位置了++] = '_';
                缓冲了[位置了++] = ',';
                索引了++;
            }

            if (索引了 == 0) {
                // 说明没有参数
                缓冲了[位置了++] = ')';
            } else {
                // 有参数的话则将最后多出来的 , 覆盖成 )
                缓冲了[位置了 - 1] = ')';
            }
            break;
        }
        // subscribe 方法形式：xxx[_,...]
        case 签名_子脚本大写: {
            缓冲了[位置了++] = '[';
            uint32_t 索引了 = 0;
            while (索引了 < 签名->实参数目了) {
                缓冲了[位置了++] = '_';
                缓冲了[位置了++] = ',';
                索引了++;
            }

            if (索引了 == 0) {
                // 说明没有参数
                缓冲了[位置了++] = ']';
            } else {
                // 有参数的话则将最后多出来的 , 覆盖成 )
                缓冲了[位置了 - 1] = ']';
            }
            break;
        }
        // subscribe setter 方法形式：xxx[_,...] = (_)
        // 这里处理的是等号左边的参数，因此需要减 1
        case 签名_子脚本的集者大写: {
            缓冲了[位置了++] = '[';
            uint32_t 索引了 = 0;
            while (索引了 < 签名->实参数目了 - 1) {
                缓冲了[位置了++] = '_';
                缓冲了[位置了++] = ',';
                索引了++;
            }

            if (索引了 == 0) {
                // 说明没有参数
                缓冲了[位置了++] = ']';
            } else {
                // 有参数的话则将最后多出来的 , 覆盖成 )
                缓冲了[位置了 - 1] = ']';
            }
            缓冲了[位置了++] = '=';
            缓冲了[位置了++] = '(';
            缓冲了[位置了++] = '_';
            缓冲了[位置了++] = ')';
            break;
        }
        default:
            break;
    }
    缓冲了[位置了] = '\0';
    return 位置了;
}

// 添加局部变量到编译单元 编单针 的 localVars 数组中，并返回该变量的索引值
static uint32_t 加上本地变量(编译单元大写 *编单针, const char *名称, uint32_t 长度) {
    本地变量大写 *变量 = &(编单针->本地变量们[编单针->本地变量数目了]);
    变量->名称 = 名称;
    变量->长度 = 长度;
    变量->作用域深度 = 编单针->作用域深度;
    变量->是否上值 = 假;
    return 编单针->本地变量数目了++;
}

// 声明局部变量（最后会调用上面的 addLocalVar）
static int 声明本地变量(编译单元大写 *编单针, const char *名称, uint32_t 长度) {
    // 一个编译单元中所有局部作用域的局部变量总数不能超过 MAX_LOCAL_VAR_NUM，即 128 个
    if (编单针->本地变量数目了 > 最大本地变量数目了大写) {
        编译_错误大写(编单针->当前词法器, "一个编译单元(例如函数)的最大本地变量数目是 %d", 最大本地变量数目了大写);
    }

    // 检测当前作用域是否存在同名变量
    // 之所以倒序遍历，是因为 scopeDepth 是随着作用域越深（越局部）而越大，而 本地变量们 数组中的局部变量是按照作用域的深度递增排列，
    // 即越深的作用域变量越排在 localVars 数组中的后面
    // 所以只需要从后向前遍历，最后的变量始终是当前作用域的变量
    int 索引了 = (int)编单针->本地变量数目了 - 1;

    while (索引了 >= 0) {
        本地变量大写 *变量 = &编单针->本地变量们[索引了];

        // 当向前遍历时发现已经进入到父级作用域，则退出
        // 因为只需要检测同一个局部作用域下是否存在变量名冲突
        if (变量->作用域深度 < 编单针->作用域深度) {
            break;
        }

        // 如果在同一个局部作用域下之前已声明同名的局部变量，则报错
        if (变量->长度 == 长度 && memcmp(变量->名称, 名称, 长度) == 0) {
            char 身份也[最大身份长度了大写] = {'\0'};
            memcpy(身份也, 名称, 长度);
            编译_错误大写(编单针->当前词法器, "标识符 \"%s\" 重新定义!", 身份也);
        }

        索引了--;
    }

    // 如果既没有超出最大局部变量数量限制，也没有同名局部变量已声明
    // 则直接添加局部变量到 编单针 的 localVars 数组中
    return 加上本地变量(编单针, 名称, 长度);
}

// 根据作用域的类型声明变量，即声明模块变量还是局部变量
static int 声明变量之(编译单元大写 *编单针, const char *名称, uint32_t 长度) {
    // 如果为模块作用域，则声明为模块变量
    if (编单针->作用域深度 == -1) {
        // 先将变量值初始化为 NULL
        int 索引 = 定义模块变量(编单针->当前词法器->虚机针, 编单针->当前词法器->当前模块, 名称, 长度, 值型到值大写(值型_空指针大写));

        // 如果同名模块变量为已经定义，则报错
        if (索引 == -1) {
            char 身份也[最大身份长度了大写] = {'\0'};
            memcpy(身份也, 名称, 长度);
            编译_错误大写(编单针->当前词法器, "标识符 \"%s\" 重新定义!", 身份也);
        }
        return 索引;
    }

    // 否则为局部作用域，声明为局部变量
    return 声明本地变量(编单针, 名称, 长度);
}

// 查找局部变量
static int 找本地变量了(编译单元大写 *编单针, const char *名称, uint32_t 长度) {
    // 内层作用域的变量会覆盖外层
    // 而 localVars 数组中的局部变量是按照作用域的深度递增排列，即越深的作用域变量越排在 本地变量们 数组中的后面
    // 所以只需要从后向前遍历，即从内层向外找
    int 索引 = 编单针->本地变量数目了 - 1;
    while (索引 >= 0) {
        if (编单针->本地变量们[索引].长度 == 长度 && memcmp(编单针->本地变量们[索引].名称, 名称, 长度) == 0) {
            return 索引;
        }
        索引--;
    }
    return -1;
}

// 丢掉作用域 scopeDepth 以内（包括子作用域）的局部变量
// 返回被丢掉的局部变量的个数
static uint32_t 抛弃本地变量了(编译单元大写 *编单针, int 作用域深度) {
    // 如果 编单针->scopeDepth == -1 ，即当前处在模块作用域中，则报错，因为模块作用域作为顶级作用域不能退出，确保类的静态属性得以保留
    断言大写(编单针->作用域深度 > -1, "最上层作用域不能到出口!");
    int 索引了 = 编单针->本地变量数目了 - 1;

    // 背景知识：
    // localVars 数组中的局部变量是按照作用域的深度递增排列，即越深的作用域变量越排在 本地变量们 数组中的后面
    // 作用域的 scopeDepth 范围大于 -1 的整数，作用域越深，值就越大，-1 表示模块作用域
    // 所以遍历作用域 scopeDepth 以内（包括子作用域）的局部变量，只需要从 本地变量们 数组后面开始遍历，
    // 并且保证变量所在作用域的 scopeDepth 小于传入的 scopeDepth 即可
    while (索引了 >= 0 && 编单针->本地变量们[索引了].作用域深度 >= 作用域深度) {
        if (编单针->本地变量们[索引了].是否上值) {
            // 如果该局部变量被内层函数使用，即对内层函数来说是自由变量 upvalue
            // 则生成【运行时栈顶保存的是地址界限，关闭地址大于地址界限的 upvalue，然后将运行时栈顶弹出】的指令
            // TODO: 没太搞懂该指令在这里的作用，后续实现虚拟机时再回填
            写字节(编单针, 操作码之_关闭上值);
        } else {
            // 否则该局部变量没有被被内层函数使用，只是普通局部变量
            // 则生成【将运行时栈顶弹出】的指令
            // TODO: 没太搞懂该指令在这里的作用，后续实现虚拟机时再回填
            写字节(编单针, 操作码之_弹);
        }
        // 此处之所以使用 写字节 而不是 writeOpCode，目的是不想影响 编单针->函->最大栈槽已用数目
        // 注：writeOpCode 函数中，不仅向指令流中写入指令，还会计算该指令对运行时栈大小的影响，并实时更新 编单针->函->最大栈槽已用数目
        // 因为局部变量是存储在运行时栈中的，退出作用域后函数的运行时栈并未回收，也就是说变量仍然在运行时栈中，不可影响的实际的栈大小
        // TODO: 没太搞懂该指令在这里的作用，后续实现虚拟机时再回填
        索引了--;
    }

    // 返回被丢掉的局部变量的个数
    return 编单针->本地变量数目了 - 1 - 索引了;
}

// 添加自由变量 upvalue
// 添加 upvalue 到 编单针->upvalues，并返回其索引值，若以存在则只返回索引即可
// 是否封闭的本地变量 表示 upvalue 是否是直接外层编译单元中的局部变量
// 如果是，则 index 表示的是此 upvalue 在直接外层编译单元的局部变量在该编译单元运行时栈的索引
// 如果不是，则 index 表示的是此 upvalue 在直接外层编译单元的 upvalue 的索引
// 也就是说内层函数可能引用的不是直接外层函数的局部变量，而是更外层函数的局部变量
// 注：upvalue 是针对引用外层函数局部变量的内层函数的
static int 加上上值(编译单元大写 *编单针, 布尔 是否封闭的本地变量, uint32_t 索引) {
    uint32_t 索引了 = 0;
    while (索引了 < 编单针->函->上值数目) {
        // 如果该 upvalue 已经添加过，则直接返回其索引值
        if (编单针->上值们[索引了].索引 == 索引 && 编单针->上值们[索引了].是否封闭的本地变量 == 是否封闭的本地变量) {
            return 索引了;
        }
        索引了++;
    }

    // 否则直接添加并返回索引
    编单针->上值们[编单针->函->上值数目].索引 = 索引;
    编单针->上值们[编单针->函->上值数目].是否封闭的本地变量 = 是否封闭的本地变量;
    return 编单针->函->上值数目++;
}

// 查找自由变量
// 供内层函数向上查找被自己引用的与 名称 变量同名的自由变量 upvalue，在哪个外层函数或模块中
static int 找上值(编译单元大写 *编单针, const char *名称, uint32_t 长度) {
    // 已经到了模块对应的编译单元，即已经到了最外层了，直接外层编译单元为 NULL，仍找不到故返回 -1
    if (编单针->封闭的单元 == NULL) {
        return -1;
    }

    // 前置知识：

    // 目前模块、类的方法、函数会有对应的编译单元，类本身没有
    // 在编译某个模块中的类的方法时，为了快捷地找到该方法所属的类的，
    // 会将该类的 ClassBookKeep 结构赋值给该模块对应的编译单元的 编单针->封闭的类BK
    // 所以 编单针->enclosingUnit->enclosingClassBK != NULL （cu->封闭的单元 为 编单针 的直接外层编译单元）
    // 说明 编单针 是类的方法的编译单元，cu->enclosingUnit 为该类所在模块的编译单元（类没有编译单元）

    // 另外类的静态属性，会被定义为类所在模块的局部变量，且为了区分模块中可能存在多个类有同名的属性，所以局部变量的格式为 'Class类名 静态属性名'
    // 所以 strchr(名称, ' ') 为 NULL，说明查找的自由变量 upvalue 名没有空格，也就不是类的静态属性，也就不是模块的局部变量（模块中无法直接定义局部变量）
    // 所以没有必要再从模块的局部变量中查找了，直接返回 -1 即可
    if (编单针->封闭的单元->封闭的类BK != NULL && !strchr(名称, ' ')) {
        return -1;
    }

    // 从直接外层编译单元中查找自由变量 upvalue
    int 直接外层本地索引 = 找本地变量了(编单针->封闭的单元, 名称, 长度);
    // 如果找到，则将 localVars 数组中对应变量的 是否上值 属性设置成 true，并将该变量添加到 编单针->上值们 数组中
    if (直接外层本地索引 != -1) {
        编单针->封闭的单元->本地变量们[直接外层本地索引].是否上值 = 真;
        // 由于是从直接外层编译单元的局部变量中找到，所以 是否封闭的本地变量 为 真
        // 且 直接外层本地索引 为在直接外层编译单元的局部变量的索引
        return 加上上值(编单针, 真, (uint32_t)直接外层本地索引);
    }

    // 否则递归调用 找上值 函数继续向上层查找自由变量 upvalue
    // 递归过程会将 upvalue 添加到编译单元链上的所有中间层编译单元的 upvalue 数组 上值们 中
    int 直接外层上值索引 = 找上值(编单针->封闭的单元, 名称, 长度);
    // 如果找到，则将变量添加到 编单针->upvalues 数组中
    if (直接外层上值索引 != -1) {
        // 由于是从非直接外层编译单元的局部变量中找到，所以 是否封闭的本地变量 为 假
        // 且 直接外层上值索引 为直接外层编译单元的 upvalue 的索引
        return 加上上值(编单针, 假, (uint32_t)直接外层上值索引);
    }

    // 没有找到名为 名称 的 upvalue，则返回 -1
    return -1;
}

// 供内层函数在局部变量和自由变量 upvalue 中查找符号 名称
// 先从内层函数中的局部变量查找，找到则更正变量类型为局部变量类型，并返回
// 否则即为自由变量 upvalue，需要调用 找上值 函数向上层编译单元中查找，如果找到则更正变量类型为 upvalue 变量类型，并返回
static 变量大写 获取变量来自本地或上值(编译单元大写 *编单针, const char *名称, uint32_t 长度) {
    变量大写 变量;
    // 变量类型默认为无效作用域类型，查找到后会被更正
    变量.作用域类型 = 变量作用域_无效大写;

    变量.索引 = 找本地变量了(编单针, 名称, 长度);

    if (变量.索引 != -1) {
        变量.作用域类型 = 变量作用域_本地大写;
        return 变量;
    }

    变量.索引 = 找上值(编单针, 名称, 长度);
    if (变量.索引 != -1) {
        变量.作用域类型 = 变量作用域_上值大写;
    }
    return 变量;
}

// 赋值变量（主要是为模块变量赋值）
static void 定义变量之(编译单元大写 *编单针, uint32_t 索引) {
    //局部变量的值只需要压入到运行时栈中即可，故无需处理
    //模块变量并不存储在运行时栈中,因此需要将其写入相应位置
    if (编单针->作用域深度 == -1) {
        // 生成【将运行时栈顶数据保存到索引为 index 的模块变量中】
        写操作码短操作范围(编单针, 操作码之_存储模块变量, 索引);
        // 上一指令已经将栈顶数据保存，所以此时只需要弹出栈顶数据即可
        写操作码(编单针, 操作码之_弹);
    }
}

// 依次从局部变量、upvalue、模块变量中查找变量
static 变量大写 找变量(编译单元大写 *编单针, const char *名称, uint32_t 长度) {
    // 先从局部变量、upvalue 中查找变量
    变量大写 变量 = 获取变量来自本地或上值(编单针, 名称, 长度);
    if (变量.索引 != -1) {
        return 变量;
    }

    // 再从模块变量中查找变量
    变量.索引 = 获取索引来自符号表(&编单针->当前词法器->当前模块->模块变量名, 名称, 长度);
    if (变量.索引 != -1) {
        变量.作用域类型 = 变量作用域_模块大写;
    }
    return 变量;
}

// 生成【将运行时栈中索引为 index 的 slot，即变量的值压入栈顶】的指令
static void 发射载入变量(编译单元大写 *编单针, 变量大写 变量) {
    switch (变量.作用域类型) {
        case 变量作用域_本地大写:
            // 生成【将局部变量的值压入栈顶】的指令
            写操作码字节操作范围(编单针, 操作码之_载入本地变量, 变量.索引);
            break;
        case 变量作用域_上值大写:
            // 生成【将自由变量的值压入栈顶】的指令
            写操作码字节操作范围(编单针, 操作码之_载入上值, 变量.索引);
            break;
        case 变量作用域_模块大写:
            // 生成【将模块变量的值压入栈顶】的指令
            写操作码短操作范围(编单针, 操作码之_载入模块变量, 变量.索引);
            break;
        default:
            不可达大写()
    }
}

// 生成【将栈顶数据存入索引为 index 的变量】的指令
static void 发射存储变量(编译单元大写 *编单针, 变量大写 变量) {
    switch (变量.作用域类型) {
        case 变量作用域_本地大写:
            // 生成【将栈顶数据存入局部变量】的指令
            写操作码字节操作范围(编单针, 操作码之_存储本地变量, 变量.索引);
            break;
        case 变量作用域_上值大写:
            // 生成【将栈顶数据存入自由变量】的指令
            写操作码字节操作范围(编单针, 操作码之_存储上值, 变量.索引);
            break;
        case 变量作用域_模块大写:
            // 生成【将栈顶数据存入模块变量】的指令
            写操作码短操作范围(编单针, 操作码之_存储模块变量, 变量.索引);
            break;
        default:
            不可达大写()
    }
}

// 生成【压入变量值到栈顶】或者【保存栈顶数据到变量】的指令
static void 发射载入或存储变量(编译单元大写 *编单针, 变量大写 变量, 布尔 能分配) {
    // 能分配 为 真 表示具备可赋值的环境，且当前 token 为等号 =，则可判断等号右边就是需要赋值的表达式
    // 先调用 表达式 方法生成计算等号右边的表达式值的指令（这些指令执行完后，运行时栈顶的值就是计算结果）
    // 然后将栈顶的值，即表达式计算结果，保存到变量中，即调用 发射存储变量 方法
    if (能分配 && 匹配牌(编单针->当前词法器, 牌_赋值号大写)) {
        表达式(编单针, 绑力量_最低的大写);
        发射存储变量(编单针, 变量);
    } else {
        // 否则生成【加载变量值到栈顶】的指令
        发射载入变量(编单针, 变量);
    }
}

// 生成【将实例对象 this 压入到运行时栈顶】的指令
static void 发射载入这个(编译单元大写 *编单针) {
    变量大写 变量 = 获取变量来自本地或上值(编单针, "这个", 4);
    // 如果找不到，即 var 的 scopeType 属性为 VAR_SCOPE_INVALID，则报错
    断言大写(变量.作用域类型 != 变量作用域_无效大写, "获取这个变量失败!");
    // 否则生成指令
    发射载入变量(编单针, 变量);
}

// 编译代码块
// 代码块是包括在 {} 中间的代码，例如函数体、方法体、方法的块参数
// 一个代码块就被视为一个独立的指令流，也就是编译单元
// 遇到 { 就调用该函数，函数中调用 编译程序 编译，直到遇到 }
static void 编译块(编译单元大写 *编单针) {
    // 调用该函数时，已经读入了 {
    while (!匹配牌(编单针->当前词法器, 牌_右大括号大写)) {
        // 如果在 } 之前遇到了 标识文件结束的 token 类型 TOKEN_EOF，则报错
        if (编单针->当前词法器->当前牌.类型 == 牌_文件终大写) {
            编译_错误大写(编单针->当前词法器, "期望 '}' 在块终处!");
        }
        编译程序(编单针);
    }
}

// 编译函数体/方法体
static void 编译物自体(编译单元大写 *编单针, 布尔 是否构造) {
    // 进入函数前已经读入了 {
    编译块(编单针);

    // 当函数执行完后，会生成【将栈顶值（即函数运行的结果）返回，并将该函数对应运行时栈的部分销毁】的指令
    // 所以函数执行完成后，需要将函数运行结果压入到栈顶
    if (是否构造) {
        // 如果是构造函数，则默认返回的函数运行结果是实例对象，即 this 的指向，
        // 而对于构造函数，默认设定 this 为第 0 个局部变量，所以只需要将该函数的第一个局部变量的值压入栈中即可
        // 注意这里的第 0 个局部变量不是指 编单针->localVars 数组中的值，该数组只是保存局部变量的名字，例如第 0 个元素为 'this'
        // 函数的局部变量的值是存储在运行时栈中的，所以需要从运行时栈中获取第 0 个局部变量 this 的值，然后将其压入栈顶
        写操作码字节操作范围(编单针, 操作码之_载入本地变量, 0);
    } else {
        // 如果是普通函数，则默认返回的函数运行结果是 NULL
        // 所以将 NULL 压入栈顶即可
        写操作码(编单针, 操作码之_推空指针);
    }

    // 当函数执行完后，会生成【将栈顶值（即函数运行的结果）返回，并将该函数对应运行时栈的部分销毁】的指令
    写操作码(编单针, 操作码之_返回);
}

// 结束编译单元的编译工作，在直接外层编译单元中为其创建闭包
// 编译单元本质就是指令流单元
#if 调试大写
static 对象函大写 *终编译单元(编译单元大写 *编单针, const char *调试名, uint32_t 调试名长度) {
    // 如果处于调试阶段，会额外调用 绑调试函名 将函数名 调试名 写入到 编单针->函->调试 中
    绑调试函名(编单针->当前词法器->虚机针, 编单针->函->调试, 调试名, 调试名长度);
#else
static 对象函大写 *终编译单元(编译单元大写 *编单针) {
#endif

    // 生成【标识编译单元编译结束】的指令
    写操作码(编单针, 操作码之_终);

    if (编单针->封闭的单元 != NULL) {
        // 将当前编译单元的 编单针->fn (其中就包括了该编译单元的指令流 编单针->函->指令流)
        // 添加到直接外层编译单元即父编译单元的常量表中
        uint32_t 索引 = 加上常量(编单针->封闭的单元, 对象到值大写(编单针->函));

        // 在直接外层编译单元的 fn->指令流 指令流中，添加 为当前内层函数创建闭包 的指令，其中 索引 就是上面添加到常量表得到的索引值
        // 也就是说，内层函数是以闭包形式在外层函数中存在
        写操作码短操作范围(编单针->封闭的单元, 操作码之_创建闭包, 索引);

        // 上面向直接外层编译单元的指令流 编单针->enclosingUnit->fn->指令流 中写入为当前内层函数创建闭包的指令 OPCODE_CREATE_CLOSURE，
        // 当虚拟机执行该命令时，已经在直接外层编译单元了，是没办法直到内层函数 upvalue 数组 编单针->upvalues 中哪些是直接外层编译单元的局部变量，哪些是直接外层编译单元的 upvalue
        // 只有知道，才能在运行时栈找到对应的值，所以需要将 是直接外层编译单元的局部变量还是 upvalue 信息记录下来
        // 这里就直接写入了直接外层编译单元的指令流 编单针->enclosingUnit->fn->指令流 中
        // 按照 {upvalue 是否是直接编译外层单元的局部变量，upvalue 在直接外层编译单元的索引} 成对信息写入的
        // 以供虚拟机后面读入
        索引 = 0;
        while (索引 < 编单针->函->上值数目) {
            写字节(编单针->封闭的单元, 编单针->上值们[索引].是否封闭的本地变量 ? 1 : 0);
            写字节(编单针->封闭的单元, 编单针->上值们[索引].索引);
            索引++;
        }
    }

    // 将当前编译单元设置成直接外层编译单元
    编单针->当前词法器->当前编译单元 = 编单针->封闭的单元;
    return 编单针->函;
}

// 处理函数/方法实参
// 基于实参列表生成【加载实参到运行时栈顶】的指令
// 虚拟机执行指令后，会从左到右依次将实参压入到运行时栈，被调用的函数/方法会从栈中获取参数
// 注：expression 就是用来计算表达式，即会生成计算表达式的一系列指令，虚拟机在执行这些指令后，就会计算出表达式的结果
static void 处理实参列表(编译单元大写 *编单针, 签名大写 *签名) {
    // 确保实参列表不为空
    断言大写(编单针->当前词法器->当前牌.类型 != 牌_右小括号大写 &&
               编单针->当前词法器->当前牌.类型 != 牌_右中括号大写,
           "空实参列表!");

    do {
        // 确保实参个数不超过 最大实参数目了大写
        if (++签名->实参数目了 > 最大实参数目了大写) {
            编译_错误大写(编单针->当前词法器, "最大实参数目是 %d", 最大实参数目了大写);
        }

        // 基于实参列表生成加载实参到运行时栈中的指令
        表达式(编单针, 绑力量_最低的大写);
    } while (匹配牌(编单针->当前词法器, 牌_逗号大写));
}

// 处理函数/方法形参
// 将形参列表中的形参声明为函数/方法中的局部变量
static void 处理形参列表(编译单元大写 *编单针, 签名大写 *签名) {
    // 确保形参列表不为空
    断言大写(编单针->当前词法器->当前牌.类型 != 牌_右小括号大写 &&
               编单针->当前词法器->当前牌.类型 != 牌_右中括号大写,
           "空实参列表!");

    do {
        // 确保形参个数不超过 最大实参数目了大写
        if (++签名->实参数目了 > 最大实参数目了大写) {
            编译_错误大写(编单针->当前词法器, "最大实参数目是 %d", 最大实参数目了大写);
        }

        // 确保形参对应的 token 类型为变量名
        断言当前牌(编单针->当前词法器, 牌_身份大写, "期望变量名称!");

        // 将形参列表中的形参声明为函数/方法中的局部变量
        声明变量之(编单针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);
    } while (匹配牌(编单针->当前词法器, 牌_逗号大写));
}

// 基于方法签名生成【调用方法】的指令
// 包括 callX 和 superX，即普通方法和基类方法
static void 发射调用通过签名(编译单元大写 *编单针, 签名大写 *签名, 操作码枚举大写 操作码_本地) {
    // 最大签名长度了大写 为方法签名的最大长度
    char 签名缓冲区[最大签名长度了大写];
    // 将方法的签名对象转化成字符串 signBuffer
    uint32_t 长度 = 签名到字符串(签名, 签名缓冲区);

    // 确保名为 signBuffer 的方法已经在 编单针->curLexer->虚机针->全部方法名们 中，没有查找到，则向其中添加
    int 符号索引 = 确保符号存在(编单针->当前词法器->虚机针, &编单针->当前词法器->虚机针->全部方法名们, 签名缓冲区, 长度);

    // 写入调用方法的指令，其中：
    // 操作码为 callX 或 superX，X 表示调用方法的参数个数，例如 操作码之_调用15
    // 操作数为方法在 编单针->curLexer->虚机针->allMethodNames 的索引值
    写操作码短操作范围(编单针, 操作码_本地 + 签名->实参数目了, 符号索引);

    // 背景知识：
    // 操作码 OPCODE_SUPER x 用于调用基类的方法的
    // 其操作数有 4 个字节，其中前两个字节存储 基类方法在基类中的索引 methodIndex，即 super.method[方法索引] 表示基类的方法
    // 后两个字节存储 基类在常量中的索引 superClassIndex，即 常量们[superClassIndex] 表示基类

    // 如果是调用基类方法，操作数除了表示 方法索引的两个字节外，还需要再写两个字节的操作数表示 基类在常量中的索引
    // 因为基类可能是在子类之后定义，不能保证基类此时已经被编译完成，
    // 所以先向常量表中添加 VT_NULL，并获得 值型_空指针大写 在常量表中的的索引，将该索引作为后两个操作数
    // 等到执行修正操作数的函数 patchOperand 时，再将常量表中的 值型_空指针大写 换成正确的基类 superClass，操作数无需修改
    if (操作码_本地 == 操作码之_超级0) {
        写短操作范围(编单针, 加上常量(编单针, 值型到值大写(值型_空指针大写)));
    }
}

// 生成【调用 getter 方法或普通方法】的指令
// 形参 sign 是待调用方法的签名，在调用本函数之前，已经处理了方法名，
// 本函数主要是处理方法名后面的部分
// 因此此时只知道方法名，并不知道方法类型等信息，所以形参 sign 是不完整的，需要在本函数进一步完善
static void 发射获取者方法调用(编译单元大写 *编单针, 签名大写 *签名, 操作码枚举大写 操作的码) {
    签名大写 新签名;
    // 默认方法类型为 getter 类型
    新签名.类型 = 签名_获取者大写;
    新签名.名称 = 签名->名称;
    新签名.长度 = 签名->长度;
    新签名.实参数目了 = 0;

    // 如果是普通方法，可能会有参数列表，在调用该方法之前，必须先将参数压入运行时栈，否则运行方法时，
    // 会获取到错误的参数（即栈中已有数据），还会在方法运行结束时，错误的回收对应的空间，导致栈失衡
    // 因此如果后面有参数，则需要先生成【将实参压入到运行时栈】的指令

    // 如果后面有 (，可能有参数列表
    if (匹配牌(编单针->当前词法器, 牌_左小括号大写)) {
        // 设置成普通函数类型
        新签名.类型 = 签名_方法大写;

        // 如果后面不是 )，说明有参数列表
        if (!匹配牌(编单针->当前词法器, 牌_右小括号大写)) {
            处理实参列表(编单针, &新签名);
            // 参数之后需为 )，否则报错
            断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在实参列表后!");
        }
    }

    // 如果后面有 {，可能有块参数，块参数就是传入的参数是一个代码块，也就是函数
    // 注意此处是函数调用，而不是函数定义
    // 块参数即函数的参数，是夹在 |形参列表| 之间的形参列表，可参考下面 ruby 的写法：
    // class A {
    //     new () {

    //     }

    //     bar(fn) {
    //         fn.call(123)
    //     }
    // }
    // var a = A.new()
    // a.bar {|n| System.print(n)}
    // 其中 n 就是块参数（即传入的函数）的参数
    if (匹配牌(编单针->当前词法器, 牌_左大括号大写)) {
        // 参数加 1
        新签名.实参数目了++;
        // 设置成普通函数类型
        新签名.类型 = 签名_方法大写;

        // 开始编译传入的函数
        编译单元大写 函编单;
        初始编译单元(编单针->当前词法器, &函编单, 编单针, 假);
        // 临时的函数签名，用于编译传入的函数
        签名大写 临时函签名 = {签名_方法大写, "", 0, 0};
        // 如果下一个字符为 |，说明该传入的函数也有参数
        if (匹配牌(编单针->当前词法器, 牌_位或号大写)) {
            处理形参列表(&函编单, &临时函签名);
            // 参数之后需为 ｜，否则报错
            断言当前牌(编单针->当前词法器, 牌_位或号大写, "期望 '｜' 在实参列表后!");
        }
        函编单.函->实参数目 = 临时函签名.实参数目了;
        // 开始编译传入的函数的函数体，将该指令写进该函数自己的指令流中
        编译物自体(&函编单, 假);
#if 调试大写
        // 以接受块参数（即传入函数）的方法来命名传入函数，传入函数名=方法名+" block arg"
        // 其中加 10，是因为 " block arg" 有 10 个字符
        char 函名[最大签名长度了大写 + 10] = {'\0'};
        // 将接受块参数的方法的签名转化成字符串，并写入到 函了名 中，最后返回字符串的长度
        uint32_t 长度 = 签名到字符串(&新签名, 函名);
        // void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1
        // 在上一行生成的字符串结尾追加字符串 " block arg"
        memmove(函名 + 长度, " 块实参", 10);
        终编译单元(&函编单, 函名, 长度 + 10);
#else
        // 结束编译传入的函数
        终编译单元(&函编单);
#endif
    }

    // 如果是构造函数类型的方法，
    if (签名->类型 == 签名_构造大写) {
        // 如果此处 新签名.类型 不是 SIGN_METHOD，仍旧是 签名_获取者大写
        // 说明没有满足上面的两个条件判断，也就是方法名后面没有 ( 或 {
        // 也就是直接按照 getter 类型方法的形式调用，即直接就是方法名
        // 但是有根据 sign->类型 判断该方法为构造函数，调用形式应类似 super() 或者 super(arguments)
        // 所以调用形式有问题，直接报编译错误即可
        if (新签名.类型 != 签名_方法大写) {
            编译_错误大写(编单针->当前词法器, "其超级调用的形式是 超级() 或 超级(实参们)");
        }
        新签名.类型 = 签名_构造大写;
    }

    // 根据函数签名生成【调用函数】指令
    发射调用通过签名(编单针, &新签名, 操作的码);
}

// 生成【调用方法】的指令，包含所有方法
static void 发射方法调用(编译单元大写 *编单针, const char *名称, uint32_t 长度, 操作码枚举大写 操作的码, 布尔 能分配) {
    签名大写 签名;
    签名.名称 = 名称;
    签名.长度 = 长度;
    签名.类型 = 签名_获取者大写;

    // 如果后面是 = 且是可赋值环境，则判定该方法为 setter 类型方法
    if (匹配牌(编单针->当前词法器, 牌_赋值号大写) && 能分配) {
        签名.类型 = 签名_集者大写;
        签名.实参数目了 = 1;

        // 加载实参（即等号 = 后面的表达式的计算结果），为下面方法调用传参
        表达式(编单针, 绑力量_最低的大写);

        发射调用通过签名(编单针, &签名, 操作的码);
    } else {
        发射获取者方法调用(编单针, &签名, 操作的码);
    }
}

// 调用下面的生成方法签名的函数之时，preToken 为方法名，curToken 为方法名右边的符号
// 例如 test(a)，preToken 为 test，curToken 为 (
// 在调用方 编译方法 中，方法名已经获取了，同时方法签名已经创建了，只需要下面的函数获取符号方法的类型、方法参数个数，来完善方法签名

// 判断是否为 setter 方法，如果是则将方法签名设置成 setter 类型，且返回 true，否则返回 假
// setter 方法判断依据是是否符合 xxx=(_)
static 布尔 尝试集者(编译单元大写 *编单针 未使用大写, 签名大写 *签名) {
    // 方法名后面没有 = ，则可判断不是 setter 方法
    if (!匹配牌(编单针->当前词法器, 牌_赋值号大写)) {
        return 假;
    }

    if (签名->类型 == 签名_子脚本大写) {
        // subscribe setter 方法形式：xxx[_,...] = (_)
        签名->类型 = 签名_子脚本的集者大写;
    } else {
        // setter 方法形式：xxx = (_)
        签名->类型 = 签名_集者大写;
    }

    // = 后面必须为 (
    断言当前牌(编单针->当前词法器, 牌_左小括号大写, "期望 '(' 在 '=' 之后!");

    // ( 后面必须为标识符
    断言当前牌(编单针->当前词法器, 牌_身份大写, "期望标识符");

    // 声明形参为局部变量
    // subscribe setter 或者 setter 方法只有一个参数
    声明变量之(编单针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);

    // 标识符后面必须为 )
    断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在实参列表后!");

    // 方法签名中的 实参数目了 加 1
    签名->实参数目了++;

    return 真;
}

// 为标识符生成方法签名
static void 身份方法签名(编译单元大写 *编单针, 签名大写 *签名) {
    // 先默认设置成 getter 类型方法
    签名->类型 = 签名_获取者大写;

    // 如果方法签名的名字为 new 则说明是构造函数，即形式为 new(_,...)
    if (签名->长度 == 3 && memcmp(签名->名称, "新", 3) == 0) {
        // 构造函数的方法名后面不能接 =
        if (匹配牌(编单针->当前词法器, 牌_赋值号大写)) {
            编译_错误大写(编单针->当前词法器, "构造不应该是设置器!");
        }

        // 构造函数的方法名 new 后面必须为 (
        if (!匹配牌(编单针->当前词法器, 牌_左小括号大写)) {
            编译_错误大写(编单针->当前词法器, "构造必须是方法!");
        }

        签名->类型 = 签名_构造大写;

        // 如果形参后面为 )，说明构造函数没有参数则直接返回，不用走后面声明形参的逻辑
        // 注意此时的 前一个牌 已经是 ( 了，因为上面有判断 new 后面是否有 ( 的逻辑，满足条件才会走到这里， 匹配牌 满足条件会读入下一个 token
        if (匹配牌(编单针->当前词法器, 牌_右小括号大写)) {
            return;
        }
    } else {
        // 若不是构造函数，则判断是否为 setter 或者 subscribe setter
        // 如果是，trySetter 中已经将 类型 设置了，并且处理了，直接返回即可
        if (尝试集者(编单针, 签名)) {
            return;
        }

        // 如果方法名后面不是 (，则说明是 getter 类型方法，开头已经默认设置，且 getter 方法没有参数，所以直接返回即可
        if (!匹配牌(编单针->当前词法器, 牌_左小括号大写)) {
            return;
        }

        // 经过上面的判断，最后就可以判断该方法应该是普通方法了，即形式为 xxx(_,...)
        签名->类型 = 签名_方法大写;

        // ( 后面为 )，说明没有参数，直接返回即可，不用走后面声明形参的逻辑
        if (匹配牌(编单针->当前词法器, 牌_右小括号大写)) {
            return;
        }
    }

    // 声明形参为局部变量
    处理形参列表(编单针, 签名);

    // 形参后面必须为 )
    断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在形参列表后!");
}

// 为单运算符的符号方法生成方法签名
static void 一元方法签名(编译单元大写 *编单针 未使用大写, 签名大写 *签名) {
    // 单运算符的符号方法类型 getter 方法，且没有方法参数
    签名->类型 = 签名_获取者大写;
}

// 为中缀运算符的符号方法生成方法签名
static void 中缀方法签名(编译单元大写 *编单针 未使用大写, 签名大写 *签名 未使用大写) {
    // 中缀运算符的符号方法类型普通方法
    签名->类型 = 签名_方法大写;

    // 方法参数个数为 1 个
    // 例如 2 + 3 相当于 2.+(3) ，其中 + 方法参数为 3，参数个数为 1
    签名->实参数目了 = 1;

    // 方法名后面必须为 (
    断言当前牌(编单针->当前词法器, 牌_左小括号大写, "期望 '(' 在中缀操作者之后!");

    // ( 后面必须为标识符
    断言当前牌(编单针->当前词法器, 牌_身份大写, "期望变量名称!");

    // 声明中缀运算符的符号方法参数为变量
    // 此处之所以是 preToken，是因为上个 断言当前牌 方法已经读入了参数
    声明变量之(编单针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);

    // 参数后面必须为 )
    断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在形参后!");
}

// 为既可做单运算符也可做中缀运算符的符号方法生成方法签名
static void 混合方法签名(编译单元大写 *编单针 未使用大写, 签名大写 *签名 未使用大写) {
    // 先默认为单运算符，即方法类型为 getter 方法，方法形式为 xxx
    签名->类型 = 签名_获取者大写;

    // 方法名后面为 ( 则说明是普通方法，方法形式为 xxx(_,...)，进而可以判断为中缀运算符
    if (匹配牌(编单针->当前词法器, 牌_左小括号大写)) {
        // 中缀运算符的符号方法类型普通方法
        签名->类型 = 签名_方法大写;

        // 方法参数个数为 1 个
        // 例如 2 + 3 相当于 2.+(3) ，其中 + 方法参数为 3，参数个数为 1
        签名->实参数目了 = 1;

        // ( 后面必须为标识符
        断言当前牌(编单针->当前词法器, 牌_身份大写, "期望变量名称!");

        // 声明中缀运算符的符号方法参数为变量
        // 此处之所以是 preToken，是因为上个 断言当前牌 方法已经读入了参数
        声明变量之(编单针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);

        // 参数后面必须为 )
        断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在形参后!");
    }
}

// 为下标操作符 [ 生成方法签名
static void 子脚本方法签名(编译单元大写 *编单针, 签名大写 *签名) {
    签名->类型 = 签名_子脚本大写;
    签名->长度 = 0;
    // 处理中括号之间的形参
    处理形参列表(编单针, 签名);
    // 参数后面必须为 ]
    断言当前牌(编单针->当前词法器, 牌_右中括号大写, "期望 ']' 在索引列表后!");
    // 判断是否有 =，如果有则 sign->类型 设置为 签名_子脚本的集者大写
    尝试集者(编单针, 签名);
}

// 基于方法签名 生成 调用方法的指令
// 仅限于 callX，即普通方法
// 方法名 名称  方法名长度 长度  方法参数个数 实参数目了
static void 发射调用(编译单元大写 *编单针, const char *名称, int 长度, int 实参数目了) {
    // 确保名为 名称 的方法已经在 编单针->curLexer->虚机针->allMethodNames 中，没有查找到，则向其中添加
    int 符号索引 = 确保符号存在(编单针->当前词法器->虚机针, &编单针->当前词法器->虚机针->全部方法名们, 名称, 长度);
    // 写入调用方法的指令，其中：
    // 操作码为 callX，X 表示调用方法的参数个数，例如 操作码之_调用15
    // 操作数为方法在 编单针->curLexer->虚机针->allMethodNames 的索引值
    写操作码短操作范围(编单针, 操作码之_调用0 + 实参数目了, 符号索引);
}

// 在模块 对象模块 中定义名为 name，值为 值 的模块变量
int 定义模块变量(虚拟机大写 *虚机针, 对象模块大写 *对象模块, const char *名称, uint32_t 长度, 值大写 值) {
    // 如果模块变量名长度大于 最大身份长度了大写 则报错
    if (长度 > 最大身份长度了大写) {
        // 名称 指向的变量名不一定以 \0 结尾，为保险起见，将其从源码串拷贝出来
        char 身份也[最大身份长度了大写] = {'\0'};
        memcpy(身份也, 名称, 长度);

        // 定义模块变量 函数调用场景有多种，可能还未创建词法分析器
        if (虚机针->当前词法器 != NULL) {
            编译_错误大写(虚机针->当前词法器, "标识符的长度\"%s\"不应比 %d 更多", 身份也, 最大身份长度了大写);
        } else {
            内存_错误大写("标识符的长度\"%s\"不应比 %d 更多", 身份也, 最大身份长度了大写);
        }
    }

    // 查找模块变量名 名称 在 对象模块->模块变量名 中的索引
    // 如果为 -1，说明不存在，则分别在 对象模块->模块变量名 和 对象模块->模块变量值 中添加模块变量的名和值
    int 符号索引 = 获取索引来自符号表(&对象模块->模块变量名, 名称, 长度);

    if (符号索引 == -1) {
        符号索引 = 加上符号(虚机针, &对象模块->模块变量名, 名称, 长度);
        值大写缓冲区添加大写(虚机针, &对象模块->模块变量值, 值);
    } else if (值是否数目了大写(对象模块->模块变量值.数据们[符号索引])) {
        // 背景：
        // 模块变量相当于一个模块中的全局变量，支持使用变量在声明变量之前，
        // 在从上到下的编译阶段中，遇到模块变量声明，会将其对应在 对象模块->模块变量值 上的值设置成 值型_空指针大写 的 值大写 形式
        // 但当遇到使用的模块变量被使用了，但是目前为止没有看到该变量的声明，现将其对应在·objModule->模块变量值 上的值设置成行号，即 VT_NUM 的 值大写 形式
        // 直到继续向下编译，如果遇到该全局变量的声明，则就会进到这个判断分支，即变量对应在 对象模块->模块变量值 的值为 VT_NUM 类型，
        // 由此可以判断该变量已经在上面使用，但是没有声明，所以在这里将其设置成 值型_空指针大写 的 值大写 形式
        // 直到编译解阶段结束且虚拟机运行之前，检查 对象模块->模块变量值 中是否还有值类型为 VT_NUM 的模块变量，如果有就会报错
        // 误解：
        // 为什么变量的值会被设置成 值型_空指针大写 的 值大写 形式，而不是代码中真正赋的值，例如 a = 1？
        // 1. 编译阶段：先将模块变量的值初始化为 VT_NULL，同时生成 a = 1 赋值的对应指令
        // 2. 运行时阶段：虚拟机执行赋值对应的指令，从而将 1 写到模块变量 a 对应的 对象模块->模块变量值 值中
        // 目前只是处在编译阶段，故可以通过判断 对象模块->模块变量值 的值的类型来判断是否是先使用后声明的情况
        对象模块->模块变量值.数据们[符号索引] = 值;
    } else {
        // 已定义，则返回 -1（用于判断是否重复定义）
        符号索引 = -1;
    }

    return 符号索引;
}

// 声明模块变量
// 区别于 定义模块变量 函数，该函数不做重定义检查，默认直接声明
static int 声明模块变量(虚拟机大写 *虚机针, 对象模块大写 *对象模块, const char *名称, uint32_t 长度, 值大写 值) {
    值大写缓冲区添加大写(虚机针, &对象模块->模块变量值, 值);
    return 加上符号(虚机针, &对象模块->模块变量名, 名称, 长度);
}

// 获取包含 编单针->enclosingClassBK 的最近的编译单元 CompileUnit，注：
// 目前模块、类的方法、函数会有对应的编译单元，类本身没有
// 在编译某个模块中的类的方法时，为了快捷地找到该方法所属的类的，
// 会将该类的 ClassBookKeep 结构赋值给该模块对应的编译单元的 编单针->封闭的类BK
// 这样类的方法要找到所属的类，只需要在对应的的编译单元的父编译单元（或父编译单元的父编译单元）即模块的编译单元中，找到其中的 编单针->enclosingClassBK 即可
static 编译单元大写 *获取封闭类BK单元(编译单元大写 *编单针) {
    while (编单针 != NULL) {
        if (编单针->封闭的类BK != NULL) {
            return 编单针;
        }
        // 向上找父编译单元，即直接外层编译单元
        编单针 = 编单针->封闭的单元;
    }
    return NULL;
}

// 获取包含 编单针->enclosingClassBK 的最近的编译单元 编译单元大写 中的 编单针->封闭的类BK
static 类书保持大写 *获取封闭类BK(编译单元大写 *编单针) {
    编译单元大写 *封闭编单 = 获取封闭类BK单元(编单针);

    if (封闭编单 != NULL) {
        return 封闭编单->封闭的类BK;
    }
    return NULL;
}

// 判断是否是局部变量
// 如果是具有全局变量性质的变量名建议使用大写字母开头，例如：类名、模块变量名
// 如果是具有局部变量性质的变量名建议使用小写字母开头，例如：方法名、局部变量名
// 当不遵守规范，全局变量也使用了小写字母开头，恰好和类中的 getter 方法名同名，则优先选择 getter 方法，示例如下：
// class Foo {
//     var 名称
//     new(n) {
//         名称 = n
//     }
//     myName {
//         return 名称
//     }
//     hi() {
//         System.print("hello, I am " + myName + "!")
//     }
// }

// var f = Foo.new("da hong");
// var myName = "xiao sa"
// f.hi()
// 其中，hi 方法会优先选择 getter 方法 myName 而非全局变量 myName
// 注意：在同一个类中调用类中的其他方法，不需要显示地指明对象，即 “对象.方法名”，例如 this.myName  this.hi()
// 而是直接写方法名即可，编译器会从当前对象所属类的方法中查找
static 布尔 是否本地名(const char *名称) {
    return (名称[0] >= 'a' && 名称[0] <= 'z');
}

// 编译字面量（即常量，包括数字、字符串），即字面量的 空指针外延 方法
// 即在语法分析时，遇到常量时，就调用该 空指针外延 方法直接生成将该常量添加到运行时栈的指令即可
static void 字面的(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 是 前一个牌 的原因：
    // 当进入到某个 token 的 左外延/空指针外延 方法时，curToken 为该 左外延/空指针外延 方法所属 token 的右边的 token
    // 所以 左外延/空指针外延 所属的 token 就是 前一个牌
    发射载入常量(编单针, 编单针->当前词法器->前一个牌.值);
}

// 编译标识符的引用，即标识符的 空指针外延 方法，
// 调用该函数时preToken 为该标识符，curToken 为标识符右边的符号
// 标识符可以是函数名、变量名、类静态属性、对象实例属性等
// 当同名时优先级：函数调用 > 局部变量和 upvalue > 对象实例属性 > 类静态属性 > 类的 getter 方法调用 > 模块变量
static void 身份也(编译单元大写 *编单针, 布尔 能分配) {
    // 备份变量名
    牌大写 名称 = 编单针->当前词法器->前一个牌;
    类书保持大写 *类BK = 获取封闭类BK(编单针);

    // 标识符可以是任意字符，按照此顺序处理：
    // 函数调用 > 局部变量和 upvalue > 对象实例属性 > 类静态属性 > 类的 getter 方法调用 > 模块变量

    // 1. 按照【函数调用】处理
    // 编单针->enclosingUnit == NULL 说明此时处于模块的编译单元，即正在编译模块（因为模块已经是最顶级的编译单元了，已经没有直接外层编译单元了）
    // 且下一个字符是 (，故可以判断是函数调用
    if (编单针->封闭的单元 == NULL && 匹配牌(编单针->当前词法器, 牌_左小括号大写)) {
        // 在编译函数定义时，是按照 “Fn 函数名” 的形式作为模块变量存储起来，目的是和用户定义的局部变量做区分
        // 所以在查找函数名之前，需要在前面添加 “Fn ” 前缀
        char 身份也[最大身份长度了大写] = {'\0'};
        memmove(身份也, "函大 ", 3);
        memmove(身份也 + 3, 名称.起始, 名称.长度);

        变量大写 var;
        var.作用域类型 = 变量作用域_模块大写;
        // 从当前模块的模块变量名字表 模块变量名 中查找
        var.索引 = 获取索引来自符号表(&编单针->当前词法器->当前模块->模块变量名, 身份也, strlen(身份也));
        // 如果没有找到对应的 “Fn 函数名”，则报编译错误，提示该函数没有定义
        if (var.索引 == -1) {
            memmove(身份也, 名称.起始, 名称.长度);
            身份也[名称.长度] = '\0';
            编译_错误大写(编单针->当前词法器, "未定义函数: '%s'", 身份也);
        }

        // 如果找到的模块变量，即函数闭包，则生成【将函数闭包压入到运行时栈顶】的指令
        发射载入变量(编单针, var);

        // 创建函数签名，方便后面生成调用函数的指令
        签名大写 签名;
        // 函数调用是以 “函数闭包.call” 的形式，也就是说 call 是待调用的方法名
        签名.名称 = "调用";
        签名.长度 = 4;
        签名.实参数目了 = 0;
        // 函数调用的形式和 method 类型方法类似
        签名.类型 = 签名_方法大写;

        // 如果 ( 后面不是 )，则说明有参数列表，调用 处理实参列表 将参数压入运行时栈
        if (!匹配牌(编单针->当前词法器, 牌_右小括号大写)) {
            处理实参列表(编单针, &签名);
            断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在实参列表后!");
        }

        // 生成【调用函数】的指令
        发射调用通过签名(编单针, &签名, 操作码之_调用0);
    } else {
        // 2. 按照【局部变量和 upvalue】处理
        变量大写 变量 = 获取变量来自本地或上值(编单针, 名称.起始, 名称.长度);
        if (变量.索引 != -1) {
            // 如果找到，则生成【压入变量值到栈顶】或者【保存栈顶数据到变量】的方法
            发射载入或存储变量(编单针, 变量, 能分配);
            return;
        }

        // 3. 按照【对象实例的属性】处理
        // 如果正在编译一个类的时候，会将 编单针->enclosingClassBK 设为所编译的类的 classBookKeep 结构，
        // 所以如果 类BK != NULL，说明此时在编译类
        // 对象实例的属性在类中的定义形式是 “var 对象实例属性”
        if (类BK != NULL) {
            // 从类的符号属性表中查找
            int 字段索引 = 获取索引来自符号表(&类BK->字段们, 名称.起始, 名称.长度);
            // 如果找到
            if (字段索引 != -1) {
                if (类BK->是否静止) {
                    编译_错误大写(编单针->当前词法器, "实例字段不应该在静止方法内使用!");
                }

                // 编辑是使用对象实例属性，还是给对象实例属性赋值
                布尔 是否读 = 真;
                // 如果是可赋值环境，且对象实例的属性后面的字符是等号，则说明是给对象实例属性进行赋值
                // 所以调用 表达式 解析等号后面的表达式，生成【计算表达式】的指令，虚拟机执行指令后，该表达式的计算结果就保存在了运行时栈顶，方便下面使用
                if (能分配 && 匹配牌(编单针->当前词法器, 牌_赋值号大写)) {
                    是否读 = 假;
                    表达式(编单针, 绑力量_最低的大写);
                }

                // 如果当前则会跟你在编译类的方法，则按照在类的方法引用当前对象的属性处理
                if (编单针->封闭的单元 != NULL) {
                    // 如果是使用属性，则生成【压入变量值到栈顶】指令；如果是赋值给属性，则生成【保存栈顶数据到变量】指令
                    写操作码字节操作范围(编单针, 是否读 ? 操作码之_载入这个字段 : 操作码之_存储这个字段, 字段索引);
                } else {
                    // 否则按照在类外引用对象实例属性处理
                    // 先生成【将实例对象 this 压入到运行时栈顶】的指令
                    发射载入这个(编单针);
                    // 如果是使用属性，则生成【压入变量值到栈顶】指令；如果是赋值给属性，则生成【保存栈顶数据到变量】指令
                    写操作码字节操作范围(编单针, 是否读 ? 操作码之_载入字段 : 操作码之_存储字段, 字段索引);
                }
                return;
            }
        }

        // 4. 按照【类的静态属性】处理
        // 如果正在编译一个类的时候，会将 编单针->enclosingClassBK 设为所编译的类的 classBookKeep 结构，
        // 所以如果 类BK != NULL，说明此时在编译类
        // 类的静态属性在类中的定义形式是 “static var 静态属性”
        // 编译类的静态属性定义时，是按照 “Cls类名 静态属性名” 的形式作为模块编译单元的局部变量存储的（因为类的静态属性是被所有对象共享的数据，因此需要长期有效，所以保存在模块编译单元的局部变量中）
        if (类BK != NULL) {
            char *静止字段身份 = 分配数组大写(编单针->当前词法器->虚机针, char, 最大身份长度了大写);
            // void *memset(void *串, int c, size_t n) 复制字符 c（一个无符号字符）到参数 串 所指向的字符串的前 n 个字符
            // 将 静止字段身份 中的每个字符都设置成 0
            memset(静止字段身份, 0, 最大身份长度了大写);

            // 根据 “Cls类名 静态属性名” 的存储形式，拼接需要查询的字符串
            // 首先写入 Cls
            memmove(静止字段身份, "类静", 3);
            // 再写入类名
            char *类了名 = 类BK->名称->值.起始;
            uint32_t 类了长 = 类BK->名称->值.长度;
            memmove(静止字段身份 + 3, 类了名, 类了长);
            // 再写入空格
            memmove(静止字段身份 + 3 + 类了长, " ", 1);
            // 再写入静态属性名
            memmove(静止字段身份 + 3 + 类了长 + 1, 名称.起始, 名称.长度);

            // 类的静态属性是保存在模块编译单元的局部变量中
            变量 = 获取变量来自本地或上值(编单针, 静止字段身份, strlen(静止字段身份));
            // 释放上面申请的内存
            反分配数组大写(编单针->当前词法器->虚机针, 静止字段身份, 最大身份长度了大写);

            if (变量.索引 != -1) {
                // 如果找到，则生成【压入变量值到栈顶】或者【保存栈顶数据到变量】的方法
                发射载入或存储变量(编单针, 变量, 能分配);
                return;
            }
        }

        // 5. 按照【类的 getter 方法调用】处理
        // 如果正在编译一个类的时候，会将 编单针->enclosingClassBK 设为所编译的类的 classBookKeep 结构，
        // 所以如果 类BK != NULL，说明此时在编译类
        // 方法名规定以小写字符开头
        // 如果模块不按照规定，擅自以小写字符开头，则按照方法名查找，没有就报错
        if (类BK != NULL && 是否本地名(名称.起始)) {
            // 生成【将实例对象 this 压入到运行时栈顶】的指令
            // 一是为了将 this 放到 args[0]
            // 二是为了确认对象所在的类，然后从类中获得所调用的方法
            发射载入这个(编单针);
            // 生成【调用方法】的指令
            // 此时类可能还未编译完，未统计完所有方法，故此时无法判断类的方法是否定义，留待运行时检测
            发射方法调用(编单针, 名称.起始, 名称.长度, 操作码之_调用0, 能分配);
            return;
        }

        // 6. 按照【模块变量】处理
        变量.作用域类型 = 变量作用域_模块大写;
        // 从当前模块的模块变量名字表 模块变量名 中查找
        变量.索引 = 获取索引来自符号表(&编单针->当前词法器->当前模块->模块变量名, 名称.起始, 名称.长度);
        // 如果在 当前模块->模块变量名 没找到
        if (变量.索引 == -1) {
            // 标识符有可能还是函数名，原因如下：
            // 最开始是按照函数调用形式来查找（判断条件中有判断后面的字符是否是 ‘(’）
            // 有些情况，函数是作为参数形式出现的，比如函数名作为创建线程的参数，例如 thread.new(函数名)
            // 所以重新以 “Fn 函数名” 的形式在当前模块的模块变量名字表 模块变量名 中查找
            char 函了名[最大签名长度了大写 + 4] = {'\0'};
            memmove(函了名, "函大 ", 3);
            memmove(函了名 + 3, 名称.起始, 名称.长度);
            变量.索引 = 获取索引来自符号表(&编单针->当前词法器->当前模块->模块变量名, 函了名, strlen(函了名));

            // 如果不是函数名，则有可能该模块变量的定义在引用处的后面（这种情况是被允许的）
            // 先暂时以当前行号作为变量名，以 空指针乎 作为变量值，来声明模块变量
            // 等到编译结束后，在检查该模块变量是否有定义，若没有就正好用行号报错
            if (变量.索引 == -1) {
                变量.索引 = 声明模块变量(编单针->当前词法器->虚机针, 编单针->当前词法器->当前模块, 名称.起始, 名称.长度, 数目到值大写(编单针->当前词法器->当前牌.行号));
            }
        }
        // 如果找到模块变量，则生成【压入变量值到栈顶】或者【保存栈顶数据到变量】的方法
        发射载入或存储变量(编单针, 变量, 能分配);
    }
}

// 生成【将模块变量压入到运行时栈顶】的指令，类是以模块变量的形式存储的，所以用此函数加载类
static void 发射载入模块变量(编译单元大写 *编单针, const char *名称) {
    // 先从当前模块的模块变量名字表 模块变量名 中查找是否存在
    int 索引 = 获取索引来自符号表(&编单针->当前词法器->当前模块->模块变量名, 名称, strlen(名称));
    // 如果没有，则报错提示应该先定义该模块变量
    断言大写(索引 != -1, "符号本来应该被定义");
    // 如果找到，则生成【将模块变量压入到运行时栈顶】的指令
    写操作码短操作范围(编单针, 操作码之_载入模块变量, 索引);
}

// 编译内嵌表达式，即内嵌表达式的 空指针外延 方法
// 内嵌表达式即字符串内可以使用变量，类似 JavaScript 中的字符串模板
// 例如本书规定写法形式是 %(变量名)
// 例如 a %(b+c) d %(e) f 会被编译成 ["a", b+c, " d", e, "f "].join()，
// 其中 a 和 d 是 TOKEN_INTERPOLATION，b/c/e 是 TOKEN_ID，f 是 牌_字符串大写
static void 字符串插值(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 创造一个 list 实例，用来保存下面拆分字符串得到的各个部分
    // 加载 List 模块变量到运行时栈顶
    发射载入模块变量(编单针, "列表");
    // 调用 List 的 new 方法，创造一个 list 实例
    发射调用(编单针, "新()", 5, 0);

    // 每次循环处理字符串中的一个内嵌表达式
    // 例如 a %(b+c) d %(e) f，先将类型为 牌_插值大写 的字符 a 添加到 list，再将内嵌表达式 b+c 添加到 list，这是一次循环
    // 下一次循环再处理 d %(e)
    do {
        // 1. 先编译字符串中的类型为 牌_插值大写 的字符，即生成【加载常量（即该字符）到常量表，并将常量压入到运行时栈顶】的指令
        字面的(编单针, 假);
        // 调用 list 实例对象的 addCore 方法，将运行时栈顶的字符添加到 list 实例中
        发射调用(编单针, "加核_(_)", 11, 1);

        // 2. 然后编译内嵌表达式，即生成【计算表达式，并将结果压入到运行时栈顶】的指令
        表达式(编单针, 绑力量_最低的大写);
        // 调用 list 实例对象的 addCore 方法，将上面的表达式结果从运行时栈顶保存到 list 实例中
        发射调用(编单针, "加核_(_)", 11, 1);
    } while (匹配牌(编单针->当前词法器, 牌_插值大写));

    // 读取最后的字符串，例如 a %(b+c) d %(e) f 中的 f
    // 如果结尾没有字符串，则报错
    断言当前牌(编单针->当前词法器, 牌_字符串大写, "在字符串插值终期望遇到字符串!");
    // 编译最后的字符串，即生成【加载常量（即该字符）到常量表，并将常量压入到运行时栈顶】的指令
    字面的(编单针, 假);
    // 调用 list 实例对象的 addCore 方法，将最后的字符串从运行时栈顶保存到 list 实例中
    发射调用(编单针, "加核_(_)", 11, 1);

    // 调用 list 实例的 join 方法，将 list 中保存的字符合成一个字符串
    发射调用(编单针, "加入()", 6, 0);
}

// 编译 bool，即 布尔 的 空指针外延 方法
static void 布尔型(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 如果是 true，则生成【压入 真 到运行时栈顶】的指令，否则生成【压入 假 到运行时栈顶】的指令
    操作码枚举大写 操作的码 = 编单针->当前词法器->前一个牌.类型 == 牌_真大写 ? 操作码之_推真 : 操作码之_推假;
    // 上面的指令只有操作码，没有操作数
    写操作码(编单针, 操作的码);
}

// 编译 null，即 空指针乎 的 空指针外延 方法
static void 空指针乎(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 生成【压入 空指针乎 到运行时栈顶】的指令
    写操作码(编单针, 操作码之_推空指针);
}

// 编译 this，即 this 的 空指针外延 方法
static void 这个乎(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    类书保持大写 *封闭的类BK = 获取封闭类BK(编单针);

    // this 如果不在类的方法中使用，则报编译错误
    // 如果正在编译一个类的时候，会将 编单针->enclosingClassBK 设为所编译的类的 classBookKeep 结构，
    // 所以如果 enclosingClassBK == NULL，说明此时并没有在编译类
    if (封闭的类BK == NULL) {
        编译_错误大写(编单针->当前词法器, "这个必须在类方法里面");
    }
    // 生成【加载 this 对象到栈顶】的指令
    发射载入这个(编单针);
}

// 编译 super，即 super 的 空指针外延 方法
static void 超级乎(编译单元大写 *编单针, 布尔 能分配) {
    类书保持大写 *封闭的类BK = 获取封闭类BK(编单针);
    // super 如果不在类的方法中使用，则报编译错误
    // 如果正在编译一个类的时候，会将 编单针->enclosingClassBK 设为所编译的类的 classBookKeep 结构，
    // 所以如果 enclosingClassBK == NULL，说明此时并没有在编译类
    if (封闭的类BK == NULL) {
        编译_错误大写(编单针->当前词法器, "超级必须在类方法里面");
    }

    // 生成【加载 this 对象到栈顶】的指令
    // 并不是为了调用基类作准备，而是为了保证 args[0] 始终是 this 对象，即调用 super 的子类对象，保证参数数组 args 一致
    发射载入这个(编单针);

    // super 调用有两种方式：
    // 第一种：指定基类中的方法，形式如 super.methodName(argList)，其中 methodNam 是基类中的方法
    if (匹配牌(编单针->当前词法器, 牌_点大写)) {
        断言当前牌(编单针->当前词法器, 牌_身份大写, "期望方法名称在 '.' 后!");
        // 生成【调用基类方法】的指令，方法名为 super. 后面的标识符
        发射方法调用(编单针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度, 操作码之_超级0, 能分配);
    } else {
        // 第二种：调用与关键字 super 所在的子类方法同名的基类方法，形式如 super(argList)
        // enclosingClassBK->签名 就是当前所在子类的正在编译的方法的签名
        发射获取者方法调用(编单针, 封闭的类BK->签名, 操作码之_超级0);
    }
}

// 编译小括号 (，即小括号 ( 的 空指针外延 方法
static void 小括号们乎(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 小括号是用来提高优先级，被括起来的表达式相当于被分成一组，作为一个整体参与计算，所以只需生成【计算该表达式的结果】的指令
    表达式(编单针, 绑力量_最低的大写);
    断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在表达式后!");
}

// 编译 map 对象字面量，即大括号 { 的 空指针外延 方法
static void 映射字面的乎(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 执行本函数时，preToken 是字符 { 当前牌 是字符 { 后面的字符
    // 这种方式创建 map 对象其实是一种语法糖，内部也是先调用 Map.new() 方法创建一个 map 对象实例，然后通过 map.addCore_() 添加中括号里面的元素

    // 先创建 map 对象
    // 1. 生成【加载模块变量中的 Map 类到运行时栈顶，用于调用方法时，从该类的 方法们 中定位到方法】的指令
    发射载入模块变量(编单针, "映射");
    // 2. 生成【调用 Map 类的 new 方法，创造一个 map 实例】的指令
    发射调用(编单针, "新()", 5, 0);

    do {
        // 如果当前字符为 }，说明是空 map，即 {} ，所以无需循环
        if (编单针->当前词法器->当前牌.类型 == 牌_右大括号大写) {
            break;
        }

        // 生成【计算冒号左边的 key 的表达式，并将计算结果压入到运行时栈】的指令
        // 注意此处第二个参数不能传入 BP_LOWEST，否则整个 map 字面量都会被处理，正常是处理到冒号 : 就终止，原因请参见 表达式 实现
        表达式(编单针, 绑力量_一元大写);

        // key 和 值 之间必须为冒号 :
        断言当前牌(编单针->当前词法器, 牌_冒号大写, "期望 ':' 在键后!");

        // 生成【计算冒号右边的 key 的表达式，并将计算结果压入到运行时栈】的指令
        表达式(编单针, 绑力量_最低的大写);

        // 生成【调用 addCore_(_,_) 方法，将 key 和 值 写入到 map 对象实例中】
        // 此时 值 和 key 分别位于运行时栈顶和次顶
        发射调用(编单针, "加核_(_,_)", 13, 2);
    } while (匹配牌(编单针->当前词法器, 牌_逗号大写));
    // map 字面量定义必须以 } 结尾
    断言当前牌(编单针->当前词法器, 牌_右大括号大写, "映射字面应与 '}' 一起终!");
}

// 编译用于字面量的中括号，即用于字面量的中括号的 空指针外延 方法
// 例如 var listA = ["dang", 1+2*3, 'x']
// 执行本函数时，preToken 为 [，curToken 为 [ 后面的字符
static void 列表字面的乎(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 这种方式创建 list 对象其实是一种语法糖，内部也是先调用 List.new() 方法创建一个 list 对象实例，然后通过 list.addCore_() 添加中括号里面的元素

    // 先创建 list 对象
    // 1. 生成【加载模块变量中的 List 类到运行时栈顶，用于调用方法时，从该类的 方法们 中定位到方法】的指令
    发射载入模块变量(编单针, "列表");
    // 2. 生成【调用 List 类的 new 方法，创造一个 list 实例】的指令
    发射调用(编单针, "新()", 5, 0);

    do {
        // 如果当前字符为 ]，说明是空列表，即 [] ，所以无需循环
        if (编单针->当前词法器->当前牌.类型 == 牌_右中括号大写) {
            break;
        }
        // 先生成【计算中括号里的每一个表达式的结果，并压入到运行时栈顶】的指令，一次循环计算一个表达式
        // 例如 var listA = ["dang", 1+2*3, 'x']，第二次循环就计算 1+2*3 的结果 7，然后将 7 压入到运行时栈顶
        表达式(编单针, 绑力量_最低的大写);

        // 将运行时栈顶的值（即表达式的计算结果）写入到 list 对象实例中
        发射调用(编单针, "加核_(_)", 11, 1);
    } while (匹配牌(编单针->当前词法器, 牌_逗号大写));
    // list 字面量定义必须以 ] 结尾
    断言当前牌(编单针->当前词法器, 牌_右中括号大写, "期望 ']' 在列表元素后!");
}

// 编译用于索引 list 元素的中括号，即用于字面量的中括号的 左外延 方法
// 对 List 和 Map 对象实例均适用
// 例如 list[x]
static void 子脚本乎(编译单元大写 *编单针, 布尔 能分配) {
    // 确保 [] 中间不为空
    if (匹配牌(编单针->当前词法器, 牌_右中括号大写)) {
        编译_错误大写(编单针->当前词法器, "需要实参在 [] 内!");
    }

    // 用于下标的 [] 有两种形式，
    // 第一种是读列表元素如 list[x]，这是 getter 形式的下标
    // 第二种是写列表元素如 list[x] = y，这是 setter 形式的下标，比 getter 多一个等号 =
    // 只有在读取右中括号后才能确认是否有等号 =，因此先默认为 getter，即 子脚本乎 getter，方法形式为 [_]
    签名大写 签名 = {签名_子脚本大写, "", 0, 0};
    // 处理中括号之间的参数，即 list[x] 中的 x，生成【加载实参到运行时栈顶】指令
    // 仅支持一个索引值，list[x,...] 是非法的，此处 处理实参列表 函数只处理一个参数
    处理实参列表(编单针, &签名);
    // 参数后面需要右中括号 ] 结尾
    断言当前牌(编单针->当前词法器, 牌_右中括号大写, "期望 ']' 在实参列表后!");

    // 如果右中括号 ] 后面有等号且为可赋值环境，说明是 setter 形式的下标，即 子脚本乎 setter，方法形式为 [_] = (_)
    if (匹配牌(编单针->当前词法器, 牌_赋值号大写) && 能分配) {
        签名.类型 = 签名_子脚本的集者大写;

        // 书中此处是有校验 sign->实参数目了 是否大于 MAX_ARG_NUM，个人觉得没必要
        // 在上面初始化 sign 的时候，argNum 就被初始化为 0
        // 在经过 处理实参列表 处理中括号之间的参数，仅支持一个参数，多个参数非法（虽然未强制校验）
        // 所以到这里时，sign->实参数目了 必定为 1，所以没必要做 sign->实参数目了 是否大于 最大实参数目了大写 的判断

        // [_] = (_) 中等号右边也算一个参数，即 [args[1]] = (args[2])
        ++签名.实参数目了;

        // 生成【计算右边表达式，并将计算结果压入到运行时栈顶】的指令
        表达式(编单针, 绑力量_最低的大写);
    }
    // 基于方法签名生成【调用方法】的指令
    发射调用通过签名(编单针, &签名, 操作码之_调用0);
}

// 编译方法调用，即字符 . 的 左外延 方法
// 面向对象语言中，方法调用就是 “对象.方法” 的形式，也就是 . 是方法调用的符号，它的左操作数是对象，右操作数是方法名
// 调用本函数之前，对象已经由 身份也 函数加载到了栈中，也就是 args[0] 表示的 this
static void 调用条目(编译单元大写 *编单针, 布尔 能分配) {
    // 执行本函数时，preToken 是字符 .  当前牌 是字符 . 后面的字符
    断言当前牌(编单针->当前词法器, 牌_身份大写, "期望方法名称在 '.' 后!");
    // 生成【调用方法】的指令
    发射方法调用(编单针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度, 操作码之_调用0, 能分配);
}

// 针对根据条件执行不同分支的情况，例如 a && b，当 a 为 真 时，才会执行 b，否则执行 b 后面的代码
// 我们需要用到编译原理中常说的回填技术：
// 在将代码编译成对应指令之外，还要额外插入不属于用户代码的跳转指令
// 例如上面的情况，先编译 a 表达式，再编译 &&，然后再编译 b 表达式。当编译 && 时，我们需要将跳转到 b 对应指令流结束的地址的偏移量作为操作数保存起来。
// 这样当计算 a 的值为 假 时，则根据偏移量直接跳过 b 对应的指令流，执行后面的指令流
// 但由于在编译  && 时，还没有编译 b，并不知道 b 对应指令流的大小，所以需要设置一个特殊的数值占位符，等到编译完 b 的时候在将 && 的操作数设置成正确的偏移量
// 这就是所谓的回填技术

// 先用特殊的数值作为占位符，写入指令的操作数
// 后续该操作数会被正确的偏移量复写
static uint32_t 发射指令与占位符一起(编译单元大写 *编单针, 操作码枚举大写 操作的码) {
    写操作码(编单针, 操作的码);
    // 地址一般为 16 位，即两个字节，也就是操作数大小为两个字节
    // 根据大端字节序，高位地址存在内存的低地址端，低位地址存在内存的高地址端
    // 所以先写入高位地址 0xff 到低地址端
    写字节(编单针, 0xff);
    // 再写入高低位地址 0xff 到高地址端
    // 但仍旧返回高位地址所在的索引，也就是减 1 的意义，该地址用于回填，即用正确的偏移量覆盖占位符 0xff
    return 写字节(编单针, 0xff) - 1;
}

// 使用【跳转到当前指令流结束地址的偏移量】去替换【占位符 0xffff】，占位符写入逻辑请参考上面的函数
// 其中 绝对索引 就是指令流的绝对地址
static void 补丁占位符(编译单元大写 *编单针, uint32_t 绝对索引) {
    // 计算【跳转到当前指令流结束地址的偏移量】
    // 此处之所以减 2，是因为运行时虚拟机执行该指令时，已经读入了两个字节的操作数，所以偏移量需要减 2
    uint32_t 偏移 = 编单针->函->指令流.计数 - 绝对索引 - 2;

    // 其中偏移量的高位地址写入到 绝对索引 索引对应的字节中，即回填偏移量地址的高 8 位
    // (偏移 >> 8) && 0xff 就是获取 偏移 的高 8 位
    // 1010 0010 1101 0001 >> 8
    // &
    // 0000 0000 1111 1111
    编单针->函->指令流.数据们[绝对索引] = (偏移 >> 8) & 0xff;

    // 其中偏移量的低位地址写入到 绝对索引+1 索引对应的字节中，即回填偏移量地址的低 8 位
    // 偏移 && 0xff 就是获取 偏移 的低 8 位
    // 1010 0010 1101 0001
    // &
    // 0000 0000 1111 1111
    编单针->函->指令流.数据们[绝对索引 + 1] = 偏移 & 0xff;
}

// 编译 || 符号，即符号 || 的 左外延 方法
static void 逻辑或乎(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 执行此函数时，栈顶保存的就是条件表达式的结果，即符号 || 的左操作数

    // 编译 || 符号，调用 发射指令与占位符一起 函数写入指令，其中操作码为 OPCODE_OR，操作数是占位符 0xffff，
    // 其中返回的 占位符索引 就是该指令的操作数中用于保存高位地址的低地址端字节地址（操作数有两个字节，其中低地址端字节保存值的是高位）
    // 等到符号 || 的右操作数编译完之后，在将到右操作数编译得到的指令流结束地址的偏移量回填，替换占位符 0xffff
    uint32_t 占位符索引 = 发射指令与占位符一起(编单针, 操作码之_或);

    // 生成【计算符号 || 右边表达式结果】的指令流
    表达式(编单针, 绑力量_逻辑或大写);

    // 当符号 || 右边表达式编译完后，即生成【计算符号 || 右边表达式结果】的指令流后，
    // 调用 补丁占位符 计算从【OPCODE_OR 对应的指令】 到 【符号 || 右边表达式编译的指令流结束地址】之间的偏移量，将该偏移量作为 操作码之_或 操作码的对应操作数
    // 当虚拟机执行该指令时，如果符号 || 左边表达式的值为 false，则执行符号 || 右边表达式编译出来的指令流；反之，则跳过符号 || 右边表达式编译出来的指令流，直接执行后面的指令
    补丁占位符(编单针, 占位符索引);
}

// 编译 && 符号，即符号 && 的 左外延 方法
static void 逻辑与乎(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 执行此函数时，栈顶保存的就是条件表达式的结果，即符号 && 的左操作数

    // 编译 && 符号，调用 发射指令与占位符一起 函数写入指令，其中操作码为 OPCODE_OR，操作数是占位符 0xffff，
    // 其中返回的 占位符索引 就是该指令的操作数中用于保存高位地址的低地址端字节地址（操作数有两个字节，其中低地址端字节保存值的是高位）
    // 等到符号 && 的右操作数编译完之后，在将到右操作数编译得到的指令流结束地址的偏移量回填，替换占位符 0xffff
    uint32_t 占位符索引 = 发射指令与占位符一起(编单针, 操作码之_与);

    // 生成【计算符号 && 右边表达式结果】的指令流
    表达式(编单针, 绑力量_逻辑与大写);

    // 当符号 && 右边表达式编译完后，即生成【计算符号 && 右边表达式结果】的指令流后，
    // 调用 补丁占位符 计算从【OPCODE_AND对应的指令】 到 【符号 && 右边表达式编译的指令流结束地址】之间的偏移量，将该偏移量作为 操作码之_与 操作码的对应操作数
    // 当虚拟机执行该指令时，如果符号 && 左边表达式的值为 true，则执行符号 && 右边表达式编译出来的指令流；反之，则跳过符号 && 右边表达式编译出来的指令流，直接执行后面的指令
    补丁占位符(编单针, 占位符索引);
}

// 编译符号 ?: ，即符号 ?: 的 左外延 方法
// 若 条件乎 为 true，则执行真分支对应指令，并跳过假分支对应指令，执行后面的指令；否则直接跳过真分支对应指令，直接执行假分支对应的指令，以及后面的指令
static void 条件乎(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 执行此函数时，栈顶保存的就是条件表达式的结果，即符号 ? 的左操作数

    // 编译 ? 符号，调用 发射指令与占位符一起 函数写入指令，其中操作码为 OPCODE_JUMP_IF_FALSE，操作数是占位符 0xffff，
    // 返回的 假分支起始 就是该指令的操作数中用于保存高位地址的低地址端字节地址（操作数有两个字节，其中低地址端字节保存值的是高位）
    // 主要是用来保存该指令距离假分支的开始指令的偏移量
    // 用于当 条件乎 为 假 时，直接跳到假分支的开始指令执行
    // 等待真分支编译成指令后，就会调用 补丁占位符 函数将真正的偏移量回填，替换占位符 0xffff
    uint32_t 假分支起始 = 发射指令与占位符一起(编单针, 操作码之_跳若假);

    // 编译真分支代码，即生成【计算真分支代码结果，并压入到运行时栈顶】的指令
    表达式(编单针, 绑力量_最低的大写);

    // 真分支后面必须为 : 符号
    断言当前牌(编单针->当前词法器, 牌_冒号大写, "期望 ':' 在真分支后!");

    // 编译 : 符号，调用 发射指令与占位符一起 函数写入指令，其中操作码为 OPCODE_JUMP，操作数是占位符 0xffff，
    // 返回的 假分支终 就是该指令的操作数中用于保存高位地址的低地址端字节地址（操作数有两个字节，其中低地址端字节保存值的是高位）
    // 主要是用来保存该指令距离假分支的结束指令的偏移量
    // 用于当 条件乎 为 真 时，执行完真分支的指令后，直接跳过假分支的指令，执行后面的指令
    // 等待假分支编译成指令后，就会调用 补丁占位符 函数将真正的偏移量回填，替换占位符 0xffff
    uint32_t 假分支终 = 发射指令与占位符一起(编单针, 操作码之_跳);

    // 编译完真分支，知道了假分支的开始地址，回填 假分支起始
    补丁占位符(编单针, 假分支起始);

    // 编译假分支代码，即生成【计算假分支代码结果，并压入到运行时栈顶】的指令
    表达式(编单针, 绑力量_最低的大写);

    // 编译完假分支，知道了假分支的结束地址，回填 假分支终
    补丁占位符(编单针, 假分支终);
}

// 前缀符号（不关注左操作数的符号）
// 包括字面量、变量名、前缀符号等非运算符
#define 前缀_符号大写(空指针外延)             \
    {                                  \
        NULL, 绑力量_没有大写, 空指针外延, NULL, NULL \
    }

// 前缀运算符，例如 - ! ~
#define 前缀_操作者大写(身份也)                                    \
    {                                                          \
        身份也, 绑力量_没有大写, 一元操作者, NULL, 一元方法签名 \
    }

// 中缀符号（关注左操作数的符号）
// 包括 1. 数组[  2. 函数(  3. 实例和方法之间的. 等等
#define 中缀_符号大写(左绑力量, 左外延)     \
    {                              \
        NULL, 左绑力量, NULL, 左外延, NULL \
    }

// 中缀运算符，例如 - ! ~
#define 中缀_操作者大写(身份也, 左绑力量)                            \
    {                                                      \
        身份也, 左绑力量, NULL, 中缀操作者, 中缀方法签名 \
    }

// 即可做前缀运算符，也可做中缀运算符，例如 - +
#define 混合_操作者大写(身份也)                                              \
    {                                                                 \
        身份也, 绑力量_术语大写, 一元操作者, 中缀操作者, 混合方法签名 \
    }

// 对于没有规则的符号，用 未使用_规则大写 占位用的
#define 未使用_规则大写 {NULL, 绑力量_没有大写, NULL, NULL, NULL}

// 符号绑定规则的数组
// 按照 词法器.h 中定义的枚举 TokenType 中各种类型的 token 顺序，来添加对应的符号绑定规则
// 之所以要按照顺序填写，是为了方便用枚举值从 规则们大写 数组中找到某个类型的 token 的对应的符号绑定规则
符号绑规则大写 规则们大写[] = {
    /* TOKEN_INVALID */ 未使用_规则大写,
    /* TOKEN_NUM */ 前缀_符号大写(字面的),
    /* 牌_字符串大写 */ 前缀_符号大写(字面的),
    /* 牌_身份大写 */ {NULL, 绑力量_没有大写, 身份也, NULL, 身份方法签名},
    /* 牌_插值大写 */ 前缀_符号大写(字符串插值),
    /* 牌_变量了大写 */ 未使用_规则大写,
    /* 牌_函了大写 */ 未使用_规则大写,
    /* 牌_若大写 */ 未使用_规则大写,
    /* 牌_否则大写 */ 未使用_规则大写,
    /* 牌_真大写 */ 前缀_符号大写(布尔型),
    /* TOKEN_FALSE */ 前缀_符号大写(布尔型),
    /* 牌_一会儿大写 */ 未使用_规则大写,
    /* 牌_为大写 */ 未使用_规则大写,
    /* 牌_破断大写 */ 未使用_规则大写,
    /* 牌_继续大写 */ 未使用_规则大写,
    /* 牌_返回大写 */ 未使用_规则大写,
    /* TOKEN_NULL */ 前缀_符号大写(空指针乎),
    /* 牌_类大写 */ 未使用_规则大写,
    /* TOKEN_THIS */ 前缀_符号大写(这个乎),
    /* 牌_静止大写 */ 未使用_规则大写,
    /* TOKEN_IS */ 中缀_操作者大写("是", 绑力量_是大写),
    /* TOKEN_SUPER */ 前缀_符号大写(超级乎),
    /* 牌_导入大写 */ 未使用_规则大写,
    /* 牌_逗号大写 */ 未使用_规则大写,
    /* 牌_冒号大写 */ 未使用_规则大写,
    /* 牌_左小括号大写 */ 前缀_符号大写(小括号们乎),
    /* 牌_右小括号大写 */ 未使用_规则大写,
    /* TOKEN_LEFT_BRACKET */ {NULL, 绑力量_调用大写, 列表字面的乎, 子脚本乎, 子脚本方法签名},
    /* 牌_右中括号大写 */ 未使用_规则大写,
    /* 牌_左大括号大写 */ 前缀_符号大写(映射字面的乎),
    /* 牌_右大括号大写 */ 未使用_规则大写,
    /* 牌_点大写 */ 中缀_符号大写(绑力量_调用大写, 调用条目),
    /* TOKEN_DOT_DOT */ 中缀_操作者大写("..", 绑力量_范围大写),
    /* TOKEN_ADD */ 中缀_操作者大写("+", 绑力量_术语大写),
    /* TOKEN_SUB */ 混合_操作者大写("-"),
    /* TOKEN_MUL */ 中缀_操作者大写("*", 绑力量_因子大写),
    /* TOKEN_DIV */ 中缀_操作者大写("/", 绑力量_因子大写),
    /* TOKEN_MOD */ 中缀_操作者大写("%", 绑力量_因子大写),
    /* 牌_赋值号大写 */ 未使用_规则大写,
    /* TOKEN_BIT_AND */ 中缀_操作者大写("&", 绑力量_位与大写),
    /* 牌_位或号大写 */ 中缀_操作者大写("|", 绑力量_位或大写),
    /* TOKEN_BIT_NOT */ 前缀_操作者大写("~"),
    /* TOKEN_BIT_SHIFT_RIGHT */ 中缀_操作者大写(">>", 绑力量_位移大写),
    /* TOKEN_BIT_SHIFT_LEFT */ 中缀_操作者大写("<<", 绑力量_位移大写),
    /* TOKEN_LOGIC_AND */ 中缀_符号大写(绑力量_逻辑与大写, 逻辑与乎),
    /* TOKEN_LOGIC_OR */ 中缀_符号大写(绑力量_逻辑或大写, 逻辑或乎),
    /* TOKEN_LOGIC_NOT */ 前缀_操作者大写("!"),
    /* TOKEN_EQUAL */ 中缀_操作者大写("==", 绑力量_等于大写),
    /* TOKEN_NOT_EQUAL */ 中缀_操作者大写("!=", 绑力量_等于大写),
    /* TOKEN_GREAT */ 中缀_操作者大写(">", 绑力量_对比大写),
    /* TOKEN_GREAT_EQUAL */ 中缀_操作者大写(">=", 绑力量_对比大写),
    /* 牌_小于号大写 */ 中缀_操作者大写("<", 绑力量_对比大写),
    /* TOKEN_LESS_EQUAL */ 中缀_操作者大写("<=", 绑力量_对比大写),
    /* TOKEN_QUESTION */ 中缀_符号大写(绑力量_条件大写, 条件乎),
    /* 牌_文件终大写 */ 未使用_规则大写,
};

// 中缀运算符（例如 + - * /）的 左外延 方法
// 即调用此方法对中缀运算符进行语法分析
// 切记，进入任何一个符号的 左外延 或 空指针外延 方法时，preToken 都是该方法所属符号（即操作符），curToken 为该方法所属符号的右边符号（即操作数）
static void 中缀操作者(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 获取该方法所属符号对应的绑定规则
    符号绑规则大写 *规则 = &规则们大写[编单针->当前词法器->前一个牌.类型];

    // 对于中缀运算符，其对左右操作数的绑定权值相同
    绑力量大写 右绑力量 = 规则->左绑力量;
    // 解析操作符的右操作数
    // 即生成【计算右操作数的结果，并将结果压入到运行时栈顶】的指令
    表达式(编单针, 右绑力量);

    // 例如表达式 3+2 就会被视为 3.+(2)
    // 其中 3 为对象，+ 是方法，2 为参数
    // 即 op1.operator(op2)，只有一个参数 op2
    // 下面定义该方法对应的签名
    签名大写 签名 = {
        签名_方法大写,      // 类型为普通方法
        规则->身份也,         // 方法名即操作运算符的名字
        strlen(规则->身份也), // 方法名长度即操作运算符的名字长度
        1                 // 参数只有一个，即 op2。实际上在虚拟机中会有个默认参数，即调用该方法的对象实例，在这里就是 op1，所以就可以计算 op1 和 op2 的结果
    };

    // 基于该中缀操作符方法的签名 生成【调用该中缀运算符方法】的指令
    // 方法的参数就是该符号的右操作数，或者右操作树的计算结果（此时虚拟机已经执行了 表达式(编单针, 右绑力量) 编译的指令，右操作数的结果此处就在运行时栈顶）
    发射调用通过签名(编单针, &签名, 操作码之_调用0);
}

// 前缀运算符（例如 ! -）的 空指针外延 方法
// 即调用此方法对前缀运算符进行语法分析
static void 一元操作者(编译单元大写 *编单针, 布尔 能分配 未使用大写) {
    // 获取该方法所属符号对应的绑定规则
    符号绑规则大写 *规则 = &规则们大写[编单针->当前词法器->前一个牌.类型];

    // 解析操作符的右操作数，绑定权值为 BP_UNARY，绑定权值较高
    // 不能用前缀运算符的对左操作数的绑定权值（其值最低，为 BP_NONE）
    // 因为前缀运算符只关心右操作数，不关系左操作数
    表达式(编单针, 绑力量_一元大写);

    // 生成调用该前缀运算符方法的指令
    // 前缀运算符方法的名字长度，即 strlen(规则->身份也) 为 1
    // 前缀运算符方法的参数为 0
    // 例如表达式 !3 会被视为 3.!，即 3 调用 ! 操作符对应的方法
    // 实际上在虚拟机中会有个默认参数，即调用该方法的对象实例，在这里就是数字对象 3，所以就可以计算 3 取反的结果
    发射调用(编单针, 规则->身份也, 1, 0);
}

// 语法分析的核心方法 expression，用来解析表达式结果
// 只是负责调用符号的 左外延 或 空指针外延 方法，不负责语法分析，至于 左外延 或 空指针外延 方法中是否有语法分析功能，则是该符号自己协调的事
// 这里以中缀运算符表达式 aSwTeUg 为例进行注释讲解
// 其中大写字符代表运算符，小写字符代表操作数
// 表达式 开始由运算符 S 调用的，所以 右绑力量 为运算符 S 的绑定权值
static void 表达式(编译单元大写 *编单针, 绑力量大写 右绑力量) {
    // 表达式 是由运算符 S 调用的，对于中缀运算符来说，此时 当前牌 为操作数 w
    // 找到操作数 w 的 空指针外延 方法
    外延函 空指针外延 = 规则们大写[编单针->当前词法器->当前牌.类型].空指针外延;

    断言大写(空指针外延 != NULL, "空指针外延是NULL!");

    // 获取下一个 token
    // 执行后 当前牌 为运算符 T
    获取下一个牌(编单针->当前词法器);

    // 能分配 用于判断是否具备可赋值的环境
    // 即当运算符 S 的绑定权值 右绑力量 小于 绑力量_赋值大写 时，才能保证左值属于赋值运算符
    布尔 能分配 = 右绑力量 < 绑力量_赋值大写;
    // 执行操作数 w 的 空指针外延 方法，计算操作数 w 的值
    空指针外延(编单针, 能分配);

    // 右绑力量 为运算符 S 的对操作数的绑定权值
    // 因 当前牌 目前为运算符 T，所以 规则们大写[编单针->当前词法器->当前牌.类型].左绑力量 为运算符 T 对操作数的绑定权值
    // 如果运算符 S 绑定权值大于运算符 T 绑定权值，则操作数 w 为运算符 S 的右操作数，则不进入循环，直接将操作数 w 作为运算符 S 的右操作数返回
    // 反之，则操作数 w 为运算符 T 的左操作数，进入循环
    while (右绑力量 < 规则们大写[编单针->当前词法器->当前牌.类型].左绑力量) {
        // 当前牌 为运算符 T，因此该函数是获取运算符 T 的 左外延 方法
        外延函 左外延 = 规则们大写[编单针->当前词法器->当前牌.类型].左外延;

        // 获取下一个 token
        // 执行后 当前牌 为操作数 e
        获取下一个牌(编单针->当前词法器);

        // 执行运算符 T 的 左外延 方法，去构建以运算符 T 为根，以操作数 w 为左节点的语法树
        // 右节点是通过 左外延 方法里继续递归调用 表达式 去解析的
        左外延(编单针, 能分配);
    }
}

// 进入内嵌作用域
static void 进入作用域(编译单元大写 *编单针) {
    编单针->作用域深度++;
}

// 退出作用域
static void 离开作用域(编译单元大写 *编单针) {
    if (编单针->封闭的单元 != NULL) {
        // 如果不是模块编译单元，则需要丢弃该作用域下的局部变量
        // 因为模块编译单元的作用域作为顶级作用域不能退出，确保类的静态属性得以保留
        uint32_t 抛弃数目 = 抛弃本地变量了(编单针, 编单针->作用域深度);
        // 该编译单元的局部变量数量减去 抛弃数目
        编单针->本地变量数目了 -= 抛弃数目;
        // 该编译单元内所有指令对运行时栈的最终影响减去 抛弃数目
        编单针->栈槽数目了 -= 抛弃数目;
    }
    // 回到上一层作用域
    编单针->作用域深度--;
}


// 编译变量定义
// 注意：变量定义不支持一次定义多个变量，例如 var a, b;
// 是否静止 表示是否是类的静态属性
static void 编译变量定义(编译单元大写 *编单针, 布尔 是否静止) {
    // 当执行该函数时，已经读入了关键字 var，也正是主调方函数识别到了关键字 var，才会决定调用该函数（主调方函数为 compileProgram）
    // 此时 当前牌 为 var 后面的变量名
    // 变量名的 token 类型应该为 TOKEN_ID，否则报错
    断言当前牌(编单针->当前词法器, 牌_身份大写, "丢失变量名称!");

    牌大写 名称 = 编单针->当前词法器->前一个牌;
    // 只支持一次定义单个变量，当发现变量后面有逗号，则报编译错误
    if (编单针->当前词法器->当前牌.类型 == 牌_逗号大写) {
        编译_错误大写(编单针->当前词法器, "'变量' 仅支持声明一个变量.");
    }

    // 一、类中的属性（类的静态属性或实例的属性）定义，推导如下：
    // 1. 当编译一个类的时候，会把 编单针->enclosingClassBK 置为所编译类的 classBookKeep 结构，所以 编单针->封闭的类BK != NULL 说明正在编译类
    // 2. 如果在编译的是类的方法，那么 编单针->enclosingUnit 就是模块的编译单元，不可能为 NULL
    // 3. 又因为 编单针->enclosingUnit == NULL，所以肯定不是类的方法，所以只能是在编译类的静态属性或者实例属性
    if (编单针->封闭的单元 == NULL && 编单针->封闭的类BK != NULL) {
        if (是否静止) {
            // 1. 类的静态属性
            // 先申请一个数据缓冲区，并将其中的值均置为 0
            char *静止字段身份 = 分配数组大写(编单针->当前词法器->虚机针, char, 最大身份长度了大写);
            memset(静止字段身份, 0, 最大身份长度了大写);

            // 将形式为 “Cls类名 静态属性名” 的变量名写入到 staticFieldId（类的静态属性就是按照这种形式保存在模块编译单元的局部变量中的）
            char *类了名 = 编单针->封闭的类BK->名称->值.起始;
            uint32_t 类了长 = 编单针->封闭的类BK->名称->值.长度;
            memmove(静止字段身份, "类静", 3);
            memmove(静止字段身份 + 3, 类了名, 类了长);
            memmove(静止字段身份 + 3 + 类了长, " ", 1);
            memmove(静止字段身份 + 3 + 类了长 + 1, 名称.起始, 名称.长度);

            if (找本地变量了(编单针, 静止字段身份, strlen(静止字段身份)) == -1) {
                // 如果没有定义过，则将其声明为模块编译单元的局部变量
                int 索引 = 声明本地变量(编单针, 静止字段身份, strlen(静止字段身份));
                // 并赋值为 NULL
                // 先生成【将 NULL 压入栈顶】的指令
                写操作码(编单针, 操作码之_推空指针);
                断言大写(编单针->作用域深度 == 0, "应该在类作用域内");
                // 再赋值变量，即将运行时栈顶数据 NULL 保存为变量的值
                定义变量之(编单针, 索引);

                // 静态属性可以被赋值的，即如果静态属性后面有等号 =，就将等号后面的值作为静态变量的值
                // 先从模块编译单元的局部变量中找到该变量
                变量大写 var = 找变量(编单针, 静止字段身份, strlen(静止字段身份));
                if (匹配牌(编单针->当前词法器, 牌_赋值号大写)) {
                    // 生成【计算等号右边的表达式，并将计算结果压入到运行时栈顶】的指令
                    表达式(编单针, 绑力量_最低的大写);
                    // 生成【将栈顶数据存入索引为 index 的变量】的指令
                    发射存储变量(编单针, var);
                }
            } else {
                // 如果已经定义，则报错--重复定义
                // char *strchr(const char *串, int c) 在参数 串 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置
                编译_错误大写("静态字段 '%s' 重新定义!", strchr(静止字段身份, ' ') + 1);
            }
        } else {
            // 2. 实例属性
            类书保持大写 *类BK = 获取封闭类BK(编单针);
            // 从类的属性符号表 类BK->字段们 查找是否有该属性
            int 字段索引 = 获取索引来自符号表(&类BK->字段们, 名称.起始, 名称.长度);

            if (字段索引 == -1) {
                // 如果没有，就添加进去
                加上符号(编单针->当前词法器->虚机针, &类BK->字段们, 名称.起始, 名称.长度);
            } else {
                // 否则就是已经存在相同属性
                if (字段索引 > 最大字段数目了大写) {
                    // 报错--超过类的属性个数最大值
                    编译_错误大写(编单针->当前词法器, "实例字段的最大数目是 %d", 最大字段数目了大写);
                } else {
                    char 身份也[最大身份长度了大写] = {'\0'};
                    memcpy(身份也, 名称.起始, 名称.长度);
                    // 否则报错--重复定义属性
                    编译_错误大写(编单针->当前词法器, "实例字段 '%s' 重新定义!", 身份也);
                }
            }

            // 因为实例属性仅属于实对象的私有属性，所以定义类的时候不可被初始化
            if (匹配牌(编单针->当前词法器, 牌_赋值号大写)) {
                编译_错误大写(编单针->当前词法器, "实例字段不允许初始化!");
            }
        }
        return;
    }

    // 二、如果不是类中的属性定义，就当作普通的变量定义
    if (匹配牌(编单针->当前词法器, 牌_赋值号大写)) {
        // 如果定义变量时就赋值，则就生成【计算等号右边的表达式，并将计算结果压入到运行时栈顶】的指令
        表达式(编单针, 绑力量_最低的大写);
    } else {
        // 否则生成【将 NULL 压入栈顶】的指令
        // 即将 NULL 作为变量的初始值，目的是为了和上面的显示初始化保持相同的栈结构
        写操作码(编单针, 操作码之_推空指针);
    }

    // 声明变量（包括局部变量和模块变量）
    uint32_t 索引 = 声明变量之(编单针, 名称.起始, 名称.长度);
    // 赋值变量，即将运行时栈顶数据保存为变量的值
    // 主要是针对模块变量的，因为局部变量的值只需要压入到运行时栈中即可
    定义变量之(编单针, 索引);
}

// 编译 if 语句
static void 编译若语句(编译单元大写 *编单针) {
    // 执行此函数时已经读入了 if 字符
    断言当前牌(编单针->当前词法器, 牌_左小括号大写, "丢失 '(' 在若后!");
    // 生成【计算 if 条件表达式，并将计算结果压入到栈顶】的指令
    表达式(编单针, 绑力量_最低的大写);
    断言当前牌(编单针->当前词法器, 牌_右小括号大写, "丢失 ')' 在 '{' 之前在若内!");

    // 调用 发射指令与占位符一起 函数写入指令，其中操作码为 OPCODE_JUMP_IF_FALSE，操作数是占位符 0xffff，
    // 返回的 假分支起始 就是该指令的操作数中用于保存高位地址的低地址端字节地址（操作数有两个字节，其中低地址端字节保存值的是高位）
    // 主要是用来保存该指令距离假分支的开始指令的偏移量
    // 用于当 条件乎 为 假 时，直接跳到假分支的开始指令执行
    // 等待真分支编译成指令后，就会调用 补丁占位符 函数将真正的偏移量回填，替换占位符 0xffff
    uint32_t 假分支起始 = 发射指令与占位符一起(编单针, 操作码之_跳若假);

    // 编译真分支代码
    编译语句(编单针);

    if (匹配牌(编单针->当前词法器, 牌_否则大写)) {
        // 如果有 else 分支
        // 调用 发射指令与占位符一起 函数写入指令，其中操作码为 OPCODE_JUMP，操作数是占位符 0xffff，
        // 返回的 假分支终 就是该指令的操作数中用于保存高位地址的低地址端字节地址（操作数有两个字节，其中低地址端字节保存值的是高位）
        // 主要是用来保存该指令距离假分支的结束指令的偏移量
        // 用于当 条件乎 为 真 时，执行完真分支的指令后，直接跳过假分支的指令，执行后面的指令
        // 等待假分支编译成指令后，就会调用 补丁占位符 函数将真正的偏移量回填，替换占位符 0xffff
        uint32_t 假分支终 = 发射指令与占位符一起(编单针, 操作码之_跳);

        // 编译完真分支，知道了假分支的开始地址，回填 假分支起始
        补丁占位符(编单针, 假分支起始);

        // 编译假分支代码，即 else 分支代码
        编译语句(编单针);

        // 编译完假分支，即 else 分支代码，知道了假分支的结束地址，回填 假分支终
        补丁占位符(编单针, 假分支终);
    } else {
        // 如果没有 else 分支，此时就是 条件乎 为 假 时，需要跳过整个真分支的目标地址
        补丁占位符(编单针, 假分支起始);
    }
}

// 进入循环体时的相关设置
static void 进入环设置(编译单元大写 *编单针, 环大写 *环) {
    // 执行此函数时，已经读入了 while 字符

    // 将循环条件的第一条指令的地址保存为循环条件的起始指令地址
    环->条件起始索引 = 编单针->函->指令流.计数 - 1;
    // 设置循环所处的作用域，方便循环中若有 break，告诉它需要退出的作用域深度
    环->作用域深度 = 编单针->作用域深度;
    // 将之前的 curLoop 设置成当前循环的直接外层循环
    环->封闭的环 = 编单针->当前环;
    // 将当前的循环设置成 curLoop
    编单针->当前环 = 环;
}

// 编译循环体
static void 编译环物自体(编译单元大写 *编单针) {
    // 将循环体的第一条指令的地址保存为循环体起始地址
    编单针->当前环->物自体起始索引 = 编单针->函->指令流.计数;
    // 编译循环体
    编译语句(编单针);
}

// 离开循环体时的相关设置
static void 离开环设置(编译单元大写 *编单针) {
    // 在循环体结束处需要有一条向回跳到循环条件的起始处的指令
    // 因为所有的跳转指令的操作数都是偏移量，且不能是负数，所以 操作码之_跳 无法满足条件，该操作码只能向后跳
    // 而此处情况需要向前跳，所以使用单独的操作码 OPCODE_LOOP，对应操作数只需是正数的偏移量即可

    // 计算当前指令的下一个指令（即循环体对应指令流中的结尾指令的下一个指令）距离循环条件的起始指令地址的偏移量
    // 其中 操作码之_环 的操作数是两个字节（保存的值是偏移量）当虚拟机读取到 操作码之_环 时，ip 已经向后移动了两个字节，因此偏移量要加上 2 个字节
    int 环背偏移 = 编单针->函->指令流.计数 - 编单针->当前环->条件起始索引 + 2;
    // 生成【向前跳转到循环条件起始处】的指令
    写操作码短操作范围(编单针, 操作码之_环, 环背偏移);

    // 循环体已经编译结束，知道了将循环体的结束地址，回填 编单针->curLoop->出口索引
    补丁占位符(编单针, 编单针->当前环->出口索引);

    // 在编译循环体时遇到 break，按理应该生成跳转到循环体结尾处的指令（操作码为 OPCODE_JUMP），即直接跳过循环体
    // 但由于当时并没有完整地编译循环体，并不知道循环体结尾指令的地址，所以先生成操作码为 操作码之_终 的指令作为占位（OPCODE_END 没有其他用途，所以没有二义性）
    // 此时已经编译完了循环体，所以将循化体中的 操作码为 操作码之_终 的指令 替换为 操作码为 OPCODE_JUMP，操作数为当前指令地址到循环体的结尾指令地址的偏移量 的指令

    // 循环体起始指令地址
    uint32_t 索引了 = 编单针->当前环->物自体起始索引;

    // 循环体结尾指令地址
    uint32_t 环终索引 = 编单针->函->指令流.计数;

    // 遍历循环体对应指令流中的所有指令
    while (索引了 < 环终索引) {
        if (编单针->函->指令流.数据们[索引了] == 操作码之_终) {
            // 如果存在 操作码之_终 操作码（即 break 的占位符），则替换成操作码为 操作码之_跳 的指令
            编单针->函->指令流.数据们[索引了] = 操作码之_跳;
            // 将地址为 索引了 的操作码 到 当前指令（即循环体对应指令流的结尾指令地址）的 偏移量，
            // 设置到地址为 索引了 + 1 和 索引了 + 2 的两个操作数中，
            // 其中偏移量的高位保存在低地址端 索引了 + 1，偏移量的低位保存在高地址端 索引了 + 2，即大段字节序
            补丁占位符(编单针, 索引了 + 1);
            // 操作码为 操作码之_跳 的指令大小为 3 个字节，包括了 1 个字节的操作码，2 个字节的操作数
            // 所以加 3 就是指向操作码为 操作码之_跳 的指令的下一个指令
            索引了 += 3;
        } else {
            // 如果该指令不是操作码为 操作码之_跳 的指令，则指向下一个指令
            // 当前指令大小 = 操作码大小（1 个字节） + 获取操作范围们的字节们 获取到的操作数的大小
            索引了 += 1 + 获取操作范围们的字节们(编单针->函->指令流.数据们, 编单针->函->常量们.数据们, 索引了);
        }
    }

    // 退出当前循环体，将 编单针->curLoop 恢复成当前循环体的外层循环
    编单针->当前环 = 编单针->当前环->封闭的环;
}

// 编译 while 语句
static void 编译一会儿语句(编译单元大写 *编单针) {
    环大写 环;
    // 调用此函数时，已经读入了关键字 while

    // 进入循环添加时的相关设置
    进入环设置(编单针, &环);

    断言当前牌(编单针->当前词法器, 牌_左小括号大写, "期望 '(' 在条件之前!");

    // 生成【计算循环条件表达式，并将计算结果压入到运行时栈顶】的指令
    表达式(编单针, 绑力量_最低的大写);

    断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在条件之后!");

    // 调用 发射指令与占位符一起 函数写入指令，其中操作码为 OPCODE_JUMP_IF_FALSE，操作数是占位符 0xffff，
    // 该函数返回的值就是该指令的操作数中用于保存高位地址的低地址端字节地址（操作数有两个字节，其中低地址端字节保存值的是高位）
    // 主要是用来保存 该指令 距离 循环体的对应的指令流中的结束指令地址 的的偏移量
    // 用于当 条件乎 为 假 时，直接跳过循环体的指令流，执行其后面的指令
    // 等待循环体编译成指令后，就会调用 补丁占位符 函数将真正的偏移量回填，替换占位符 0xffff
    环.出口索引 = 发射指令与占位符一起(编单针, 操作码之_跳若假);

    // 编译循环体
    编译环物自体(编单针);

    // 离开循环体时的相关设置
    离开环设置(编单针);
}

// 编译 for 循环语句
//  for 循环会按照while循环的逻辑编译
//  for i (sequence) {
//      System.print(i)
//  }
//  其中 sequence 是可迭代的序列
//  在内部会变成:
//  var seq = sequence
//  var iter
//  while iter = seq.iterate(iter) {
//      var i = seq.iteratorValue(iter)
//      System.print(i)
//  }
static void 编译为语句(编译单元大写 *编单针) {
    // 为局部变量 seq 和 iter 创建作用域
    进入作用域(编单针);

    // 读取循环变量的名字，如 "for i (sequence)" 中的 i
    断言当前牌(编单针->当前词法器, 牌_身份大写, "期望变量在为后!");
    const char *环变量名 = 编单针->当前词法器->前一个牌.起始;
    uint32_t 环变量长度 = 编单针->当前词法器->前一个牌.长度;

    断言当前牌(编单针->当前词法器, 牌_左小括号大写, "期望 '(' 在序列之前!");

    // 编译迭代序列
    表达式(编单针, 绑力量_最低的大写);
    断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在序列之后!");
    // 申请局部变量 seq 来存储序列对象，其值就是上面 表达式 存储到栈中的结果
    uint32_t 序列槽 = 加上本地变量(编单针, "序列 ", 4);

    写操作码(编单针, 操作码之_推空指针);
    // 分配及初始化 iter，其值就是上面加载到栈中的的 NULL
    uint32_t 迭代槽 = 加上本地变量(编单针, "迭代 ", 5);

    环大写 环;
    进入环设置(编单针, &环);

    // 为调用 "seq.iterate(iter)" 做准备
    // 1. 先压入序列对象 seq，即 "seq.iterate(iter)" 中的seq
    写操作码字节操作范围(编单针, 操作码之_载入本地变量, 序列槽);
    // 2. 再压入参数 iter，即 "seq.iterate(iter)" 中的iter
    写操作码字节操作范围(编单针, 操作码之_载入本地变量, 迭代槽);
    // 3. 调用 "seq.iterate(iter)"
    发射调用(编单针,  "迭代的(_)", 10, 1);

    // "seq.iterate(iter)" 把结果(下一个迭代器)存储到
    // args[0](即栈顶)，现在将其同步到变量iter
    写操作码字节操作范围(编单针, 操作码之_存储本地变量, 迭代槽);

    // 如果条件失败则跳出循环体，目前不知道循环体的结束地址，
    // 先写入占位符.
    环.出口索引 = 发射指令与占位符一起(编单针, 操作码之_跳若假);

    // 调用 "seq.iteratorValue(iter)" 以获取值
    // 1. 为调用 "seq.iteratorValue(iter)" 压入参数 seq
    写操作码字节操作范围(编单针, 操作码之_载入本地变量, 序列槽);
    // 2. 为调用 "seq.iteratorValue(iter)" 压入参数 iter
    写操作码字节操作范围(编单针, 操作码之_载入本地变量, 迭代槽);
    // 3. 调用 "seq.iteratorValue(iter)"
    发射调用(编单针, "迭代的值(_)", 16, 1);

    // 为循环变量 i 创建作用域
    进入作用域(编单针);
    // "seq.iteratorValue(iter)" 已经把结果存储到栈顶，
    // 添加循环变量为局部变量，其值在栈顶
    加上本地变量(编单针, 环变量名, 环变量长度);

    // 编译循环体
    编译环物自体(编单针);

    //离开循环变量 i 的作用域
    离开作用域(编单针);

    离开环设置(编单针);

    //离开变量 seq 和 iter 的作用域
    离开作用域(编单针);
}

// 编译 return 语句
inline static void 编译返回语句(编译单元大写 *编单针) {
    // 执行此函数时已经读入了 return，即 前一个牌 为 return

    // TODO: 判断逻辑等待后续完善
    if (编单针->当前词法器->当前牌.类型 == 牌_右大括号大写) {
        // 如果 return 后面是符号 }，则说明没有明确返回值，此时默认返回值为 NULL
        // 生成【将 NULL 压入到运行时栈顶】的指令
        写操作码(编单针, 操作码之_推空指针);
    } else {
        // 否则就是明确了返回值，则生成【计算 return 后面的表达式，并将计算结果压入到运行时栈顶】的指令
        表达式(编单针, 绑力量_最低的大写);
    }
    // 生成【退出当前函数并弹出栈顶的值作为返回值】的指令
    写操作码(编单针, 操作码之_返回);
}

// 编译 break 语句
inline static void 编译破断语句(编译单元大写 *编单针) {
    if (编单针->当前环 == NULL) {
        编译_错误大写(编单针->当前词法器, "破断应在环内使用!");
    }

    // 在退出循环体之前要丢掉循环体内的局部变量
    // 此处加 1 是为了丢掉比循环体的作用域更深一层的作用域，即循环（包括循环条件、循环体）的作用域中的局部变量
    抛弃本地变量了(编单针, 编单针->当前环->作用域深度 + 1);

    // 将 break 编译为操作码为 OPCODE_END，操作数为 0xffff （2 个字节）的指令（OPCODE_END 不作他用，所以没有二义性问题），
    // 等到整个循环体编译完成后，会遍历对应指令流，找到操作码为 操作码之_终 的指令，
    // 将操作码 操作码之_终 替换为 OPCODE_JUMP，操作数替换成当前指令到循环体对应指令流的结尾指令的偏移量（相关逻辑在 离开环设置 函数中）
    // 所以不用返回需要回填的地址（即保存偏移量的地址，也就是 操作码之_终 操作数中的高位字节地址），因为 离开环设置 中会遍历，遍历的时候会得到地址
    发射指令与占位符一起(编单针, 操作码之_终);
}

// 编译 continue 语句
inline static void 编译继续语句(编译单元大写 *编单针) {
    if (编单针->当前环 == NULL) {
        编译_错误大写(编单针->当前词法器, "继续应在环内使用!");
    }

    // 在退出循环体之前要丢掉循环体内的局部变量
    // 此处加 1 是为了丢掉比循环体的作用域更深一层的作用域，即循环（包括循环条件、循环体）的作用域中的局部变量
    抛弃本地变量了(编单针, 编单针->当前环->作用域深度 + 1);

    // 计算当前指令的下一个指令（即循环体对应指令流中的结尾指令的下一个指令）距离循环条件的起始指令地址的偏移量
    // 其中 操作码之_环 的操作数是两个字节（保存的值是偏移量）当虚拟机读取到 操作码之_环 时，ip 已经向后移动了两个字节，因此偏移量要加上 2 个字节
    int 环背偏移 = 编单针->函->指令流.计数 - 编单针->当前环->条件起始索引 + 2;

    // 生成【向前跳转到循环条件起始处】的指令
    写操作码短操作范围(编单针, 操作码之_环, 环背偏移);
}

// 编译语句
// 代码分为两种：
// 1. 定义：生命数据的代码，例如定义变量、定义函数、定义类
// 2. 语句：具备能动性的代码，可执行各种动作，例如 return、break 等
static void 编译语句(编译单元大写 *编单针) {
    if (匹配牌(编单针->当前词法器, 牌_若大写)) {
        编译若语句(编单针);
    } else if (匹配牌(编单针->当前词法器, 牌_一会儿大写)) {
        编译一会儿语句(编单针);
    } else if (匹配牌(编单针->当前词法器, 牌_为大写)) {
        编译为语句(编单针);
    } else if (匹配牌(编单针->当前词法器, 牌_返回大写)) {
        编译返回语句(编单针);
    } else if (匹配牌(编单针->当前词法器, 牌_破断大写)) {
        编译破断语句(编单针);
    } else if (匹配牌(编单针->当前词法器, 牌_继续大写)) {
        编译继续语句(编单针);
    } else if (匹配牌(编单针->当前词法器, 牌_左大括号大写)) {
        // 编译代码块，即大括号之间的代码块
        进入作用域(编单针);
        编译块(编单针);
        离开作用域(编单针);
    } else {
        // 若不是以上的语法结构，则是单一表达式
        // 生成【计算表达式，并将计算结果压入到运行时栈顶】的指令
        表达式(编单针, 绑力量_最低的大写);
        // 生成【将运行时栈顶弹出（栈顶保存的是上一条指令计算的表达式结果）】的指令
        // 例如 a = 1 + 2，右边表达式的结果是 3，被压入到运行时栈顶，3 会被保存到变量 a 中，
        // 但变量 a 中只是保存了 3 的副本，也就是说只是将数值 3 复制到变量 a 所在的运行时栈相应的 slot 中，栈顶的 3 还在，因此需要被弹出
        写操作码(编单针, 操作码之_弹);
    }
}

// 声明类的方法
// 其中方法名相当于方法的标识，存储在 虚机针->allMethodNames
// 方法体相当于方法的值，存储在方法所属类 class->方法们
// 声明方法只是在 虚机针->allMethodNames 声明方法名，不涉及方法体
static int 声明方法(编译单元大写 *编单针, char *签名串, uint32_t 长度) {
    // 首先确保该方法名被录入到了 虚机针->allMethodNames
    // 确保符号存在 方法会在 虚机针->allMethodNames 中查找是否存在方法名 signStr，如果存在，则直接返回对应索引；如果不存在，则插入方法名并返回索引。
    int 索引 = 确保符号存在(编单针->当前词法器->虚机针, &编单针->当前词法器->虚机针->全部方法名们, 签名串, 长度);

    // 为了防止重复声明，即方法名 签名串 对应的方法之前已经声明过了（ensureSymbolExist 方法无法做到）
    // 定义了两个结构，ClassBookKeep->静止方法们 保存类方法在 虚机针->全部方法名们 的索引
    // ClassBookKeep->实例方法们 保存实例方法在 虚机针->全部方法名们 的索引
    // 所以从 ClassBookKeep->实例方法们/静止方法们 中查找是否存在与上面 确保符号存在 得到的索引 索引 相同的值
    // 如果有，则就是重复声明方法名
    整型大写缓冲区大写 *方法们 = 编单针->封闭的类BK->是否静止 ? &编单针->封闭的类BK->静止方法们 : &编单针->封闭的类BK->实例方法们;
    uint32_t 索引了 = 0;
    while (索引了 < 方法们->计数) {
        if (方法们->数据们[索引了] == 索引) {
            编译_错误大写(编单针->当前词法器, "重复定义方法 %s 在类 %s 内!", 签名串, 编单针->封闭的类BK->名称->值.起始);
        }
        索引了++;
    }

    // 如果执行到这里，说明该类方法之前没有声明过，则将其加入到 ClassBookKeep->实例方法们/staticMethods，方便后续排查是否重复声明
    整型大写缓冲区添加大写(编单针->当前词法器->虚机针, 方法们, 索引);
    return 索引;
}

// 定义类的方法
// 其中方法名相当于方法的标识，存储在 虚机针->allMethodNames
// 方法体相当于方法的值，存储在方法所属类的 class->方法们
// 定义方法需要将方法体存在到所属类的 class->方法们 中
// 即将索引 方法索引 对应的方法存储到变量 类变量 指向的类的 class->方法们[方法索引] 中，methodIndex 就是该方法名在 虚机针->全部方法名们 中的索引
static void 定义方法(编译单元大写 *编单针, 变量大写 类变量, 布尔 是否静止, int 方法索引) {
    // 执行此函数时，待定义的方法已经被压入到了运行时栈顶

    // 生成【将方法所属类压入到运行时栈顶】的指令
    发射载入变量(编单针, 类变量);

    // 此时，运行时栈顶为方法所属类，次栈顶为待定义的方法
    // 生成【将次栈顶的方法，存储到栈顶的类的 class->方法们[方法索引] 中，其中 方法索引 为指令的操作数】的指令
    操作码枚举大写 操作的码 = 是否静止 ? 操作码之_静止方法 : 操作码之_实例方法;
    写操作码短操作范围(编单针, 操作的码, 方法索引);
}

// 生成【创建对象实例】的方法，并将该方法闭包压入到运行时栈顶
// 创建对象实例的示例代码如下：
// class Foo {
//     var bar
//     new(arg) {
//         bar = arg
//     }
// }
// var obj = Foo.new(9)
// 注意：Foo.new(9) 中的 new 方法是类的静态方法，类定义中的 new(arg) {...} 是实例方法
// 发射创建实例 实现的逻辑就是类的静态方法 new 的核心逻辑，在该方法中会调用类定义中的实例方法 new
// 下面参数 sign 就是类定义中的实例方法 new 的方法签名，methodIndex 是该实例方法 new 的方法签名在 虚机针->全部方法名们 中的索引
static void 发射创建实例(编译单元大写 *编单针, 签名大写 *签名, uint32_t 方法索引) {
    // 定义一个用于存储创建对象的指令的编译单元
    编译单元大写 方法编单;
    // 初始化编译单元 methodCU，并将该编译单元作为 编单针 的内层编译单元
    初始编译单元(编单针->当前词法器, &方法编单, 编单针, 真);

    // 1. 生成【类对象在当前运行时栈的栈底（即 stack[0]），该操作码会创建一个类的实例，然后用该实例替换栈底的类对象】的指令
    写操作码(&方法编单, 操作码之_构造);

    // 2. 生成【调用上个指令创建的处在栈底的实例对象的 new 方法】的指令
    // 注：实例对象的 new 方法，会将上条指令创建的处在栈底的实例对象，压入到栈顶，并返回
    // 即实例对象的 new 方法除了用户写的代码之外，还会在被编译的指令流尾部添加两个指令：
    // 操作码之_载入本地变量, 0（将栈底的实例对象加载到栈顶）    OPCODE_RETURN（将栈顶的实例对象返回）
    // 该逻辑会在后面编译类的定义中的编译类中的实例方法 new() {...} 方法时看到
    写操作码短操作范围(&方法编单, (操作码枚举大写)(操作码之_调用0 + 签名->实参数目了), 方法索引);

    // 3. 生成【返回 上面指令调用的实例对象的实例方法 new 返回的实例对象】的指令
    写操作码(&方法编单, 操作码之_返回);

#if 调试大写
    终编译单元(&方法编单, "", 0);
#else
    // 生成该方法的闭包，并压入到运行时栈顶（由操作码为 操作码之_创建闭包 的指令实现）
    // 等待下面被定义为类的静态方法 new
    终编译单元(&方法编单);
#endif
}

// 编译方法定义
// 是否静止 表示是否在编译类的静态方法
static void 编译方法(编译单元大写 *编单针, 变量大写 类变量, 布尔 是否静止) {
    // 调用此方法时，已经读入了方法名，即 当前牌 为方法名

    // 设置当前是否正在编译类的静态方法（如果是静态方法，方法名前面会有 static 关键字，在执行该函数的都是已经读入了方法名，所以已经知道是否是在编译静态方法了）
    编单针->封闭的类BK->是否静止 = 是否静止;

    // 获取方法的生成签名的函数
    // 当前牌 为方法名，所以 当前牌.类型 为 TOKEN_ID，对应的 methodSign（用于生成方法签名的函数） 为 身份方法签名
    方法签名函 方法签名了 = 规则们大写[编单针->当前词法器->当前牌.类型].方法签名了;
    if (方法签名了 == NULL) {
        编译_错误大写(编单针->当前词法器, "方法需要签名函数!");
    }

    // 初始化方法签名
    签名大写 签名;
    签名.名称 = 编单针->当前词法器->当前牌.起始;
    签名.长度 = 编单针->当前词法器->当前牌.长度;
    签名.实参数目了 = 0;
    // 并将该签名设置成对应类的 ClassBookKeep 结构中的 signature（指向当前正在编译的方法的签名）
    编单针->封闭的类BK->签名 = &签名;

    // 读入下一个 token，正常来说应该是方法名后面的符号 (
    // 主要是为了后面调用 方法签名了 构造方法签名
    获取下一个牌(编单针->当前词法器);

    // 初始化方法的编译单元
    // 注：方法或函数都是独立的指令流，需要独立的编译单元
    编译单元大写 方法编单;
    初始编译单元(编单针->当前词法器, &方法编单, 编单针, 真);

    // 构造方法签名
    方法签名了(&方法编单, &签名);
    // 执行完构造方法签名的函数后，curToken 应该是符号 {
    断言当前牌(编单针->当前词法器, 牌_左大括号大写, "期望 '{' 在方法物自体的开头.");

    // 构造完方法签名后，先判断下方法类型是否是构造函数，如果是构造函数且还是静态方法，就报错
    if (编单针->封闭的类BK->是否静止 && 签名.类型 == 签名_构造大写) {
        编译_错误大写(编单针->当前词法器, "构造不允许是静止!");
    }

    // 将方法签名转成字符串形式
    char 签名字符串[最大签名长度了大写] = {'\0'};
    uint32_t 签名长度 = 签名到字符串(&签名, 签名字符串);

    // 声明方法`
    // 声明方法只是在 虚机针->allMethodNames 声明方法名，不涉及方法体
    uint32_t 方法索引 = 声明方法(编单针, 签名字符串, 签名长度);

    // 编译方法体，将编译出的指令流写入到自己的编译单元 方法编单
    编译物自体(&方法编单, 签名.类型 == 签名_构造大写);

#if 调试大写
    终编译单元(&方法编单, "", 0);
#else
    // 结束编译，并生成方法闭包，并压入到运行时栈顶（由操作码为 操作码之_创建闭包 的指令实现）
    终编译单元(&方法编单);
#endif

    // 定义方法
    // 即将索引 方法索引 对应的方法闭包存储到变量 类变量 指向的类的 class->方法们[方法索引] 中，methodIndex 就是该方法名在 虚机针->全部方法名们 中的索引
    定义方法(编单针, 类变量, 编单针->封闭的类BK->是否静止, 方法索引);

    // 针对类定义中的实例方法 new 方法，经过上面的处理会被编译成实例方法
    // 需要在实例方法 new 方法基础上再创建一个类的静态方法 new，以供类直接调用生成对象实例，该静态方法 new 方法中最终也是会调用之前的实例方法 new 方法
    // 详细逻辑请参考上面的 发射创建实例 方法
    if (签名.类型 == 签名_构造大写) {
        // 改变方法类型并重新生成方法签名和对应的字符串形式
        签名.类型 = 签名_方法大写;
        char 签名字符串2[最大签名长度了大写] = {'\0'};
        uint32_t 签名长度2 = 签名到字符串(&签名, 签名字符串2);

        // 确保该方法签名在 虚机针->allMethodNames 存在，不存在的话会直接插入并返回其索引，存在的话直接返回索引
        uint32_t 构造索引 = 确保符号存在(编单针->当前词法器->虚机针, &编单针->当前词法器->虚机针->全部方法名们, 签名字符串2, 签名长度2);

        // 生成【创建对象实例】的方法，并将该方法闭包压入到运行时栈顶，等待下面被定义为类的静态方法 new
        发射创建实例(编单针, &签名, 方法索引);

        // 定义新创建的类的静态方法 new
        // 此时栈顶为【创建对象实例】的方法闭包
        // 定义方法 的两个核心操作：
        // 1. 将方法所属类压入到运行时栈顶，此时，运行时栈顶为方法所属类，次栈顶为待定义的方法
        // 2. 将次栈顶的方法，存储到栈顶的类的 class->方法们[方法索引] 中，其中 方法索引 为指令的操作数
        // 由此便将上面 发射创建实例 生成【创建对象实例】的方法定义为类的静态方法 new
        定义方法(编单针, 类变量, 真, 构造索引);
    }
}

// 编译类体
// 类体形式如下：
// class Foo {
//     var instantField
//     static var staticField
//     instantMethod() {
//     }
//     static staticMethod() {
//     }
//     new() {
//     }
// }
static void 编译类物自体(编译单元大写 *编单针, 变量大写 类变量) {
    if (匹配牌(编单针->当前词法器, 牌_静止大写)) {
        if (匹配牌(编单针->当前词法器, 牌_变量了大写)) {
            // 1. 类的静态属性
            编译变量定义(编单针, 真);
        } else {
            // 2. 类的静态方法
            编译方法(编单针, 类变量, 真);
        }
    } else if (匹配牌(编单针->当前词法器, 牌_变量了大写)) {
        // 3. 实例属性
        编译变量定义(编单针, 假);
    } else {
        // 4. 实例方法
        编译方法(编单针, 类变量, 假);
    }
}

// 编译类定义
static void 编译类的定义(编译单元大写 *编单针) {
    // 执行此函数时，已经读入了关键字 class

    变量大写 类变量;
    // 只支持在模作用域中定义类
    if (编单针->作用域深度 != -1) {
        编译_错误大写(编单针->当前词法器, "类定义必须在模块作用域内!");
    }

    类变量.作用域类型 = 变量作用域_模块大写;
    // 读入类名
    断言当前牌(编单针->当前词法器, 牌_身份大写, "关键字类应跟随类名称!");
    // 声明类名
    // 声明变量之 方法会调用 defineModuleVar，defineModuleVar 方法会将类名插入到 当前模块->模块变量名 中，并返回索引
    类变量.索引 = 声明变量之(编单针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);

    // 生成类名，用于后面创建类
    对象字符串大写 *类名 = 新对象字符串(编单针->当前词法器->虚机针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);

    // 将类名通过 加上常量 加载到常量表，并生成【将类名压入到运行时栈顶】的指令
    发射载入常量(编单针, 对象到值大写(类名));

    // 处理类继承
    if (匹配牌(编单针->当前词法器, 牌_小于号大写)) {
        // 如果类名后面有用于继承的关键字 <，则将关键字 < 后面的类名作为父类名，压入到栈顶
        表达式(编单针, 绑力量_调用大写);
    } else {
        // 否则默认 object 类为父类名，压入到栈顶
        发射载入模块变量(编单针, "对象");
    }

    // 生成【创建类】的指令
    // 经过上面的代码，此时栈顶保存的是基类名（父类名），次栈顶保存的是类名，OPCODE_CREATE_CLASS 会将基类名所在的栈顶 slot 回收，并创建类然后存储到原来次栈顶所在的 slot
    // 操作码之_创建类 对应的操作数含义是属性个数，即 fieldNum，然而目前类未定义完，因此属性的个数未知，因此先临时写为 255，待类编译完成后再回填属性个数
    int 字段数目索引 = 写操作码字节操作范围(编单针, 操作码之_创建类, 255);

    // 到此，栈顶就保存了创建好的类
    if (编单针->作用域深度 == -1) {
        // 生成【把栈顶的类存储到 当前模块->模块变量值 中，索引为 类变量.index（即和类名在 当前模块->模块变量名 中的索引相同）】的指令
        // 也就是变量名储存在 当前模块->模块变量名 中，变量值存储在 当前模块->模块变量值 中，两者在各个表中的索引相同
        写操作码短操作范围(编单针, 操作码之_存储模块变量, 类变量.索引);
        // 将栈顶的创建好的类弹出
        写操作码(编单针, 操作码之_弹);
    }

    // 初始化 ClassBookKeep 结构
    // 类BK 用于在编译类时跟踪类信息
    类书保持大写 类BK;
    类BK.名称 = 类名;
    类BK.是否静止 = 假;
    字符串大写缓冲区初始化大写(&类BK.字段们);
    整型大写缓冲区初始化大写(&类BK.实例方法们);
    整型大写缓冲区初始化大写(&类BK.静止方法们);

    // 此时 编单针 是模块的编译单元，负责跟踪当前编译的类
    // 注：类没有编译单元
    编单针->封闭的类BK = &类BK;

    // 类名后面需为符号 {
    断言当前牌(编单针->当前词法器, 牌_左大括号大写, "期望 '{' 在类名称后在类声明内!");

    // 进入类体
    进入作用域(编单针);

    // 编译类体，直到遇到右大括号 } 为止
    while (!匹配牌(编单针->当前词法器, 牌_右大括号大写)) {
        编译类物自体(编单针, 类变量);
        if (编单针->当前词法器->当前牌.类型 == 牌_文件终大写) {
            编译_错误大写(编单针->当前词法器, "期望 '}' 在类声明终处!");
        }
    }

    // 上面 写操作码字节操作范围(编单针, 操作码之_创建类, 255) 中将类的属性个数默认设置成 255，即操作码 操作码之_创建类 的操作数
    // 现在类已经编译完了，回填正确的属性个数
    编单针->函->指令流.数据们[字段数目索引] = 类BK.字段们.计数;

    // 类BK 用于在编译类的过程记录一些类的信息，例如 类BK.字段们 收集属性，classBK.静止方法们 收集类的静态方法 等，
    // 方便在编译类的过程中做类似判断是否命名冲突等逻辑，等到类的编译结束时，就会回收分配给 类BK 的内存
    符号表清除(编单针->当前词法器->虚机针, &类BK.字段们);
    整型大写缓冲区清除大写(编单针->当前词法器->虚机针, &类BK.静止方法们);
    整型大写缓冲区清除大写(编单针->当前词法器->虚机针, &类BK.实例方法们);

    // enclosingClassBK 用来表示是否正在编译类，
    // 编译完类后要置空，编译下一个类时在重新赋值
    编单针->封闭的类BK = NULL;

    // 退出类体
    离开作用域(编单针);
}

// 编译 fun 关键字形式的函数定义
// 本语言完全面向对象,
// (一)
//    函数定义的形式是:
//       var function = Fn.new {|形参|
//          函数体代码
//       }
//    Fn.new返回的是{}内函数的闭包

//    函数调用的形式是"函数闭包.call(...)"

//    但是传统上
// (二)
//    函数定义的形式是:
//       function 函数名(形参) {
//          函数体代码
//       }
//    函数调用形式是:
//       函数名(实参)
static void 编译函数定义(编译单元大写 *编单针) {
    // 执行此函数时已经读入了 fun 关键字

    // 规定只能在模块作用域中进行 fun 关键字形式的函数定义，且也只能在模块作用域中调用
    if (编单针->封闭的单元 != NULL) {
        编译_错误大写(编单针->当前词法器, "'函了' 应该在模块作用域内!");
    }

    // 关键字 fun 后面需要为函数名，token 类型为 牌_身份大写
    断言当前牌(编单针->当前词法器, 牌_身份大写, "丢失函数名称!");

    // 在模块变量中声明函数名
    // 为了和模块中自定义的变量做区分，在函数名前面添加 Fn 前缀，即 'Fn xxx\0'
    char 函了名[最大签名长度了大写 + 4] = {'\0'};
    memmove(函了名, "函大 ", 3);
    memmove(函了名 + 3, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);
    uint32_t 函名索引 = 声明变量之(编单针, 函了名, strlen(函了名));

    // 初始化函数编译单元 fnCU，用于存储编译函数得到的指令流
    编译单元大写 函编单;
    初始编译单元(编单针->当前词法器, &函编单, 编单针, 假);

    // 创建临时方法签名，用于后续 处理形参列表 声明函数参数时，记录参数个数
    签名大写 临时函签名 = {签名_方法大写, "", 0, 0};

    // 函数名后面需要是小括号 (
    断言当前牌(编单针->当前词法器, 牌_左小括号大写, "期望 '(' 在函数名称后!");

    // 如果后面没有小括号 )，说明该函数有参数需要声明
    if (!匹配牌(编单针->当前词法器, 牌_右小括号大写)) {
        // 声明函数参数为该函数的局部变量
        处理形参列表(&函编单, &临时函签名);
        // 参数后面需要是小括号 )
        断言当前牌(编单针->当前词法器, 牌_右小括号大写, "期望 ')' 在形参列表后!");
    }

    // 将 处理形参列表 函数中记录的参数个数保存到 函->实参数目了 中
    函编单.函->实参数目 = 临时函签名.实参数目了;

    // 小括号 ) 后面需要是大括号 {
    断言当前牌(编单针->当前词法器, 牌_左大括号大写, "期望 '{' 在方法物自体的开头.");

    // 编译函数体，将指令流写入该函数对应的编译单元 函编单
    编译物自体(&函编单, 假);

#if 调试大写
    终编译单元(&函编单, 函了名, strlen(函了名));
#else
    // 终止编译，为函数体生成闭包，并压入到运行时栈顶
    终编译单元(&函编单);
#endif
    // 将运行时栈顶的函数体闭包，保存到索引为 函名索引 的模块变量中
    // 即函数名保存到 当前模块->moduleVarName，函数体保存到 当前模块->模块变量值
    定义变量之(编单针, 函名索引);
}

// 编译模块导入
// import foo
// 将按照一下形式处理：
// System.importModule("foo")
// import foo for bar1, bar2
// 将按照一下形式处理：
// var bar1 = System.getModuleVariable("foo", "bar1")
// var bar2 = System.getModuleVariable("foo", "bar2")
static void 编译导入(编译单元大写 *编单针) {
    // 执行此函数时已经读入了关键字 import

    // import 后面需要为模块名，即 token 类型为 牌_身份大写
    断言当前牌(编单针->当前词法器, 牌_身份大写, "期望模块名称在导出之后!");

    // 备份模块名token
    牌大写 模块名牌 = 编单针->当前词法器->前一个牌;

    // 导入时模块的扩展名不需要，有可能用户会把模块的扩展名加上
    // 比如 import hello.di，这时候就要跳过扩展名
    if (编单针->当前词法器->前一个牌.起始[编单针->当前词法器->前一个牌.长度] == '.') {
        printf("\n 警告!!! 导入的模块不需要扩展名!, 编译器尝试去忽略它!\n");

        // 跳过扩展名
        获取下一个牌(编单针->当前词法器); // 跳过 '.'
        获取下一个牌(编单针->当前词法器); // 跳过 'di'
    }

    // 将模块名转为字符串
    对象字符串大写 *模块名称 = 新对象字符串(编单针->当前词法器->虚机针, 模块名牌.起始, 模块名牌.长度);

    // 将模块名转化后的字符串作为变量添加到编译单元的 fn->常量们 中
    uint32_t 常量模块索引 = 加上常量(编单针, 对象到值大写(模块名称));

    // 1. 为调用 System.importModule('foo')，生成【压入参数 System 到运行时栈顶】的指令
    // 即压入 名为 System 的模块变量 到运行时栈中，其实是压入 其在 当前模块->模块变量名 的索引值
    发射载入模块变量(编单针, "系统");

    // 2. 为调用 System.importModule('foo')，生成【压入参数 foo 到运行时栈顶】的指令
    // 即压入 模块名转化为字符串保存到编译单元的 fn->常量们 中的索引值 到运行时栈
    写操作码短操作范围(编单针, 操作码之_载入常量, 常量模块索引);

    // 3. 生成【调用 System.importModule('foo')，此时次栈顶是调用方对象 System，栈顶是参数--模块名 foo】的指令
    发射调用(编单针, "导入模块(_)", 15, 1);

    // 此时栈顶是 System.importModule('foo') 的返回值
    // 生成【弹出栈顶中的 System.importModule('foo') 的返回值】
    写操作码(编单针, 操作码之_弹);

    // 如果后面没有关键字 for，则直接退出
    if (!匹配牌(编单针->当前词法器, 牌_为大写)) {
        return;
    }

    // 否则后面有 for，例如 import foo for bar1, bar2，其中 bar1 和 bar2 就是 foo 模块中的变量
    // 将其转成 var bar1 = System.getModuleVariable("foo", "bar1") var bar2 = System.getModuleVariable("foo", "bar2") 形式处理
    do {
        // 关键字 for 后面需要跟变量名，对应 token 类型为 牌_身份大写
        断言当前牌(编单针->当前词法器, 牌_身份大写, "期望变量名称在'为'之后在导入内!");

        // 在本模块中声明导入的模块变量名，即将变量名插入到 当前模块->moduleVarName，并返回对应的索引
        uint32_t 变量索引了 = 声明变量之(编单针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);

        // 把模块变量转为字符串
        对象字符串大写 *常量的变量名 = 新对象字符串(编单针->当前词法器->虚机针, 编单针->当前词法器->前一个牌.起始, 编单针->当前词法器->前一个牌.长度);

        // 将模块名转化后的字符串作为变量添加到编译单元的 fn->常量们 中
        uint32_t 常量的变量索引 = 加上常量(编单针, 对象到值大写(常量的变量名));

        // 1. 为调用 System.getModuleVariable('foo', 'bar1')，生成【压入参数 System 到运行时栈顶】的指令
        发射载入模块变量(编单针, "系统");

        // 2. 为调用 System.getModuleVariable('foo', 'bar1')，生成【压入参数 foo 到运行时栈顶】的指令
        写操作码短操作范围(编单针, 操作码之_载入常量, 常量模块索引);

        // 3. 为调用 System.getModuleVariable('foo', 'bar1')，生成【压入参数 bar1 到运行时栈顶】的指令
        写操作码短操作范围(编单针, 操作码之_载入常量, 常量的变量索引);

        // 4. 生成【调用 System.getModuleVariable('foo', 'bar1')，此时次次栈顶是调用方对象 System，次栈顶是参数--模块名 foo，栈顶是参数--变量名 bar】的指令
        发射调用(编单针, "获取模块变量(_,_)", 22, 2);

        // 此时栈顶是 System.getModuleVariable('foo', 'bar1') 的返回值
        // 将运行时栈顶的返回值保存到索引为 变量索引了 的模块变量中
        // 即导入的模块变量名保存到 当前模块->moduleVarName，导入的模块变量值保存到 当前模块->模块变量值
        定义变量之(编单针, 变量索引了);
    } while (匹配牌(编单针->当前词法器, 牌_逗号大写));
}

// 编译程序
static void 编译程序(编译单元大写 *编单针) {
    if (匹配牌(编单针->当前词法器, 牌_类大写)) {
        // 编译类定义
        编译类的定义(编单针);
    } else if (匹配牌(编单针->当前词法器, 牌_函了大写)) {
        // 编译函数定义
        编译函数定义(编单针);
    } else if (匹配牌(编单针->当前词法器, 牌_变量了大写)) {
        // 编译变量定义
        // 判断前面的 token 是否是 static，如果是，则该变量为类的静态属性
        编译变量定义(编单针, 编单针->当前词法器->前一个牌.类型 == 牌_静止大写);
    } else if (匹配牌(编单针->当前词法器, 牌_导入大写)) {
        // 编译模块导入
        编译导入(编单针);
    } else {
        // 编译语句（除了上面的情况之外的语句）
        编译语句(编单针);
    }
}

// 编译模块
对象函大写 *编译模块(虚拟机大写 *虚机针, 对象模块大写 *对象模块, const char *模块代码) {
    // 每个模块（文件）都需要一个单独的词法分析器进行编译
    词法器大写 词法器;
    词法器.父母 = 虚机针->当前词法器;
    虚机针->当前词法器 = &词法器;

    // 初始化词法分析器
    if (对象模块->名称 == NULL) {
        // 核心模块对应的词法分析器用 core.script.inc 作为模块名进行初始化
        初始词法器(虚机针, &词法器, "核心.脚本.inc", 模块代码, 对象模块);
    } else {
        // 其余模块对应的词法分析器用该模块名进行初始化
        初始词法器(虚机针, &词法器, (const char *)对象模块->名称->值.起始, 模块代码, 对象模块);
    }

    // 初始化编译单元（模块也有编译单元）
    // 有编译单元的：模块、函数、方法
    编译单元大写 模块编单;
    初始编译单元(&词法器, &模块编单, NULL, 假);

    //记录当前编译模块的变量数量，后面检查预定义模块变量时可减少遍历，也就是在下面编译之前，就已经在 模块变量值 中的变量，无需遍历检查是否声明过
    uint32_t 模块变量数目之前 = 对象模块->模块变量值.计数;

    // 由于 初始词法器 初始化函数中将 词法器 的 当前牌 的 类型 设置为 TOKEN_UNKNOWN
    // 会导致后面的 while 循环不执行（循环体用于执行真正编译的方法）
    // 需要调用 获取下一个牌 指向第一个合法的 token
    获取下一个牌(&词法器);

    // 循环调用 编译程序 函数进行编译，直到 token 流结尾
    // 牌_文件终大写 标记文件结束，即该 token 为最后一个 token
    while (!匹配牌(&词法器, 牌_文件终大写)) {
        编译程序(&模块编单);
    }

    // 模块编译完成后，生成 return 空指针乎 对应的指令，以避免虚拟机执行下面 终编译单元 函数生成的 操作码之_终 指令
    // 操作码之_终 只是程序结束的标记，属于伪操作码，永远不应该被执行
    写操作码(&模块编单, 操作码之_推空指针);
    写操作码(&模块编单, 操作码之_返回);

    // 背景：
    // 模块变量相当于一个模块中的全局变量，支持使用变量在声明变量之前，
    // 在从上到下的编译阶段中，遇到模块变量声明，会将其对应在 对象模块->模块变量值 上的值设置成 值型_空指针大写 的 值大写 形式
    // 但当遇到使用的模块变量被使用了，但是目前为止没有看到该变量的声明，现将其对应在·objModule->模块变量值 上的值设置成行号，即 VT_NUM 的 值大写 形式
    // 直到继续向下编译，如果遇到该全局变量的声明，则就会进到这个判断分支，即变量对应在 对象模块->模块变量值 的值为 VT_NUM 类型，
    // 由此可以判断该变量已经在上面使用，但是没有声明，所以在这里将其设置成 值型_空指针大写 的 值大写 形式
    // 直到编译解阶段结束且虚拟机运行之前，检查 对象模块->模块变量值 中是否还有值类型为 VT_NUM 的模块变量，如果有就会报错
    // 误解：
    // 为什么变量的值会被设置成 值型_空指针大写 的 值大写 形式，而不是代码中真正赋的值，例如 a = 1？
    // 1. 编译阶段：先将模块变量的值初始化为 VT_NULL，同时生成 a = 1 赋值的对应指令
    // 2. 运行时阶段：虚拟机执行赋值对应的指令，从而将 1 写到模块变量 a 对应的 对象模块->模块变量值 值中
    // 目前只是处在编译阶段，故可以通过判断 对象模块->模块变量值 的值的类型来判断是否是先使用后声明的情况

    // 所以此处检测本次编译得到的 模块变量值 中的变量值是否还是存 VT_NUM 类型，也就是变量尚未声明的，如果有就直接报错
    // 注：在本次编译之前，就已经在 模块变量值 中的变量，无需遍历检查是否声明过
    uint32_t 索引了 = 模块变量数目之前;
    while (索引了 < 对象模块->模块变量值.计数) {
        if (值是否数目了大写(对象模块->模块变量值.数据们[索引了])) {
            char *串 = 对象模块->模块变量名.数据们[索引了].串;
            uint32_t 行号 = 值到数目大写(对象模块->模块变量值.数据们[索引了]);
            编译_错误大写(&词法器, "行:%d, 变量 \'%s\' 未定义!", 行号, 串);
        }
        索引了++;
    }

    // 模块编译完成后，置空当前编译单元
    虚机针->当前词法器->当前编译单元 = NULL;
    虚机针->当前词法器 = 虚机针->当前词法器->父母;

#if 调试大写
    return 终编译单元(&模块编单, "(脚本)", 8);
#else
    return 终编译单元(&模块编单);
#endif
}