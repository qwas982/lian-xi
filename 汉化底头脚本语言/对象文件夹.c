#include "底头.h"

//将所有的跟对象有关的实现文件整合在一起

//************头部的对象.c************

// TODO: 待后续解释
定义缓冲区方法大写(值大写)

// 初始化对象头
void 初始对象头部(虚拟机大写 *虚机针, 对象头部大写 *对象头部, 对象类型大写 对象类型, 类大写 *类) {
    对象头部->类型 = 对象类型;
    // 对象是否可达初始化为 false，其值最终由垃圾回收机制设置
    对象头部->是否访问 = 假;
    // 设置成 meta 类
    对象头部->类指针 = 类;
    // 初始化的 objHeader 的 next 指向当前所有已分配对象链表的首节点
    对象头部->下一个 = 虚机针->全部对象们;
    // 然后再将初始化的 objHeader 设为当前所有已分配对象链表的首节点
    // 这两步操作就是为了将初始化的 objHeader 插入到已分配对象链表的表头
    虚机针->全部对象们 = 对象头部;
}

//看来要尽可能地实现数据抽象,才能在C里覆盖足够多的中文汉字编程.


//**************对象字符串.c***************

#include <string.h>

// 将字符串值根据 fnv-1a 算法转成对应哈希值
uint32_t 哈希字符串(const char *串, uint32_t 长度) {
    uint32_t 哈希代码 = 2166136261, 索引 = 0;
    while (索引 < 长度) {
        哈希代码 ^= 串[索引];
        哈希代码 *= 16777619;
        索引++;
    }
    return 哈希代码;
}

// 根据字符串对象中的值设置对应的哈希值
void 哈希对象字符串(对象字符串大写 *对象字符串) {
    对象字符串->哈希代码 = 哈希字符串(对象字符串->值.起始, 对象字符串->值.长度);
}

// 新建字符串对象
对象字符串大写 *新对象字符串(虚拟机大写 *虚机针, const char *串, uint32_t 长度) {
    //length为 0 时 str 必为 NULL  length 不为 0 时 str 不为 NULL
    断言大写(长度 == 0 || 串 != NULL, "串长度不匹配串!");

    // 根据字符串对象结构体和字符串长度申请需要的内存
    // 注：之所以需要加 1，是因为需要设置字符串结束符 \0
    // 因为 objIString->value 是一个字符串，需要额外内存存储字符串本身数据，
    // 所以使用 ALLOCATE_EXTRA 来申请内存
    对象字符串大写 *对象字符串 = 分配额外大写(虚机针, 对象字符串大写, 长度 + 1);

    // 内存申请失败
    if (对象字符串 == NULL) {
        内存_错误大写("分配对象字符串失败!");
    }

    /** 1. 初始化对象头 **/
    // 注意：&objString->objHeader 中 -> 优先级高于 &
    // 所以是取的 objHeader，然后再获取它的地址
    初始对象头部(虚机针, &对象字符串->对象头部, 对类_字符串大写, 虚机针->字符串类);

    /** 2. 设置 value **/
    // 如果字符串非空，则需要赋值其内容
    对象字符串->值.长度 = 长度;

    if (长度 > 0) {
        // 将 str 所指的字符串的 length 个字符复制到 objString->value.start 所指的字符串
        memcpy(对象字符串->值.起始, 串, 长度);
    }

    // 结尾添加字符串结束符 \0
    对象字符串->值.起始[长度] = '\0';

    /** 3. 设置 hashCode **/
    哈希对象字符串(对象字符串);

    return 对象字符串;
}

//*****************元对象.c*****************
// 新建模块对象
对象模块大写 *新对象模块(虚拟机大写 *虚机针, const char *模块名) {
    // 申请内存
    对象模块大写 *对象模块 = 分配大写(虚机针, 对象模块大写);

    // 内存申请失败
    if (对象模块 == NULL) {
        内存_错误大写("分配对象模块失败!");
    }

    /** 1. 初始化对象头 **/
    // 注意：&objModule->objHeader 中 -> 优先级高于 &
    // 所以是取的 objHeader，然后再获取它的地址
    // 另外 ObjModule 时元信息对象，不属于任何一个类，
    // 所以最后一个参数传 NULL
    初始对象头部(虚机针, &对象模块->对象头部, 对类_模块大写, NULL);

    /** 2. 设置 moduleName **/
    // TODO: 待后续解释
    字符串大写缓冲区初始化大写(&对象模块->模块变量名);

    /** 3. 设置 moduleValue **/
    // TODO: 待后续解释
    值大写缓冲区初始化大写(&对象模块->模块变量值);

    /** 4. 设置 name **/
    对象模块->名称 = NULL;
    if (模块名 != NULL) {
        对象模块->名称 = 新对象字符串(虚机针, 模块名, strlen(模块名));
    }

    return 对象模块;
}

// 新建实例对象
对象实例大写 *新对象实例(虚拟机大写 *虚机针, 类大写 *类) {
    // 申请内存
    // 注意：其中实例对象的属性个数保存在生成它的类中
    // 因为 objInstance->fields 是一个数组，需要额外内存存储字符串本身数据，
    // 所以使用 ALLOCATE_EXTRA 来申请内存
    对象实例大写 *对象实例 = 分配额外大写(虚机针, 对象实例大写, sizeof(值大写) * 类->字段数目了);

    // 内存申请失败
    if (对象实例 == NULL) {
        内存_错误大写("分配对象实例失败!");
    }

    /** 1. 设置 objHeader **/
    // 注意：&objInstance->objHeader 中 -> 优先级高于 &
    // 所以是取的 objHeader，然后再获取它的地址
    初始对象头部(虚机针, &对象实例->对象头部, 对类_实例大写, 类);

    /** 2. 设置 fields **/
    // 根据存放在所属类中的属性数量，
    // 来循环遍历进行初始化实例对象的属性值
    uint32_t 索引 = 0;
    while (索引 < 类->字段数目了) {
        对象实例->字段们[索引++] = 值型到值大写(值型_空指针大写);
    }

    return 对象实例;
}

//************对象函.c*****************

// 新建自由变量对象
// localVarPtr 是外部函数的局部变量在运行时栈的地址
对象上值大写 *新对象上值(虚拟机大写 *虚机针, 值大写 *本地变量指针) {
    // 申请内存
    对象上值大写 *对象上值 = 分配大写(虚机针, 对象上值大写);

    // 申请内存失败
    if (对象上值 == NULL) {
        内存_错误大写("分配对象上值失败!");
    }

    // 初始化对象头
    初始对象头部(虚机针, &对象上值->对象头部, 对类_上值大写, NULL);

    // 将外部函数的局部变量在运行时栈的地址赋值给变量 localVarPtr
    对象上值->本地变量指针 = 本地变量指针;

    对象上值->已关闭上值 = 值型到值大写(值型_空指针大写);

    对象上值->下一个 = NULL;

    return 对象上值;
}

// 新建函数对象
对象函大写 *新对象函(虚拟机大写 *虚机针, 对象模块大写 *对象模块, uint32_t 槽数目了) {
    // 申请内存
    对象函大写 *对象函 = 分配大写(虚机针, 对象函大写);

    // 申请内存失败
    if (对象函 == NULL) {
        内存_错误大写("分配对象函失败!");
    }

    // 初始化对象头
    初始对象头部(虚机针, &对象函->对象头部, 对类_函数大写, 虚机针->函类);

    // 用于存储函数编译后的指令流
    字节大写缓冲区初始化大写(&对象函->指令流);

    // 常量表，用于储存指令流单元中的常量
    // 实际上函数并没有常量，所以这里存储的是其他指令流单元的常量
    // 例如模块中定义的全局变量、类的类名等
    值大写缓冲区初始化大写(&对象函->常量们);

    // 函数（包括类中的方法）所属的模块
    对象函->模块 = 对象模块;

    // 函数参数的个数
    对象函->实参数目 = 0;

    // 函数所引用的自由变量 upvalue 的数量
    对象函->上值数目 = 0;

    // 函数在运行时栈中所需的最大空间
    对象函->最大栈槽已用数目 = 槽数目了;

    return 对象函;
}

// 新建闭包对象
// 其中 objFn->upvalueNum 指的是该函数对象所引用自由变量的个数
对象闭包大写 *新对象闭包(虚拟机大写 *虚机针, 对象函大写 *对象函) {
    // 申请内存
    对象闭包大写 *对象闭包 = 分配额外大写(虚机针, 对象闭包大写, sizeof(对象上值大写 *) * 对象函->上值数目);

    // 申请内存失败
    if (对象闭包 == NULL) {
        内存_错误大写("分配对象闭包失败!");
    }

    // 初始化对象头
    初始对象头部(虚机针, &对象闭包->对象头部, 对类_闭包大写, 虚机针->函类);

    对象闭包->函 = 对象函;

    // 清空自由变量数组 upvalues
    // 避免在向 upvalues 塞入真正的自由变量之前触发GC
    uint32_t 索引 = 0;
    while (索引 < 对象函->上值数目) {
        对象闭包->上值们[索引] = NULL;
        索引++;
    }

    return 对象闭包;
}

//****************对象列表.c************
// 新建元素个数为 elementNum 的 list 对象
对象列表大写 *新对象列表(虚拟机大写 *虚机针, uint32_t 元素数目) {
    值大写 *元素数组 = NULL;

    // 分配内存
    if (元素数目 > 0) {
        元素数组 = 分配数组大写(虚机针, 值大写, 元素数目);
    }
    对象列表大写 *对象列表 = 分配大写(虚机针, 对象列表大写);

    // 申请内存失败
    if (对象列表 == NULL) {
        内存_错误大写("分配对象列表失败!");
    }

    // 初始化对象头
    初始对象头部(虚机针, &对象列表->对象头部, 对类_列表大写, 虚机针->列表类);

    对象列表->元素们.数据们 = 元素数组;
    对象列表->元素们.容量 = 对象列表->元素们.计数 = 元素数目;

    return 对象列表;
}

// 向 objList 中索引为 index 处插入 value，相当于 objList[index] = value
void 插入元素(虚拟机大写 *虚机针, 对象列表大写 *对象列表, uint32_t 索引乎, 值大写 值) {
    // 如果索引 index 超出 objList 元素总长度，则报错
    if (索引乎 > 对象列表->元素们.计数 - 1) {
        跑_错误大写("索引已出边界!");
    }

    // 新增一个 Value 的空间用于保存新增的元素
    值大写缓冲区添加大写(虚机针, &对象列表->元素们, 值型到值大写(值型_空指针大写));

    // 将 index 索引后面的元素整体后移一位
    uint32_t 索引 = 对象列表->元素们.计数 - 1;
    while (索引 > 索引乎) {
        对象列表->元素们.数据们[索引] = 对象列表->元素们.数据们[索引 - 1];
        索引--;
    }

    // 在索引 index 处插入数值
    对象列表->元素们.数据们[索引乎] = 值;
}

// 调整 objList 的容量为 newCapacity（容量即列表最大可容纳的元素数量）
static void 收缩列表(虚拟机大写 *虚机针, 对象列表大写 *对象列表, uint32_t 新容量) {
    // 调整 objList 被分配的内存空间
    uint32_t 旧大小 = 对象列表->元素们.容量 * sizeof(值大写);
    uint32_t 新大小 = 新容量 * sizeof(值大写);
    内存管理器(虚机针, 对象列表->元素们.数据们, 旧大小, 新大小);
    // 调整 objList 的容量值
    对象列表->元素们.容量 = 新容量;
}

值大写 移除元素(虚拟机大写 *虚机针, 对象列表大写 *对象列表, uint32_t 索引乎) {
    // 找到被删除的元素，并在最后返回
    值大写 值已移除 = 对象列表->元素们.数据们[索引乎];

    // 将 index 索引后面的元素整体前移一位
    uint32_t 索引 = 索引乎;
    while (索引 < 对象列表->元素们.计数 - 1) {
        对象列表->元素们.数据们[索引] = 对象列表->元素们.数据们[索引 + 1];
        索引++;
    }

    // 宏 CAPACITY_GROW_FACTOR 为 4
    // 当列表中元素实际使用空间不足列表容量的 1/4 时，就调用 shrinkList 函数调整列表容量
    uint32_t _容量 = 对象列表->元素们.容量 / 容量生长因子大写;
    if (_容量 > 对象列表->元素们.计数) {
        收缩列表(虚机针, 对象列表, _容量);
    }

    // 计数减少一个元素
    对象列表->元素们.计数--;

    return 值已移除;
}

//***************对象映射.c*******************
// 新建 map 对象
对象映射大写 *新对象映射(虚拟机大写 *虚机针) {
    // 分配内存
    对象映射大写 *对象映射 = 分配大写(虚机针, 对象映射大写);

    // 申请内存失败
    if (对象映射 == NULL) {
        内存_错误大写("分配对象映射失败!");
    }

    // 初始化对象头
    初始对象头部(虚机针, &对象映射->对象头部, 对类_映射大写, 虚机针->映射类);

    对象映射->容量 = 对象映射->计数 = 0;
    对象映射->条目们 = NULL;

    return 对象映射;
}

// 计算数字的哈希值
static uint32_t 哈希数目了(double 数目了) {
    位们64大写 _64位;
    _64位.数目了 = 数目了;
    // num 的高 32 位和低 32 位异或的结果作为 num 的哈希值
    return _64位.位们32[0] ^ _64位.位们32[1];
}

// 计算对象的哈希值
static uint32_t 哈希对象(对象头部大写 *对象头部) {
    switch (对象头部->类型) {
        case 对类_字符串大写:
            // 直接返回 string 对象的 hashCode
            return ((对象字符串大写 *)对象头部)->哈希代码;
        case 对类_范围大写: {
            // 强制类型转换成 range 对象
            对象范围大写 *对象范围 = (对象范围大写 *)对象头部;
            // 返回 range 对象的 from 和 to 的哈希值再做异或的值
            return 哈希数目了(对象范围->来自) ^ 哈希数目了(对象范围->到);
        }
        case 对类_类大写: {
            // 强制类型转换成 class 对象
            类大写 *类针 = (类大写 *)对象头部;
            // 返回 class 对象的 name 字符串的哈希值
            return 哈希字符串(类针->名称->值.起始, 类针->名称->值.长度);
        }
        default:
            跑_错误大写("哈希表必须是对象字符串, 对象范围与类.");
    }
    return 0;
}

// 根据 value 的类型调用相应的方法计算其哈希值
static uint32_t 哈希值(值大写 值) {
    switch (值.类型) {
        case 值型_假大写:
            return 0;
        case 值型_空指针大写:
            return 1;
        case 值型_真大写:
            return 2;
        case 值型_数目了大写:
            return 哈希数目了(值.数目了);
        case 值型_对象大写:
            return 哈希对象(值.对象头部);
        default:
            跑_错误大写("不支持虚线类型!");
    }
    return 0;
}

// 向 entries 中添加 entry
// 先根据 key 的哈希值按照一定算法计算在 entries 中的位置 index（下面方法是 key 的哈希值和 entries 的容量 capacity 取模来得到在 entries 中的位置 index）
// 会遇到三种情况：
// 1. index 对应位置没有被使用过，则正常赋值 entry 的 key 和 value ，并返回 true 即可
// 2. index 对应位置被使用过了，但已存在的 entry 的 key 和传入的 key 相同，则将 entry 的 value 覆盖成传入的，并返回 false 即可
// 3. index 对应位置被使用过了，且已存在的 entry 的 key 和传入的 key 不同，即不同的 key 计算出来的哈希值是相同的，就会发生冲突，可采用开放探测法解决，
// 例如 index 加 1 再和 entries 的容量 capacity 取模，探测下一个位置是否可以存储
static 布尔 加上条目(条目大写 *条目们, uint32_t 容量, 值大写 键, 值大写 值) {
    // key 的哈希值和 entries 的容量 capacity 取模得到在 entries 中的位置
    uint32_t 索引 = 哈希值(键) % 容量;

    // 通过开放探测法找到可用的 slot
    while (真) {
        // 1. 如果 slot 中的 entry 的 key 类型为 VT_UNDEFINED，则说明为空闲 slot，直接赋值即可
        if (条目们[索引].键.类型 == 值型_未定义大写) {
            条目们[索引].键 = 键;
            条目们[索引].值 = 值;
            return 真;
        }
        // 2. 如果 slot 中的 entry 的 key 和传入的 key 相同，则说明该 slot 就是存储该 key-value 的 slot，直接覆盖 value 即可
        else if (值是否相等(条目们[索引].键, 键)) {
            条目们[索引].值 = 值;
            return 假;
        }

        // 3. 如果以上两个情况不满足，则 index 加 1 再和 entries 的容量 capacity 取模
        // 得出来的值作为下一次循环中的位置 index，探测下一个位置是否可以存储
        索引 = (索引 + 1) % 容量;
    }
}

// 在 objMap 中查找 key 对应的 entry
static 条目大写 *找条目(对象映射大写 *对象映射, 值大写 键) {
    // 如果 objMap 为空，则返回 null
    if (对象映射->容量 == 0) {
        return NULL;
    }

    // 根据 key 计算对应的 entry 在 entries 中的位置，即槽位（slot）
    uint32_t 索引 = 哈希值(键) % 对象映射->容量;
    条目大写 *条目;
    while (真) {
        条目 = &对象映射->条目们[索引];

        // 如果该 entry 的 key 和传入的 key 相等，则说明就是该 entry
        if (值是否相等(条目->键, 键)) {
            return 条目;
        }

        // 当 entry 的 key 类型为 undefined
        // 且 entry 的 value 类型为 false，则说明探测链结束
        // 背景知识如下：
        // 当存储的多个 entry 中的 key 的哈希值相同时，就会产生冲突探测链，具体可参考上面的 addEntry
        // 此时查找时，依然根据 entry 的 key 的哈希值计算 entry 在 entries 上的位置 index
        // 如果没有，则 index 加 1 继续沿着冲突探测链向下寻找
        // 但当遇到某个一个 entry 被删除了，这个链条就断掉了
        // 假设某个 entry 就是存储在被删除的 entry 的后面，则无法找到该 entry
        // 为了解决这个问题，决定采用伪删除：
        // 开始时我们会将所有的 entry 的 value 的 type 初始化成 VT_FALSE
        // 当删除某个 entry 时，则将该 entry 的 value 的 type 设置成 VT_TRUE
        // 当查找某个 key 对应的 entry 时，在冲突探测链中，当 entry 的 value 的 type 为 VT_TRUE，说明冲突探测链
        // 没有断，可以继续循环顺着探测链继续往下找（前提是 entry 的 key 的 type 为 VT_UNDEFINED）
        // 如果遇到下一个 entry 的 value 的 type 为 VT_FALSE，说明这个 entry 是没有被用来存储的，即已经走到了探测链的尾部
        if (值是否未定义大写(条目->键) && 值是否假大写(条目->值)) {
            return NULL;
        }

        // 继续沿着探测链往下探测
        索引 = (索引 + 1) % 对象映射->容量;
    }
}

// 将 objMap 的容量调整到 newCapacity
// 之所以要将原有数据复制到新的空间中，再回收旧空间，而不是在旧空间的基础上扩容，
// 原因是哈希遍存储数据的方式不是线性的，数据所在的槽位 slot 是利用线性结构的容量取模得到的，属于离散分布
// 当在原有的旧空间基础上扩容，容量就变化了，根据新容量取模计算得到的槽位 slot 的位置就不对了，也就是找不到原来的数据了
// 所以只能将原有的数据拷贝到新的空间，再回收旧空间
static void 重新大小映射(虚拟机大写 *虚机针, 对象映射大写 *对象映射, uint32_t 新容量) {
    // 1. 先新建一个 entry 数组
    条目大写 *新条目们 = 分配数组大写(虚机针, 条目大写, 新容量);
    uint32_t 索引 = 0;
    while (索引 < 新容量) {
        新条目们[索引].键 = 值型到值大写(值型_未定义大写); // entry 的 key 的 type 初始化为 VT_UNDEFINED
        新条目们[索引].值 = 值型到值大写(值型_假大写);   // entry 的 value 的 type 初始化为 VT_FALSE，用于和删除的槽位作区分（删除的 value 的 type 设置成 VT_TRUE）
        索引++;
    }

    // 2. 在遍历老的 entry 数组，将有值的部分插入到新的数组中
    if (对象映射->计数 > 0) {
        索引 = 0;
        while (索引 < 对象映射->容量) {
            // 如果该槽位 slot 有值，则将值插入到新的数组中
            if (对象映射->条目们[索引].键.类型 != 值型_未定义大写) {
                加上条目(新条目们, 新容量, 对象映射->条目们[索引].键, 对象映射->条目们[索引].值);
            }
            索引++;
        }
    }

    // 3. 将老的 entries 数组所占内存回收
    反分配数组大写(虚机针, 对象映射->条目们, 对象映射->计数);

    对象映射->条目们 = 新条目们;   // 更新 entry 数组
    对象映射->容量 = 新容量; // 更新容量
}

// 向 map 对象的键值为 key 的地方设置值 value
void 映射集(虚拟机大写 *虚机针, 对象映射大写 *对象映射, 值大写 键, 值大写 值) {
    // 如果新增一个 entry 后，容量利用率超过 80 % 时，就需要扩容
    if (对象映射->计数 + 1 > 对象映射->容量 * 映射载入百分比大写) {
        uint32_t 新容量 = 对象映射->容量 * 容量生长因子大写; // 新空间为到旧空间的 4 倍
        // 如果小于容量最小值 64，则按照最小值设置
        if (新容量 < 最小容量大写) {
            新容量 = 最小容量大写;
        }

        重新大小映射(虚机针, 对象映射, 新容量);
    }

    // 判断是新增的 entry，还是覆盖原有的 entry
    布尔 是否新加入 = 加上条目(对象映射->条目们, 对象映射->容量, 键, 值);
    // 如果创建了新的 key 则 objMap->count 加 1
    if (是否新加入) {
        对象映射->计数++;
    }
}

// 获取 map 对象的键值为 key 的地方的值
值大写 映射获取(对象映射大写 *对象映射, 值大写 键) {
    条目大写 *条目 = 找条目(对象映射, 键);

    // 如果 map 对象中没有找到 key 对应的 entry，则返回 undefined
    if (条目 == NULL) {
        return 值型到值大写(值型_未定义大写);
    }

    // 找到则返回 key 对应的 value
    return 条目->值;
}

// 删除 map 对象的键值为 key 的地方的值
值大写 移除键(虚拟机大写 *虚机针, 对象映射大写 *对象映射, 值大写 键) {
    条目大写 *条目 = 找条目(对象映射, 键);

    // 如果没有 key 对应的值则返回 NULL
    if (条目 == NULL) {
        return 值型到值大写(值型_空指针大写);
    }

    值大写 值 = 条目->值;
    条目->键 = 值型到值大写(值型_未定义大写); // 将 entry 的 key 的 type 设置成 VT_UNDEFINED
    条目->值 = 值型到值大写(值型_真大写);    // 将 entry 的 key 的 type 设置成 VT_TRUE，用于在冲突探测链中标记此处槽位 slot 为删除，而非未使用过
    对象映射->计数--;

    // 如果删除后 objMap 为空，则回收内存空间
    if (对象映射->计数 == 0) {
        清除映射(虚机针, 对象映射);
    } else if ((对象映射->计数 < 对象映射->容量 / 容量生长因子大写 * 映射载入百分比大写) && 对象映射->计数 > 最小容量大写) {
        // 如果删除后实际使用槽位 slot 数量小于容量的 1 / 4 的 80%，且实际使用量仍大于规定的最小容量，则缩小容量
        uint32_t 新容量 = 对象映射->容量 / 容量生长因子大写;

        // 如果缩小的新容量小于最小容量，则设置为最小容量
        if (新容量 < 最小容量大写) {
            新容量 = 最小容量大写;
        }

        重新大小映射(虚机针, 对象映射, 新容量);
    }

    return 值;
}

// 删除 map 对象，即收回 map 对象占用的内存
void 清除映射(虚拟机大写 *虚机针, 对象映射大写 *对象映射) {
    反分配数组大写(虚机针, 对象映射->条目们, 对象映射->计数);
    对象映射->条目们 = NULL;
    对象映射->计数 = 对象映射->容量 = 0;
}

//**********************************对象范围.c*************
// 新建 range 对象
对象范围大写 *新对象范围(虚拟机大写 *虚机针, int 来自, int 到) {
    // 分配内存
    对象范围大写 *对象范围 = 分配大写(虚机针, 对象范围大写);

    // 申请内存失败
    if (对象范围 == NULL) {
        内存_错误大写("分配对象范围失败!");
    }

    // 初始化对象头
    初始对象头部(虚机针, &对象范围->对象头部, 对类_范围大写, 虚机针->范围类);

    对象范围->来自 = 来自;
    对象范围->到 = 到;

    return 对象范围;
}

// 为线程 objThread 中运行的闭包函数 objClosure 准备堆栈框架，即闭包（函数或方法）的运行资源，包括如下：
// 1.运行时栈    2.待运行的指令流    3.当前运行的指令地址 ip
void 预备帧(对象线程大写 *对象线程, 对象闭包大写 *对象闭包, 值大写 *栈起始) {
    // 如果分配的帧栈超出最大容量，则报错
    断言大写(对象线程->帧容量 > 对象线程->已用帧数目, "帧不够!");

    // 从函数调用帧栈（frames）数组中取最新的帧栈（frame）准备分配给运行函数
    帧大写 *帧 = &(对象线程->帧们[对象线程->已用帧数目++]);

    // 线程中分配给每个函数的帧栈（frame）都是共用线程的运行时栈的
    // 帧栈（frame）的 stackStart 指向了各自帧栈（frame）在线程的运行时栈的起始位置
    帧->栈起始 = 栈起始;
    // 执行的闭包为 objClosure
    帧->闭包 = 对象闭包;
    // 指令起始地址是闭包中函数的指令流的起始地址
    帧->指令指针 = 对象闭包->函->指令流.数据们;
}

// 重置线程对象，即为闭包 objClosure 中的函数初始化运行时栈
void 重置线程(对象线程大写 *对象线程, 对象闭包大写 *对象闭包) {
    // 将线程的运行时栈的栈顶 esp 置为栈底 stack
    对象线程->栈指针 = 对象线程->栈;
    对象线程->打开上值们 = NULL;
    对象线程->调用者 = NULL;
    对象线程->错误对象 = 值型到值大写(值型_空指针大写);
    对象线程->已用帧数目 = 0;

    // 闭包 objClosure 为空则报错
    断言大写(对象闭包 != NULL, "对象闭包是空指针在函数重置线程内");

    // 将线程的运行时栈底 objThread->stack 作为闭包 objClosure 中的函数的运行时栈的起始位置
    预备帧(对象线程, 对象闭包, 对象线程->栈);
}

// 新建线程对象，线程中运行的是闭包 objClosure 中的函数
对象线程大写 *新对象线程(虚拟机大写 *虚机针, 对象闭包大写 *对象闭包) {
    // 闭包 objClosure 为空则报错
    断言大写(对象闭包 != NULL, "对象闭包是空指针");

    // 为函数帧栈（frame）数组申请内存，默认为 4 个 frame，即 INITIAL_FRAME_NUM 为 4
    帧大写 *帧们 = 分配数组大写(虚机针, 帧大写, 初始化帧数目大写);

    // 计算线程的运行时栈的容量
    // TODO: 线程的运行时栈容量 stackCapacity 为什么是大于等于函数的 maxStackSlotUsedNum + 1 的最小 2 次幂？
    // 补充：ceilToPowerOf2 方法作用--找出大于等于 v 的最小的 2 次幂
    uint32_t 栈容量 = 向上取最接近的2次幂(对象闭包->函->最大栈槽已用数目 + 1);

    // 为线程的运行时栈申请内存
    值大写 *新栈 = 分配数组大写(虚机针, 值大写, 栈容量);

    // 申请内存
    对象线程大写 *对象线程 = 分配大写(虚机针, 对象线程大写);

    // 申请内存失败
    if (对象线程 == NULL) {
        内存_错误大写("分配对象线程失败!");
    }

    // 初始化对象头
    初始对象头部(虚机针, &对象线程->对象头部, 对类_线程大写, 虚机针->线程类);

    对象线程->帧们 = 帧们;
    对象线程->帧容量 = 初始化帧数目大写;
    对象线程->栈容量 = 栈容量;
    对象线程->栈 = 新栈;

    // 重置线程对象，即为闭包 objClosure 中的函数初始化运行时栈
    重置线程(对象线程, 对象闭包);
    return 对象线程;
}

//*****************对象的类.c*******************
// TODO: 待后续解释
定义缓冲区方法大写(方法大写)

// 判断 a 和 b 是否相等
布尔 值是否相等(值大写 甲, 值大写 乙) {
    // 类型不同则不相等
    if (甲.类型 != 乙.类型) {
        return 假;
    }

    // 类型为数字则比较数值
    if (甲.类型 == 值型_数目了大写) {
        return 甲.数目了 == 乙.数目了;
    }

    // 指向同一个对象头则相等
    if (甲.对象头部 == 乙.对象头部) {
        return 真;
    }

    // 对象类型不同则不相等
    if (甲.对象头部->类型 != 乙.对象头部->类型) {
        return 假;
    }

    // 若为字符串对象则比较字符串的内容是否相等
    // 先比较字符串的长度，是为了避免一个字符串时是另一个字符串的前缀，例如 "abc" 和 "abcd"
    // int memcmp(const void *str1, const void *str2, size_t n)) 把存储区 str1 和存储区 str2 的前 n 个字节进行比较
    // 返回值 = 0，则表示 str1 等于 str2；返回值 > 0，则表示 str2 小于 str1。
    if (甲.对象头部->类型 == 对类_字符串大写) {
        对象字符串大写 *串的甲 = 值到对象串大写(甲);
        对象字符串大写 *串的乙 = 值到对象串大写(乙);

        return (串的甲->值.长度 == 串的乙->值.长度 && memcmp(串的甲->值.起始, 串的乙->值.起始, 串的甲->值.长度) == 0);
    }

    // 若为 range 对象，则比较两个对象的 from / to 值
    if (甲.对象头部->类型 == 对类_范围大写) {
        对象范围大写 *范围的甲 = 值到对象范围大写(甲);
        对象范围大写 *范围的乙 = 值到对象范围大写(乙);

        return (范围的甲->来自 == 范围的乙->来自 && 范围的甲->到 == 范围的乙->到);
    }

    // 默认不相等
    return 假;
}

// 新建名字为 name，属性个数为 fieldNum 的裸类（裸类即没有归属的类，其对象头的 class 指针为空）
类大写 *新未加工类(虚拟机大写 *虚机针, const char *名称, uint32_t 字段数目) {
    // 申请内存
    类大写 *类针 = 分配大写(虚机针, 类大写);

    // 申请内存失败
    if (类针 == NULL) {
        内存_错误大写("分配未加工类失败!");
    }

    // 初始化对象头
    初始对象头部(虚机针, &类针->对象头部, 对类_类大写, NULL);

    类针->名称 = 新对象字符串(虚机针, 名称, strlen(名称));
    类针->字段数目了 = 字段数目;
    类针->超级类 = NULL; // 默认没有基类
    方法大写缓冲区初始化大写(&类针->方法们);

    return 类针;
}

// 创建一个类
// 类名为 className，属性个数为 fieldNum，基类为 superClass
类大写 *新类(虚拟机大写 *虚机针, 对象字符串大写 *类名, uint32_t 字段数目, 类大写 *超级类) {
    // 1. 先创建类的 meta 类 metaClass（为了和类做区分，类的 meta 类名称是在类的名称后面追加 metaClass）
    // 1.1 先创建 meta 类的类名，加 10 是为了在类名 className 后面追加字符串 " metaClass"
    char 新类名[最大身份长度了大写 + 10] = {'\0'};
    memcpy(新类名, 类名->值.起始, 类名->值.长度);
    memcpy(新类名 + 类名->值.长度, " 元类", 10);
    // 1.2 创建 mata 类
    类大写 *元类针 = 新未加工类(虚机针, 新类名, 0);
    // 1.3 设置 meta 类的 meta 类为 classOfClass
    元类针->对象头部.类指针 = 虚机针->类的类;
    // 1.4 设置 meta 类的基类为 classOfClass
    绑超级类(虚机针, 元类针, 虚机针->类的类);

    // 2. 创建类
    // 2.1 创建类的类名，仍利用之前的字符串变量 newClassName
    memcpy(新类名, 类名->值.起始, 类名->值.长度);
    新类名[类名->值.长度] = '\0';
    // 2.2 创建类
    类大写 *类针 = 新未加工类(虚机针, 新类名, 字段数目);
    // 2.3 设置类的 meta 类
    类针->对象头部.类指针 = 元类针;
    // 2.4 设置类的基类
    绑超级类(虚机针, 类针, 超级类);

    return 类针;
}

// 获取对象所属的类
类大写 *获取对象的类(虚拟机大写 *虚机针, 值大写 对象也) {
    switch (对象也.类型) {
        case 值型_空指针大写:
            return 虚机针->空指针类;
        case 值型_真大写:
        case 值型_假大写:
            return 虚机针->布尔类;
        case 值型_数目了大写:
            return 虚机针->数目类;
        case 值型_对象大写:
            return 值到对象大写(对象也)->类指针;
        default:
            不可达大写()
    }
}

