#include <stdio.h>
#include <string.h>

#include "底头.h"

// 运行脚本文件
static void 跑文件(const char *路径) {
    // 搜索字符串 路径 中最后一次出现 / 的位置
    const char *最后斜杠 = strrchr(路径, '/');
    // 如果不存在 /，则说明文件就在当前目录下，无需设置 根目录
    if (最后斜杠 != NULL) {
        // 申请 最后斜杠 - 路径 + 2 个字节大小的内存空间，root 指向该空间
        // 即用字符串最后一个 / 的地址减去字符串的首地址，再加 1，就是 / 左边所有的字符
        // 例如 examples/demo/a.di 中 examples/demo 的长度
        char *根 = (char *)malloc(最后斜杠 - 路径 + 2);
        // 将 路径 中 最后斜杠 - 路径 + 1 个字节复制到 根 中
        memcpy(根, 路径, 最后斜杠 - 路径 + 1);
        // 根 中最后一个字节设置成字符串结束符号 \0
        根[最后斜杠 - 路径 + 1] = '\0';
        // 将 根 赋值给 根目录
        根目录 = 根;
    }

    // 创建虚拟机
    虚拟机大写 *虚机针 = 新虚拟机();
    const char *源代码 = 读文件(路径);

    // 第二个参数为模块名称（moduleName），即用文件路径作为模块名称
    执行模块(虚机针, 对象到值大写(新对象字符串(虚机针, 路径, strlen(路径))), 源代码);

    // 释放虚拟机
    自由虚拟机(虚机针);
}

// 运行命令行
static void 跑命令行(void) {
    // 创建虚拟机
    虚拟机大写 *虚机针 = 新虚拟机();

    char 源码行[最大行的长大写];
    while (真) {
        printf(">>> ");

        // 若读取失败或者键入 quit 就退出循环
        if (!fgets(源码行, 最大行的长大写, stdin) || memcmp(源码行, "退出", 4) == 0) {
            break;
        }
        // 执行输入的脚本代码
        执行模块(虚机针, 对象到值大写(新对象字符串(虚机针, "命令行", 3)), 源码行);
    }

    // 释放虚拟机
    自由虚拟机(虚机针);
}

int main(int 实参计数, const char **实参值) {
    if (实参计数 == 1) {
        跑命令行();
    } else {
        // 运行脚本文件
        跑文件(实参值[1]);
    }
    return 0;
}