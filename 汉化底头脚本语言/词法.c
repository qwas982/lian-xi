#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "底头.h"

// 定义关键字对应 Token 的结构体
struct 关键字牌 {
    char *关键字;
    uint8_t 长度;
    牌类型大写 牌;
};

// 定义了关键字 Token 的数组，用于后面词法分析识别关键词时进行查找
struct 关键字牌 关键字们牌[] = {
    {"变量", 3, 牌_变量了大写},
    {"函了", 3, 牌_函了大写},
    {"若", 2, 牌_若大写},
    {"否则", 4, 牌_否则大写},
    {"真", 4, 牌_真大写},
    {"假", 5, 牌_假大写},
    {"一会儿", 5, 牌_一会儿大写},
    {"为", 3, 牌_为大写},
    {"破断", 5, 牌_破断大写},
    {"继续", 8, 牌_继续大写},
    {"返回", 6, 牌_返回大写},
    {"空指针", 4, 牌_空指针大写},
    {"类", 5, 牌_类大写},
    {"是", 2, 牌_是大写},
    {"静止", 6, 牌_静止大写},
    {"这个", 4, 牌_这个大写},
    {"超级", 5, 牌_超级大写},
    {"导入", 6, 牌_导入大写},
    {NULL, 0, 牌_未知大写},
};

// 判断以 start 开头，长度为 length 的单词是否是关键字，然后返回相应的 TokenType
static 牌类型大写 关键字或身份(const char *起始, uint32_t 长度) {
    uint32_t 索引 = 0;
    while (关键字们牌[索引].关键字 != NULL) {
        // 遍历关键字 Token 数组，查看和 start 开头，长度为 length 的单词是否相同
        // memcmp 比较 keywordsToken[idx].keyword 指向的字符串 和 start 指向的字符串的前 length 个字符
        // 如果返回 0，则说明两者相等
        if (关键字们牌[索引].长度 == 长度 &&
            memcmp(关键字们牌[索引].关键字, 起始, 长度) == 0) {
            // 找到则返回该 Token 的类型
            return 关键字们牌[索引].牌;
        }
        索引++;
    }

    // 找不到则返回变量名类型
    return 牌_身份大写;
}

// 向前看一个字符
static char 看向前字符(词法器大写 *词法器) {
    return *词法器->下一个字符指针;
}

// 用于更新词法分析器所指向的字符，读进下一个字符
static void 获取下一个字符(词法器大写 *词法器) {
    // 将 nextCharPtr 所指的字符赋给 curChar，然后 nextCharPtr 加 1，即指向下下个字符
    词法器->当前字符 = *词法器->下一个字符指针++;
}

// 匹配下一个字符，如果匹配则读进该字符并返回 true，否则直接返回 false
static 布尔 匹配下一个字符(词法器大写 *词法器, char 期望的字符) {
    if (看向前字符(词法器) == 期望的字符) {
        获取下一个字符(词法器);
        return 真;
    }
    return 假;
}

// 跳过空白字符
static void 跳过空白们(词法器大写 *词法器) {
    while (isspace(词法器->当前字符)) {
        if (词法器->当前字符 == '\n') {
            词法器->当前牌.行号++;
        }
        获取下一个字符(词法器);
    }
}

// 解析关键字
static void 词器身份(词法器大写 *词法器, 牌类型大写 类型) {
    // 判断当前字符 curChar 是否是字母/数字/_，如果是则继续读下个字符
    while (isalnum(词法器->当前字符) || 词法器->当前字符 == '_') {
        获取下一个字符(词法器);
    }

    // 将指向下一个字符地址的 nextCharPtr 值减去 curToken 的 start 再减去 1（nextCharPtr 所指的字符不满足条件），即可得到当前读进的字符数
    // 注意 curToken 是调用本函数的函数，在调用本函数之前已经设置好的
    uint32_t 长度 = (uint32_t)(词法器->下一个字符指针 - 词法器->当前牌.起始 - 1);

    词法器->当前牌.长度 = 长度;

    if (类型 == 牌_未知大写) {
        // 如果 token 类型未知，则可以通过 keywordOrId 查找该单词对应的 token type
        词法器->当前牌.类型 = 关键字或身份(词法器->当前牌.起始, 长度);
    } else {
        词法器->当前牌.类型 = 类型;
    }
}

// 解析十六进制数字
static void 词器十六进制数目(词法器大写 *词法器) {
    // 判断当前字符是否是合法的十六进制数字
    while (isxdigit(词法器->当前字符)) {
        获取下一个字符(词法器);
    }
}

// 解析十进制数字
static void 词器十进制数目(词法器大写 *词法器) {
    // 判断当前字符是否是合法的十进制数字
    while (isdigit(词法器->当前字符)) {
        获取下一个字符(词法器);
    }

    if (词法器->当前字符 == '.' && isdigit(看向前字符(词法器))) {
        获取下一个字符(词法器);
        while (isdigit(词法器->当前字符)) {
            // 遇到小数点，则跳过小数点解析后面的数字
            获取下一个字符(词法器);
        }
    }
}

// 解析八进制数字
static void 词器八进制数目(词法器大写 *词法器) {
    // 判断当前字符是否是合法的八进制数字
    while (词法器->当前字符 >= '0' && 词法器->当前字符 < '8') {
        获取下一个字符(词法器);
    }
}

// 解析数字
static void 词器数目(词法器大写 *词法器) {
    // 十六进制以 0x 开头
    if (词法器->当前字符 == '0' && 匹配下一个字符(词法器, 'x')) {
        // 跳过 x
        获取下一个字符(词法器);
        // 解析十六进制数字
        词器十六进制数目(词法器);
        // strtol 方法是将 lexer->curToken.start 指向的字符串转成数字
        // 第三个参数 16 表示是转成十六进制数字
        // 第二个参数 NULL 表示不需要返回转换失败的字符串地址
        词法器->当前牌.值 = 数目到值大写(strtol(词法器->当前牌.起始, NULL, 16));
    } else if (词法器->当前字符 == '0' && isdigit(看向前字符(词法器))) {
        // 解析八进制数字
        词器八进制数目(词法器);
        // strtol 同上
        词法器->当前牌.值 = 数目到值大写(strtol(词法器->当前牌.起始, NULL, 8));
    } else {
        // 解析十进制数字
        词器十进制数目(词法器);
        // strtod 方法是将 lexer->curToken.start 指向的字符串转成十进制数字
        // 第二个参数 NULL 表示不需要返回转换失败的字符串地址
        词法器->当前牌.值 = 数目到值大写(strtod(词法器->当前牌.起始, NULL));
    }

    // nextCharPtr 会指向第一个不合法字符的下一个字符，所以需要再减 1
    词法器->当前牌.长度 = (uint32_t)(词法器->下一个字符指针 - 词法器->当前牌.起始 - 1);
    词法器->当前牌.类型 = 牌_数目了大写;
}

// 解析 unicode 码点
// 前置知识：
// unicode 码点是 4 个十六进制数字，比如 “字” 的码点就是 0x5B57
// 为了和数字区分，用转义字符 \u 做前缀，即 \u5B57
// 该函数将 unicode 码点按照 UTF-8 编码然后写入制定缓冲区 buf 中
static void 词器Unicode代码点(词法器大写 *词法器, 字节大写缓冲区大写 *缓冲) {
    uint32_t 索引 = 0;
    int 值 = 0;
    uint8_t 数字 = 0;

    // 循环的过程就是将十六进制转成十进制
    // 例如将 \u5B57 中的 5B57（十六进制）转成十进制 23383 (十进制)
    while (索引++ < 4) {
        获取下一个字符(词法器);

        // 先获取每一位数，然后转成十进制的数
        if (词法器->当前字符 == '\0') {
            词法_错误大写(词法器, "未终结的Unicode!");
        }

        if (词法器->当前字符 >= '0' && 词法器->当前字符 <= '9') {
            数字 = 词法器->当前字符 - '0';
        } else if (词法器->当前字符 >= 'a' && 词法器->当前字符 <= 'f') {
            数字 = 词法器->当前字符 - 'a' + 10;
        } else if (词法器->当前字符 >= 'A' && 词法器->当前字符 <= 'F') {
            数字 = 词法器->当前字符 - 'A' + 10;
        } else {
            词法_错误大写(词法器, "无效Unicode!");
        }
        // 将每一位的值转换成十进制后，累积到 value 中
        值 = 值 * 16 | 数字;
    }

    // 根据计算出十进制的数值 value，转换其如果用 UTF-8 序列时，需要几个字节
    uint32_t 字节数目 = 获取编码UTF8的字节数(值);
    断言大写(字节数目 != 0, "UTF8编码字节数目应在1到4之间");

    // 在真正将 value 写入 buf 之前，先写入 byteNum 个 0，以确保事先有 byteNum 个空间
    // 因为 encodeUtf8 方法中是直接将每个字节写入到 buf 中的，例如 *buf = value & 0x7f
    // 并不是调用 ByteBufferAdd 方法，因如果空间不足，则无法为 buf 自动扩容
    字节大写缓冲区填充写入大写(词法器->虚机针, 缓冲, 0, 字节数目);

    // 将十进制 value 进行 UTF-8 编码，然后写入指定缓冲区 buf
    编码UTF8(缓冲->数据们 + 缓冲->计数 - 字节数目, 值);
}

// 解析字符串
static void 词器字符串(词法器大写 *词法器) {
    字节大写缓冲区大写 串;
    字节大写缓冲区初始化大写(&串);

    while (真) {
        // 循环扫描下一个字符
        获取下一个字符(词法器);

        // 如果在遇到右双引号 “"” 之前遇到字符串结束符 \0，说明字符串是不完整的
        if (词法器->当前字符 == '\0') {
            词法_错误大写(词法器, "未终结的字符串!");
        }

        // 如果遇到了右双引号 “"”，则说明字符串已结束，跳出循环
        if (词法器->当前字符 == '"') {
            词法器->当前牌.类型 = 牌_字符串大写;
            break;
        }

        // 如果遇到了 % 说明可能是内嵌表达式
        // 即 %(表达式) ，其中括号里相当于一段代码，类似 JS 中的 eval 方法
        // % 不能单独使用
        // 以上为该脚本语言定义的语法
        if (词法器->当前字符 == '%') {
            // 如果 % 后面没有根 ( 则报错
            if (!匹配下一个字符(词法器, '(')) {
                词法_错误大写(词法器, "'%' 后应跟随 '('!");
            }

            // 一般遇到 %，interpolationExpectRightParenNum 会赋值 1
            // 如果下一次循环中 interpolationExpectRightParenNum 为 1
            // 说明之前的循环中已经遇到了 1，则说明由多个 %
            // 即内嵌表达式会嵌套使用，则报错提示不支持嵌套使用内嵌表达式
            if (词法器->插值期望右括号数目 > 0) {
                编译_错误大写(词法器, "不支持嵌套插值表达式!");
            }

            词法器->插值期望右括号数目 = 1;
            词法器->当前牌.类型 = 牌_插值大写;
            break;
        }

        // 当遇到 \ 说明可能遇到了转义字符，例如 \n，所以读取下个字符进一步确认
        // 之所以判断条件中是 '\\'，则是在 C 语言中也需要转义字符
        if (词法器->当前字符 == '\\') {
            获取下一个字符(词法器);
            switch (词法器->当前字符) {
                case '0':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '\0');
                    break;
                case 'a':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '\a');
                    break;
                case 'b':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '\b');
                    break;
                case 'f':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '\f');
                    break;
                case 'n':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '\n');
                    break;
                case 'r':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '\r');
                    break;
                case 't':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '\t');
                    break;
                case 'u':
                    // 如果是 \u 说明是 unicode 码点
                    // 则使用 lexUnicodeCodePoint 处理其后面的 4 个十六进制数字
                    词器Unicode代码点(词法器, &串);
                    break;
                case '"':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '"');
                    break;
                case '\\':
                    字节大写缓冲区添加大写(词法器->虚机针, &串, '\\');
                    break;
                default:
                    词法_错误大写(词法器, "不支持跳出 \\%c", 词法器->当前字符);
                    break;
            }
        } else {
            // 如果不是转义字符，仅是普通字符，则直接写入
            字节大写缓冲区添加大写(词法器->虚机针, &串, 词法器->当前字符);
        }
    }
    // 用解析到的字符串新建字符串对象，并存储到 curToken 的 value 中
    对象字符串大写 *对象字符串 = 新对象字符串(词法器->虚机针, (const char *)串.数据们, 串.计数);
    词法器->当前牌.值 = 对象到值大写(对象字符串);
    字节大写缓冲区清除大写(词法器->虚机针, &串);
}

// 跳过一行
static void 跳过一行(词法器大写 *词法器) {
    获取下一个字符(词法器);
    while (词法器->当前字符 != '\0') {
        if (词法器->当前字符 == '\n') {
            词法器->当前牌.行号++;
            获取下一个字符(词法器);
            break;
        }
        获取下一个字符(词法器);
    }
}

// 跳过行注释和区块注释
static void 跳过注释(词法器大写 *词法器) {
    char 下一个字符 = 看向前字符(词法器);
    if (词法器->当前字符 == '/') {
        // 行注释
        跳过一行(词法器);
    } else {
        // 区块注释
        // TODO: 该逻辑可能有 bug，当在注释中有 * 作为注释的内容时，
        // 不应该简单的跳出循环，然后判断下一个字符是不是 /
        // 后续完善
        while (下一个字符 != '*' && 下一个字符 != '\0') {
            // 不停地读入注释中下一个字符
            获取下一个字符(词法器);

            // 如果注释有换行，则更新 lineNo
            // 主要是为了当某段代码报错时，能准确报出出错行数
            if (词法器->当前字符 == '\n') {
                词法器->当前牌.行号++;
            }
            // 获取下一个字符，用作下一个循环的判断
            下一个字符 = 看向前字符(词法器);
        }

        // 循环退出后，下一个字符要么是 * 要么是 \0
        // 如果下一个字符是 *，再判断下下个字符是不是 /
        // 如果是，则说明注释结束，读取下个字符
        if (匹配下一个字符(词法器, '*')) {
            if (!匹配下一个字符(词法器, '/')) {
                词法_错误大写(词法器, "期望 '/' 在 '*' 之后!");
            }
            获取下一个字符(词法器);
        } else {
            // 如果下一个字符是 \0，则报错
            词法_错误大写(词法器, "期望 '*/' 在注释终之前!");
        }
    }
    // 注释之后可能会有空白符
    跳过空白们(词法器);
}

// 获取 Token 方法
void 获取下一个牌(词法器大写 *词法器) {
    // 将 curToken 备份到 preToken
    词法器->前一个牌 = 词法器->当前牌;
    // 跳过待识别单词之前的空格
    跳过空白们(词法器);

    // 初始化 curToken

    // 默认为文件结束类型 TOKEN_EOF
    词法器->当前牌.类型 = 牌_文件终大写;
    词法器->当前牌.长度 = 0;
    // 将下一个字符的地址减 1 即是当前字符地址，也就是 curToken 开始地址
    词法器->当前牌.起始 = 词法器->下一个字符指针 - 1;
    // 初始化 curToken 值为 VT_UNDEFINED 的 Value 结构形式
    词法器->当前牌.值 = 值型到值大写(值型_未定义大写);

    // 因词法分析器并不采用有限状态机，所以并不需要循环
    // 之所以这里有循环，是因为如果解析碰到注释，没有循环的话，本次函数调用无法获得一个正常的 Token
    // 所以需要继续循环，直到碰到非注释的 Token
    while (词法器->当前字符 != '\0') {
        switch (词法器->当前字符) {
            case ',':
                词法器->当前牌.类型 = 牌_逗号大写;
                break;
            case ':':
                词法器->当前牌.类型 = 牌_冒号大写;
                break;
            case '(':
                // 如果 interpolationExpectRightParenNum 大于 0，说明遇到了内嵌表达式
                // 即以 % 开头的 %()
                // 因为不支持嵌套使用内嵌表达式
                // 则 interpolationExpectRightParenNum 加 1，用来后面判断内嵌表达式是否嵌套
                // 判断的具体代码在 lexString 中
                if (词法器->插值期望右括号数目 > 0) {
                    词法器->插值期望右括号数目++;
                }
                词法器->当前牌.类型 = 牌_左小括号大写;
                break;
            case ')':
                if (词法器->插值期望右括号数目 > 0) {
                    // 如果 interpolationExpectRightParenNum 大于 0
                    // 说明之前已经遇到了 %(，因此当 ) 出现后，说明已经完结
                    // interpolationExpectRightParenNum 减 1
                    词法器->插值期望右括号数目--;
                    // 如果 interpolationExpectRightParenNum 减 1 后为 0
                    // 说明没有嵌套
                    // 然后调用 lexString 词法分析内嵌表达式后面的字符串
                    // 例如 "ab%(4+6)cb" 中的 cb
                    // 因为内嵌表达式一定会在字符串中
                    if (词法器->插值期望右括号数目 == 0) {
                        词器字符串(词法器);
                        break;
                    }
                }
                词法器->当前牌.类型 = 牌_右小括号大写;
                break;
            case '[':
                词法器->当前牌.类型 = 牌_左中括号大写;
                break;
            case ']':
                词法器->当前牌.类型 = 牌_右中括号大写;
                break;
            case '{':
                词法器->当前牌.类型 = 牌_左大括号大写;
                break;
            case '}':
                词法器->当前牌.类型 = 牌_右大括号大写;
                break;
            case '.':
                // .. 用于便是范围，例如 1 2 3 4  可以用 1..4 表示
                词法器->当前牌.类型 = 匹配下一个字符(词法器, '.') ? 牌_点点大写 : 牌_点大写;
                break;
            case '=':
                词法器->当前牌.类型 = 匹配下一个字符(词法器, '=') ? 牌_等于号大写 : 牌_赋值号大写;
                break;
            case '+':
                词法器->当前牌.类型 = 牌_加号大写;
                break;
            case '-':
                词法器->当前牌.类型 = 牌_减号大写;
                break;
            case '*':
                词法器->当前牌.类型 = 牌_乘号大写;
                break;
            case '/':
                if (匹配下一个字符(词法器, '/') || 匹配下一个字符(词法器, '*')) {
                    // 如果是注释，则调用跳过注释函数
                    跳过注释(词法器);
                    // 跳过注释后，重置 curToken 的起始地址
                    词法器->当前牌.起始 = 词法器->下一个字符指针 - 1;
                    // 开始下一个循环，不会执行下面的逻辑
                    // 直到匹配到非注释的正常 TOKEN
                    continue;
                } else {
                    词法器->当前牌.类型 = 牌_除号大写;
                }
                break;
            case '%':
                词法器->当前牌.类型 = 牌_取模号大写;
                break;
            case '&':
                词法器->当前牌.类型 = 匹配下一个字符(词法器, '&') ? 牌_逻辑与号大写 : 牌_位与号大写;
                break;
            case '|':
                词法器->当前牌.类型 = 匹配下一个字符(词法器, '|') ? 牌_逻辑或号大写 : 牌_位或号大写;
                break;
            case '~':
                词法器->当前牌.类型 = 牌_位非号大写;
                break;
            case '?':
                词法器->当前牌.类型 = 牌_问号大写;
                break;
            case '>':
                if (匹配下一个字符(词法器, '=')) {
                    词法器->当前牌.类型 = 牌_大等号大写;
                } else if (匹配下一个字符(词法器, '>')) {
                    词法器->当前牌.类型 = 牌_位右移号大写;
                } else {
                    词法器->当前牌.类型 = 牌_大于号大写;
                }
                break;
            case '<':
                if (匹配下一个字符(词法器, '=')) {
                    词法器->当前牌.类型 = 牌_小等号大写;
                } else if (匹配下一个字符(词法器, '<')) {
                    词法器->当前牌.类型 = 牌_位左移号大写;
                } else {
                    词法器->当前牌.类型 = 牌_小于号大写;
                }
                break;
            case '!':
                词法器->当前牌.类型 = 匹配下一个字符(词法器, '=') ? 牌_不等于号大写 : 牌_逻辑非号大写;
                break;
            case '"':
                // 遇到 " 字符，则调用解析字符串的函数 lexString
                词器字符串(词法器);
                break;
            default:
                // 如果首字符是字母或者 _ 则说明是变量名（包含保留的关键字）
                if (isalpha(词法器->当前字符) || 词法器->当前字符 == '_') {
                    词器身份(词法器, 牌_未知大写);
                } else if (isdigit(词法器->当前字符)) {
                    词器数目(词法器);
                } else {
                    if (词法器->当前字符 == '#' && 匹配下一个字符(词法器, '!')) {
                        跳过一行(词法器);
                        词法器->当前牌.起始 = 词法器->下一个字符指针 - 1; //重置下一个token起始地址
                        continue;
                    }
                    词法_错误大写(词法器, "不支持的字符: \'%c\', 退出.", 词法器->当前字符);
                }
                return;
        }

        // 计算当前 Token 的长度
        词法器->当前牌.长度 = (uint32_t)(词法器->下一个字符指针 - 词法器->当前牌.起始);
        // 读进下一个字符
        获取下一个字符(词法器);
        return;
    }
}

// 如果当前 token 类型为期望类型，则读入下一个 token 并返回 true
// 否则直接返回 false
布尔 匹配牌(词法器大写 *词法器, 牌类型大写 期望的牌类型) {
    if (词法器->当前牌.类型 == 期望的牌类型) {
        获取下一个牌(词法器);
        return 真;
    }
    return 假;
}

// 断言当前 token 类型为期望类型，并读取下一个 token，否则报错
void 断言当前牌(词法器大写 *词法器, 牌类型大写 期望的牌类型, const char *错消息) {
    if (词法器->当前牌.类型 != 期望的牌类型) {
        编译_错误大写(词法器, 错消息);
    }
    获取下一个牌(词法器);
}

// 初始化词法分析器
void 初始词法器(虚拟机大写 *虚机针, 词法器大写 *词法器, const char *文件, const char *源代码, 对象模块大写 *对象模块) {
    // 由于 sourceCode 未必源自文件
    // 当源码是直接输入的，则 file 只是个字符串
    词法器->文件 = 文件;
    // sourceCode 本身就是源码串中首字符地址
    词法器->源代码 = 源代码;
    词法器->当前字符 = *词法器->源代码;
    词法器->下一个字符指针 = 词法器->源代码 + 1;
    词法器->当前牌.行号 = 1;
    词法器->当前牌.类型 = 牌_未知大写;
    词法器->当前牌.起始 = NULL;
    词法器->当前牌.长度 = 0;
    词法器->前一个牌 = 词法器->当前牌;
    词法器->插值期望右括号数目 = 0;
    // 当前正在解析的模块
    词法器->虚机针 = 虚机针;
    词法器->当前模块 = 对象模块;
}