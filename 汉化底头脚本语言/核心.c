#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>

#include "底头.h"
#include "核心.脚本.inc"

// 源码文件所在的根目录，其值是在 cli.c 文件中设置的
// 解释器运行时会获得源码文件所在路径并写入 根目录
char *根目录 = NULL;

// 宏 核心_模块大写 用来表示核心模块，值是 VT_NUL 的 值大写 结构
#define 核心_模块大写 值型到值大写(值型_空指针大写)

// 定义原生方法的返回值
// 将 值 存储在 实参了[0] 中
// 返回 真 或 false，会使虚拟机在回收该参数时采用不同的回收策略
#define 返_值大写(值) \
    do {                 \
        实参们_[0] = 值; \
        return 真;     \
    } while (0);

//将值转为 值大写 格式后做为返回值
#define 返_对象大写(对象指针) 返_值大写(对象到值大写(对象指针))
#define 返_布尔大写(布尔型) 返_值大写(布尔到值大写(布尔型))
#define 返_数目大写(数目了) 返_值大写(数目到值大写(数目了))
#define 返_空指针大写 返_值大写(值型到值大写(值型_空指针大写))
#define 返_真大写 返_值大写(值型到值大写(值型_真大写))
#define 返_假大写 返_值大写(值型到值大写(值型_假大写))

// 设置线程报错
// 返回 假 通知虚拟机当前线程已报错，该切换线程了
#define 集_错误_假大写(虚机指针, 错消息)                                 \
    do {                                                               \
        虚机指针->当前线程->错误对象 =                                   \
            对象到值大写(新对象字符串(虚机指针, 错消息, strlen(错消息))); \
        return 假;                                                  \
    } while (0);

// 绑定原生方法 函乎 到 类指针 指向的类
// 其中 方法名 为脚本中使用的方法名，func 为原生方法
// 绑定后，脚本中类 类指针 的方法 方法名 对应的原生方法是 func，即脚本中调用 方法名 方法就是调用原生方法 函乎
// 步骤：
// 首先从 虚机针->全部方法名们 中查找 methodName，如果找到则获取对应索引，否则向 虚机针->全部方法名们 加入 方法名 并获取对应索引
// 然后基于 函乎 新建一个 方法
// 最后将 方法 绑定到 类指针 指向的类，并且保证索引和 方法名 在 虚机针->全部方法名们 索引相同（bindMethod 函数实现逻辑）
// 即 虚机针->全部方法名们 中的方法名和 类大写->方法们 中的方法体一一映射
#define 原语_方法_绑大写(类指针, 方法名, 函了乎)                                      \
    {                                                                                     \
        uint32_t 长度 = strlen(方法名);                                             \
        int 全局索引 = 获取索引来自符号表(&虚机针->全部方法名们, 方法名, 长度); \
        if (全局索引 == -1) {                                                            \
            全局索引 = 加上符号(虚机针, &虚机针->全部方法名们, 方法名, 长度);           \
        }                                                                                 \
        方法大写 方法;                                                                    \
        方法.类型 = 方法类型_原语;                                                       \
        方法.原语函 = 函了乎;                                                             \
        绑方法(虚机针, 类指针, (uint32_t)全局索引, 方法);                            \
    }

// 读取源码文件的方法
// 路径 为源码路径
char *读文件(const char *路径) {
    //获取源码文件的句柄 文件
    FILE *文件 = fopen(路径, "r");
    if (文件 == NULL) {
        入出_错误大写("不能打开文件 \"%s\".\n", 路径);
    }

    struct stat 文件态;
    stat(路径, &文件态);
    size_t 文件大小 = 文件态.st_size;

    // 获取源码文件大小后，为源码字符串申请内存，多申请的1个字节是为了字符串结尾 \0
    char *文件内容 = (char *)malloc(文件大小 + 1);
    if (文件内容 == NULL) {
        内存_错误大写("不能分配内存为读文件 \"%s\".\n", 路径);
    }

    size_t 数目读 = fread(文件内容, sizeof(char), 文件大小, 文件);
    if (数目读 < 文件大小) {
        入出_错误大写("不能读文件 \"%s\".\n", 路径);
    }
    // 字符串要以 \0 结尾
    文件内容[文件大小] = '\0';

    fclose(文件);
    return 文件内容;
}

// 将数字转换为字符串
static 对象字符串大写 *数目到串(虚拟机大写 *虚机针, double 数目了) {
    // NaN 不是一个确定的值,因此 NaN 和 NaN 是不相等的
    if (数目了 != 数目了) {
        return 新对象字符串(虚机针, "非数字", 3);
    }

    if (数目了 == INFINITY) {
        return 新对象字符串(虚机针, "无限", 8);
    }

    if (数目了 == -INFINITY) {
        return 新对象字符串(虚机针, "-无限", 9);
    }

    // 以下 24 字节的缓冲区足以容纳双精度到字符串的转换
    char 缓冲了[24] = {'\0'};
    int 长度了 = sprintf(缓冲了, "%.14g", 数目了);
    return 新对象字符串(虚机针, 缓冲了, 长度了);
}

// 判断 实参了 是否为函数
static 布尔 有效的函(虚拟机大写 *虚机针, 值大写 实参了) {
    if (值到对象闭包大写(实参了)) {
        return 真;
    }
    虚机针->当前线程->错误对象 = 对象到值大写(新对象字符串(虚机针, "实参必须是一个函数!", 28));
    return 假;
}

// 判断 实参了 是否为字符串
static 布尔 有效的字符串(虚拟机大写 *虚机针, 值大写 实参了) {
    if (值是否对象串大写(实参了)) {
        return 真;
    }
    集_错误_假大写(虚机针, "实参必须是字符串!")
}

//判断 实参了 是否为数字
static 布尔 有效的数目(虚拟机大写 *虚机针, 值大写 实参了) {
    if (值是否数目了大写(实参了)) {
        return 真;
    }
    集_错误_假大写(虚机针, "实参必须是数目!")
}

// 判断 值 是否为整数
static 布尔 有效的整型值(虚拟机大写 *虚机针, double 值) {
    if (trunc(值) == 值) {
        return 真;
    }
    集_错误_假大写(虚机针, "实参必须是整数!")
}

// 判断 实参了 是否为整数
static 布尔 有效的整型(虚拟机大写 *虚机针, 值大写 实参了) {
    // 首先得是数字
    if (!有效的数目(虚机针, 实参了)) {
        return 假;
    }

    // 再校验数值
    return 有效的整型值(虚机针, 值到数目大写(实参了));
}

// 判断参数 索引 是否是落在 [0, 长度) 之间的整数
static uint32_t 有效的索引值(虚拟机大写 *虚机针, double 索引, uint32_t 长度) {
    // 索引必须是整数，如果校验失败则返回 UINT32_MAX
    // UINT32_MAX 是 32 为无符号数的最大值，即 5294967295，用十六进制表示就是 0xFFFFFFFF
    if (!有效的整型值(虚机针, 索引)) {
        return UINT32_MAX;
    }

    // 支持负数索引，负数是从后往前索引，转换其对应的正数索引
    if (索引 < 0) {
        索引 += 长度;
    }

    // 索引应该落在 [0, 长度)
    if (索引 >= 0 && 索引 < 长度) {
        return (uint32_t)索引;
    }

    // 执行到此说明超出范围
    虚机针->当前线程->错误对象 = 对象到值大写(新对象字符串(虚机针, "索引出边界!", 19));
    return UINT32_MAX;
}

// 校验 索引 合法性
static uint32_t 有效的索引(虚拟机大写 *虚机针, 值大写 索引, uint32_t 长度) {
    return 有效的索引值(虚机针, 值到数目大写(索引), 长度);
}

// 校验 键 合法性
static 布尔 有效的键(虚拟机大写 *虚机针, 值大写 实参了) {
    if (值是否真大写(实参了) ||
        值是否假大写(实参了) ||
        值是否空指针大写(实参了) ||
        值是否数目了大写(实参了) ||
        值是否对象串大写(实参了) ||
        值是否对象范围大写(实参了) ||
        值是否类大写(实参了)) {
        return 真;
    }
    集_错误_假大写(虚机针, "键必须是值类型!")
}

// 基于码点 值 创建字符串
static 值大写 制作字符串来自代码点(虚拟机大写 *虚机针, int 值) {
    uint32_t 字节数目 = 获取编码UTF8的字节数(值);
    断言大写(字节数目 != 0, "UTF8编码字节应在1到4之间!");

    // +1是为了结尾的 '\0'
    对象字符串大写 *对象字符串 = 分配额外大写(虚机针, 对象字符串大写, 字节数目 + 1);

    if (对象字符串 == NULL) {
        内存_错误大写("分配内存失败在运行时内!");
    }

    初始对象头部(虚机针, &对象字符串->对象头部, 对类_字符串大写, 虚机针->字符串类);
    对象字符串->值.长度 = 字节数目;
    对象字符串->值.起始[字节数目] = '\0';
    编码UTF8((uint8_t *)对象字符串->值.起始, 值);

    // 根据字符串对象中的值 对象字符串->值 设置对应的哈希值给 对象字符串->hashCode
    哈希对象字符串(对象字符串);

    return 对象到值大写(对象字符串);
}

// 用索引 索引 处的字符创建字符串对象
static 值大写 字符串代码点在(虚拟机大写 *虚机针, 对象字符串大写 *对象字符串, uint32_t 索引) {
    断言大写(索引 < 对象字符串->值.长度, "索引出边界!");
    int 代码点 = 解码UTF8((uint8_t *)对象字符串->值.起始 + 索引, 对象字符串->值.长度 - 索引);

    // 若不是有效的 utf8 序列，将其处理为单个裸字符
    if (代码点 == -1) {
        return 对象到值大写(新对象字符串(虚机针, &对象字符串->值.起始[索引], 1));
    }

    return 制作字符串来自代码点(虚机针, 代码点);
}

// 计算 对象范围 中元素的起始索引及索引方向
// 计数指针 指针指向存储 对象范围 所能索引的元素个数的变量
// 方向指针 指针指向存储 对象范围 索引方向的变量（-1 表示反向，索引递减；1 表示正向，索引递增）
static uint32_t 计算范围(虚拟机大写 *虚机针, 对象范围大写 *对象范围, uint32_t *计数指针, int *方向指针) {
    uint32_t 来自 = 有效的索引值(虚机针, 对象范围->来自, *计数指针);
    if (来自 == UINT32_MAX) {
        return UINT32_MAX;
    }

    uint32_t 到 = 有效的索引值(虚机针, 对象范围->到, *计数指针);
    if (到 == UINT32_MAX) {
        return UINT32_MAX;
    }

    //如果 来自 和 到 为负值,经过 有效的索引值 已经变成了相应的正索引
    // -1 表示反向，索引递减；1 表示正向，索引递增
    *方向指针 = 来自 < 到 ? 1 : -1;
    // 计数指针 指针指向存储 对象范围 所能索引的元素个数的变量
    *计数指针 = abs((int)(来自 - 到)) + 1;
    return 来自;
}

// 按照 UTF-8 编码【从 源串 中起始为 startIndex，方向为 方向 的 计数 个字符】
static 对象字符串大写 *新对象字符串来自子(虚拟机大写 *虚机针, 对象字符串大写 *源串, int 起始索引, uint32_t 计数, int 方向) {
    uint8_t *源 = (uint8_t *)源串->值.起始;
    uint32_t 总共长度 = 0, 索引了 = 0;

    // 计算没有 UTF-8 编码的字符的 UTF-8 编码字节数，以便后面申请内存空间
    while (索引了 < 计数) {
        总共长度 += 获取解码UTF8的字节数(源[起始索引 + 索引了 * 方向]);
        索引了++;
    }

    // +1 是为了结尾的 '\0'
    对象字符串大写 *结果 = 分配额外大写(虚机针, 对象字符串大写, 总共长度 + 1);

    if (结果 == NULL) {
        内存_错误大写("分配内存失败在运行时内!");
    }
    初始对象头部(虚机针, &结果->对象头部, 对类_字符串大写, 虚机针->字符串类);
    结果->值.起始[总共长度] = '\0';
    结果->值.长度 = 总共长度;

    uint8_t *目的地 = (uint8_t *)结果->值.起始;
    索引了 = 0;
    while (索引了 < 计数) {
        int 索引 = 起始索引 + 索引了 * 方向;
        // 先调用 解码UTF8 获得字符的码点
        int 代码点 = 解码UTF8(源 + 索引, 源串->值.长度 - 索引);
        if (代码点 != -1) {
            // 然后调用 编码UTF8 将码点按照 UTF-8 编码，并写入dest 即 结果
            目的地 += 编码UTF8(目的地, 代码点);
        }
        索引了++;
    }

    // 根据字符串对象中的值 结果->值 设置对应的哈希值给 结果->hashCode
    哈希对象字符串(结果);
    return 结果;
}

// 使用 Boyer-Moore-HorsPool 字符串匹配算法在 干草堆 中查找 针状物
static int 找字符串(对象字符串大写 *干草堆, 对象字符串大写 *针状物) {
    // 如果待查找的 patten 为空则为找到，直接返回 0 即可
    if (针状物->值.长度 == 0) {
        //返回起始下标 0
        return 0;
    }

    // 若待搜索的字符串比原串还长，肯定搜不到，直接返回 -1 即可
    if (针状物->值.长度 > 干草堆->值.长度) {
        return -1;
    }

    // 构建 “bad-character shift表” 以确定窗口滑动的距离
    // 数组 转移 的值便是滑动距离
    uint32_t 转移[UINT8_MAX];
    // 针状物 中最后一个字符的下标
    uint32_t 针状物终 = 针状物->值.长度 - 1;

    // 一、先假定 “bad character” 不属于 针状物(即 模式)
    // 对于这种情况，滑动窗口跨过整个 针状物
    uint32_t 索引了 = 0;
    while (索引了 < UINT8_MAX) {
        // 默认为滑过整个 针状物 的长度
        转移[索引了] = 针状物->值.长度;
        索引了++;
    }

    // 二、假定 干草堆 中与 针状物 不匹配的字符在 针状物 中之前已匹配过的位置出现过
    // 就滑动窗口以使该字符与在needle中匹配该字符的最末位置对齐。
    // 这里预先确定需要滑动的距离
    索引了 = 0;
    while (索引了 < 针状物终) {
        char c = 针状物->值.起始[索引了];
        // 索引了 从前往后遍历 needle，当 针状物 中有重复的字符 c 时，
        // 后面的字符 c 会覆盖前面的同名字符 c，这保证了数组 转移 中字符是 针状物 中最末位置的字符，
        // 从而保证了 转移[c] 的值是 针状物 中 最末端同名字符与 针状物 末端的偏移量
        转移[(uint8_t)c] = 针状物终 - 索引了;
        索引了++;
    }

    // Boyer-Moore-HorsPool 是从后往前比较，这是处理 bad-character 高效的地方，
    // 因此获取 针状物 中最后一个字符，用于同 干草堆 的窗口中最后一个字符比较
    char 最后字符 = 针状物->值.起始[针状物终];

    // 长度差便是滑动窗口的滑动范围
    uint32_t 范围 = 干草堆->值.长度 - 针状物->值.长度;

    // 从 干草堆 中扫描 needle，寻找第 1 个匹配的字符，如果遍历完了就停止
    索引了 = 0;
    while (索引了 <= 范围) {
        // 拿 针状物 中最后一个字符同 干草堆 窗口的最后一个字符比较
        //（因为Boyer-Moore-HorsPool是从后往前比较），如果匹配，看整个 针状物 是否匹配
        char c = 干草堆->值.起始[索引了 + 针状物终];
        if (最后字符 == c &&
            memcmp(干草堆->值.起始 + 索引了, 针状物->值.起始, 针状物终) == 0) {
            // 找到了就返回匹配的位置
            return 索引了;
        }

        // 否则就向前滑动继续下一伦比较
        索引了 += 转移[(uint8_t)c];
    }

    // 未找到就返回 -1
    return -1;
}

// 从核心模块中获取名为 名称 的类
static 值大写 获取核心类值(对象模块大写 *对象模块, const char *名称) {
    int 索引 = 获取索引来自符号表(&对象模块->模块变量名, 名称, strlen(名称));
    if (索引 == -1) {
        char 身份了[最大身份长度了大写] = {'\0'};
        memcpy(身份了, 名称, strlen(名称));
        跑_错误大写("某些错误被想起: 丢失核心类 \"%s\"!", 身份了);
    }
    return 对象模块->模块变量值.数据们[索引];
}

// 从 虚机针->全部模块们 中获取名为 模块名 的模块
static 对象模块大写 *获取模块(虚拟机大写 *虚机针, 值大写 模块名) {
    值大写 值 = 映射获取(虚机针->全部模块们, 模块名);

    if (值.类型 == 值型_未定义大写) {
        return NULL;
    }
    return (对象模块大写 *)(值.对象头部);
}

// 加载名为 模块名 的模块并进行编译
static 对象线程大写 *载入模块(虚拟机大写 *虚机针, 值大写 模块名, const char *模块代码) {
    // 先在 虚机针->全部模块们 中查找是否存在 模块名
    // 如果存在，说明对应模块已经加载，以避免重复加载
    对象模块大写 *模块 = 获取模块(虚机针, 模块名);

    // 否则需要先加载模块，且该模块需要继承核心模块中的变量
    if (模块 == NULL) {
        // 创建模块并添加到 虚机针->全部模块们
        对象字符串大写 *模名 = 值到对象串大写(模块名);
        断言大写(模名->值.起始[模名->值.长度] == '\0', "字符串.值.起始 是非终结!");
        // 创建模块名为 模名 的模块对象
        模块 = 新对象模块(虚机针, 模名->值.起始);
        // 将名为 模块名 的模块加载到 虚机针->全部模块们
        映射集(虚机针, 虚机针->全部模块们, 模块名, 对象到值大写(模块));

        // 继承核心模块中变量，即将核心模块中的变量也拷贝到该模块中
        // TODO: 待后续解释
        对象模块大写 *核心模块 = 获取模块(虚机针, 核心_模块大写);
        uint32_t 索引了 = 0;
        while (索引了 < 核心模块->模块变量名.计数) {
            定义模块变量(虚机针, 模块,
                            核心模块->模块变量名.数据们[索引了].串,
                            核心模块->模块变量名.数据们[索引了].长度,
                            核心模块->模块变量值.数据们[索引了]);
            索引了++;
        }
    }

    对象函大写 *函_ = 编译模块(虚机针, 模块, 模块代码);
    // 单独创建一个线程运行编译后的模块
    对象闭包大写 *对象闭包 = 新对象闭包(虚机针, 函_);
    对象线程大写 *模块线程 = 新对象线程(虚机针, 对象闭包);
    return 模块线程;
}

// 根据模块名获取文件绝对路径
// 拼接规则：rootDir + 模块名 + '.di'
static char *获取文件路径(const char *模块名) {
    uint32_t 根目录长度 = 根目录 == NULL ? 0 : strlen(根目录);
    uint32_t 名称长度 = strlen(模块名);
    uint32_t 路径长度 = 根目录长度 + 名称长度 + strlen(".底头");
    char *路径 = (char *)malloc(路径长度 + 1);

    if (根目录 != NULL) {
        memmove(路径, 根目录, 根目录长度);
    }

    memmove(路径 + 根目录长度, 模块名, 名称长度);
    memmove(路径 + 根目录长度 + 名称长度, ".底头", 3);
    路径[路径长度] = '\0';
    return 路径;
}

// 读取名为 模块名 的模块
static char *读模块(const char *模块名) {
    char *模块路径 = 获取文件路径(模块名);
    char *模块代码 = 读文件(模块路径);
    free(模块路径);
    return 模块代码;
}

// 输出字符串
static void 打印字符串(const char *串) {
    printf("%s", 串);
    // 输出到缓冲区后立即刷新
    fflush(stdout);
}

// 导入模块 moduleName，主要是把编译模块并加载到 虚机针->全部模块们
static 值大写 导入模块(虚拟机大写 *虚机针, 值大写 模块名) {
    // 若模块已经导入则返回 NULL
    if (!值是否未定义大写(映射获取(虚机针->全部模块们, 模块名))) {
        return 值型到值大写(值型_空指针大写);
    }
    对象字符串大写 *对象字符串 = 值到对象串大写(模块名);
    // 读取名为 模块名 的模块
    const char *源代码 = 读模块(对象字符串->值.起始);

    // 加载名为 模块名 的模块并进行编译
    对象线程大写 *模块线程 = 载入模块(虚机针, 模块名, 源代码);
    return 对象到值大写(模块线程);
}

// 从模块 模块名 中获取模块变量 变量名
static 值大写 获取模块变量(虚拟机大写 *虚机针, 值大写 模块名, 值大写 变量名) {
    // 调用本函数前模块应该提前被加载
    // 也就是导入模块变量之前需要导入模块，在执行本函数之前，必须先执行 导入模块 函数将整个模块加载进来
    // 所以编译 “import 模块 for 模块变量” 会先生成调用 导入模块 函数的指令，再生成调用 获取模块变量 函数的指令获取模块中某个模块变量
    对象模块大写 *对象模块 = 获取模块(虚机针, 模块名);

    // 如果模块没有被提前加载，则向 虚机针->当前线程->错误对象 添加错误信息并返回 NULL
    if (对象模块 == NULL) {
        对象字符串大写 *模名 = 值到对象串大写(模块名);
        // 24 是下面 sprintf 中 fmt 中除 %s 的字符个数
        断言大写(模名->值.长度 < 512 - 24, "身份的缓冲区不够大!");
        char 身份了[512] = {'\0'};
        int 长度了 = sprintf(身份了, "模块 \'%s\' 未被载入!", 模名->值.起始);
        虚机针->当前线程->错误对象 = 对象到值大写(新对象字符串(虚机针, 身份了, 长度了));
        return 值型到值大写(值型_空指针大写);
    }

    对象字符串大写 *变量了名 = 值到对象串大写(变量名);

    // 从 对象模块->模块变量名 中获得待导入的模块变量的索引
    int 索引 = 获取索引来自符号表(&对象模块->模块变量名, 变量了名->值.起始, 变量了名->值.长度);

    // 如果索引为 -1，即模块变量 变量名 不存在，则向 虚机针->当前线程->错误对象 添加错误信息并返回 NULL
    if (索引 == -1) {
        // 32 是下面 sprintf 中 fmt 中除 %s 的字符个数
        断言大写(变量了名->值.长度 < 512 - 32, "身份的缓冲区不够大!");
        对象字符串大写 *模名 = 值到对象串大写(模块名);
        char 身份了[512] = {'\0'};
        int 长度了 = sprintf(身份了, "变量 \'%s\' 不在模块内 \'%s\'!", 变量了名->值.起始, 模名->值.起始);
        虚机针->当前线程->错误对象 = 对象到值大写(新对象字符串(虚机针, 身份了, 长度了));
        return 值型到值大写(值型_空指针大写);
    }

    // 否则模块变量存在，直接返回对应的模块变量 变量名 的值
    return 对象模块->模块变量值.数据们[索引];
}

/**
 * Object 类的原生方法
**/

// !实参们_[0]: object 取反，结果为 假
static 布尔
    原语对象非(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    返_值大写(值型到值大写(值型_假大写))
}

// 实参们_[0] == 实参们_[1]: 返回 object 是否相等
static 布尔 原语对象相等(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    值大写 布尔值 = 布尔到值大写(值是否相等(实参们_[0], 实参们_[1]));
    返_值大写(布尔值)
}

// 实参们_[0] == 实参们_[1]: 返回 object 是否不等
static 布尔 原语对象不相等(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    值大写 布尔值 = 布尔到值大写(!值是否相等(实参们_[0], 实参们_[1]));
    返_值大写(布尔值)
}

// 实参们_[0] is 实参们_[1]: 实参们_[1] 类是否是 实参们_[0] 对象所属的类或者其子类
static 布尔 原语对象是(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 实参们_[1] 必须是 class
    if (!值是否类大写(实参们_[1])) {
        跑_错误大写("实参必须是类!");
    }

    类大写 *这个类 = 获取对象的类(虚机针, 实参们_[0]);
    类大写 *基本类 = (类大写 *)(实参们_[1].对象头部);

    // 可能是多级继承，所以需要自下而上遍历基类链
    while (基本类 != NULL) {
        // 如果某一级基类匹配到，就设置返回值为 值型_真大写 并返回
        if (这个类 == 基本类) {
            返_值大写(值型到值大写(值型_真大写))
        }
        基本类 = 基本类->超级类;
    }

    // 若未找到满足条件的基类，则设置返回值为 值型_假大写 并返回
    返_值大写(值型到值大写(值型_假大写))
}

// 实参们_[0].toString: 返回 实参们_[0] 所属的 类 的名字
static 布尔 原语对象到字符串(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    类大写 *类 = 实参们_[0].对象头部->类指针;
    值大写 名称值 = 对象到值大写(类->名称);
    返_值大写(名称值)
}

// 实参们_[0].类型: 返回 实参们_[0] 对象所属的类
static 布尔 原语对象类型(虚拟机大写 *虚机针, 值大写 *实参们_) {
    类大写 *类 = 获取对象的类(虚机针, 实参们_[0]);
    返_对象大写(类)
}

/**
 * 类大写 类的原生方法
**/

// 实参们_[0].名称: 返回 实参们_[0] 类的名字
static 布尔 原语类名(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    类大写 *类 = 值到类大写(实参们_[0]);
    返_对象大写(类->名称)
}

// 实参们_[0].toString: 返回 实参们_[0] 类的名字
static 布尔 原语类到字符串(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    类大写 *类 = 值到类大写(实参们_[0]);
    返_对象大写(类->名称)
}

// 实参们_[0].supertype: 返回 实参们_[0] 类的基类
static 布尔 原语类超级类型(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    类大写 *类 = 值到类大写(实参们_[0]);
    if (类->超级类 != NULL) {
        返_对象大写(类->超级类)
    }
    返_值大写(值型到值大写(值型_空指针大写))
}

/**
 * 对象类 的元信息类的原生方法
**/

// 实参们_[0].same(实参们_[1], 实参们_[2]): 返回 实参们_[1] 和 实参们_[2] 是否相等
static 布尔 原语对象元相同(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    值大写 布尔值 = 布尔到值大写(值是否相等(实参们_[1], 实参们_[2]));
    返_值大写(布尔值)
}

/**
 * Bool 类的原生方法
**/

// 实参们_[0].toString: 返回 布尔 的字符串形式
static 布尔 原语布尔到字符串(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象字符串大写 *对象字符串;
    if (值到布尔大写(实参们_[0])) {
        对象字符串 = 新对象字符串(虚机针, "真", 4);
    } else {
        对象字符串 = 新对象字符串(虚机针, "假", 5);
    }
    返_对象大写(对象字符串)
}

// !实参们_[0]: 布尔 值取反
static 布尔 原语布尔非(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    返_布尔大写(!值到布尔大写(实参们_[0]))
}

/**
 * Thread 类的原生方法
**/

// Thread.new(函乎): 创建一个 thread 实例
// 该方法是脚本中调用 Thread.new(函乎) 所执行的原生方法
static 布尔 原语线程新(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 参数必须为函数
    if (!有效的函(虚机针, 实参们_[1])) {
        return 假;
    }

    对象线程大写 *对象线程 = 新对象线程(虚机针, 值到对象闭包大写(实参们_[1]));

    // 使stack[0]为接收者,保持栈平衡
    对象线程->栈[0] = 值型到值大写(值型_空指针大写);
    对象线程->栈指针++;
    返_对象大写(对象线程)
}

// Thread.abort(err): 以错误信息err为参数退出线程
// 该方法是脚本中调用 Thread.abort(err) 所执行的原生方法，所以 实参们_[1] 便是 err
static 布尔 原语线程中止(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 保存 err 到线程的 错误对象 上
    虚机针->当前线程->错误对象 = 实参们_[1]; //
    // 在原生方法返回后，虚拟机应该判断 err 即 实参们_[1] 是否为空，如果非空说明原生方法出现异常，然后进行异常捕获（该逻辑暂未实现）
    return 值是否空指针大写(实参们_[1]);
}

// Thread.current: 返回当前的线程
// 该方法是脚本中调用 Thread.current 所执行的原生方法
static 布尔 原语线程当前(虚拟机大写 *虚机针, 值大写 *实参们_ 未使用大写) {
    返_对象大写(虚机针->当前线程)
}

// Thread.suspend(): 挂起线程，退出解释器
// 该方法是脚本中调用 Thread.suspend() 所执行的原生方法
static 布尔 原语线程挂起(虚拟机大写 *虚机针, 值大写 *实参们_ 未使用大写) {
    // 将 当前线程 设置为 NULL后，虚拟机监测到 当前线程 为 NULL 是，表示当前没有可运行的线程，会退出解释器
    虚机针->当前线程 = NULL;
    return 假;
}

// Thread.yield(实参了): 带参数（args[1]）让出 CPU 使用权
// 该方法是脚本中调用 Thread.yield(实参了) 所执行的原生方法
static 布尔 原语线程屈服与实参一起(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 交回 CPU 控制权给调用当前线程的那个线程
    对象线程大写 *当前线程 = 虚机针->当前线程;
    虚机针->当前线程 = 当前线程->调用者;
    // 将当前线程的主调方设置为 NULL，断开与主调用的调用关系
    当前线程->调用者 = NULL;

    // 若主调方不为空，即当前线程有主调方，
    if (虚机针->当前线程 != NULL) {
        // 如果当前线程有主调方，就将当前线程的返回值放在主调方的栈顶，使得主调方可以获得当前线程 yield 时的参数
        虚机针->当前线程->栈指针[-1] = 实参们_[1];

        // 对于脚本来说，当前方法调用 Thread.yield(实参了) 拥有两个参数，即 Thread 和 arg，那么这两个参数占用了栈中两个 slot，
        // 由于存储主调方的参数只需要一个 slot，所以丢弃栈顶空间，预留之前的次栈顶空间
        // 即丢弃 Thread.yield(实参了) 中的 arg，也就是 实参们_[1]，只保留 实参们_[0] 用于存储主调用方线程通过 call 方法传递的参数
        // 即保留 thread 参数所在的空间,将来唤醒时用于存储 yield 结果
        当前线程->栈指针--;
    }
    // 返回 假 给虚拟机，表示需要切换线程
    // 虚拟机会从 虚机针->当前线程 中获取当前运行的线程，在函数开头已经将 虚机针->当前线程 设置成当前线程的主调方
    // 如果 虚机针->当前线程 为 NULL，虚拟机就认为全部线程执行完毕，可以退出了
    return 假;
}

// Thread.yield(): 无参数让出 CPU 使用权
static 布尔 原语线程屈服不与实参一起(虚拟机大写 *虚机针, 值大写 *实参们_ 未使用大写) {
    // 交回 CPU 控制权给调用当前线程的那个线程
    对象线程大写 *当前线程 = 虚机针->当前线程;
    虚机针->当前线程 = 当前线程->调用者;
    // 将当前线程的主调方设置为 NULL，断开与主调用的调用关系
    当前线程->调用者 = NULL;

    if (虚机针->当前线程 != NULL) {
        // 为保持通用的栈结构,如果当前线程有主调方，就将空值做为返回值放在主调方的栈顶
        虚机针->当前线程->栈指针[-1] = 值型到值大写(值型_空指针大写);
    }
    // 返回 假 给虚拟机，表示需要切换线程
    // 虚拟机会从 虚机针->当前线程 中获取当前运行的线程，在函数开头已经将 虚机针->当前线程 设置成当前线程的主调方
    // 如果 虚机针->当前线程 为 NULL，虚拟机就认为全部线程执行完毕，可以退出了
    return 假;
}

// 切换到下一个线程 下一个线程
static 布尔 切换线程(虚拟机大写 *虚机针, 对象线程大写 *下一个线程, 值大写 *实参们_, 布尔 与实参一起) {
    // 在下一线程 下一个线程 执行之前,其主调线程应该为空
    if (下一个线程->调用者 != NULL) {
        跑_错误大写("线程已被调用!");
    }

    // 将下一个线程 下一个线程 指向当前线程
    下一个线程->调用者 = 虚机针->当前线程;

    // 只有已经运行完毕的线程 thread 的 已用帧数目 才为 0，这种没有执行任务的线程不应该被调用
    if (下一个线程->已用帧数目 == 0) {
        集_错误_假大写(虚机针, "一个完毕的线程不能被切换到!")
    }

    // 如果线程上次运行已经出错了，其 错误对象 就会记录出错对象，已经出错的线程不应该被调用
    if (!值是否空指针大写(下一个线程->错误对象)) {
        集_错误_假大写(虚机针, "一个中止的线程不能被切换到!")
    }

    // 背景知识：
    // 尽管待运行线程 下一个线程 能运行是调用了该线程对象的 call 方法，但是 call 方法的参数可是存储都在当前线程 当前线程 的栈中
    // 确切的说是存储在 当前线程 中当前正在运行的闭包的运行时栈中
    // 当前线程 当前线程 正要交出 CPU 使用权给 nextThread，待将来 下一个线程 运行完毕后，再将 CPU 使用权交还给主调方，即 当前线程
    // 则 当前线程 恢复运行，curThread 需要从栈顶获取此时所调用的 下一个线程 线程的返回值，所以我们需要将 下一个线程 的返回值存储到
    // 主调方即当前线程 当前线程 的栈顶，如此 当前线程 才能拿到 下一个线程 的返回值

    // 如果主调方是通过 下一个线程.call() 无参数的形式激活 下一个线程 运行，那么主调方栈中只有一个参数即 nextThread，此时正好用
    // 下一个线程 在栈中的 slot 来存储将来 下一个线程 运行后的返回值
    // 如果主调方是通过 下一个线程.call(实参了) 有参数的形式激活 下一个线程 运行，那么主调方栈中有一两个参数，分别是 下一个线程 和 实参了
    // 占用两个 slot，由于当前主调线程只需要一个 slot 来存储 下一个线程 运行后的返回值，所以需要回收一个 slot 空间，
    // 只保留次栈顶用于存储 下一个线程 运行后的返回值
    if (与实参一起) {
        虚机针->当前线程->栈指针--;
    }

    断言大写(下一个线程->栈指针 > 下一个线程->栈, "栈指针应该大于栈!");

    // 线程 下一个线程 如果之前通过 yield 让出了 CUP 使用权给主调方 curThread，
    // 这次主调方 当前线程 又通过 下一个线程.call(实参了) 使 下一个线程 恢复运行
    // 那么 下一个线程.call(实参了) 中的 实参了 将作为返回值存储到 下一个线程 的栈顶
    下一个线程->栈指针[-1] = 与实参一起 ? 实参们_[1] : 值型到值大写(值型_空指针大写);

    // 虚拟机是根据 虚机针->当前线程 来确定当前运行的线程，设置当前线程为 下一个线程
    虚机针->当前线程 = 下一个线程;

    // 返回 假 使虚拟机进行线程切换
    return 假;
}

// 对象线程.call(实参了): 有参数调用下一个线程 下一个线程
// 该方法是脚本中调用 对象线程.call(实参了) 所执行的原生方法，注意是实例方法不是类方法
// 对于脚本来说，当前方法调用 Thread.call(实参了) 拥有两个参数，即 Thread 和 arg，分别是 实参们_[0] 和 实参们_[1]
static 布尔 原语线程调用与实参一起(虚拟机大写 *虚机针, 值大写 *实参们_) {
    return 切换线程(虚机针, 值到对象线程大写(实参们_[0]), 实参们_, 真);
}

// 对象线程.call(): 无参数调用下一个线程 下一个线程
// 该方法是脚本中调用 对象线程.call() 所执行的原生方法，注意是实例方法不是类方法
// 对于脚本来说，当前方法调用 Thread.call() 拥有一个参数，即 Thread，也就是 实参们_[0]
static 布尔 原语线程调用不与实参一起(虚拟机大写 *虚机针, 值大写 *实参们_) {
    return 切换线程(虚机针, 值到对象线程大写(实参们_[0]), 实参们_, 假);
}

// 对象线程.isDone：返回线程是否运行完成
// 该方法是脚本中调用 对象线程.isDone 所执行的原生方法，注意是实例方法不是类方法
static 布尔 原语线程是完成(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    // 对于脚本来说，当前方法调用 Thread.isDone 拥有一个参数，即 Thread，也就是 实参们_[0]，isDone 的调用者
    对象线程大写 *对象线程 = 值到对象线程大写(实参们_[0]);
    // 线程运行完毕的两种情况：
    // 1. 帧栈使用量 已用帧数目 为 0
    // 2. 线程是否有错误出现
    返_布尔大写(对象线程->已用帧数目 == 0 || !值是否空指针大写(对象线程->错误对象))
}

/**
 * Fn 类的原生方法
**/

// 新建一个函数对象
// 该方法是脚本中调用 Fn.new(_) 所执行的原生方法
static 布尔 原语函新(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 代码块为参数必为闭包
    if (!有效的函(虚机针, 实参们_[1]))
        return 假;

    // 直接返回函数闭包
    返_值大写(实参们_[1])
}

/**
 * Null 类的原生方法
**/

// !null: null 取非得到 真
// 该方法为 Null 类的实例方法
static 布尔 原语空指针非(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_ 未使用大写) {
    返_值大写(布尔到值大写(真))
}

// null.toString: null 字符串化
// 该方法为 Null 类的实例方法
static 布尔 原语空指针到字符串(虚拟机大写 *虚机针, 值大写 *实参们_ 未使用大写) {
    对象字符串大写 *对象字符串 = 新对象字符串(虚机针, "空指针", 4);
    返_对象大写(对象字符串)
}

/**
 * Num 类的原生方法
**/

// 将字符串转换为数字
// 该方法是脚本中调用 Num.fromString(_) 所执行的原生方法，为类的方法
static 布尔 原语数目来自字符串(虚拟机大写 *虚机针, 值大写 *实参们_) {
    if (!有效的字符串(虚机针, 实参们_[1])) {
        return 假;
    }

    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[1]);

    // 空字符串返回 RETURN_NULL
    if (对象字符串->值.长度 == 0) {
        返_空指针大写
    }

    断言大写(对象字符串->值.起始[对象字符串->值.长度] == '\0', "对象字符串不要终结!");

    errno = 0;
    char *终指针;

    // 将字符串转换为 double 型, 它会自动跳过前面的空白
    double 数目了 = strtod(对象字符串->值.起始, &终指针);

    // 以 终指针 是否等于 起始+长度 来判断不能转换的字符之后是否全是空白
    while (*终指针 != '\0' && isspace((unsigned char)*终指针)) {
        终指针++;
    }

    if (errno == ERANGE) {
        跑_错误大写("字符串太大!");
    }

    // 如果字符串中不能转换的字符不全是空白，则字符串非法，返回 NULL
    if (终指针 < 对象字符串->值.起始 + 对象字符串->值.长度) {
        返_空指针大写
    }

    // 至此，检查通过，返回正确结果
    返_数目大写(数目了)
}

// 返回圆周率
// 该方法是脚本中调用 Num.pi 所执行的原生方法，为类的方法
static 布尔 原语数目派(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_ 未使用大写) {
    返_数目大写(3.14159265358979323846)
}

// 定义 Num 相关中缀运算符的宏，共性如下：
// 先校验数字的合法性，然后再用 实参们_[0] 和 实参们_[1] 做中追运算符表示的运算
// 例如 1 + 2，args[0] 是 1，args[1] 是 2，中缀运算符 操作者 是 +，那么表达式的计算公式即 实参们_[0] 操作者 实参们_[1]
#define 原语_数目_中缀大写(名称, 操作者, 类型)                              \
    static 布尔 名称(虚拟机大写 *虚机针, 值大写 *实参们_) {                               \
        if (!有效的数目(虚机针, 实参们_[1])) {                                  \
            return 假;                                                 \
        }                                                                 \
        返_##类型(值到数目大写(实参们_[0]) 操作者 值到数目大写(实参们_[1])); \
    }

原语_数目_中缀大写(原语数目加法, +, 数目大写)
原语_数目_中缀大写(原语数目减法, -, 数目大写)
原语_数目_中缀大写(原语数目乘法, *, 数目大写)
原语_数目_中缀大写(原语数目除法, /, 数目大写)
原语_数目_中缀大写(原语数目大于, >, 布尔大写)
原语_数目_中缀大写(原语数目大等, >=, 布尔大写)
原语_数目_中缀大写(原语数目小于, <, 布尔大写)
原语_数目_中缀大写(原语数目小等, <=, 布尔大写)
#undef 原语_数目_中缀大写

// 定义 Num 相关位操作的宏，原理和上面一样
#define 原语_数目_位大写(名称, 操作者)                   \
    static 布尔 名称(虚拟机大写 *虚机针, 值大写 *实参们_) {            \
        if (!有效的数目(虚机针, 实参们_[1])) {               \
            return 假;                              \
        }                                              \
        uint32_t 左操作范围 = 值到数目大写(实参们_[0]);  \
        uint32_t 右操作范围 = 值到数目大写(实参们_[1]); \
        返_数目大写(左操作范围 操作者 右操作范围);    \
    }

原语_数目_位大写(原语数目位与, &)
原语_数目_位大写(原语数目位或, |)
原语_数目_位大写(原语数目位右移, >>)
原语_数目_位大写(原语数目位左移, <<)
#undef 原语_数目_位大写

// 使用数学库函数的宏
#define 原语_数目_数学_函大写(名称, 数学函)             \
    static 布尔 名称(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) { \
        返_数目大写(数学函(值到数目大写(实参们_[0])));    \
    }

原语_数目_数学_函大写(原语数目绝对值, fabs)
原语_数目_数学_函大写(原语数目反余弦, acos)
原语_数目_数学_函大写(原语数目反正弦, asin)
原语_数目_数学_函大写(原语数目反正切, atan)
原语_数目_数学_函大写(原语数目天花板, ceil)
原语_数目_数学_函大写(原语数目余弦, cos)
原语_数目_数学_函大写(原语数目地板, floor)
原语_数目_数学_函大写(原语数目否定, -)
原语_数目_数学_函大写(原语数目正弦, sin)
原语_数目_数学_函大写(原语数目平方, sqrt)
原语_数目_数学_函大写(原语数目正切, tan)
#undef 原语_数目_数学_函大写

// 数字取模
// 该方法是脚本中调用 num1%num2 所执行的原生方法，该方法为实例方法
static 布尔 原语数目取模(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    if (!有效的数目(虚机针, 实参们_[1])) {
        return 假;
    }
    返_数目大写(fmod(值到数目大写(实参们_[0]), 值到数目大写(实参们_[1])))
}

// 数字取反
// 该方法是脚本中调用 ~数目了 所执行的原生方法，该方法为实例方法
static 布尔 原语数目位非(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    返_数目大写(~(uint32_t)值到数目大写(实参们_[0]))
}

// 数字获取范围
// 该方法是脚本中调用[num1..num2] 所执行的原生方法，该方法为实例方法
static 布尔 原语数目范围(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    if (!有效的数目(虚机针, 实参们_[1])) {
        return 假;
    }

    double 来自 = 值到数目大写(实参们_[0]);
    double 到 = 值到数目大写(实参们_[1]);
    返_对象大写(新对象范围(虚机针, 来自, 到))
}

// 取数字的整数部分
// 该方法是脚本中调用 数目了.truncate 所执行的原生方法，该方法为实例方法
static 布尔 原语数目截断(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    double 整数;
    modf(值到数目大写(实参们_[0]), &整数);
    返_数目大写(整数)
}

// 返回小数部分
// 该方法是脚本中调用 数目了.fraction 所执行的原生方法，该方法为实例方法
static 布尔 原语数目分数(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    double 蠢整数;
    返_数目大写(modf(值到数目大写(实参们_[0]), &蠢整数))
}

// 判断数字是否无穷大，不区分正负无穷大
// 该方法是脚本中调用 数目了.isInfinity 所执行的原生方法，该方法为实例方法
static 布尔 原语数目是否无限(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    返_布尔大写(isinf(值到数目大写(实参们_[0])))
}

// 判断是否为整数
// 该方法是脚本中调用 数目了.isInteger 所执行的原生方法，该方法为实例方法
static 布尔 原语数目是否整数(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    double 数目了 = 值到数目大写(实参们_[0]);
    // 如果是 NaN (不是一个数字)或无限大的数字就返回 假
    if (isnan(数目了) || isinf(数目了)) {
        返_假大写
    }
    返_布尔大写(trunc(数目了) == 数目了)
}

// 判断数字是否为 NaN
// 该方法是脚本中调用 数目了.isNan 所执行的原生方法，该方法为实例方法
static 布尔 原语数目是否非数字(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    返_布尔大写(isnan(值到数目大写(实参们_[0])))
}

// 数字转换为字符串
// 该方法是脚本中调用 数目了.toString 所执行的原生方法，该方法为实例方法
static 布尔 原语数目到字符串(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    返_对象大写(数目到串(虚机针, 值到数目大写(实参们_[0])))
}

// 判断两个数字是否相等
// 该方法是脚本中调用 num1 == num2 所执行的原生方法，该方法为实例方法
static 布尔 原语数目相等(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    if (!有效的数目(虚机针, 实参们_[1])) {
        返_假大写
    }

    返_布尔大写(值到数目大写(实参们_[0]) == 值到数目大写(实参们_[1]))
}

// 判断两个数字是否不等
// 该方法是脚本中调用 num1 != num2 所执行的原生方法，该方法为实例方法
static 布尔 原语数目不等(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    if (!有效的数目(虚机针, 实参们_[1])) {
        返_真大写
    }
    返_布尔大写(值到数目大写(实参们_[0]) != 值到数目大写(实参们_[1]))
}

/**
 * 字符串大写 类的原生方法
**/

// 基于码点 实参们_[1] 创建字符串
// 该方法是脚本中调用 对象字符串大写.fromCodePoint(实参们_[1]) 所执行的原生方法，该方法为类方法
static 布尔 原语字符串来自代码点(虚拟机大写 *虚机针, 值大写 *实参们_) {
    if (!有效的整型(虚机针, 实参们_[1])) {
        return 假;
    }

    int 代码点 = (int)值到数目大写(实参们_[1]);
    if (代码点 < 0) {
        集_错误_假大写(虚机针, "代码点不能是负的!")
    }

    if (代码点 > 0x10ffff) {
        集_错误_假大写(虚机针, "代码点必须是在0到0x10ffff之间!")
    }

    返_值大写(制作字符串来自代码点(虚机针, 代码点))
}

// 字符串相加
// 该方法是脚本中调用 实参们_[0] +实参们_[1] 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串加法(虚拟机大写 *虚机针, 值大写 *实参们_) {
    if (!有效的字符串(虚机针, 实参们_[1])) {
        return 假;
    }

    对象字符串大写 *左 = 值到对象串大写(实参们_[0]);
    对象字符串大写 *右 = 值到对象串大写(实参们_[1]);

    // 结果字符串 结果 长度为两个字符串长度之和
    uint32_t 总共长度 = strlen(左->值.起始) + strlen(右->值.起始);

    // +1 是为了结尾的 '\0'
    // 为结果字符串 结果 申请内存空间
    对象字符串大写 *结果 = 分配额外大写(虚机针, 对象字符串大写, 总共长度 + 1);
    if (结果 == NULL) {
        内存_错误大写("分配内存失败在运行时内!");
    }

    初始对象头部(虚机针, &结果->对象头部, 对类_字符串大写, 虚机针->字符串类);
    // 分别将 左->值 和 右->值 拷贝到 结果->值 中
    memcpy(结果->值.起始, 左->值.起始, strlen(左->值.起始));
    memcpy(结果->值.起始 + strlen(左->值.起始), 右->值.起始, strlen(右->值.起始));
    结果->值.起始[总共长度] = '\0';
    结果->值.长度 = 总共长度;

    // 根据字符串对象中的值 结果->值 设置对应的哈希值给 结果->hashCode
    哈希对象字符串(结果);

    返_对象大写(结果)
}

// 索引字符串
// 通过数字或 对象范围 对象作为索引，获取字符串中的部分字符串
// 该方法是脚本中调用 对象字符串[实参们_[1]] 所执行的原生方法，其中 nargs[1]为数字或者 对象范围 对象，该方法为实例方法
static 布尔 原语字符串子脚本(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);

    // 索引可以是数字或 对象范围 对象
    // 1. 如果索引是数字，就直接索引 1 个字符
    if (值是否数目了大写(实参们_[1])) {
        // 先判断该数字是否是在 [0, 对象字符串->值.长度) 区间
        uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象字符串->值.长度);
        if (索引 == UINT32_MAX) {
            return 假;
        }
        // 若数字合法，则调用 字符串代码点在 为该索引处的字符生成字符串对象并返回
        返_值大写(字符串代码点在(虚机针, 对象字符串, 索引))
    }

    // 2. 如果索引不是数字，必定为 对象范围 对象，否则报错
    if (!值是否对象范围大写(实参们_[1])) {
        集_错误_假大写(虚机针, "子脚本应该是整数 或 范围!")
    }

    // direction是索引的方向，1 表示正方向，即索引值递增，-1表示反方向，即索引值递减
    // 来自 若比 to大，即索引值递减，则为反方向，direction 为 1
    int 方向;
    uint32_t 计数 = 对象字符串->值.长度;

    // 返回的 起始索引 是 对象范围.来自 在 对象字符串.值.起始 中的下标
    // 计算范围 主要是判断 对象范围.来自 和 对象范围.到 是否在 [0, 对象字符串->值.长度) 区间内，即索引范围是否合法
    uint32_t 起始索引 = 计算范围(虚机针, 值到对象范围大写(实参们_[1]), &计数, &方向);
    if (起始索引 == UINT32_MAX) {
        return 假;
    }
    // 从字符串 源串 中获取起始为 startIndex，方向为 方向 的 计数 个字符，创建字符串并返回
    返_对象大写(新对象字符串来自子(虚机针, 对象字符串, 起始索引, 计数, 方向))
}

// 获取字符串中指定索引的字符对应的字节
// 该方法是脚本中调用 对象字符串.byteAt_(实参们_[1]) 所执行的原生方法，其中 实参们_[1]为索引，该方法为实例方法
static 布尔 原语字符串字节在(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);
    // 先判断该索引 实参们_[1] 是否是在 [0, 对象字符串->值.长度) 区间
    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象字符串->值.长度);
    if (索引 == UINT32_MAX) {
        return 假;
    }
    // 如果索引合法，则返回对应字符的数字形式
    返_数目大写((uint8_t)对象字符串->值.起始[索引])
}

// 获取字符串对应的字节数
// 该方法是脚本中调用 对象字符串.byteCount_ 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串字节计数(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);
    返_数目大写(对象字符串->值.长度)
}

// 获取字符串中指定索引的字符对应的码点
// 该方法是脚本中调用 对象字符串.codePointAt_(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串代码点在(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);
    // 先判断该索引 实参们_[1] 是否是在 [0, 对象字符串->值.长度) 区间
    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象字符串->值.长度);
    if (索引 == UINT32_MAX) {
        return 假;
    }

    const uint8_t *字节们 = (uint8_t *)对象字符串->值.起始;
    if ((字节们[索引] & 0xc0) == 0x80) {
        // 如果 索引 指向的并不是 UTF-8 编码的最高字节
        // 而是后面的低字节,返回 -1 提示用户
        返_数目大写(-1)
    }

    // 调用 解码UTF8 解码对应字符并返回
    返_数目大写(解码UTF8((uint8_t *)对象字符串->值.起始 + 索引, 对象字符串->值.长度 - 索引))
}

// 判断字符串 实参们_[0] 中是否包含子字符串 实参们_[1]
// 该方法是脚本中调用 对象字符串.contains(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串内容(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    // 先校验参数 实参们_[1] 是否为字符串
    if (!有效的字符串(虚机针, 实参们_[1])) {
        return 假;
    }

    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);
    对象字符串大写 *模式 = 值到对象串大写(实参们_[1]);

    // 调用 找字符串 来判断字符串 实参们_[0] 中是否包含子字符串 实参们_[1]
    返_布尔大写(找字符串(对象字符串, 模式) != -1)
}

// 检索字符串 实参们_[0] 中子串 实参们_[1] 的起始下标
// 该方法是脚本中调用 对象字符串.indexOf(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串索引的(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    // 先校验参数 实参们_[1] 是否为字符串
    if (!有效的字符串(虚机针, 实参们_[1])) {
        return 假;
    }

    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);
    对象字符串大写 *模式 = 值到对象串大写(实参们_[1]);

    // 若 模式 比源串 对象字符串 还长，源串 对象字符串 必然不包括 模式
    if (模式->值.长度 > 对象字符串->值.长度) {
        返_假大写
    }

    // 否则调用 找字符串 来检索字符串 实参们_[0] 中子串 实参们_[1] 的起始下标
    int 索引 = 找字符串(对象字符串, 模式);
    返_数目大写(索引)
}

// 判断字符串 实参们_[0] 是否以字符串 实参们_[1] 为开始
// 该方法是脚本中调用 对象字符串.startsWith(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串与起始一起(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    // 先校验参数 实参们_[1] 是否为字符串
    if (!有效的字符串(虚机针, 实参们_[1])) {
        return 假;
    }

    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);
    对象字符串大写 *模式 = 值到对象串大写(实参们_[1]);

    // 若 模式 比源串 对象字符串 还长，源串 对象字符串 必然不包括 模式
    if (模式->值.长度 > 对象字符串->值.长度) {
        返_假大写
    }

    // 否则调用 memcmp 函数比较相同位置的字符串是否相同
    返_布尔大写(memcmp(对象字符串->值.起始, 模式->值.起始, 模式->值.长度) == 0)
}

// 判断字符串 实参们_[0] 是否以字符串 实参们_[1] 为结束
// 该方法是脚本中调用 对象字符串.endsWith(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串与终一起(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    // 先校验参数 实参们_[1] 是否为字符串
    if (!有效的字符串(虚机针, 实参们_[1])) {
        return 假;
    }

    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);
    对象字符串大写 *模式 = 值到对象串大写(实参们_[1]);

    // 若 模式 比源串 对象字符串 还长，源串 对象字符串 必然不包括 模式
    if (模式->值.长度 > 对象字符串->值.长度) {
        返_假大写
    }

    // 否则调用 memcmp 函数比较相同位置的字符串是否相同
    char *对比索引 = 对象字符串->值.起始 + 对象字符串->值.长度 - 模式->值.长度;
    返_布尔大写(memcmp(对比索引, 模式->值.起始, 模式->值.长度) == 0)
}

// 字符串输出自己
// 该方法是脚本中调用 对象字符串.toString() 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串到字符串(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    返_值大写(实参们_[0])
}

// 返回下一个 UTF-8 字符 (不是字节) 的迭代器
// 该方法是脚本中调用 对象字符串.iterate(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串迭代的(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);

    // 如果是第一次迭代，迭代索引肯定为空
    if (值是否空指针大写(实参们_[1])) {
        if (对象字符串->值.长度 == 0) {
            返_假大写
        }
        返_数目大写(0)
    }

    // 迭代器必须是正整数
    if (!有效的整型(虚机针, 实参们_[1])) {
        return 假;
    }

    double 迭代 = 值到数目大写(实参们_[1]);
    if (迭代 < 0) {
        返_假大写
    }

    uint32_t 索引 = (uint32_t)迭代;
    do {
        索引++;

        // 到了结尾就返回 false，表示迭代完毕
        if (索引 >= 对象字符串->值.长度)
            返_假大写

        // 读取连续的数据字节，直到下一个 UTF-8 的高字节
    } while ((对象字符串->值.起始[索引] & 0xc0) == 0x80);

    返_数目大写(索引)
}

// 迭代索引，内部使用
// 该方法是脚本中调用 对象字符串.iterateByte_(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串迭代的字节(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);

    // 如果是第一次迭代，迭代索引肯定为空，直接返回索引 0
    if (值是否空指针大写(实参们_[1])) {
        if (对象字符串->值.长度 == 0) {
            返_假大写
        }
        返_数目大写(0)
    }

    // 迭代器必须是正整数
    if (!有效的整型(虚机针, 实参们_[1])) {
        return 假;
    }

    double 迭代 = 值到数目大写(实参们_[1]);

    if (迭代 < 0) {
        返_假大写
    }

    uint32_t 索引 = (uint32_t)迭代;
    // 移进到下一个字节的索引
    索引++;
    if (索引 >= 对象字符串->值.长度) {
        返_假大写
    }

    返_数目大写(索引)
}

// 返回迭代器对应的value
// 该方法是脚本中调用 对象字符串.iteratorValue(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语字符串迭代器值(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[0]);
    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象字符串->值.长度);
    if (索引 == UINT32_MAX) {
        return 假;
    }
    返_值大写(字符串代码点在(虚机针, 对象字符串, 索引))
}

/**
 * List 类的原生方法
**/

// 创建 list 实例
// 该方法是脚本中调用 对象列表大写.new() 所执行的原生方法，该方法为类方法
static 布尔 原语列表新(虚拟机大写 *虚机针, 值大写 *实参们_ 未使用大写) {
    // 返回列表自身
    返_对象大写(新对象列表(虚机针, 0))
}

// 索引 list 中的元素（索引可以是数字或者 对象范围 实例）
// 该方法是脚本中调用 对象列表[实参们_[1]] 所执行的原生方法，该方法为实例方法
static 布尔 原语列表子脚本(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);

    // 索引可以是数字或 对象范围 对象
    // 1. 如果索引是数字，就直接索引 1 个字符
    if (值是否数目了大写(实参们_[1])) {
        // 先判断该数字是否是在 [0, 对象字符串->值.长度) 区间
        uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象列表->元素们.计数);
        if (索引 == UINT32_MAX) {
            return 假;
        }
        // 若数字合法，则获取该元素并返回
        返_值大写(对象列表->元素们.数据们[索引])
    }

    // 2. 如果索引不是数字，必定为 对象范围 对象，否则报错
    if (!值是否对象范围大写(实参们_[1])) {
        集_错误_假大写(虚机针, "子脚本应该是整数 或 范围!")
    }

    // direction是索引的方向，1 表示正方向，即索引值递增，-1表示反方向，即索引值递减
    // 来自 若比 to大，即索引值递减，则为反方向，direction 为 1
    int 方向;
    uint32_t 计数 = 对象列表->元素们.计数;

    // 返回的 起始索引 是 对象范围.来自 在 对象字符串.值.起始 中的下标
    // 计算范围 主要是判断 对象范围.来自 和 对象范围.到 是否在 [0, 对象字符串->值.长度) 区间内，即索引范围是否合法
    uint32_t 起始索引 = 计算范围(虚机针, 值到对象范围大写(实参们_[1]), &计数, &方向);

    // 新建一个 list 存储该 范围 在原来 list 中索引的元素
    对象列表大写 *结果 = 新对象列表(虚机针, 计数);
    uint32_t 索引了 = 0;
    while (索引了 < 计数) {
        // direction为 -1 表示从后往前倒序赋值
        // 如 var l = [a,b,c,d,e,f,g]; l[5..3]表示[f,e,d]
        结果->元素们.数据们[索引了] = 对象列表->元素们.数据们[起始索引 + 索引了 * 方向];
        索引了++;
    }
    返_对象大写(结果)
}

// 对 list 中某个索引的元素赋值（索引只能是数字）
// 该方法是脚本中调用 对象列表[实参们_[1]] = 实参们_[2] 所执行的原生方法，该方法为实例方法
static 布尔 原语列表子脚本设置器(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    // 获取对象
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);

    // 获取索引
    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象列表->元素们.计数);
    if (索引 == UINT32_MAX) {
        return 假;
    }

    // 直接赋值
    对象列表->元素们.数据们[索引] = 实参们_[2];

    // 把要赋的值 实参们_[2] 做为返回值
    返_值大写(实参们_[2])
}

// 向 list 后面追加元素
// 该方法是脚本中调用 对象列表.add(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语列表加上(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);
    值大写缓冲区添加大写(虚机针, &对象列表->元素们, 实参们_[1]);
    // 将要追加的元素 实参们_[1] 做为返回值
    返_值大写(实参们_[1])
}

// 向 list 后面追加元素
// 该方法是脚本中调用 对象列表.addCore_(实参们_[1]) 所执行的原生方法，该方法为实例方法
// 该方法主要用于内部使用，主要是为了支持字面量形式创建的 list 而非 List.new() 方式，例如 var l = [1, 4, 7];
static 布尔 原语列表加上核心(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);
    值大写缓冲区添加大写(虚机针, &对象列表->元素们, 实参们_[1]);
    // 返回列表自身
    返_值大写(实参们_[0])
}

// 向 list 中某个位置插入元素
// 该方法是脚本中调用 对象列表.insert(实参们_[1], 实参们_[2]) 所执行的原生方法，args[1] 为索引，args[2] 为元素，该方法为实例方法
static 布尔 原语列表插入(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);
    // +1 确保可以在最后插入
    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象列表->元素们.计数 + 1);
    if (索引 == UINT32_MAX) {
        return 假;
    }
    插入元素(虚机针, 对象列表, 索引, 实参们_[2]);
    // 元素 实参们_[2] 做为返回值
    返_值大写(实参们_[2])
}

// 删除 list 中某个位置的元素
// 该方法是脚本中调用 对象列表.removeAt(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语列表移除在(虚拟机大写 *虚机针, 值大写 *实参们_) {
    //获取实例对象
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);

    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象列表->元素们.计数);
    if (索引 == UINT32_MAX) {
        return 假;
    }
    // 被删除的元素做为返回值
    返_值大写(移除元素(虚机针, 对象列表, 索引))
}

// 清空 list 中所有元素
// 该方法是脚本中调用 对象列表.clear() 所执行的原生方法，该方法为实例方法
static 布尔 原语列表清除(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);
    值大写缓冲区清除大写(虚机针, &对象列表->元素们);
    返_空指针大写
}

// 返回 list 的元素个数
// 该方法是脚本中调用 对象列表.计数 所执行的原生方法，该方法为实例方法
static 布尔 原语列表计数(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);
    返_数目大写(对象列表->元素们.计数)
}

// 迭代 list 中的元素
// 该方法是脚本中调用 对象列表.iterate(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语列表迭代的(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);

    // 如果是第一次迭代，迭代索引肯定为空，直接返回索引0
    if (值是否空指针大写(实参们_[1])) {
        if (对象列表->元素们.计数 == 0) {
            返_假大写
        }
        返_数目大写(0)
    }

    // 确保迭代器是整数
    if (!有效的整型(虚机针, 实参们_[1])) {
        return 假;
    }

    double 迭代 = 值到数目大写(实参们_[1]);
    // 如果迭代完了就终止
    if (迭代 < 0 || 迭代 >= 对象列表->元素们.计数 - 1) {
        返_假大写
    }
    //返回下一个
    返_数目大写(迭代 + 1)
}

// 返回迭代值
// 该方法是脚本中调用 对象列表.iteratorValue(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语列表迭代器值(虚拟机大写 *虚机针, 值大写 *实参们_) {
    //获取实例对象
    对象列表大写 *对象列表 = 值到对象列表大写(实参们_[0]);

    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象列表->元素们.计数);
    if (索引 == UINT32_MAX) {
        return 假;
    }

    返_值大写(对象列表->元素们.数据们[索引])
}

/**
 * Map 类的原生方法
**/

// 创建 map 实例
// 该方法是脚本中调用 ObjMap.new() 所执行的原生方法，该方法为类方法
static 布尔 原语映射新(虚拟机大写 *虚机针, 值大写 *实参们_ 未使用大写) {
    返_对象大写(新对象映射(虚机针))
}

// 获取 map[键] 对应的 值
// 该方法是脚本中调用 对象映射[实参们_[1]] 所执行的原生方法，该方法为类方法
static 布尔 原语映射子脚本(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 先校验 键 的合法性
    if (!有效的键(虚机针, 实参们_[1])) {
        return 假;
    }

    // 获得 map 对象实例
    对象映射大写 *对象映射 = 值到对象映射大写(实参们_[0]);

    // 从 map 中查找 键 即 实参们_[1] 对应的 值
    值大写 值 = 映射获取(对象映射, 实参们_[1]);

    // 若没有相应的 键 则返回 NULL
    if (值是否未定义大写(值)) {
        返_空指针大写
    }
    返_值大写(值)
}

// 对 map[键] 赋值
// 该方法是脚本中调用 对象映射[实参们_[1]] = 实参们_[2] 所执行的原生方法，其中 实参们_[1] 为 key，args[2] 为要赋的值，该方法为实例方法
static 布尔 原语映射子脚本设置器(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 先校验 键 的合法性
    if (!有效的键(虚机针, 实参们_[1])) {
        return 假;
    }

    // 获得 map 对象实例
    对象映射大写 *对象映射 = 值到对象映射大写(实参们_[0]);

    // 在 map 中将 键 和 值 关联，即 map[键] = 值
    映射集(虚机针, 对象映射, 实参们_[1], 实参们_[2]);
    返_值大写(实参们_[2])
}

// 在 map 中添加 键-值 对并返回 map 自身
// 该方法是脚本中调用 对象映射.addCore_(实参们_[1], 实参们_[2]) 所执行的原生方法，该方法为实例方法
// 该方法主要用于内部使用，主要是为了支持字面量形式创建的 map 而非 Map.new() 方式，例如 var map = {a: 1};
static 布尔 原语映射加上核心(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 先校验 键 的合法性
    if (!有效的键(虚机针, 实参们_[1])) {
        return 假;
    }

    //获得 map 对象实例
    对象映射大写 *对象映射 = 值到对象映射大写(实参们_[0]);

    // 在 map 中将 键 和 值 关联，即 map[键] = 值
    映射集(虚机针, 对象映射, 实参们_[1], 实参们_[2]);
    // 返回 map 对象自身
    返_值大写(实参们_[0])
}

// 删除 map 中对应 键 的 entry（即 键-值 对）
// 该方法是脚本中调用 对象映射.remove(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语映射移除(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 先校验 键 的合法性
    if (!有效的键(虚机针, 实参们_[1])) {
        return 假;
    }

    返_值大写(移除键(虚机针, 值到对象映射大写(实参们_[0]), 实参们_[1]))
}

// 清空 map
// 该方法是脚本中调用 对象映射.clear() 所执行的原生方法，该方法为实例方法
static 布尔 原语映射清除(虚拟机大写 *虚机针, 值大写 *实参们_) {
    清除映射(虚机针, 值到对象映射大写(实参们_[0]));
    返_空指针大写
}

// 判断 map 即 实参们_[0] 是否包含 键 即 实参们_[1]
// 该方法是脚本中调用 对象映射.containsKey(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语映射内容键(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 先校验 键 的合法性
    if (!有效的键(虚机针, 实参们_[1])) {
        return 假;
    }

    // 从 map 中获取该 键 对应的 value，如果 值 存在则 键 存在，否则不存在
    返_布尔大写(!值是否未定义大写(映射获取(值到对象映射大写(实参们_[0]), 实参们_[1])))
}

// 获取 map 中 条目 个数，即 键-值 的对数
// 该方法是脚本中调用 对象映射.计数 所执行的原生方法，该方法为实例方法
static 布尔 原语映射计数(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象映射大写 *对象映射 = 值到对象映射大写(实参们_[0]);
    返_数目大写(对象映射->计数)
}

// 迭代 map 中的 entry，即 键-值 对
// 该方法是脚本中调用 对象映射.iterate_(实参们_[1]) 所执行的原生方法，该方法为实例方法
// 返回 条目 的索引供 keyIteratorValue_ 和 valueIteratorValue_ 做迭代器
static 布尔 原语映射迭代的(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // 获得 map 对象实例
    对象映射大写 *对象映射 = 值到对象映射大写(实参们_[0]);

    // map 中若空则返回 假 不可迭代
    if (对象映射->计数 == 0) {
        返_假大写
    }

    // 若没有传入迭代器，迭代默认是从第 0 个 条目 开始
    uint32_t 索引 = 0;

    // 若不是第一次迭代，传进了迭代器
    if (!值是否空指针大写(实参们_[1])) {
        // 迭代 必须为整数
        if (!有效的整型(虚机针, 实参们_[1])) {
            // 本线程出错了，返回 假 是为了切换到下一线
            return 假;
        }

        // 迭代器不能小于 0
        if (值到数目大写(实参们_[1]) < 0) {
            返_假大写
        }

        索引 = (uint32_t)值到数目大写(实参们_[1]);
        // 迭代器不能越界
        if (索引 >= 对象映射->容量) {
            返_假大写
        }
        // 更新迭代器
        索引++;
    }

    // 返回下一个正在使用 (有效) 的 条目
    while (索引 < 对象映射->容量) {
        // 条目们 是个数组，元素是哈希槽，
        // 哈希值散布在这些槽中并不连续，因此逐个判断槽位是否在用
        if (!值是否未定义大写(对象映射->条目们[索引].键)) {
            // 返回 条目 索引
            返_数目大写(索引)
        }
        索引++;
    }

    // 若没有有效的 条目 就返回 false，迭代结束
    返_假大写
}

// 迭代 map 中的 键
// 该方法是脚本中调用 对象映射.keyIteratorValue_(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语映射键迭代器值(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象映射大写 *对象映射 = 值到对象映射大写(实参们_[0]);

    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象映射->容量);
    if (索引 == UINT32_MAX) {
        return 假;
    }

    条目大写 *条目 = &对象映射->条目们[索引];
    if (值是否未定义大写(条目->键)) {
        集_错误_假大写(虚机针, "无效迭代器!")
    }

    // 返回该 键
    返_值大写(条目->键)
}

// 迭代 map 中的 值
// 该方法是脚本中调用 对象映射.valueIteratorValue_(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语映射值迭代器值(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象映射大写 *对象映射 = 值到对象映射大写(实参们_[0]);

    uint32_t 索引 = 有效的索引(虚机针, 实参们_[1], 对象映射->容量);
    if (索引 == UINT32_MAX) {
        return 假;
    }

    条目大写 *条目 = &对象映射->条目们[索引];
    if (值是否未定义大写(条目->键)) {
        集_错误_假大写(虚机针, "无效迭代器!")
    }

    // 返回该 值
    返_值大写(条目->值)
}

/**
 * 范围 类的原生方法
**/

// 返回 范围 实例对象的 来自 属性的值
// 该方法是脚本中调用 对象范围.来自 所执行的原生方法，该方法为实例方法
static 布尔 原语范围来自(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象范围大写 *对象范围 = 值到对象范围大写(实参们_[0]);
    返_数目大写(对象范围->来自)
}

// 返回 范围 实例对象的 到 属性的值
// 该方法是脚本中调用 对象范围.到 所执行的原生方法，该方法为实例方法
static 布尔 原语范围到(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象范围大写 *对象范围 = 值到对象范围大写(实参们_[0]);
    返_数目大写(对象范围->到)
}

// 返回 范围 实例对象的 来自 属性和 到 属性的中的较小值
// 该方法是脚本中调用 对象范围.min 所执行的原生方法，该方法为实例方法
static 布尔 原语范围最小(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象范围大写 *对象范围 = 值到对象范围大写(实参们_[0]);
    返_数目大写(fmin(对象范围->来自, 对象范围->到))
}

// 返回 范围 实例对象的 来自 属性和 到 属性的中的较大值
// 该方法是脚本中调用 对象范围.max 所执行的原生方法，该方法为实例方法
static 布尔 原语范围最大(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象范围大写 *对象范围 = 值到对象范围大写(实参们_[0]);
    返_数目大写(fmax(对象范围->来自, 对象范围->到))
}

// 迭代 范围 中的值
// 该方法是脚本中调用 对象范围.iterate(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语范围迭代的(虚拟机大写 *虚机针, 值大写 *实参们_) {
    对象范围大写 *对象范围 = 值到对象范围大写(实参们_[0]);

    // 若未提供 迭代 说明是第一次迭代，因此返回 范围->来自
    if (值是否空指针大写(实参们_[1])) {
        返_数目大写(对象范围->来自)
    }

    // 迭代器必须是数字
    if (!有效的数目(虚机针, 实参们_[1])) {
        return 假;
    }

    // 获得迭代器
    double 迭代 = 值到数目大写(实参们_[1]);

    // 若是正方向
    if (对象范围->来自 < 对象范围->到) {
        迭代++;
        if (迭代 > 对象范围->到) {
            返_假大写
        }
    } else {
        // 若是反向迭代
        迭代--;
        if (迭代 < 对象范围->到) {
            返_假大写
        }
    }

    返_数目大写(迭代)
}

// 范围 的迭代就是 范围 中从 来自 到 到 之间的值，因此直接返回迭代器就是range的值
// 该方法是脚本中调用 对象范围.iteratorValue(实参们_[1]) 所执行的原生方法，该方法为实例方法
static 布尔 原语范围迭代器值(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象范围大写 *对象范围 = 值到对象范围大写(实参们_[0]);
    double 值 = 值到数目大写(实参们_[1]);

    // 确保 实参们_[1] 在 来自 和 到 的范围中
    // 若是正方向
    if (对象范围->来自 < 对象范围->到) {
        if (值 >= 对象范围->来自 && 值 <= 对象范围->到) {
            返_值大写(实参们_[1])
        }
    } else {
        // 若是反向
        if (值 <= 对象范围->来自 && 值 >= 对象范围->到) {
            返_值大写(实参们_[1])
        }
    }
    返_假大写
}

/**
 * System 类的原生方法
**/

// 返回以秒为单位的系统时钟
// 该方法是脚本中调用 System.clock 所执行的原生方法，该方法为类方法
static 布尔 原语系统时钟(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_ 未使用大写) {
    返_数目大写((double)time(NULL))
}

// 启动 gc
// 该方法是脚本中调用 System.gc() 所执行的原生方法，该方法为类方法
static 布尔 原语系统垃圾回收(虚拟机大写 *虚机针, 值大写 *实参们_) {
    // startGC(虚机针);
    返_空指针大写
}

// 导入并编译模块（即将模块挂载到 虚机针->allModules）
// 该方法是脚本中调用 System.导入模块(实参们_[1]) 所执行的原生方法，该方法为类方法
static 布尔 原语系统导入模块(虚拟机大写 *虚机针, 值大写 *实参们_) {
    if (!有效的字符串(虚机针, 实参们_[1])) { //模块名为字符串
        return 假;
    }

    // 导入模块并编译（即将模块挂载到 虚机针->allModules）
    值大写 结果 = 导入模块(虚机针, 实参们_[1]);

    // 若模块已经导入（模块导入时 导入模块 返回 NULL），则返回 NULL
    if (值是否空指针大写(结果)) {
        返_空指针大写
    }

    // 若模块编译过程中出了问题，则返回 false，通知虚拟机切换线程
    if (!值是否空指针大写(虚机针->当前线程->错误对象)) {
        return 假;
    }

    // 调用本函数时，已经在主调方的运行时栈中压入了 System 和 模块名 两个 slot
    // 而只需要一个 slot 来存储返回值，所以回收一个 slot
    虚机针->当前线程->栈指针--;

    对象线程大写 *下一个线程 = 值到对象线程大写(结果);
    下一个线程->调用者 = 虚机针->当前线程;
    虚机针->当前线程 = 下一个线程;
    // 返回 false，虚拟机会切换到此新加载模块的线程 下一个线程
    return 假;
}

// 获取模块 实参们_[1] 中的模块变量 实参们_[2]
// 该方法是脚本中调用 System.获取模块变量(实参们_[1], 实参们_[2]) 所执行的原生方法，该方法为类方法
static 布尔 原语系统获取模块变量(虚拟机大写 *虚机针, 值大写 *实参们_) {
    if (!有效的字符串(虚机针, 实参们_[1])) {
        return 假;
    }

    if (!有效的字符串(虚机针, 实参们_[2])) {
        return 假;
    }

    值大写 结果 = 获取模块变量(虚机针, 实参们_[1], 实参们_[2]);
    if (值是否空指针大写(结果)) {
        // 如果出错，则返回 false，通知虚拟机切换线程
        return 假;
    }

    返_值大写(结果)
}

// 输出字符串
// 该方法是脚本中调用 System.writeString_(实参们_[1]) 所执行的原生方法，该方法为类方法
static 布尔 原语系统写字符串(虚拟机大写 *虚机针 未使用大写, 值大写 *实参们_) {
    对象字符串大写 *对象字符串 = 值到对象串大写(实参们_[1]);

    断言大写(对象字符串->值.起始[对象字符串->值.长度] == '\0', "字符串未终结!");

    打印字符串(对象字符串->值.起始);
    返_值大写(实参们_[1])
}

/**
 * 至此，原生方法定义部分结束
**/

// 执行名为 模块名 代码为 模块代码 的模块
虚拟机结果大写 执行模块(虚拟机大写 *虚机针, 值大写 模块名, const char *模块代码) {
    对象线程大写 *对象线程 = 载入模块(虚机针, 模块名, 模块代码);
    return 执行指令(虚机针, 对象线程);
}

// 在 表格 中查找符号 symbol，找到后返回索引，否则返回 -1
int 获取索引来自符号表(符号表大写 *表格, const char *符号, uint32_t 长度) {
    断言大写(长度 != 0, "符号的长度是0!");
    uint32_t 索引 = 0;
    // 遍历 表格->data，找到与 符号 相等的，然后返回该索引值
    while (索引 < 表格->计数) {
        if (长度 == 表格->数据们[索引].长度 && memcmp(表格->数据们[索引].串, 符号, 长度) == 0) {
            return 索引;
        }
        索引++;
    }
    // 找不到则返回 -1
    return -1;
}

// 向 表格 中添加符号 symbol，并返回 符号 对应在 表格 的索引
int 加上符号(虚拟机大写 *虚机针, 符号表大写 *表格, const char *符号, uint32_t 长度) {
    断言大写(长度 != 0, "符号的长度是0!");

    字符串大写 字符串;
    字符串.串 = 分配数组大写(虚机针, char, 长度 + 1); // 申请内存，加 1 是为了添加结尾符 \0
    memcpy(字符串.串, 符号, 长度);                // 将 符号 内容拷贝到 字符串.串 上
    字符串.串[长度] = '\0';
    字符串.长度 = 长度;
    字符串大写缓冲区添加大写(虚机针, 表格, 字符串); // 向 表格 中塞入 字符串
    return 表格->计数 - 1;
}

// 确保符号 符号 已经添加到符号表 表格 中，如果查找没有，则向其中添加
int 确保符号存在(虚拟机大写 *虚机针, 符号表大写 *表格, const char *符号, uint32_t 长度) {
    // 先从 表格 中查找 符号
    int 符号索引 = 获取索引来自符号表(表格, 符号, 长度);

    // 如果没找到·，则添加 符号 到 表格 中，然后返回其索引
    if (符号索引 == -1) {
        return 加上符号(虚机针, 表格, 符号, 长度);
    }
    // 如果找到，则返回其索引
    return 符号索引;
}

// 在 对象模块 模块中定义名为 名称 的类
static 类大写 *定义类(虚拟机大写 *虚机针, 对象模块大写 *对象模块, const char *名称) {
    // 创建类
    类大写 *类 = 新未加工类(虚机针, 名称, 0);
    // 将类作为普通变量在模块中定义
    定义模块变量(虚机针, 对象模块, 名称, strlen(名称), 对象到值大写(类));
    return 类;
}

// 绑定方法到指定类
// 将方法 方法 到类 类 的 方法们 数组中，位置为 索引
void 绑方法(虚拟机大写 *虚机针, 类大写 *类, uint32_t 索引, 方法大写 方法) {
    // 各类自己的 方法们 数组和 虚机针->全部方法名们 长度保持一致，进而 虚机针->全部方法名们 中的方法名和各个类的 方法们 数组对应方法体的索引值相等，
    // 这样就可以通过相同的索引获取到方法体或者方法名
    // 然而 虚机针->全部方法名们 只有一个，但会对应多个类，所以各个类的 方法们 数组中的方法体数量必然会小于 虚机针->全部方法名们 中的方法名数量
    // 为了保证一样长度，就需要将各个类的 方法们 数组中无用的索引处用空占位填充
    if (索引 >= 类->方法们.计数) {
        方法大写 空垫子 = {方法类型_没有, {0}};
        方法大写缓冲区填充写入大写(虚机针, &类->方法们, 空垫子, 索引 - 类->方法们.计数 + 1);
    }

    类->方法们.数据们[索引] = 方法;
}

// 绑定 超级类 为 子类 的基类
// 即继承基类的属性个数和方法（通过复制实现）
void 绑超级类(虚拟机大写 *虚机针, 类大写 *子类, 类大写 *超级类) {
    子类->超级类 = 超级类;

    // 继承基类的属性个数
    子类->字段数目了 += 超级类->字段数目了;

    // 继承基类的方法
    uint32_t 索引了 = 0;
    while (索引了 < 超级类->方法们.计数) {
        绑方法(虚机针, 子类, 索引了, 超级类->方法们.数据们[索引了]);
        索引了++;
    }
}

//绑定 函_.call 的重载，同样一个函数的 call 方法支持 0～16 个参数
static void 绑函过载调用(虚拟机大写 *虚机针, const char *签名了) {
    uint32_t 索引 = 确保符号存在(虚机针, &虚机针->全部方法名们, 签名了, strlen(签名了));
    //构造 方法
    方法大写 方法 = {方法类型_函调用, {0}};
    绑方法(虚机针, 虚机针->函类, 索引, 方法);
}

// 编译核心模块
void 建造核心(虚拟机大写 *虚机针) {
    // 创建核心模块
    // 核心模块不需要名字
    对象模块大写 *核心模块 = 新对象模块(虚机针, NULL);

    // 将核心模块 核心模块 收集到 虚机针->全部模块们 中
    // 虚机针->全部模块们 的 键 为 CORE_MODULE， 值 为 核心模块 的 值大写 结构
    映射集(虚机针, 虚机针->全部模块们, 核心_模块大写, 对象到值大写(核心模块));

    // 1. 创建 对象类 类，是所有类的基类，所有类都会直接或间接继承这个类
    虚机针->对象类 = 定义类(虚机针, 核心模块, "对象");
    // 绑定对象的原生方法到 对象类 类
    原语_方法_绑大写(虚机针->对象类, "!", 原语对象非)
    原语_方法_绑大写(虚机针->对象类, "==(_)", 原语对象相等)
    原语_方法_绑大写(虚机针->对象类, "!=(_)", 原语对象不相等)
    原语_方法_绑大写(虚机针->对象类, "是(_)", 原语对象是)
    原语_方法_绑大写(虚机针->对象类, "到字符串", 原语对象到字符串)
    原语_方法_绑大写(虚机针->对象类, "类型", 原语对象类型)

    // 2. 创建 类的类 类，是所有元信息类的基类和元信息类
    // 注：元信息类，用于描述普通类的信息的，主要保存类的方法，即静态方法
    虚机针->类的类 = 定义类(虚机针, 核心模块, "类");
    // 绑定类的原生方法到 类的类 类
    原语_方法_绑大写(虚机针->类的类, "名称", 原语类名)
    原语_方法_绑大写(虚机针->类的类, "超级类型", 原语类超级类型)
    原语_方法_绑大写(虚机针->类的类, "到字符串", 原语类到字符串)

    // 同时 类的类 类又继承了 对象类 类，所以 对象类 类是所有类的基类
    绑超级类(虚机针, 虚机针->类的类, 虚机针->对象类);

    // 3. 创建 对象类 类的元信息类，即 对象元类 类
    // 其无需挂在到 虚机针 上
    类大写 *对象元类 = 定义类(虚机针, 核心模块, "元对象");
    // 绑定元信息类的原生方法到 对象元类 类
    原语_方法_绑大写(对象元类, "相同(_,_)", 原语对象元相同)

    // 同时 对象元类 类也继承了 类的类 类，即 类的类 类是所有元信息类的基类和元信息类
    绑超级类(虚机针, 对象元类, 虚机针->类的类);

    // 4. 绑定各自的元信息类
    // 对象元类 类是 对象类 类的元信息类
    虚机针->对象类->对象头部.类指针 = 对象元类;
    // 类的类 类是 对象元类 类的元信息类（实际上是所有元信息类的元信息类）
    对象元类->对象头部.类指针 = 虚机针->类的类;
    // 类的类 类就是本身的元信息类，即元信息类的终点
    虚机针->类的类->对象头部.类指针 = 虚机针->类的类;

    //执行核心模块
    执行模块(虚机针, 核心_模块大写, 核心模块代码);

    /* Bool 类定义在 core.script.inc，将其挂载到 虚机针->boolClass，并绑定原生方法 */
    虚机针->布尔类 = 值到类大写(获取核心类值(核心模块, "布尔"));
    原语_方法_绑大写(虚机针->布尔类, "到字符串", 原语布尔到字符串)
    原语_方法_绑大写(虚机针->布尔类, "!", 原语布尔非)

    /* Thread 类定义在 core.script.inc，将其挂载到 虚机针->threadClass，并绑定原生方法 */
    虚机针->线程类 = 值到类大写(获取核心类值(核心模块, "线程"));
    // 以下是 Thread 类方法
    原语_方法_绑大写(虚机针->线程类->对象头部.类指针, "新(_)", 原语线程新)
    原语_方法_绑大写(虚机针->线程类->对象头部.类指针, "中止(_)", 原语线程中止)
    原语_方法_绑大写(虚机针->线程类->对象头部.类指针, "当前", 原语线程当前)
    原语_方法_绑大写(虚机针->线程类->对象头部.类指针, "挂起()", 原语线程挂起)
    原语_方法_绑大写(虚机针->线程类->对象头部.类指针, "屈服(_)", 原语线程屈服与实参一起)
    原语_方法_绑大写(虚机针->线程类->对象头部.类指针, "屈服()", 原语线程屈服不与实参一起)
    // 以下是 Thread 实例方法
    原语_方法_绑大写(虚机针->线程类, "调用()", 原语线程调用不与实参一起)
    原语_方法_绑大写(虚机针->线程类, "调用(_)", 原语线程调用与实参一起)
    原语_方法_绑大写(虚机针->线程类, "是否做完", 原语线程是完成)

    /* Fn 类定义在 core.script.inc，将其挂载到 虚机针->fnClass，并绑定原生方法 */
    虚机针->函类 = 值到类大写(获取核心类值(核心模块, "函大"));
    原语_方法_绑大写(虚机针->函类->对象头部.类指针, "新(_)", 原语函新)

    // 绑定 call 的重载方法
    绑函过载调用(虚机针, "调用()");
    绑函过载调用(虚机针, "调用(_)");
    绑函过载调用(虚机针, "调用(_,_)");
    绑函过载调用(虚机针, "调用(_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_,_,_,_,_,_,_,_)");
    绑函过载调用(虚机针, "调用(_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_)");

    /* Null 类定义在 core.script.inc，将其挂载到 虚机针->nullClass，并绑定原生方法 */
    虚机针->空指针类 = 值到类大写(获取核心类值(核心模块, "空指针大"));
    原语_方法_绑大写(虚机针->空指针类, "!", 原语空指针非)
    原语_方法_绑大写(虚机针->空指针类, "到字符串", 原语空指针到字符串)

    /* Num 类定义在 core.script.inc，将其挂载到 虚机针->numClass，并绑定原生方法 */
    虚机针->数目类 = 值到类大写(获取核心类值(核心模块, "数目"));
    // 以下是 Num 类方法
    原语_方法_绑大写(虚机针->数目类->对象头部.类指针, "来自字符串(_)", 原语数目来自字符串)
    原语_方法_绑大写(虚机针->数目类->对象头部.类指针, "圆周率", 原语数目派)
    // 以下是 Num 实例方法
    原语_方法_绑大写(虚机针->数目类, "+(_)", 原语数目加法)
    原语_方法_绑大写(虚机针->数目类, "-(_)", 原语数目减法)
    原语_方法_绑大写(虚机针->数目类, "*(_)", 原语数目乘法)
    原语_方法_绑大写(虚机针->数目类, "/(_)", 原语数目除法)
    原语_方法_绑大写(虚机针->数目类, ">(_)", 原语数目大于)
    原语_方法_绑大写(虚机针->数目类, ">=(_)", 原语数目大等)
    原语_方法_绑大写(虚机针->数目类, "<(_)", 原语数目小于)
    原语_方法_绑大写(虚机针->数目类, "<=(_)", 原语数目小等)
    原语_方法_绑大写(虚机针->数目类, "&(_)", 原语数目位与)
    原语_方法_绑大写(虚机针->数目类, "|(_)", 原语数目位或)
    原语_方法_绑大写(虚机针->数目类, ">>(_)", 原语数目位右移)
    原语_方法_绑大写(虚机针->数目类, "<<(_)", 原语数目位左移)
    原语_方法_绑大写(虚机针->数目类, "绝对值", 原语数目绝对值)
    原语_方法_绑大写(虚机针->数目类, "反余弦", 原语数目反余弦)
    原语_方法_绑大写(虚机针->数目类, "反正弦", 原语数目反正弦)
    原语_方法_绑大写(虚机针->数目类, "反正切", 原语数目反正切)
    原语_方法_绑大写(虚机针->数目类, "天花板", 原语数目天花板)
    原语_方法_绑大写(虚机针->数目类, "余弦", 原语数目余弦)
    原语_方法_绑大写(虚机针->数目类, "地板", 原语数目地板)
    原语_方法_绑大写(虚机针->数目类, "-", 原语数目否定)
    原语_方法_绑大写(虚机针->数目类, "正弦", 原语数目正弦)
    原语_方法_绑大写(虚机针->数目类, "平方", 原语数目平方)
    原语_方法_绑大写(虚机针->数目类, "正切", 原语数目正切)
    原语_方法_绑大写(虚机针->数目类, "%(_)", 原语数目取模)
    原语_方法_绑大写(虚机针->数目类, "~", 原语数目位非)
    原语_方法_绑大写(虚机针->数目类, "..(_)", 原语数目范围)
    原语_方法_绑大写(虚机针->数目类, "截断", 原语数目截断)
    原语_方法_绑大写(虚机针->数目类, "分数", 原语数目分数)
    原语_方法_绑大写(虚机针->数目类, "是否无限", 原语数目是否无限)
    原语_方法_绑大写(虚机针->数目类, "是否整数", 原语数目是否整数)
    原语_方法_绑大写(虚机针->数目类, "是否非数字", 原语数目是否非数字)
    原语_方法_绑大写(虚机针->数目类, "到字符串", 原语数目到字符串)
    原语_方法_绑大写(虚机针->数目类, "==(_)", 原语数目相等)
    原语_方法_绑大写(虚机针->数目类, "!=(_)", 原语数目不等)

    /* 字符串大写 类定义在 core.script.inc，将其挂载到 虚机针->stringClass，并绑定原生方法 */
    虚机针->字符串类 = 值到类大写(获取核心类值(核心模块, "字符串"));
    // 以下是 字符串大写 类方法
    原语_方法_绑大写(虚机针->字符串类->对象头部.类指针, "来自代码点(_)", 原语字符串来自代码点)
    // 以下是 字符串大写 实例方法
    原语_方法_绑大写(虚机针->字符串类, "+(_)", 原语字符串加法)
    原语_方法_绑大写(虚机针->字符串类, "[_]", 原语字符串子脚本)
    原语_方法_绑大写(虚机针->字符串类, "字节在(_)", 原语字符串字节在)
    原语_方法_绑大写(虚机针->字符串类, "字节计数_", 原语字符串字节计数)
    原语_方法_绑大写(虚机针->字符串类, "代码点在_(_)", 原语字符串代码点在)
    原语_方法_绑大写(虚机针->字符串类, "内容(_)", 原语字符串内容)
    原语_方法_绑大写(虚机针->字符串类, "求索引(_)", 原语字符串索引的)
    原语_方法_绑大写(虚机针->字符串类, "始于(_)", 原语字符串与起始一起)
    原语_方法_绑大写(虚机针->字符串类, "终于(_)", 原语字符串与终一起)
    原语_方法_绑大写(虚机针->字符串类, "到字符串", 原语字符串到字符串)
    原语_方法_绑大写(虚机针->字符串类, "计数", 原语字符串字节计数)
    原语_方法_绑大写(虚机针->字符串类, "迭代的(_)", 原语字符串迭代的)
    原语_方法_绑大写(虚机针->字符串类, "迭代的字节(_)", 原语字符串迭代的字节)
    原语_方法_绑大写(虚机针->字符串类, "迭代器值(_)", 原语字符串迭代器值)

    /* List 类定义在 core.script.inc，将其挂载到 虚机针->listClass，并绑定原生方法 */
    虚机针->列表类 = 值到类大写(获取核心类值(核心模块, "列表"));
    // 以下是 List 类方法
    原语_方法_绑大写(虚机针->列表类->对象头部.类指针, "新()", 原语列表新)
    // 以下是 List 实例方法
    原语_方法_绑大写(虚机针->列表类, "[_]", 原语列表子脚本)
    原语_方法_绑大写(虚机针->列表类, "[_]=(_)", 原语列表子脚本设置器)
    原语_方法_绑大写(虚机针->列表类, "加上(_)", 原语列表加上)
    原语_方法_绑大写(虚机针->列表类, "加上核_(_)", 原语列表加上核心)
    原语_方法_绑大写(虚机针->列表类, "插入(_,_)", 原语列表插入)
    原语_方法_绑大写(虚机针->列表类, "移除在(_)", 原语列表移除在)
    原语_方法_绑大写(虚机针->列表类, "清除()", 原语列表清除)
    原语_方法_绑大写(虚机针->列表类, "计数", 原语列表计数)
    原语_方法_绑大写(虚机针->列表类, "迭代的(_)", 原语列表迭代的)
    原语_方法_绑大写(虚机针->列表类, "迭代器值(_)", 原语列表迭代器值)

    /* Map 类定义在 core.script.inc，将其挂载到 虚机针->mapClass，并绑定原生方法 */
    虚机针->映射类 = 值到类大写(获取核心类值(核心模块, "映射"));
    // 以下是 Map 类方法
    原语_方法_绑大写(虚机针->映射类->对象头部.类指针, "新()", 原语映射新)
    // 以下是 Map 实例方法
    原语_方法_绑大写(虚机针->映射类, "[_]", 原语映射子脚本)
    原语_方法_绑大写(虚机针->映射类, "[_]=(_)", 原语映射子脚本设置器)
    原语_方法_绑大写(虚机针->映射类, "加上核_(_,_)", 原语映射加上核心)
    原语_方法_绑大写(虚机针->映射类, "移除(_)", 原语映射移除)
    原语_方法_绑大写(虚机针->映射类, "清除()", 原语映射清除)
    原语_方法_绑大写(虚机针->映射类, "内容键(_)", 原语映射内容键)
    原语_方法_绑大写(虚机针->映射类, "计数", 原语映射计数)
    原语_方法_绑大写(虚机针->映射类, "迭代的_(_)", 原语映射迭代的)
    原语_方法_绑大写(虚机针->映射类, "键迭代器值_(_)", 原语映射键迭代器值)
    原语_方法_绑大写(虚机针->映射类, "值迭代器值_(_)", 原语映射值迭代器值)

    /* 范围 类定义在 core.script.inc，将其挂载到 虚机针->rangeClass，并绑定原生方法 */
    虚机针->范围类 = 值到类大写(获取核心类值(核心模块, "范围"));
    // 以下是 范围 实例方法
    原语_方法_绑大写(虚机针->范围类, "来自", 原语范围来自)
    原语_方法_绑大写(虚机针->范围类, "到", 原语范围到)
    原语_方法_绑大写(虚机针->范围类, "最小", 原语范围最小)
    原语_方法_绑大写(虚机针->范围类, "最大", 原语范围最大)
    原语_方法_绑大写(虚机针->范围类, "迭代的(_)", 原语范围迭代的)
    原语_方法_绑大写(虚机针->范围类, "迭代器值(_)", 原语范围迭代器值)

    /* System 类定义在 core.script.inc，将其挂载到 虚机针->systemClass，并绑定原生方法 */
    类大写 *系统类 = 值到类大写(获取核心类值(核心模块, "系统"));
    // 以下是 System 类方法
    原语_方法_绑大写(系统类->对象头部.类指针, "时钟", 原语系统时钟)
    原语_方法_绑大写(系统类->对象头部.类指针, "垃圾回收()", 原语系统垃圾回收)
    原语_方法_绑大写(系统类->对象头部.类指针, "导入模块(_)", 原语系统导入模块)
    原语_方法_绑大写(系统类->对象头部.类指针, "获取模块变量(_,_)", 原语系统获取模块变量)
    原语_方法_绑大写(系统类->对象头部.类指针, "写字符串_(_)", 原语系统写字符串)

    // 在核心自举过程中创建了很多 对象字符串大写 对象，创建过程中需要调用 初始对象头部 初始化对象头，
    // 使其 class 指向 虚机针->stringClass，但那时的 虚机针->字符串类 尚未初始化，因此现在更正。

    // 例如 建造核心 函数中在 虚机针->字符串类 赋值之前执行的 载入模块 函数
    // 载入模块 里调用的链路：loadModule -> 编译模块 -> compileProgram -> compileClassDefinition -> 新对象字符串 -> 初始对象头部
    // 其中 初始对象头部 函数中会将类头中的 class 成员指向 虚机针->stringClass，但那时的 虚机针->字符串类 尚未赋值
    对象头部大写 *对象头部 = 虚机针->全部对象们;
    while (对象头部 != NULL) {
        if (对象头部->类型 == 对类_字符串大写) {
            对象头部->类指针 = 虚机针->字符串类;
        }
        对象头部 = 对象头部->下一个;
    }
}