## 汉化一个脚本语言

看起来像是国内开发者写的,因为注释用了中文.  

我取了音译, 叫底头.  

这次汉化是失败的, 因为原项目可以编译通过, 但我汉化后不行.  
大概率是汉化后的标识符对不上, 汉化标识符并不是简单的替换,   
还要根据C语言的语法做相应适配, 除此之外,   
还有C语言的库函数是否兼容, 并不是每个库函数或库变量库常量都做了Unicode优化的.  

## 版权与许可证

因为失败了, 就不做过多赘述,  
许可证跟随原作者的.  

## 总结

这次的完成度挺高, 若是没有面向对象部分, 或许就成功了,  
主要是面向对象部分的源码相对复杂, 我也理解不了, 所以汉化的时候,   
我也不知道哪个标识符在C语言炫技的语法部分到底是怎么用来写面向对象部分的.  
可以推理出百分百是标识符没用对, 一个萝卜一个坑, 肯定是哪里没对上.  

不过倒是学到了很多, 结合这里的源码,再问大模型, 我才知道函数指针竟然可以在结构体里当类型用.  
词法分析原来可以写得如此简洁, 我一直以为很难. 主要是若加上Unicode支持, 我不知道该如何写,  
再加上又没有支持Unicode的词法分析源码可供参考.  

也是在这个过程中, 我学到了C的精髓, 其实是用结构体联合体做数据抽象, 就是SICP里的数据抽象,  
这才是C应该做的事, 我认为C语言发展了这么多年, 把精力用在指针上, 完全就是走偏, 奇技淫巧.  

也学到了一个简单的虚拟机该怎么写.  
不过这里的虚拟机有炫技的成分, 我是认为简单角度出发没必要这样写.  

还领悟到的就是, 不管啥项目, 哈希表几乎都是必须要实现的, 若要存储键值对类型的数据.  
还有个就是, 若是要加上对中文汉字编程的支持, 几乎必须要处理Unicode相关.  
现在都流行用utf8, Unicode代码点到utf8字节序列之间的转换, 还要写函数找长度, 找字节序.  
其实UTF16BE是最适合存储中文汉字字符的, 0到FFFF之间的Unicode, 完全够用了,  
UTF16BE字节序列的字节序与Unicode是同步的, 也只需要2字节16位二进制即可存储.  
但现在都用utf8, 这没办法, 生态已经僵化, utf8几乎必须要3字节24位二进制才行,  

读了TAOCP, 知道了6位计算机就可以写算法, 2的6次方, 64个状态, 就可以描述可计算范围内的算法.  
读了SICP, 发现7个指令就能构造一个基本的计算模型. 不过是学术级的, 工业级可以在此基础上追加更多指令.  
这时候你就体会到用UTF8编码存储汉字是多么的浪费...  
所以要做中文汉字编程的中文汉字计算机, 断然是不能基于现在的拉丁字母编程生态的,  
要从零打造, 一个人实在太难.  
老实说, 我们的六十四卦也是64个状态, 为啥我们就没造出易经朋克计算机呢.  

还有个问题是, 就是汉化过程.   
因为英文词汇或拉丁字母里有大小写区别, 复数, 还有缩写,   
比如MEM mem mems,或VM vm, 汉字都是一个意思, 但变成代码, 编译器就会认为是三个意思.   
这些都可以成为一个单独牌token, 但汉字就没有这种,   
所以汉化的时候就得加上单位, 以示区别.   
由此汉字代码就带来了准确易读的特点.  
