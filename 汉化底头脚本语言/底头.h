//说明: 只要含有大写字母的,一律在标识符后面跟上'大写'字样的单位说明,阅读时忽略即可.
//  短写, 不拼写完整的, 一律在后面加'了'字样.
//  缩写的就缩写式直译.
//  其它的小写词汇就是原意直译.


//*****************公共**************
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// 定义了 VM Lexer Class 的完整实现
typedef struct 虚拟机 虚拟机大写;
typedef struct 词法器 词法器大写;
typedef struct 类 类大写;

// 定义部分数据结构
#define 布尔 unsigned char
#define 真 1
#define 假 0

// 如果函数中一部分形参并未使用，编译时会发出警告
// 下面的定义就使用 gcc 内部属性 __attribute__ ((unused)) 告诉 gcc 不要报警
#define 未使用大写 __attribute__((unused))

// 为方便系统调试，就需要断言 ASSERT
// 如果宏 DEBUG 定义了，表明在调试阶段，才会定义 ASSERT
// 因此我们可以在 makefile 中编译的时候来定义宏 DEBUG，不需要的时候则去掉宏 DEBUG
// 相当于一个开关控制是否需要断言 ASSERT
#ifdef 调试大写
#define 断言大写(条件, 错消息)                                          \
    do {                                                                \
        if (!(条件)) {                                                   \
            fprintf(stderr, "断言失败! %s:%d 在函数 %s() 内: %s\n",       \
                    __FILE__, __LINE__, __func__, 错消息);                 \
            abort();                                                       \
        }                                                                  \
    } while (0);
#else
#define 断言大写(条件, 错消息) ((void)0)
#endif

// 宏 Not_REACHED() 表示 “不可能到达”
// 用于一些程序中不能被执行到的地方，说明程序出错了
#define 不可达大写()                                            \
    do {                                                         \
        fprintf(stderr, "不可达: %s:%d 在函数 %s() 内\n", \
                __FILE__, __LINE__, __func__);                   \
        while (1)                                                \
            ;                                                    \
    } while (0);



//************************Unicode到utf8字节序列*************
// 计算已经 UTF-8 编码的字符的 UTF-8 编码字节数，其中参数 byte 是 UTF-8 编码的高字节
uint32_t 获取编码UTF8的字节数(uint8_t 字节);

// 计算没有 UTF-8 编码的字符的 UTF-8 编码字节数
uint32_t 获取解码UTF8的字节数(int 值);

// 将 值 编码成 UTF-8 后，写入缓冲区 buf，并返回写入的字节数
uint8_t 编码UTF8(uint8_t *缓冲区, int 值);

// 将 UTF-8 编码的字符序列解码成 值
int 解码UTF8(const uint8_t *字节指针, uint32_t 长度);

//**************************实用工具*****************************

//  第一部分：内存分配

// 定义内存管理函数 memManager 原型
void *内存管理器(虚拟机大写 *虚机针, void *指针, uint32_t 旧大小, uint32_t 新大小);

// 给类型为 类型 的数据申请内存
#define 分配大写(虚拟机指针, 类型) \
    (类型 *)内存管理器(虚拟机指针, NULL, 0, sizeof(类型))

// 针对柔性数组，除了为主类型 mainType 申请内存外，再额外申请 extraSize 大小的内存
#define 分配额外大写(虚拟机指针, 主类型, 额外大小) \
    (主类型 *)内存管理器(虚拟机指针, NULL, 0, sizeof(主类型) + 额外大小)

// 为数组申请内存
#define 分配数组大写(虚拟机指针, 类型, 计数) \
    (类型 *)内存管理器(虚拟机指针, NULL, 0, sizeof(类型) * 计数)

// 释放数组占用的内存
#define 反分配数组大写(虚拟机指针, 数组指针, 计数) \
   内存管理器(虚拟机指针, 数组指针, sizeof(数组指针[0]) * 计数, 0)

// 释放内存
#define 反分配大写(虚拟机指针, 内存指针) \
    内存管理器(虚拟机指针, 内存指针, 0, 0)

// 第二部分：查找满足条件数的方法

// 定义找出大于等于 v 的最小的 2 次幂的函数 ceilToPowerOf2 原型
uint32_t 向上取最接近的2次幂(uint32_t 值也);

// 第三部分：数据缓冲区
// 基于四个类型：Int/Char/Byte/String 宏定义了四种数据缓冲区，用来存储这四种数据类型的数据
// 例如 ByteBuffer 结构如下，其中 datas 数组主要就是存储 byte 类型的数据，
// count 表示 datas 数组中实际存储的 byte 类型的数据，capacity 表示 datas 数组最多可存储  byte 类型的数据的最大容量：
// typedef struct
// {
//     byte *datas;
//     uint32_t count;
//     uint32_t capacity;
// } ByteBuffer;

typedef struct
{
    char *串;
    uint32_t 长度;
} 字符串大写;

typedef struct
{
    uint32_t 长度;
    char 起始[0];
} 字符值大写;

#define 声明缓冲区类型大写(类型)                                                         \
    typedef struct                                                                \
    {                                                                             \
        类型 *数据们;                                                               \
        uint32_t 计数;                                                            \
        uint32_t 容量;                                                            \
    } 类型##缓冲区大写;                                                                \
     void 类型##缓冲区初始化大写(类型##缓冲区大写 *缓冲);                                    \
     void 类型##缓冲区填充写入大写(虚拟机大写 *虚机针,                                             \
                                 类型##缓冲区大写 *缓冲, 类型 数据, uint32_t 填充计数); \
     void 类型##缓冲区添加大写(虚拟机大写 *虚机针, 类型##缓冲区大写 *缓冲, 类型 数据);                   \
     void 类型##缓冲区清除大写(虚拟机大写 *虚机针, 类型##缓冲区大写 *缓冲);


#define 定义缓冲区方法大写(类型)                                                           \
    void 类型##缓冲区初始化大写(类型##缓冲区大写 *缓冲) {                                      \
        缓冲->数据们 = NULL;                                                            \
        缓冲->计数 = 缓冲->容量 = 0;                                                   \
    }                                                                                  \
    void 类型##缓冲区填充写入大写(虚拟机大写 *虚机针, 类型##缓冲区大写 *缓冲, 类型 数据, uint32_t 填充计数) { \
        uint32_t 新计数们 = 缓冲->计数 + 填充计数;                                         \
        if (新计数们 > 缓冲->容量) {                                                      \
            size_t 旧大小 = 缓冲->容量 * sizeof(类型);                                   \
            缓冲->容量 = 向上取最接近的2次幂(新计数们);                                         \
            size_t 新大小 = 缓冲->容量 * sizeof(类型);                                   \
            断言大写(新大小 > 旧大小, "昏厥了的...内存分配!");                      \
            缓冲->数据们 = (类型 *)内存管理器(虚机针, 缓冲->数据们, 旧大小, 新大小);              \
        }                                                                              \
        uint32_t 计的数 = 0;                                                             \
        while (计的数 < 填充计数) {                                                       \
            缓冲->数据们[缓冲->计数++] = 数据;                                              \
            计的数++;                                                                    \
        }                                                                              \
    }                                                                                  \
    void 类型##缓冲区添加大写(虚拟机大写 *虚机针, 类型##缓冲区大写 *缓冲, 类型 数据) {                     \
        类型##缓冲区填充写入大写(虚机针, 缓冲, 数据, 1);                                        \
    }                                                                                  \
    void 类型##缓冲区清除大写(虚拟机大写 *虚机针, 类型##缓冲区大写 *缓冲) {                                \
        size_t 旧大小 = 缓冲->容量 * sizeof(缓冲->数据们[0]);                               \
        内存管理器(虚机针, 缓冲->数据们, 旧大小, 0);                                          \
        类型##缓冲区初始化大写(缓冲);                                                       \
    }

#define 符号表大写 字符串大写缓冲区大写
typedef uint8_t 字节大写;
typedef char 字符大写;
typedef int 整型大写;
声明缓冲区类型大写(整型大写)
声明缓冲区类型大写(字符大写)
声明缓冲区类型大写(字节大写)
声明缓冲区类型大写(字符串大写)

void 符号表清除(虚拟机大写 *虚机针, 符号表大写 *缓冲区);

// 第四部分：通用报错函数

// 定义全部的错误类型
typedef enum {
    错误_入出大写,
    错误_内存大写,
    错误_词法大写,
    错误_编译大写,
    错误_运行时大写,
} 错误类型大写;

// 定义通用报错函数的原型
void 错误报告(void *词法器, 错误类型大写 错误类型, const char *格式, ...);

// 宏定义不同类型错误的报错
#define 入出_错误大写(...) \
    错误报告(NULL, 错误_入出大写, __VA_ARGS__)

#define 内存_错误大写(...) \
    错误报告(NULL, 错误_内存大写, __VA_ARGS__)

#define 词法_错误大写(词法器, ...) \
    错误报告(词法器, 错误_词法大写, __VA_ARGS__)

#define 编译_错误大写(词法器, ...) \
    错误报告(词法器, 错误_编译大写, __VA_ARGS__)

#define 跑_错误大写(...) \
    错误报告(NULL, 错误_运行时大写, __VA_ARGS__)

#define 默认_缓冲区_大小 512

//******************对象文件夹*************************


//*********************头部的对象****************
typedef enum {
    对类_类大写,    // 类
    对类_列表大写,     // 列表
    对类_映射大写,      // 散列数组
    对类_模块大写,   // 模块作用域
    对类_范围大写,    // 步进为 1 的数字范围
    对类_字符串大写,   // 字符串
    对类_上值大写,  // 自由变量，闭包中的概念
    对类_函数大写, // 函数
    对类_闭包大写,  // 闭包
    对类_实例大写, // 对象实例
    对类_线程大写    // 线程
} 对象类型大写;

// 对象头，用于记录元信息和垃圾回收
typedef struct 对象头部 {
    对象类型大写 类型;           // 对象类型
    布尔 是否访问;          // 对象是否可达，用于垃圾回收
    类大写 *类指针;           // 指向对象所属的类
    struct 对象头部 *下一个; // 指向下一个创建的对象，用于垃圾回收
} 对象头部大写;

// 值类型
typedef enum {
    值型_未定义大写, // 未定义
    值型_空指针大写,      // 空
    值型_假大写,     // 布尔假
    值型_真大写,      // 布尔真
    值型_数目了大写,       // 数字
    值型_对象大写        // 对象
} 值类型大写;

// 通用的值结构
// 可以表示所有类型的值
typedef struct {
    // union 中的值由 type 的值决定
    值类型大写 类型; // 值类型
    union {
        double 数目了;
        对象头部大写 *对象头部;
    };
} 值大写;

// TODO: 待后续解释
声明缓冲区类型大写(值大写)

// 初始化对象头
void 初始对象头部(虚拟机大写 *虚机针, 对象头部大写 *对象头部, 对象类型大写 对象类型, 类大写 *类指针);


//**************************对象字符串***********************
// 定义字符串对象结构
typedef struct {
    对象头部大写 对象头部; // 对象头
    uint32_t 哈希代码;   // 由字符串值计算的哈希值
    字符值大写 值;     // 字符串值
} 对象字符串大写;

// 将字符串值根据 fnv-1a 算法转成对应哈希值
uint32_t 哈希字符串(const char *串, uint32_t 长度);

// 根据字符串对象中的值设置对应的哈希值
void 哈希对象字符串(对象字符串大写 *对象字符串);

// 新建字符串对象
对象字符串大写 *新对象字符串(虚拟机大写 *虚机针, const char *串, uint32_t 长度);

//****************元对象***************
// 定义模块对象结构
typedef struct {
    对象头部大写 对象头部;
    符号表大写 模块变量名;  // 模块中定义的全局变量名
    值大写缓冲区大写 模块变量值; // 模块中定义的全局变量值
    对象字符串大写 *名称; // 模块名称
} 对象模块大写;

// 定义实例对象结构
typedef struct {
    对象头部大写 对象头部;
    // 同一个类的不同实例对象，不同点主要在于对象之间可以有不同的属性值，
    // 而属性个数、属性名以及方法，都是相同的，所以这些都放在类的结构中，
    // 这里只需要用数组 fields 记录实例对象的属性值即可
    值大写 字段们[0];
} 对象实例大写;

// 新建模块对象
对象模块大写 *新对象模块(虚拟机大写 *虚机针, const char *模块名);

// 新建实例对象
对象实例大写 *新对象实例(虚拟机大写 *虚机针, 类大写 *类指针);

//*********************对象函*****************
// 前置知识

// 闭包
// upvalue 是指内部函数所引用的位于外层函数中的局部变量
// open upvalue 是指当外层函数仍在运行时栈，内部函数仍可以通过运行时栈访问的局部变量
// close upvalue 是指当外层函数已经执行完，在运行时栈中被收回，
// 闭包机制会将该变量从栈复制到一个安全且只有该内部函数可以访问的地方
//（在这里的实现，安全的地方是 ObjUpvalue 结构体中的 closed Upvalue 变量）

// 指令流单元
// 独立的指令集合单元成为指令流单元，例如模块就是最大的指令流单元，函数、类中的每个方法、代码块、闭包都是指令流单元
// 只要是指令流单元就可以用 ObjFn 表示，因此 ObjFn 泛指一切指令流单元

// 定义函数中的调试的结构体
typedef struct {
    char *函名;
    整型大写缓冲区大写 行号;
} 函调试大写;

// 定义自由变量 upvalue 对象的结构体
typedef struct 上值 {
    对象头部大写 对象头部;
    // 该指针用于指向对应的自由变量 upvalue，以供内部函数访问
    值大写 *本地变量指针;
    // 当外部函数执行完后，在运行时栈被释放，对应的自由变量 upvalue 也就不存在了
    // 此时会有如下操作：
    // 1. 对应的 upvalue 会从栈中被拷复制到 closedValue 中
    // 2. 然后指针 localVarPtr 指向 closedUpvalue
    // 这样的话引用 ObjUpvalue 的内部函数，仍可以通过 localVarPtr 访问到自由变量
    值大写 已关闭上值;
    // 指向下一个 upvalue，从而形成 upvalue 链表
    struct 上值 *下一个;  //上值就是上面的值.
} 对象上值大写;

// 定义函数对象的结构体
typedef struct {
    对象头部大写 对象头部;
    // 用于存储函数编译后的指令流
    字节大写缓冲区大写 指令流;
    // 常量表，用于储存指令流单元中的常量
    // 实际上函数并没有常量，所以这里存储的是其他指令流单元的常量
    // 例如模块中定义的全局变量、类的类名等
    值大写缓冲区大写 常量们;
    // 函数（包括类中的方法）所属的模块
    对象模块大写 *模块;
    // 函数在运行时栈中所需的最大空间，这是在编译期间计算的
    uint32_t 最大栈槽已用数目;
    // 函数所引用的自由变量 upvalue 的数量
    uint32_t 上值数目;
    // 函数参数的个数
    uint8_t 实参数目;

#if 调试大写
    // 只有在 debug 模式下才添加
    函调试大写 *调试;
#endif
} 对象函大写;

// 定义闭包对象的结构体
// 闭包：引用自由变量的内部函数 + 引用的自由变量集合
typedef struct {
    对象头部大写 对象头部;
    // 引用自由变量的内部函数
    对象函大写 *函;
    // 引用的自由变量集合
    对象上值大写 *上值们[0];
} 对象闭包大写;

// 定义函数调用帧栈的结构体
typedef struct {
    // 程序计算器 PC，存储的是下一条指令的地址
    uint8_t *指令指针;
    // 待运行的闭包（函数引用了自由变量 upvalue 就变成了闭包）
    对象闭包大写 *闭包;
    // 函数运行时栈的起始地址
    值大写 *栈起始;
} 帧大写;

// 线程中初始化的函数调用帧栈数量
#define 初始化帧数目大写 4

// 新建自由变量对象
对象上值大写 *新对象上值(虚拟机大写 *虚机针, 值大写 *本地变量指针);

// 新建闭包对象
对象闭包大写 *新对象闭包(虚拟机大写 *虚机针, 对象函大写 *对象函);

// 新建函数对象
对象函大写 *新对象函(虚拟机大写 *虚机针, 对象模块大写 *对象模块, uint32_t 最大栈槽已用数目);

//***********************对象列表***********
// 定义 list 对象结构
typedef struct {
    对象头部大写 对象头部;  // 对象头
    值大写缓冲区大写 元素们; // 用于存储 list 中的元素
} 对象列表大写;

// 新建 list 对象
对象列表大写 *新对象列表(虚拟机大写 *虚机针, uint32_t 元素数目);

// 向 objList 中索引为 index 处插入 value，相当于 objList[index] = value
void 插入元素(虚拟机大写 *虚机针, 对象列表大写 *对象列表, uint32_t 索引, 值大写 值);

// 删除 objList 中索引为 index 处的元素，即删除 objList[index]
值大写 移除元素(虚拟机大写 *虚机针, 对象列表大写 *对象列表, uint32_t 索引);

//***********************对象映射********************
// map 对象装载率，即容量利用率，即 map 对象中 Entry 的实际数量占 map 对象中  Entry 的容量 的百分比
#define 映射载入百分比大写 0.8

typedef struct {
    值大写 键;
    值大写 值;
} 条目大写; // 键值对

// 定义 map 对象结构
typedef struct
{
    对象头部大写 对象头部;
    uint32_t 容量; // map 对象中  Entry 的容量（即最多容纳的 Entry 的数量）
    uint32_t 计数;    // map 对象中 Entry 的实际数量
    条目大写 *条目们;    // Entry 数组
} 对象映射大写;

// 新建 map 对象
对象映射大写 *新对象映射(虚拟机大写 *虚机针);

// 向 map 对象的键值为 key 的地方设置值 value
void 映射集(虚拟机大写 *虚机针, 对象映射大写 *对象映射, 值大写 键, 值大写 值);

// 获取 map 对象的键值为 key 的地方的值
值大写 映射获取(对象映射大写 *对象映射, 值大写 键);

// 删除 map 对象的键值为 key 的地方的值
值大写 移除键(虚拟机大写 *虚机针, 对象映射大写 *对象映射, 值大写 键);

// 删除 map 对象
void 清除映射(虚拟机大写 *虚机针, 对象映射大写 *对象映射);

//***************************对象范围*********************
// 定义 range 对象结构
typedef struct {
    对象头部大写 对象头部;
    int 来自; // 范围的起始
    int 到;   // 范围的结束
} 对象范围大写;

// 新建 range 对象
对象范围大写 *新对象范围(虚拟机大写 *虚机针, int 来自, int 到);




//************************对象线程***************
// 定义线程对象结构
typedef struct 对象线程 {
    对象头部大写 对象头部;

    值大写 *栈;           // 函数运行时栈的栈底
    值大写 *栈指针;             // 函数运行时栈的栈顶
    uint32_t 栈容量; // 函数运行时栈的容量

    帧大写 *帧们;          // 函数调用帧栈数组
    uint32_t 已用帧数目;  // 已使用的 frame 的数量，从 0 开始计数
    uint32_t 帧容量; // 函数调用帧栈（frame）数组的容量

    对象上值大写 *打开上值们; // TODO: 暂时未搞懂，后面填坑

    struct 对象线程 *调用者; // 当前线程（thread）对象的调用者，若当前线程退出，则将控制权交回调用者（调用者本身也是一个线程对象）

    值大写 错误对象; // 导致运行时错误的对象会放在这里，否则为空
} 对象线程大写;

//这里有很多翻译其实在中文汉字里有更优的命名,但为了逻辑连贯,我直译了作者的英语用词

// 为线程 objThread 中运行的闭包函数 objClosure 准备运行时栈
void 预备帧(对象线程大写 *对象线程, 对象闭包大写 *对象闭包, 值大写 *栈起始);

// 重置线程对象，即为闭包 objClosure 中的函数初始化运行时栈
void 重置线程(对象线程大写 *对象线程, 对象闭包大写 *对象闭包);

// 新建线程对象，线程中运行的是闭包 objClosure 中的函数
对象线程大写 *新对象线程(虚拟机大写 *虚机针, 对象闭包大写 *对象闭包);


//********************对象的类**********************
// 方法类型
typedef enum {
    方法类型_没有,        // 空方法
    方法类型_原语,      // 用 C 实现的原生方法
    方法类型_脚本,      // 脚本语言中实现的方法
    方法类型_函调用    // 关于函数对象的调用方法，用于实现函数重载，如 fun1.call()
} 方法类型大写;

/** 值结构转换 **/

// 将类型为 vt 的值转成 Value 结构
#define 值型到值大写(值型了) \
    ((值大写){值型了, {0}}) // 强制类型转换成 Value

// 将 Bool 结构转成 Value 结构
#define 布尔到值大写(布尔者) \
    (布尔者 ? 值型到值大写(值型_真大写) : 值型到值大写(值型_假大写))

// 将 Value 结构转成  Bool 结构
#define 值到布尔大写(值) \
    (值.类型 == 值型_真大写 ? 真 : 假)

// 将 Number 结构转成 Value 结构
#define 数目到值大写(数目了) \
    ((值大写){值型_数目了大写, {数目了}})

// 将 Value结构转成 Number 结构
#define 值到数目大写(值) \
    (值.数目了)

// 将 Object 结构转成 Value 结构
#define 对象到值大写(对象指针) ({              \
    值大写 值了;                             \
    值了.类型 = 值型_对象大写;                     \
    值了.对象头部 = (对象头部大写 *)(对象指针); \
    值了;                                   \
})

// 将 Value 结构转成 Object 结构
#define 值到对象大写(值) \
    (值.对象头部)

// 将 Value 结构转成 String 结构
#define 值到对象串大写(值) \
    ((对象字符串大写 *)值到对象大写(值))

// 将 Value 结构转成 Function 结构
#define 值到对象函大写(值) \
    ((对象函大写 *)值到对象大写(值))

// 将 Value 结构转成 Range 结构
#define 值到对象范围大写(值) \
    ((对象范围大写 *)值到对象大写(值))

// 将 Value 结构转成 Instance 结构
#define 值到对象实例大写(值) \
    ((对象实例大写 *)值到对象大写(值))

// 将 Value 结构转成 List 结构
#define 值到对象列表大写(值) \
    ((对象列表大写 *)值到对象大写(值))

// 将 Value 结构转成 Map 结构
#define 值到对象映射大写(值) \
    ((对象映射大写 *)值到对象大写(值))

// 将 Value 结构转成 Closure 结构
#define 值到对象闭包大写(值) \
    ((对象闭包大写 *)值到对象大写(值))

// 将 Value 结构转成 Thread 结构
#define 值到对象线程大写(值) \
    ((对象线程大写 *)值到对象大写(值))

// 将 Value 结构转成 Module 结构
#define 值到对象模块大写(值) \
    ((对象模块大写 *)值到对象大写(值))

// 将 Value 结构转成 Class 结构
#define 值到类大写(值) \
    ((类大写 *)值到对象大写(值))

/** 判断值类型 **/

#define 值是否未定义大写(值) \
    (值.类型 == 值型_未定义大写)

#define 值是否空指针大写(值) \
    (值.类型 == 值型_空指针大写)

#define 值是否真大写(值) \
    (值.类型 == 值型_真大写)

#define 值是否假大写(值) \
    (值.类型 == 值型_假大写)

#define 值是否数目了大写(值) \
    (值.类型 == 值型_数目了大写)

#define 值是否对象大写(值) \
    (值.类型 == 值型_对象大写)

// 判断是否是某个特定的对象类型
#define 值是否肯定的对象大写(值, 对象类型) \
    (值是否对象大写(值) && 值到对象大写(值)->类型 == 对象类型)

#define 值是否对象串大写(值) \
    (值是否肯定的对象大写(值, 对类_字符串大写))

#define 值是否对象实例大写(值) \
    (值是否肯定的对象大写(值, 对类_实例大写))

#define 值是否对象闭包大写(值) \
    (值是否肯定的对象大写(值, 对类_闭包大写))

#define 值是否对象范围大写(值) \
    (值是否肯定的对象大写(值, 对类_范围大写))

#define 值是否对象范围大写(值) \
    (值是否肯定的对象大写(值, 对类_范围大写))

#define 值是否类大写(值) \
    (值是否肯定的对象大写(值, 对类_类大写))

// 定义指向原生方法的指针 Primitive
// 系统中定义的原生方法太多，后面就用这个指针指向不同的方法，统一调用
// *Primitive 表示 Primitive 所指的原生方法本身，声明它的第一个参数为 vm
typedef char (*原语大写)(虚拟机大写 *虚机针, 值大写 *实参们);

// 定义方法的结构体
typedef struct
{
    // union 中的值由 type 的值决定
    // 当 type 为 MT_FN_CALL 时，primFn 和 obj 均为空，实例对象本身就是待调用的函数
    方法类型大写 类型;
    union {
        // 指向脚本语言方法关联的 C 方法
        // 即脚本语言方法其实是由原生方法实现的
        // 当 type 为 MT_PRIMITIVE 时有效
        原语大写 原语函;

        // obj 指向脚本代码编译后的 ObjClosure 或 ObjFn
        // 当 type 为 MT_SCRIPT 时有效
        对象闭包大写 *对象了;
    };
} 方法大写;

// TODO: 待后续解释
声明缓冲区类型大写(方法大写)

// 定义类的结构
struct 类 {
    // 类也有自己的类，类的类就是 meta class，meta class 存储了类的原信息
    // 既然类也有所属类，那么就要有对象头
    对象头部大写 对象头部;
    // 指向 class 的基类
    struct 类 *超级类;
    // 类中属性的数量，此数量包括了从基类继承的属性
    uint32_t 字段数目了;
    // 存储所有的实例方法
    方法大写缓冲区大写 方法们;
    // 类的名称
    对象字符串大写 *名称;
};

// Bits64 用于存储 64 位数据
typedef union {
    uint64_t 位们64;
    uint32_t 位们32[2];
    double 数目了;
} 位们64大写;

// 容量的扩展倍数（用于 list、map 等对象的容量设置中）
#define 容量生长因子大写 4

// 最小容量（用于 map 等对象的容量设置中）
#define 最小容量大写 64

// 判断 a 和 b 是否相等
布尔 值是否相等(值大写 甲, 值大写 乙);

// 新建名字为 name，属性个数为 fieldNum 的裸类（裸类即没有归属的类，其对象头的 class 指针为空）
类大写 *新未加工类(虚拟机大写 *虚机针, const char *名称, uint32_t 字段数目了);

// 创建一个类
// 类名为 className，属性个数为 fieldNum，基类为 superClass
类大写 *新类(虚拟机大写 *虚机针, 对象字符串大写 *类名称, uint32_t 字段数目了, 类大写 *超级类);

// 获取对象所属的类
类大写 *获取对象的类(虚拟机大写 *虚机针, 值大写 对象);

//**********************对象文件夹结束*******************

//*************词法*****************
// 定义脚本语言的所有 Token 类型
typedef enum {
    // 未知类型
    牌_未知大写,

    // 数据类型
    牌_数目了大写,           // 数字
    牌_字符串大写,        // 字符串
    牌_身份大写,            // 变量名
    牌_插值大写, // 内嵌表达式

    // 关键字(系统保留字)
    牌_变量了大写,      // 'var'
    牌_函了大写,      // 'fun'
    牌_若大写,       // 'if'
    牌_否则大写,     // 'else'
    牌_真大写,     // 'true'
    牌_假大写,    // 'false'
    牌_一会儿大写,    // 'while'
    牌_为大写,      // 'for'
    牌_破断大写,    // 'break'
    牌_继续大写, // 'continue'
    牌_返回大写,   // 'return'
    牌_空指针大写,     // 'null'

    // 以下是关于类和模块导入的 token
    牌_类大写,  // 'class'
    牌_这个大写,   // 'this'
    牌_静止大写, // 'static'  感觉翻译为静止要比静态更符合
    牌_是大写,     // 'is'
    牌_超级大写,  // 'super'
    牌_导入大写, // 'import'

    // 分隔符
    牌_逗号大写,         // ','
    牌_冒号大写,         // ':'
    牌_左小括号大写,    // '('
    牌_右小括号大写,   // ')'
    牌_左中括号大写,  // '['
    牌_右中括号大写, // ']'
    牌_左大括号大写,    // '{'
    牌_右大括号大写,   // '}'
    牌_点大写,           // '.'
    牌_点点大写,       // '..'

    // 简单双目运算符
    牌_加号大写, // '+'
    牌_减号大写, // '-'
    牌_乘号大写, // '*'
    牌_除号大写, // '/'
    牌_取模号大写, // '%'

    // 赋值运算符
    牌_赋值号大写, // '='

    // 位运算符
    牌_位与号大写,         // '&'
    牌_位或号大写,          // '|'
    牌_位非号大写,         // '~'
    牌_位右移号大写, // '>>'
    牌_位左移号大写,  // '<<'

    // 逻辑运算符
    牌_逻辑与号大写, // '&&'
    牌_逻辑或号大写,  // '||'
    牌_逻辑非号大写, // '!'

    //关系操作符
    牌_等于号大写,        // '=='
    牌_不等于号大写,    // '!='
    牌_大于号大写,       // '>'
    牌_大等号大写, // '>='
    牌_小于号大写,         // '<'
    牌_小等号大写,   // '<='

    牌_问号大写, // '?'

    // 文件结束标记,仅词法分析时使用
    牌_文件终大写, // 'EOF'
} 牌类型大写;

//因为词法的主要处理过程是针对符号,所以翻译时应明确表示.

// 定义表示一个 Token 的结构体
typedef struct
{
    牌类型大写 类型;
    const char *起始; // 指向源码串中单词的起始地址
    uint32_t 长度;   // 该单词的长度
    uint32_t 行号;   // 该单词所在源码中的行数
    值大写 值;
} 牌大写;

// 定义编译单元的结构，具体定义在 compiler.c 文件中
typedef struct 编译单元 编译单元大写;

// 定义词法分析器的结构
struct 词法器 {
    const char *文件;        // 该指针指向源码文件名，用于标记当前正在编译哪个文件
    const char *源代码;  // 该指针指向源码字符串，将源码读出来后存储到某缓冲区，然后 sourceCode 指向该缓冲区
    const char *下一个字符指针; // 该指针指向 sourceCode 中下一个字符
    char 当前字符;            // 保存 sourceCode 中当前字符
    牌大写 当前牌;
    牌大写 前一个牌;
    对象模块大写 *当前模块;        // 当前正在编译的模块
    编译单元大写 *当前编译单元; // 当前编译单元

    int 插值期望右括号数目; // 记录内嵌表达式 %() 中括号对的数量
    struct 词法器 *父母;                 // 指向父词法解析器
    虚拟机大写 *虚机针;                               // 表示该 lexer 属于那个 vm
};

// 获取 Token 方法
void 获取下一个牌(词法器大写 *词法器);

// 如果当前 token 类型为期望类型，则读如下一个 token 并返回 true
// 否则直接返回 false
布尔 匹配牌(词法器大写 *词法器, 牌类型大写 期望牌类型);

// 断言当前 token 类型为期望类型，并读取下一个 token，否则报错
void 断言当前牌(词法器大写 *词法器, 牌类型大写 期望牌类型, const char *错消息);

// 初始化词法分析器
void 初始词法器(虚拟机大写 *虚机针, 词法器大写 *词法器, const char *文件, const char *源代码, 对象模块大写 *对象模块);

//**********************************编译器*************************
// 作用域中局部变量最多 128 个
#define 最大本地变量数目了大写 128
// upvalue 最多 128 个
#define 最大上值数目了大写 128
// 标识符最大长度 128 个字符
#define 最大身份长度了大写 128
// 方法名最大长度 128 个字符
#define 最大方法名长度了大写 最大身份长度了大写   //在用utf8编码的情况下,中文汉字最多只能使用42个字
// 参数最多 16 个
#define 最大实参数目了大写 16

// 方法的签名最大长度
// 方法的签名 = 方法名长度 + '(' + n 个参数 + n -1 个参数分隔符 ',' + ')'
#define 最大签名长度了大写 最大方法名长度了大写 + 最大实参数目了大写 * 2 + 1

// 类中的域（属性）最多 128 个
#define 最大字段数目了大写 128

// 定义 Upvalue 的结构
typedef struct
{
    布尔 是否封闭的本地变量; // 是否是直接外层函数的局部变量
    uint32_t 索引;           // 如果 isEnclosingLocalVar 为 true，则 index 表示外层函数中局部变量的索引，否则是外层函数中 upvalue 中的索引
} 上值大写;

// 定义局部变量的结构
// 注：局部变量的值是存储在运行时栈的，此处不存储
typedef struct
{
    const char *名称; // 局部变量名
    uint32_t 长度;  // 局部变量名长度
    int 作用域深度;   // 局部变量的作用域
    布尔 是否上值;   // 该局部变量是否是其内层函数所引用的 upvalue，谁引用谁设置，因此此项是其内层函数设置的
} 本地变量大写;

// 定义方法签名类型的枚举
typedef enum {
    签名_构造大写,       // 构造函数
    签名_方法大写,          // 普通方法
    签名_获取者大写,          // getter 方法
    签名_集者大写,          // setter 方法
    签名_子脚本大写,       // getter 形式的下标
    签名_子脚本的集者大写 // setter 形式的下标
} 签名类型大写;

// 定义方法签名的结构
typedef struct
{
    签名类型大写 类型; // 签名类型
    const char *名称;   // 签名
    uint32_t 长度;    // 签名长度
    uint32_t 实参数目了;    // 方法参数个数
} 签名大写;

// 定义 Loop 结构（实现 while 会用到此结构）
typedef struct 环 {
    int 条件起始索引;         // 循环中条件的起始地址
    int 物自体起始索引;         // 循环体起始地址
    int 作用域深度;             // 循环中若有 break，告诉它需要退出的作用域深度
    int 出口索引;              // 循环条件不满足时跳出循环体的目标地址
    struct 环 *封闭的环; // 直接外层循环
} 环大写;

// 定义 ClassBookKeep 结构（用于记录类编译时的信息）
// 注：每定义一个方法，就将这个方法在 vm->allMethodNames 中的索引 index 写入到 instantMethods 或 staticMethods 中，
// 在写入之前先检查下 instantMethods 或 staticMethods 是否已经存在 index，如果存在则报错重复定义，否则直接写入
typedef struct
{
    对象字符串大写 *名称;          // 类名
    符号表大写 字段们;       // 类的属性符号表（只包含实例属性，不包括类的静态属性）
    布尔 是否静止;            // 当前编译静态方法则为真
    整型大写缓冲区大写 实例方法们; // 实例方法的集合，只保存方法对应的索引，不保存方法体
    整型大写缓冲区大写 静止方法们; // 静态方法的集合，只保存方法对应的索引，不保存方法体
    签名大写 *签名;     // 当前正在编译的方法的签名
} 类书保持大写;



// 在模块 objModule 中定义名为 name，值为 value 的模块变量
int 定义模块变量(虚拟机大写 *虚机针, 对象模块大写 *对象模块, const char *名称, uint32_t 长度, 值大写 值);

// 编译模块 objModule 的方法
对象函大写 *编译模块(虚拟机大写 *虚机针, 对象模块大写 *对象模块, const char *模块代码);

// 获取 ip 所指向的操作码的操作数占用的字节数
uint32_t 获取操作范围们的字节们(const 字节大写 *指令流, 值大写 *常量们, int 指令指针);

//********************************虚拟机部分*****************



//***********************虚拟机头************
// 为定义在 opcode.inc 中的操作码加上前缀 OPCODE_
#define 操作码之_槽们大写(操作码, 效果) 操作码之_##操作码,

// 定义指令
// 通过上面对 OPCODE_SLOTS 的宏定义，可以获取到加了前缀的操作码
// 例如 OPCODE_SLOTS(LOAD_CONSTANT, 1) 返回的是 OPCODE_LOAD_CONSTANT
// 然后将这些指令集合声明称枚举数据 OpCode
// 之所以后面又将宏定义 OPCODE_SLOTS 取消定义，是因为其他地方也需要自定义 OPCODE_SLOTS 宏的逻辑，来获取不同的数据
typedef enum {
#include "操作码.inc"
} 操作码枚举大写;
#undef 操作码之_槽们大写

// 虚拟机执行结果
typedef enum 虚拟机结果 {
    虚拟机结果成功大写,
    虚拟机结果错误大写
} 虚拟机结果大写;

struct 虚拟机 {
    类大写 *类的类;
    类大写 *对象类;
    类大写 *字符串类;
    类大写 *映射类;
    类大写 *范围类;
    类大写 *列表类;
    类大写 *空指针类;
    类大写 *布尔类;
    类大写 *数目类;
    类大写 *函类;
    类大写 *线程类;

    uint32_t 已分配字节们;    // 累计已分配的内存总和
    对象头部大写 *全部对象们;      // 累计已分配的所有对象的链表（用于垃圾回收）
    符号表大写 全部方法名们; // 所有类的方法
    对象映射大写 *全部模块们;         // 所有模块
    对象线程大写 *当前线程;       // 当前正在执行的线程
    词法器大写 *当前词法器;            // 当前词法分析器
};

// 初始化虚拟机
void 初始虚拟机(虚拟机大写 *虚机针);

// 新建虚拟机
虚拟机大写 *新虚拟机(void);

// 释放虚拟机
void 自由虚拟机(虚拟机大写 *虚机针);

// 确保栈的容量及数据有效
// needSlots 表示栈最少具有的容量，如果当前栈容量 stackCapacity 大于需要的栈数量，则直接返回即可
void 确保栈(虚拟机大写 *虚机针, 对象线程大写 *对象线程, uint32_t 需要槽们);

// 执行指令
虚拟机结果大写 执行指令(虚拟机大写 *虚机针, register 对象线程大写 *当前线程);


//*************核心******************
// 源码文件所在的根目录
extern char *根目录;

// 读取源码文件的方法
char *读文件(const char *源文件);

// 执行模块
虚拟机结果大写 执行模块(虚拟机大写 *虚机针, 值大写 模块名, const char *源代码);

// 编译核心模块
void 建造核心(虚拟机大写 *虚机针);

// 在 table 中查找符号 symbol，找到后返回索引，否则返回 -1
int 获取索引来自符号表(符号表大写 *表, const char *符号, uint32_t 长度);

// 向 table 中添加符号 symbol，并返回其索引
int 加上符号(虚拟机大写 *虚机针, 符号表大写 *表, const char *符号, uint32_t 长度);

// 绑定方法到指定类
// 将方法 method 到类 class 的 methods 数组中，位置为 index
void 绑方法(虚拟机大写 *虚机针, 类大写 *类, uint32_t 索引, 方法大写 方法);

// 绑定 superClass 为 subClass 的基类
// 即继承基类的属性个数和方法（通过复制实现）
void 绑超级类(虚拟机大写 *虚机针, 类大写 *子类, 类大写 *超级类);

// 确保符号 symbol 已经添加到符号表 table 中，如果查找没有，则向其中添加
int 确保符号存在(虚拟机大写 *虚机针, 符号表大写 *表, const char *符号, uint32_t 长度);

//*************************垃圾回收****************
void 自由对象(虚拟机大写 *虚机针, 对象头部大写 *对象了);


//****************************命令行***************
#define 最大行的长大写 1024
