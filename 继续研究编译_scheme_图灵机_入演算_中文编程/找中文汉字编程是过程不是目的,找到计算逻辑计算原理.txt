lambda演算(微积分), 其实很简单;
x y.x + y 没了   
这其中, 你可以把(x y)部分替换为一个或多个数目, 把(x + y)里的"+"替换为别的操作.
除了四则运算以外, 也可以是一元操作, 或复合操作.
并且, 这种操作形成的方式可以递归.
哦, 还有, "x", "y" 也可以是地球上别的文字, 因为这本质上是代表符号.

仅仅是这样还不够, 这个确实简单, 普通人一看这串符号[x y.x + y], 外带一些简单解说,
几分钟内就能掌握. 我也是用了几年才理解, 因为没人教我、带我.
我独自看了很多注解与书籍才弄懂, 比如阿隆佐●邱琦的形式逻辑相关的评论.

为啥说这样还不够呢? 
因为这串符号现在还是人肉在演算.
形式逻辑的目的是从数学里提炼出来, 放到机器里去计算. 我们让机器帮我们演算这些形式.
也就是实现一些自动的操作.
为了做到这一点, 我们需要让状态自动跑起来, 
因为操作也是一种状态, 被操作物亦是状态, 这里可以简化为"操作者"与"操作范围", 顾名思义.
状态它是静态的, 若想让其自动跑起来, 我们需要把它变成动态的状态. 
这引出了图灵机, 图灵机是一台无限状态机.
图灵机是一台抽象的机器, 意味着, 可以用多种方式实现,
起初我不懂元循环(轮)求值器是什么, 没意识到它的本质,
直到我阅读了大量的代码, 一些评论类书籍(或网页与帖子), 各种交流与沟通(就是闲聊).
我明白到, 元循环(轮)求值器其实是一种图灵机, 虽然它只能操纵一些有限范围内的状态.

绕了这么多, 想说啥呢?
想指出, 元循环(轮)求值器被用来求解lambda演算.
因为lambda演算需要一个运行的环境, 这串符号[x y.x + y]若是想要自动地跑起来,
就需要一个能识别这串符号 与 对每个符号求值 与 存储符号之间关系的这么个环境.(注意;与是布尔的与)
而做这些事的宿主就是元循环(轮)求值器.
从巴贝奇的差分机, 哦, 不对, 从珍妮纺织机, 甚至上古嫘祖发明的织布方式, 到现在的集成电路,
都是在做这件事, 求值.
我们把求值这件事抽象后, 就得到了编程.
给编程打造各种脚手架、扳手、螺母螺丝、钉子等等工具, 它就变成了编程语言.
语言? 错. 功能集? 对.
编程与程序在西文里是一个意思, 翻译过来后, 变成了两种东西, 怎么样? 被误导了吧? 走了多少年弯路呢.
我也是走了很多弯路才懂得. 国内的翻译, 有大问题! 不管是专业术语还是不专业的.
以至于现在出现很多傻子, 认为直译 = 机翻, 它们反而看不懂源头的东西. 属实劣币驱逐良币了.
这挺好, 我不需要去救它们, 也不会, 也用不着. 该死死, 该生生. 道法自然.
历史不可改变, 历史没有假设, 历史没有如果!

扯远了, 到底是求值生编程, 还是编程生求值,
这就像蛋生鸡鸡生蛋一样, 可能需要拜祖师爷才能得到答案.

我做了很多事, 花了很多年, 其实就弄懂了上面我总结的这些,
仅仅是要理解求值器, 就需要从C开始, 不断深入底层, 到汇编, 到机器码, 到CPU四个流水.
到底了, 往上了解算法, 数据结构, 程序的组织逻辑, 流程与业务.
横的是一面, 纵的也需要, 于是又去研究原理,
所以接触到编译, 编译之后又是解释, 还有非C系, 不断地往古老的方向前进, 属实是刨根问底了,
其中接触了不同的编程方式, 比如forth, lisp. 无非就是表示函数的三种形式,
直到我发现学了这些也还是不能解答我的疑惑.
我学会化繁为简, 我接触并研究中文汉字编程, 我刻意排斥C系.
当我把繁复、繁杂的噪音(C系), 屏蔽掉后, 我逐渐看到了清晰的路.
原来一切是如此的简单.
我重新拿起lisp系的一切(代码、文章、评论), 我理解到了forth也是函数式.
我看了SICP(原版,中译本在我看来是假书), 第四章的解释器, 第五章的编译器与仿真机.
真正理解了啥是原语. 并领悟,抽象设计想象力.
我又对比了与C系的计算过程(求值过程), 再加上大模型的辅助.
我发现, 编译就是收集、搜集、编织, 解释就是直译、剖开、解构, 这就是原理.
哦, 还有管道行, line应该翻译为行(hang), 而不是线, 线有专门的字thread.
当然, 本质都是翻译, 翻译就是键值对, 编码、解码;键值对, 一进一出是为键值对,核壳是为键值对.
其实求值也是翻译, lambda演算也是翻译.
没有我的这些经历, 你也理解不了我说的翻译是个啥子.

重拾lisp系, 让我最终走到了根, 即-lambda演算,
求值过程, 应用实参.
这就是我为什么说一切如此简单, 
所有东西从此而来,来自于此. 硬件的, 软件的, 非硬非软的.
真正强大的东西就是最简单的东西,
大道至简!

我理解到了胖宝娃、婴儿的快乐,
或许, 这就是元婴态吧.

多么有意思的二元论世界.

//
学习笔记,2024年10月26日

函数应用到参数上,
过程应用到实参上,
人吃饭应用到饭菜上...

抽象: 功能体/机器 应用到 变量. 动态 应用到 静态.

如何想象编译?
我用御膳房做菜, 最终变为成品, 类比编译的过程.

阿隆佐邱琦的lambda演算: [求值] [应用] [环境(键值对)]
阿兰图灵的图灵机: [变量(存储状态)] [顺序] [跳转]

//
今天发现编译(解释)过程其实是个存储过程.
从词法开始到生成机器码, 问了大模型, 大模型演示给我看后,
我才知道这几个阶段, 主要是怎么存储数据和操作的问题.
昨天又被困在了词法怎么开始的一步, 因为又重复了过去的那些误导教程的步骤,
思路不对, 今天一看伪代码演示, 原来只需要一个哈希表, 就可以通吃词法->句法->AST->代码生成.
哈希表综合了数组与链表的优点, 键值对组合进行递归, 可以表示树形结构,
词法要从字符串生成牌-token, 牌的形式就是类型:字符, 这样的键值对形式.
并且,我发现,编译(解释)过程是动态构造一气呵成的, 只有学习研究的时候, 才把它们拆成一个个阶段来静态分析.
句法生成AST还不熟.
只知道句法树是富裕树,AST是简化树.
AST生成代码倒是更进一步认识. 原来并不是非得化为二叉树, 普通树一样也能轻易生成代码,
AST生成三地址码(或四地址或零地址),之后再生成静态单赋值, 这样才简单,
以前觉得SSA很复杂, 没想到这么容易, 就是用数字编号重命名, 就是顾名思义:单赋值,一个变量赋值一次.
之后SSA再生成汇编或机器码, 都是点对点操作罢了, 就是变量赋值, 只是名称不同,
汇编有汇编的一套名称, 中间码有中间码的一套名称, 
AST后生成代码的每一步都是这样, 不过是一直在重复操作.
哦, 要实现对Unicode的支持, 需要在读取字符串后立即识别, 原来生成牌token, 根本就不管这一小步.
以前我一直被困在怎么解决Unicode的词法分析上, 真是误事.
到底是选虚拟机解释执行,还是物理机编译执行,还拿不定主意.


//
我来翻译一下编译器的中文语境;
文章 -> 字词分析 :得到: [牌] -> 句段分析 :得到: [关系树] -> 生成数字编码 :得到: [数字串]

我来解释下为啥是数字编码, 在多方研究后,
我得出一个简单的结论, 汇编码中间码这些, 其实都是翻译为数字, 二进制更是数字,
业界流行用16进制与2进制表示和代表数字, 特别是用16进制表示机器码二进制, 让一堆的小白发晕找不到北.
原来分析还有细察与分解的意思.
而解析也有剖开、解构的意思.
字词到牌也有化为牌、牌化的内涵,本来还分成了两部分处理,
先扫描后化为牌.
生成就是产出、生产,产品、成品, 换到程序里来说就是打印,
把结果打印出来, 打印列表, 获得的是 [值] .
句段由什么构成、构造?
名动名,主谓宾, 推理到根源, 谓词、名词.
中文汉字汉语的文法, 我简化为由递归的谓词与名词构成的树形结构, 
没有谓词的时候, 就用空操作代替, 也就是空谓词.
如此一来,谓词名词就可以方便地转化为键值对,
进而转化为关系树, 用图的视角看就是关系网.
键值对在计算机里既方便存储,也方便处理.
编译过程看起来就是化整为零,聚零为整,递归交替进行.

生成数字,意味着可以用算盘计算,但怎么让算盘自动算?


//
原来fixpoint是固定点, 英文源码里搞个fix缩写在那里, 我还以为是修...
不可思议,英文字母写的这些源码, 缩写简写, 大小写, 单复数, 歧义之大, 难以想象.
外包程序员还反咬一口说中文汉字编程的标识符歧义大, 这群人果然是坏种, 语文水平也差得很!
我明白为啥要用固定点表示Y组合子了, 固定点不就是锚吗? 为啥要取Y当做这个符号呢,
Y不就是锚的形状反过来? Y组合子的意思是, 在lambda函数里造一个锚作为固定点, 以此实现递归.


//
我设想的指令集虚拟化, 原来就是仿真与模拟, 让仿真在虚拟化上, 让虚拟化在仿真上,
我明白了, 是指令集仿真,
或,指令集模拟.
还是有区别的. 虚拟化（Virtualization） , 仿真（Emulation） , 模拟（Simulation）.
所谓硬件抽象层这种虚拟化, 远远达不到我的需求, 我就说以前的理解怎么总是差了那么一点,
到底在哪里呢? 原来还有更精深的, 更底层.. 也不能说是底层, 好像已经上升到哲学, 或, 维度的改变了.
操作系统, 呵呵. 编译/解释, 呵呵. 原来都是玩具级.
因为以前没接触中间表示, 让我到不了这一层, 只能停留在硬件抽象层这种虚拟化上,
即使是想象到了指令集虚拟化, 也无奈被短促的某些现实表象绊倒, 
要是配上lisp域或forth域呢, 果然还有已知空间以外的存在, 普通的存在理解不了.
还企图垄断认知, 还想企图囚禁在C系, 我看透了造这些的可怜虫.
找到窗户, 打开.

使用计算理论去仿真或模拟物理世界的这种虚拟化, 就是一种中间表示.
量子/场, 会不会是一种中间表示?

