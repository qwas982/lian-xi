原来编译|解释的翻译过程如此简单,
1,剖开连续的字符串, 使其成为稀疏的离散结构, 牌-token, 按牌位存储.
2,预先设计一个能存储键值对的数据结构, 把牌的种类与值存进去, 后面也要用到这个键值对数据结构; 牌流|牌表.
3,预先设计编程语言的文法, 按照文法, 从牌流|牌表里读取键值对信息, 生成具体句法树-CST.
4,遍历具体句法树, 提取语素信息, 生成抽象句法树-AST, 再次存储到键值对数据结构; 符号表.
5,使用遍历的方式, 对比符号表与CST与AST, 进行语义检查, 更新符号表.


第二遍学习.
没想到都可以用键值对表示, 用哈希表存储.
从源码字符串到指令序列, 
需要用到队列, 序列, 树, 符号表, 序列, 图, 栈, 数据结构.
并且都可以用哈希表存储.
1,
读取字符串进行字词分析|词法分析,
细分为两步; 扫描, 牌化.
字符串被剖开生成队列, 队列解剖生成序列.
2,
读取牌序列进行解析|语法分析,
细分为两步; 具体句法树, 抽象句法树.
牌序列被遍历, 根据文法被逐个赋值到树根或树左叶或树右叶, 得到具体句法树.
继续遍历具体句法树, 进入平行处理状态, 一边把树根与树叶存储到符号表, 一边逐个赋值到抽象句法树的树根与树叶.
继续遍历抽象句法树, 检查文法, 验证语义, 更新符号表.
继续遍历抽象句法树, 生成指令序列.
根据树根与树叶的值, 打印相应的操作者(操作码)与操作范围(操作数).

生成中间码, 重复以上过程.
生成汇编, 重复以上过程.
生成机器码, 重复以上过程.

物理机或虚拟机,
读取指令序列, 或用字符表示, 或用数字编码表示.
拾取每条指令序列.
解码指令序列, 从序列里译码出操作者与操作范围, 找出操作类型与操作的具体位置.
有机组合运算器与控制器, 执行.
把求值结果写回存储器.
输出, 调用打印中断, 显示求出的值.
回到第一步.

假如字符串是Unicode编码, 每个代码点 = 每个字.
源码字符串存储为字节序列, 首先, 需要解码字节序列, 还原为Unicode代码点.
根据编码方式(UTF8, UTF16, UTF32), 有不同的解码算法.
解码完成后, 需要验证字节序与字节长度, 出错要重新解码.
在编译|解释的中途, 遇到需要输出的情况, 需要重新编码代码点为字节序列,
也可以不用, 一般外部编辑器、终端、其它程序自带编解码.


剖开整体, 化为原子, 按位处理, 附加关系和属性, 附魔,
从附魔的信息打印指令.


原来提示语需要树形结构.
解释xxxx,用目录与提纲形式展现, 并细分解释每个分支