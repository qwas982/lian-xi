(import (chibi))  ; 假设 chibicc.h 中的内容已经转换为 Scheme 模块

;; 定义常量
(define 通用寄存器最大数量 6)
(define 浮点寄存器最大数量 8)

;; 静态变量
(define 输出文件 #f)  ; 假设 FILE 类型在 Scheme 中用 #f 表示
(define 深度 0)
(define 参数寄存器8 '("%dil" "%sil" "%dl" "%cl" "%r8b" "%r9b"))
(define 参数寄存器16 '("%di" "%si" "%dx" "%cx" "%r8w" "%r9w"))
(define 参数寄存器32 '("%edi" "%esi" "%edx" "%ecx" "%r8d" "%r9d"))
(define 参数寄存器64 '("%rdi" "%rsi" "%rdx" "%rcx" "%r8" "%r9"))
(define 当前函数 #f)  ; 假设 Obj 类型在 Scheme 中用 #f 表示

;; 函数 println
(define (打印行 格式 . 参数)
  (apply fprintf 输出文件 (string-append 格式 "\n") 参数))

;; 函数 count
(define (计数)
  (let ((i 1))
    (lambda ()
      (let ((current i))
        (set! i (+ i 1))
        current))))

;; 函数 push
(define (压栈)
  (打印行 "  push %%rax")
  (set! 深度 (+ 深度 1)))

;; 函数 pop
(define (弹栈 参数)
  (打印行 "  pop ~a" 参数)
  (set! 深度 (- 深度 1)))

;; 函数 pushf
(define (压栈浮点)
  (打印行 "  sub $8, %%rsp")
  (打印行 "  movsd %%xmm0, (%%rsp)")
  (set! 深度 (+ 深度 1)))

;; 函数 popf
(define (弹栈浮点 寄存器)
  (打印行 "  movsd (%%rsp), %%xmm~a" 寄存器)
  (打印行 "  add $8, %%rsp")
  (set! 深度 (- 深度 1)))

;; 将 `n` 向上舍入到最接近的 `align` 的倍数。例如，
;; align_to(5, 8) 返回 8，align_to(11, 8) 返回 16。
(define (对齐到 n 对齐)
  (* (ceiling (/ n 对齐)) 对齐))

;; 根据大小返回对应的寄存器名称
(define (寄存器_dx 大小)
  (case 大小
    ((1) "%dl")
    ((2) "%dx")
    ((4) "%edx")
    ((8) "%rdx")
    (else (error "不可达"))))

;; 根据大小返回对应的寄存器名称
(define (寄存器_ax 大小)
  (case 大小
    ((1) "%al")
    ((2) "%ax")
    ((4) "%eax")
    ((8) "%rax")
    (else (error "不可达"))))

;; 计算给定节点的绝对地址。
;; 如果给定节点不在内存中，则报错。
(define (生成地址 节点)
  (cond
    ((equal? (节点 '类型) "变量")
     (if (equal? ((节点 '变量) '类型) "可变长度数组")
         (打印行 "  mov ~a(%%rbp), %%rax" ((节点 '变量) '偏移))
         (if ((节点 '变量) '是局部变量)
             (打印行 "  lea ~a(%%rbp), %%rax" ((节点 '变量) '偏移))
             (if opt_fpic
                 (if ((节点 '变量) '是线程局部变量)
                     (打印行 "  data16 lea ~a@tlsgd(%%rip), %%rdi" ((节点 '变量) '名称))
                     (打印行 "  mov ~a@GOTPCREL(%%rip), %%rax" ((节点 '变量) '名称)))
                 (if ((节点 '变量) '是线程局部变量)
                     (打印行 "  mov %%fs:0, %%rax")
                     (if (equal? ((节点 '类型) '类型) "函数")
                         (if ((节点 '变量) '是定义)
                             (打印行 "  lea ~a(%%rip), %%rax" ((节点 '变量) '名称))
                             (打印行 "  mov ~a@GOTPCREL(%%rip), %%rax" ((节点 '变量) '名称)))
                         (打印行 "  lea ~a(%%rip), %%rax" ((节点 '变量) '名称))))))))
    ((equal? (节点 '类型) "解引用")
     (生成表达式 (节点 '左)))
    ((equal? (节点 '类型) "逗号")
     (生成表达式 (节点 '左))
     (生成地址 (节点 '右)))
    ((equal? (节点 '类型) "成员")
     (生成地址 (节点 '左))
     (打印行 "  add $%d, %%rax" ((节点 '成员) '偏移)))
    ((equal? (节点 '类型) "函数调用")
     (if (节点 '返回缓冲区)
         (生成表达式 节点)))
    ((or (equal? (节点 '类型) "赋值") (equal? (节点 '类型) "条件"))
     (if (or (equal? ((节点 '类型) '类型) "结构体") (equal? ((节点 '类型) '类型) "联合体"))
         (生成表达式 节点)))
    ((equal? (节点 '类型) "可变长度数组指针")
     (打印行 "  lea ~a(%%rbp), %%rax" ((节点 '变量) '偏移)))
    (else
     (错误_tok (节点 '标记) "不是左值"))))

;; 从 %rax 指向的位置加载一个值。
(define (加载 类型)
  (cond
    ((or (equal? (类型 '类型) "数组") (equal? (类型 '类型) "结构体") (equal? (类型 '类型) "联合体") (equal? (类型 '类型) "函数") (equal? (类型 '类型) "可变长度数组"))
     #f)
    ((equal? (类型 '类型) "浮点数")
     (打印行 "  movss (%%rax), %%xmm0"))
    ((equal? (类型 '类型) "双精度浮点数")
     (打印行 "  movsd (%%rax), %%xmm0"))
    ((equal? (类型 '类型) "长双精度浮点数")
     (打印行 "  fldt (%%rax)"))
    (else
     (let ((指令 (if (类型 '是无符号) "movz" "movs")))
       (case (类型 '大小)
         ((1) (打印行 "  ~abl (%%rax), %%eax" 指令))
         ((2) (打印行 "  ~awl (%%rax), %%eax" 指令))
         ((4) (打印行 "  movsxd (%%rax), %%rax"))
         (else (打印行 "  mov (%%rax), %%rax")))))))

;; 将 %rax 存储到栈顶指向的地址。
(define (存储 类型)
  (弹栈 "%rdi")
  (cond
    ((or (equal? (类型 '类型) "结构体") (equal? (类型 '类型) "联合体"))
     (for-each (lambda (i)
                 (打印行 "  mov ~a(%%rax), %%r8b" i)
                 (打印行 "  mov %%r8b, ~a(%%rdi)" i))
               (iota (类型 '大小))))
    ((equal? (类型 '类型) "浮点数")
     (打印行 "  movss %%xmm0, (%%rdi)"))
    ((equal? (类型 '类型) "双精度浮点数")
     (打印行 "  movsd %%xmm0, (%%rdi)"))
    ((equal? (类型 '类型) "长双精度浮点数")
     (打印行 "  fstpt (%%rdi)"))
    (else
     (case (类型 '大小)
       ((1) (打印行 "  mov %%al, (%%rdi)"))
       ((2) (打印行 "  mov %%ax, (%%rdi)"))
       ((4) (打印行 "  mov %%eax, (%%rdi)"))
       (else (打印行 "  mov %%rax, (%%rdi)"))))))

;; 比较类型为零的值
(define (比较零 类型)
  (cond
    ((equal? (类型 '类型) "浮点数")
     (打印行 "  xorps %%xmm1, %%xmm1")
     (打印行 "  ucomiss %%xmm1, %%xmm0"))
    ((equal? (类型 '类型) "双精度浮点数")
     (打印行 "  xorpd %%xmm1, %%xmm1")
     (打印行 "  ucomisd %%xmm1, %%xmm0"))
    ((equal? (类型 '类型) "长双精度浮点数")
     (打印行 "  fldz")
     (打印行 "  fucomip")
     (打印行 "  fstp %%st(0)"))
    (else
     (if (and (是整数 类型) (<= (类型 '大小) 4))
         (打印行 "  cmp $0, %%eax")
         (打印行 "  cmp $0, %%rax")))))

;; 类型ID枚举
(define I8 0)
(define I16 1)
(define I32 2)
(define I64 3)
(define U8 4)
(define U16 5)
(define U32 6)
(define U64 7)
(define F32 8)
(define F64 9)
(define F80 10)

;; 获取类型ID
(define (获取类型ID 类型)
  (cond
    ((equal? (类型 '类型) "字符")
     (if (类型 '是无符号) U8 I8))
    ((equal? (类型 '类型) "短整数")
     (if (类型 '是无符号) U16 I16))
    ((equal? (类型 '类型) "整数")
     (if (类型 '是无符号) U32 I32))
    ((equal? (类型 '类型) "长整数")
     (if (类型 '是无符号) U64 I64))
    ((equal? (类型 '类型) "浮点数")
     F32)
    ((equal? (类型 '类型) "双精度浮点数")
     F64)
    ((equal? (类型 '类型) "长双精度浮点数")
     F80)
    (else
     U64)))

;; 类型转换表
(define i32i8 "movsbl %al, %eax")
(define i32u8 "movzbl %al, %eax")
(define i32i16 "movswl %ax, %eax")
(define i32u16 "movzwl %ax, %eax")
(define i32f32 "cvtsi2ssl %eax, %xmm0")
(define i32i64 "movsxd %eax, %rax")
(define i32f64 "cvtsi2sdl %eax, %xmm0")
(define i32f80 "mov %eax, -4(%rsp); fildl -4(%rsp)")

(define u32f32 "mov %eax, %eax; cvtsi2ssq %rax, %xmm0")
(define u32i64 "mov %eax, %eax")
(define u32f64 "mov %eax, %eax; cvtsi2sdq %rax, %xmm0")
(define u32f80 "mov %eax, %eax; mov %rax, -8(%rsp); fildll -8(%rsp)")

(define i64f32 "cvtsi2ssq %rax, %xmm0")
(define i64f64 "cvtsi2sdq %rax, %xmm0")
(define i64f80 "movq %rax, -8(%rsp); fildll -8(%rsp)")

(define u64f32 "cvtsi2ssq %rax, %xmm0")
(define u64f64 "test %rax,%rax; js 1f; pxor %xmm0,%xmm0; cvtsi2sd %rax,%xmm0; jmp 2f; 1: mov %rax,%rdi; and $1,%eax; pxor %xmm0,%xmm0; shr %rdi; or %rax,%rdi; cvtsi2sd %rdi,%xmm0; addsd %xmm0,%xmm0; 2:")
(define u64f80 "mov %rax, -8(%rsp); fildq -8(%rsp); test %rax, %rax; jns 1f; mov $1602224128, %eax; mov %eax, -4(%rsp); fadds -4(%rsp); 1:")

(define f32i8 "cvttss2sil %xmm0, %eax; movsbl %al, %eax")
(define f32u8 "cvttss2sil %xmm0, %eax; movzbl %al, %eax")
(define f32i16 "cvttss2sil %xmm0, %eax; movswl %ax, %eax")
(define f32u16 "cvttss2sil %xmm0, %eax; movzwl %ax, %eax")
(define f32i32 "cvttss2sil %xmm0, %eax")
(define f32u32 "cvttss2siq %xmm0, %rax")
(define f32i64 "cvttss2siq %xmm0, %rax")
(define f32u64 "cvttss2siq %xmm0, %rax")
(define f32f64 "cvtss2sd %xmm0, %xmm0")
(define f32f80 "movss %xmm0, -4(%rsp); flds -4(%rsp)")

(define f64i8 "cvttsd2sil %xmm0, %eax; movsbl %al, %eax")
(define f64u8 "cvttsd2sil %xmm0, %eax; movzbl %al, %eax")
(define f64i16 "cvttsd2sil %xmm0, %eax; movswl %ax, %eax")
(define f64u16 "cvttsd2sil %xmm0, %eax; movzwl %ax, %eax")
(define f64i32 "cvttsd2sil %xmm0, %eax")
(define f64u32 "cvttsd2siq %xmm0, %rax")
(define f64i64 "cvttsd2siq %xmm0, %rax")
(define f64u64 "cvttsd2siq %xmm0, %rax")
(define f64f32 "cvtsd2ss %xmm0, %xmm0")
(define f64f80 "movsd %xmm0, -8(%rsp); fldl -8(%rsp)")

(define FROM_F80_1 "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); ")
(define FROM_F80_2 " -24(%rsp); fldcw -10(%rsp); ")

(define f80i8 (string-append FROM_F80_1 "fistps" FROM_F80_2 "movsbl -24(%rsp), %eax"))
(define f80u8 (string-append FROM_F80_1 "fistps" FROM_F80_2 "movzbl -24(%rsp), %eax"))
(define f80i16 (string-append FROM_F80_1 "fistps" FROM_F80_2 "movzbl -24(%rsp), %eax"))
(define f80u16 (string-append FROM_F80_1 "fistpl" FROM_F80_2 "movswl -24(%rsp), %eax"))
(define f80i32 (string-append FROM_F80_1 "fistpl" FROM_F80_2 "mov -24(%rsp), %eax"))
(define f80u32 (string-append FROM_F80_1 "fistpl" FROM_F80_2 "mov -24(%rsp), %eax"))
(define f80i64 (string-append FROM_F80_1 "fistpq" FROM_F80_2 "mov -24(%rsp), %rax"))
(define f80u64 (string-append FROM_F80_1 "fistpq" FROM_F80_2 "mov -24(%rsp), %rax"))
(define f80f32 "fstps -8(%rsp); movss -8(%rsp), %xmm0")
(define f80f64 "fstpl -8(%rsp); movsd -8(%rsp), %xmm0")

;; 类型转换表
(define 转换表
  (list
   ;; i8   i16     i32     i64     u8     u16     u32     u64     f32     f64     f80
   (list #f #f #f i32i64 i32u8 i32u16 #f i32i64 i32f32 i32f64 i32f80) ;; i8
   (list i32i8 #f #f i32i64 i32u8 i32u16 #f i32i64 i32f32 i32f64 i32f80) ;; i16
   (list i32i8 i32i16 #f i32i64 i32u8 i32u16 #f i32i64 i32f32 i32f64 i32f80) ;; i32
   (list i32i8 i32i16 #f #f i32u8 i32u16 #f #f i64f32 i64f64 i64f80) ;; i64

   (list i32i8 #f #f i32i64 #f #f #f i32i64 i32f32 i32f64 i32f80) ;; u8
   (list i32i8 i32i16 #f i32i64 i32u8 #f #f i32i64 i32f32 i32f64 i32f80) ;; u16
   (list i32i8 i32i16 #f u32i64 i32u8 i32u16 #f u32i64 u32f32 u32f64 u32f80) ;; u32
   (list i32i8 i32i16 #f #f i32u8 i32u16 #f #f u64f32 u64f64 u64f80) ;; u64

   (list f32i8 f32i16 f32i32 f32i64 f32u8 f32u16 f32u32 f32u64 #f f32f64 f32f80) ;; f32
   (list f64i8 f64i16 f64i32 f64i64 f64u8 f64u16 f64u32 f64u64 f64f32 #f f64f80) ;; f64
   (list f80i8 f80i16 f80i32 f80i64 f80u8 f80u16 f80u32 f80u64 f80f32 f80f64 #f))) ;; f80

;; 类型转换函数
(define (类型转换 来源 目标)
  (if (equal? (目标 '类型) "空")
      #f
      (let ((类型ID1 (获取类型ID 来源))
            (类型ID2 (获取类型ID 目标)))
        (if (list-ref (list-ref 转换表 类型ID1) 类型ID2)
            (打印行 "  ~a" (list-ref (list-ref 转换表 类型ID1) 类型ID2))))))

;; 检查结构体或联合体在指定字节范围内是否只包含浮点数成员
(define (包含浮点数 类型 下限 上限 偏移)
  (cond
    ((or (equal? (类型 '类型) "结构体") (equal? (类型 '类型) "联合体"))
     (every (lambda (成员)
              (包含浮点数 (成员 '类型) 下限 上限 (+ 偏移 (成员 '偏移))))
            (类型 '成员)))
    ((equal? (类型 '类型) "数组")
     (every (lambda (i)
              (包含浮点数 (类型 '基类型) 下限 上限 (+ 偏移 (* (类型 '基类型 '大小) i))))
            (iota (类型 '数组长度))))
    (else
     (or (< 偏移 下限) (>= 上限 偏移) (member (类型 '类型) '("浮点数" "双精度浮点数"))))))

;; 检查结构体或联合体的前8字节是否只包含浮点数成员
(define (包含浮点数1 类型)
  (包含浮点数 类型 0 8 0))

;; 检查结构体或联合体的第8到16字节是否只包含浮点数成员
(define (包含浮点数2 类型)
  (包含浮点数 类型 8 16 0))

;; 将结构体或联合体压入栈
(define (压入结构体 类型)
  (let ((大小 (对齐到 (类型 '大小) 8)))
    (打印行 "  sub $%d, %%rsp" 大小)
    (set! 深度 (+ 深度 (/ 大小 8)))
    (for-each (lambda (i)
                (打印行 "  mov ~a(%%rax), %%r10b" i)
                (打印行 "  mov %%r10b, ~a(%%rsp)" i))
              (iota (类型 '大小)))))

;; 递归压入函数调用参数
(define (压入参数2 参数 首次传递)
  (if 参数
      (begin
        (压入参数2 (参数 '下一个) 首次传递)
        (if (or (and 首次传递 (not (参数 '通过栈传递))) (and (not 首次传递) (参数 '通过栈传递)))
            #f
            (begin
              (生成表达式 参数)
              (if (member ((参数 '类型) '类型) '("结构体" "联合体"))
                  (压入结构体 (参数 '类型))
                  (if (member ((参数 '类型) '类型) '("浮点数" "双精度浮点数"))
                      (压入浮点)
                      (if (equal? ((参数 '类型) '类型) "长双精度浮点数")
                          (begin
                            (打印行 "  sub $16, %%rsp")
                            (打印行 "  fstpt (%%rsp)")
                            (set! 深度 (+ 深度 2)))
                          (压入)))))))))

;; 加载函数调用参数
(define (压入参数 节点)
  (let ((栈 0)
        (通用寄存器 0)
        (浮点寄存器 0))
    (if (and (节点 '返回缓冲区) (> ((节点 '类型) '大小) 16))
        (set! 通用寄存器 (+ 通用寄存器 1)))
    (for-each (lambda (参数)
                (let ((类型 (参数 '类型)))
                  (cond
                    ((member (类型 '类型) '("结构体" "联合体"))
                     (if (> (类型 '大小) 16)
                         (set! (参数 '通过栈传递) #t)
                         (let ((浮点数1 (包含浮点数1 类型))
                               (浮点数2 (包含浮点数2 类型)))
                           (if (and (< (+ 浮点寄存器 浮点数1 浮点数2) 浮点寄存器最大数量)
                                    (< (+ 通用寄存器 (not 浮点数1) (not 浮点数2)) 通用寄存器最大数量))
                               (begin
                                 (set! 浮点寄存器 (+ 浮点寄存器 浮点数1 浮点数2))
                                 (set! 通用寄存器 (+ 通用寄存器 (not 浮点数1) (not 浮点数2))))
                               (set! (参数 '通过栈传递) #t)))))
                    ((member (类型 '类型) '("浮点数" "双精度浮点数"))
                     (if (>= 浮点寄存器 浮点寄存器最大数量)
                         (set! (参数 '通过栈传递) #t)
                         (set! 浮点寄存器 (+ 浮点寄存器 1))))
                    ((equal? (类型 '类型) "长双精度浮点数")
                     (set! (参数 '通过栈传递) #t))
                    (else
                     (if (>= 通用寄存器 通用寄存器最大数量)
                         (set! (参数 '通过栈传递) #t)
                         (set! 通用寄存器 (+ 通用寄存器 1)))))))
              (节点 '参数))
    (if (odd? (+ 深度 栈))
        (begin
          (打印行 "  sub $8, %%rsp")
          (set! 深度 (+ 深度 1))
          (set! 栈 (+ 栈 1))))
    (压入参数2 (节点 '参数) #t)
    (压入参数2 (节点 '参数) #f)
    (if (and (节点 '返回缓冲区) (> ((节点 '类型) '大小) 16))
        (begin
          (打印行 "  lea ~a(%%rbp), %%rax" ((节点 '返回缓冲区) '偏移))
          (压入)))
    栈))

;; 复制返回缓冲区
(define (复制返回缓冲区 变量)
  (let ((类型 (变量 '类型))
        (通用寄存器 0)
        (浮点寄存器 0))
    (if (包含浮点数1 类型)
        (if (equal? (类型 '大小) 4)
            (打印行 "  movss %%xmm0, ~a(%%rbp)" (变量 '偏移))
            (打印行 "  movsd %%xmm0, ~a(%%rbp)" (变量 '偏移)))
        (for-each (lambda (i)
                    (打印行 "  mov %%al, ~a(%%rbp)" (+ (变量 '偏移) i))
                    (打印行 "  shr $8, %%rax"))
                  (iota (min 8 (类型 '大小)))))
    (if (> (类型 '大小) 8)
        (if (包含浮点数2 类型)
            (if (equal? (类型 '大小) 12)
                (打印行 "  movss %%xmm~a, ~a(%%rbp)" 浮点寄存器 (+ (变量 '偏移) 8))
                (打印行 "  movsd %%xmm~a, ~a(%%rbp)" 浮点寄存器 (+ (变量 '偏移) 8)))
            (let ((寄存器1 (if (equal? 通用寄存器 0) "%al" "%dl"))
                  (寄存器2 (if (equal? 通用寄存器 0) "%rax" "%rdx")))
              (for-each (lambda (i)
                          (打印行 "  mov ~a, ~a(%%rbp)" 寄存器1 (+ (变量 '偏移) i))
                          (打印行 "  shr $8, ~a" 寄存器2))
                        (iota 8 8)))))))

;; 复制结构体寄存器
(define (复制结构体寄存器)
  (let ((类型 (当前函数 '类型 '返回类型))
        (通用寄存器 0)
        (浮点寄存器 0))
    (打印行 "  mov %%rax, %%rdi")
    (if (包含浮点数 类型 0 8 0)
        (if (equal? (类型 '大小) 4)
            (打印行 "  movss (%%rdi), %%xmm0")
            (打印行 "  movsd (%%rdi), %%xmm0"))
        (begin
          (打印行 "  mov $0, %%rax")
          (for-each (lambda (i)
                      (打印行 "  shl $8, %%rax")
                      (打印行 "  mov ~a(%%rdi), %%al" i))
                    (iota (min 8 (类型 '大小)) -1))))
    (if (> (类型 '大小) 8)
        (if (包含浮点数 类型 8 16 0)
            (if (equal? (类型 '大小) 12)
                (打印行 "  movss 8(%%rdi), %%xmm~a" 浮点寄存器)
                (打印行 "  movsd 8(%%rdi), %%xmm~a" 浮点寄存器))
            (let ((寄存器1 (if (equal? 通用寄存器 0) "%al" "%dl"))
                  (寄存器2 (if (equal? 通用寄存器 0) "%rax" "%rdx")))
              (打印行 "  mov $0, ~a" 寄存器2)
              (for-each (lambda (i)
                          (打印行 "  shl $8, ~a" 寄存器2)
                          (打印行 "  mov ~a(%%rdi), ~a" i 寄存器1))
                        (iota (min 16 (类型 '大小)) 7 -1)))))))

;; 复制结构体内存
(define (复制结构体内存)
  (let ((类型 (当前函数 '类型 '返回类型))
        (变量 (当前函数 '参数)))
    (打印行 "  mov ~a(%%rbp), %%rdi" (变量 '偏移))
    (for-each (lambda (i)
                (打印行 "  mov ~a(%%rax), %%dl" i)
                (打印行 "  mov %%dl, ~a(%%rdi)" i))
              (iota (类型 '大小)))))

;; 内置 alloca 函数
(define (内置_alloca)
  (打印行 "  add $15, %%rdi")
  (打印行 "  and $0xfffffff0, %%edi")
  (打印行 "  mov ~a(%%rbp), %%rcx" ((当前函数 'alloca_bottom) '偏移))
  (打印行 "  sub %%rsp, %%rcx")
  (打印行 "  mov %%rsp, %%rax")
  (打印行 "  sub %%rdi, %%rsp")
  (打印行 "  mov %%rsp, %%rdx")
  (打印行 "1:")
  (打印行 "  cmp $0, %%rcx")
  (打印行 "  je 2f")
  (打印行 "  mov (%%rax), %%r8b")
  (打印行 "  mov %%r8b, (%%rdx)")
  (打印行 "  inc %%rdx")
  (打印行 "  inc %%rax")
  (打印行 "  dec %%rcx")
  (打印行 "  jmp 1b")
  (打印行 "2:")
  (打印行 "  mov ~a(%%rbp), %%rax" ((当前函数 'alloca_bottom) '偏移))
  (打印行 "  sub %%rdi, %%rax")
  (打印行 "  mov %%rax, ~a(%%rbp)" ((当前函数 'alloca_bottom) '偏移)))

;; 生成给定节点的代码
(define (生成表达式 节点)
  (打印行 "  .loc ~a ~a" ((节点 '标记) '文件 '文件编号) ((节点 '标记) '行号))
  (cond
    ((equal? (节点 '类型) "空表达式")
     #f)
    ((equal? (节点 '类型) "数值")
     (if (equal? ((节点 '类型) '类型) "浮点数")
         (let ((u (make-u "f32" (节点 '浮点值) "u32" 0)))
           (打印行 "  mov $~a, %%eax  # float ~a" (u 'u32) (节点 '浮点值))
           (打印行 "  movq %%rax, %%xmm0"))
         (if (equal? ((节点 '类型) '类型) "双精度浮点数")
             (let ((u (make-u "f64" (节点 '浮点值) "u64" 0)))
               (打印行 "  mov $~a, %%rax  # double ~a" (u 'u64) (节点 '浮点值))
               (打印行 "  movq %%rax, %%xmm0"))
             (if (equal? ((节点 '类型) '类型) "长双精度浮点数")
                 (let ((u (make-u "f80" (节点 '浮点值) "u64" (list 0 0))))
                   (memset u 0 (sizeof u))
                   (u 'f80 (节点 '浮点值))
                   (打印行 "  mov $~a, %%rax  # long double ~a" (u 'u64 0) (节点 '浮点值))
                   (打印行 "  mov %%rax, -16(%%rsp)")
                   (打印行 "  mov $~a, %%rax" (u 'u64 1))
                   (打印行 "  mov %%rax, -8(%%rsp)")
                   (打印行 "  fldt -16(%%rsp)"))
                 (打印行 "  mov $~a, %%rax" (节点 '值)))))
    ((equal? (节点 '类型) "负数")
     (生成表达式 (节点 '左))
     (if (equal? ((节点 '类型) '类型) "浮点数")
         (begin
           (打印行 "  mov $1, %%rax")
           (打印行 "  shl $31, %%rax")
           (打印行 "  movq %%rax, %%xmm1")
           (打印行 "  xorps %%xmm1, %%xmm0"))
         (if (equal? ((节点 '类型) '类型) "双精度浮点数")
             (begin
               (打印行 "  mov $1, %%rax")
               (打印行 "  shl $63, %%rax")
               (打印行 "  movq %%rax, %%xmm1")
               (打印行 "  xorpd %%xmm1, %%xmm0"))
             (if (equal? ((节点 '类型) '类型) "长双精度浮点数")
                 (打印行 "  fchs")
                 (打印行 "  neg %%rax")))))
    ((equal? (节点 '类型) "变量")
     (生成地址 节点)
     (加载 (节点 '类型)))
    ((equal? (节点 '类型) "成员")
     (生成地址 节点)
     (加载 (节点 '类型))
     (let ((成员 (节点 '成员)))
       (if (成员 '是位域)
           (begin
             (打印行 "  shl $~a, %%rax" (- 64 (成员 '位宽) (成员 '位偏移)))
             (if (成员 '类型 '是无符号)
                 (打印行 "  shr $~a, %%rax" (- 64 (成员 '位宽)))
                 (打印行 "  sar $~a, %%rax" (- 64 (成员 '位宽))))))))
    ((equal? (节点 '类型) "解引用")
     (生成表达式 (节点 '左))
     (加载 (节点 '类型)))
    ((equal? (节点 '类型) "地址")
     (生成地址 (节点 '左)))
    ((equal? (节点 '类型) "赋值")
     (生成地址 (节点 '左))
     (压栈)
     (生成表达式 (节点 '右))
     (if (and (equal? (节点 '左 '类型) "成员") ((节点 '左 '成员) '是位域))
         (begin
           (打印行 "  mov %%rax, %%r8")
           (let ((成员 (节点 '左 '成员)))
             (打印行 "  mov %%rax, %%rdi")
             (打印行 "  and $~a, %%rdi" (- (expt 2 (成员 '位宽)) 1))
             (打印行 "  shl $~a, %%rdi" (成员 '位偏移))
             (打印行 "  mov (%%rsp), %%rax")
             (加载 (成员 '类型))
             (let ((掩码 (- (expt 2 (成员 '位宽)) 1)))
               (打印行 "  mov $~a, %%r9" (- 掩码))
               (打印行 "  and %%r9, %%rax")
               (打印行 "  or %%rdi, %%rax")
               (存储 (节点 '类型))
               (打印行 "  mov %%r8, %%rax"))))
         (存储 (节点 '类型))))
    ((equal? (节点 '类型) "语句表达式")
     (for-each 生成语句 (节点 '主体)))
    ((equal? (节点 '类型) "逗号")
     (生成表达式 (节点 '左))
     (生成表达式 (节点 '右)))
    ((equal? (节点 '类型) "类型转换")
     (生成表达式 (节点 '左))
     (类型转换 (节点 '左 '类型) (节点 '类型)))
    ((equal? (节点 '类型) "内存清零")
     (打印行 "  mov $~a, %%rcx" ((节点 '变量 '类型) '大小))
     (打印行 "  lea ~a(%%rbp), %%rdi" ((节点 '变量) '偏移))
     (打印行 "  mov $0, %%al")
     (打印行 "  rep stosb"))
    ((equal? (节点 '类型) "条件")
     (let ((计数 (计数)))
       (生成表达式 (节点 '条件))
       (比较零 (节点 '条件 '类型))
       (打印行 "  je .L.else.~a" 计数)
       (生成表达式 (节点 '然后))
       (打印行 "  jmp .L.end.~a" 计数)
       (打印行 ".L.else.~a:" 计数)
       (if (节点 '否则)
           (生成表达式 (节点 '否则)))
       (打印行 ".L.end.~a:" 计数)))
    ((equal? (节点 '类型) "非")
     (生成表达式 (节点 '左))
     (比较零 (节点 '左 '类型))
     (打印行 "  sete %%al")
     (打印行 "  movzx %%al, %%rax"))
    ((equal? (节点 '类型) "位非")
     (生成表达式 (节点 '左))
     (打印行 "  not %%rax"))
    ((equal? (节点 '类型) "逻辑与")
     (let ((计数 (计数)))
       (生成表达式 (节点 '左))
       (比较零 (节点 '左 '类型))
       (打印行 "  je .L.false.~a" 计数)
       (生成表达式 (节点 '右))
       (比较零 (节点 '右 '类型))
       (打印行 "  je .L.false.~a" 计数)
       (打印行 "  mov $1, %%rax")
       (打印行 "  jmp .L.end.~a" 计数)
       (打印行 ".L.false.~a:" 计数)
       (打印行 "  mov $0, %%rax")
       (打印行 ".L.end.~a:" 计数)))
    ((equal? (节点 '类型) "逻辑或")
     (let ((计数 (计数)))
       (生成表达式 (节点 '左))
       (比较零 (节点 '左 '类型))
       (打印行 "  jne .L.true.~a" 计数)
       (生成表达式 (节点 '右))
       (比较零 (节点 '右 '类型))
       (打印行 "  jne .L.true.~a" 计数)
       (打印行 "  mov $0, %%rax")
       (打印行 "  jmp .L.end.~a" 计数)
       (打印行 ".L.true.~a:" 计数)
       (打印行 "  mov $1, %%rax")
       (打印行 ".L.end.~a:" 计数)))
    ((equal? (节点 '类型) "函数调用")
     (if (and (equal? (节点 '左 '类型) "变量") (not (strcmp ((节点 '左 '变量) '名称) "alloca")))
         (begin
           (生成表达式 (节点 '参数))
           (打印行 "  mov %%rax, %%rdi")
           (内置_alloca))
         (let ((栈参数 (压入参数 节点)))
           (生成表达式 (节点 '左))
           (let ((通用寄存器 0)
                 (浮点寄存器 0))
             (if (and (节点 '返回缓冲区) (> ((节点 '类型) '大小) 16))
                 (begin
                   (弹栈 (参数寄存器64 通用寄存器))
                   (set! 通用寄存器 (+ 通用寄存器 1))))
             (for-each (lambda (参数)
                         (let ((类型 (参数 '类型)))
                           (cond
                             ((member (类型 '类型) '("结构体" "联合体"))
                              (if (> (类型 '大小) 16)
                                  #f
                                  (let ((浮点数1 (包含浮点数1 类型))
                                        (浮点数2 (包含浮点数2 类型)))
                                    (if (and (< (+ 浮点寄存器 浮点数1 浮点数2) 浮点寄存器最大数量)
                                             (< (+ 通用寄存器 (not 浮点数1) (not 浮点数2)) 通用寄存器最大数量))
                                        (begin
                                          (if 浮点数1
                                              (弹栈浮点 浮点寄存器)
                                              (弹栈 (参数寄存器64 通用寄存器)))
                                          (set! 浮点寄存器 (+ 浮点寄存器 浮点数1 浮点数2))
                                          (set! 通用寄存器 (+ 通用寄存器 (not 浮点数1) (not 浮点数2))))
                                        #f)))))
                             ((member (类型 '类型) '("浮点数" "双精度浮点数"))
                              (if (< 浮点寄存器 浮点寄存器最大数量)
                                  (begin
                                    (弹栈浮点 浮点寄存器)
                                    (set! 浮点寄存器 (+ 浮点寄存器 1)))
                                  #f))
                             ((equal? (类型 '类型) "长双精度浮点数")
                              #f)
                             (else
                              (if (< 通用寄存器 通用寄存器最大数量)
                                  (begin
                                    (弹栈 (参数寄存器64 通用寄存器))
                                    (set! 通用寄存器 (+ 通用寄存器 1)))
                                  #f)))))
                       (节点 '参数))
             (打印行 "  mov %%rax, %%r10")
             (打印行 "  mov $~a, %%rax" 浮点寄存器)
             (打印行 "  call *%%r10")
             (打印行 "  add $~a, %%rsp" (* 栈参数 8))
             (set! 深度 (- 深度 栈参数))
             (if (equal? ((节点 '类型) '类型) "布尔")
                 (打印行 "  movzx %%al, %%eax"))
             (if (equal? ((节点 '类型) '类型) "字符")
                 (if ((节点 '类型) '是无符号)
                     (打印行 "  movzbl %%al, %%eax")
                     (打印行 "  movsbl %%al, %%eax")))
             (if (equal? ((节点 '类型) '类型) "短整数")
                 (if ((节点 '类型) '是无符号)
                     (打印行 "  movzwl %%ax, %%eax")
                     (打印行 "  movswl %%ax, %%eax")))
             (if (and (节点 '返回缓冲区) (<= ((节点 '类型) '大小) 16))
                 (begin
                   (复制返回缓冲区 (节点 '返回缓冲区))
                   (打印行 "  lea ~a(%%rbp), %%rax" ((节点 '返回缓冲区) '偏移)))))))
    ((equal? (节点 '类型) "标签值")
     (打印行 "  lea ~a(%%rip), %%rax" (节点 '唯一标签)))
    ((equal? (节点 '类型) "CAS")
     (生成表达式 (节点 'CAS地址))
     (压栈)
     (生成表达式 (节点 'CAS新值))
     (压栈)
     (生成表达式 (节点 'CAS旧值))
     (打印行 "  mov %%rax, %%r8")
     (加载 ((节点 'CAS旧值 '类型) '基类型))
     (弹栈 "%rdx")  ; 新值
     (弹栈 "%rdi")  ; 地址
     (let ((大小 ((节点 'CAS地址 '类型) '基类型 '大小)))
       (打印行 "  lock cmpxchg ~a, (%%rdi)" (寄存器_dx 大小))
       (打印行 "  sete %%cl")
       (打印行 "  je 1f")
       (打印行 "  mov ~a, (%%r8)" (寄存器_ax 大小))
       (打印行 "1:")
       (打印行 "  movzbl %%cl, %%eax")))
    ((equal? (节点 '类型) "交换")
     (生成表达式 (节点 '左))
     (压栈)
     (生成表达式 (节点 '右))
     (弹栈 "%rdi")
     (let ((大小 ((节点 '左 '类型) '基类型 '大小)))
       (打印行 "  xchg ~a, (%%rdi)" (寄存器_ax 大小))))
    (else
     (if (member ((节点 '左 '类型) '类型) '("浮点数" "双精度浮点数"))
         (begin
           (生成表达式 (节点 '右))
           (压栈浮点)
           (生成表达式 (节点 '左))
           (弹栈浮点 1)
           (let ((大小 (if (equal? ((节点 '左 '类型) '类型) "浮点数") "ss" "sd")))
             (cond
               ((equal? (节点 '类型) "加")
                (打印行 "  add~a %%xmm1, %%xmm0" 大小))
               ((equal? (节点 '类型) "减")
                (打印行 "  sub~a %%xmm1, %%xmm0" 大小))
               ((equal? (节点 '类型) "乘")
                (打印行 "  mul~a %%xmm1, %%xmm0" 大小))
               ((equal? (节点 '类型) "除")
                (打印行 "  div~a %%xmm1, %%xmm0" 大小))
               ((member (节点 '类型) '("等于" "不等于" "小于" "小于等于"))
                (打印行 "  ucomi~a %%xmm0, %%xmm1" 大小)
                (cond
                  ((equal? (节点 '类型) "等于")
                   (打印行 "  sete %%al")
                   (打印行 "  setnp %%dl")
                   (打印行 "  and %%dl, %%al"))
                  ((equal? (节点 '类型) "不等于")
                   (打印行 "  setne %%al")
                   (打印行 "  setp %%dl")
                   (打印行 "  or %%dl, %%al"))
                  ((equal? (节点 '类型) "小于")
                   (打印行 "  seta %%al"))
                  ((equal? (节点 '类型) "小于等于")
                   (打印行 "  setae %%al")))
                (打印行 "  and $1, %%al")
                (打印行 "  movzb %%al, %%rax"))
               (else
                (错误_tok (节点 '标记) "无效表达式"))))
         (if (equal? ((节点 '左 '类型) '类型) "长双精度浮点数")
             (begin
               (生成表达式 (节点 '左))
               (生成表达式 (节点 '右))
               (cond
                 ((equal? (节点 '类型) "加")
                  (打印行 "  faddp"))
                 ((equal? (节点 '类型) "减")
                  (打印行 "  fsubrp"))
                 ((equal? (节点 '类型) "乘")
                  (打印行 "  fmulp"))
                 ((equal? (节点 '类型) "除")
                  (打印行 "  fdivrp"))
                 ((member (节点 '类型) '("等于" "不等于" "小于" "小于等于"))
                  (打印行 "  fcomip")
                  (打印行 "  fstp %%st(0)")
                  (cond
                    ((equal? (节点 '类型) "等于")
                     (打印行 "  sete %%al"))
                    ((equal? (节点 '类型) "不等于")
                     (打印行 "  setne %%al"))
                    ((equal? (节点 '类型) "小于")
                     (打印行 "  seta %%al"))
                    ((equal? (节点 '类型) "小于等于")
                     (打印行 "  setae %%al")))
                  (打印行 "  movzb %%al, %%rax"))
                 (else
                  (错误_tok (节点 '标记) "无效表达式"))))
             (begin
               (生成表达式 (节点 '右))
               (压栈)
               (生成表达式 (节点 '左))
               (弹栈 "%rdi")
               (let ((寄存器_ax (寄存器_ax ((节点 '左 '类型) '大小)))
                     (寄存器_di (寄存器_di ((节点 '左 '类型) '大小)))
                     (寄存器_dx (寄存器_dx ((节点 '左 '类型) '大小))))
                 (cond
                   ((equal? (节点 '类型) "加")
                    (打印行 "  add ~a, ~a" 寄存器_di 寄存器_ax))
                   ((equal? (节点 '类型) "减")
                    (打印行 "  sub ~a, ~a" 寄存器_di 寄存器_ax))
                   ((equal? (节点 '类型) "乘")
                    (打印行 "  imul ~a, ~a" 寄存器_di 寄存器_ax))
                   ((or (equal? (节点 '类型) "除") (equal? (节点 '类型) "取模"))
                    (if ((节点 '类型) '是无符号)
                        (打印行 "  mov $0, ~a" 寄存器_dx)
                        (if (equal? ((节点 '左 '类型) '大小) 8)
                            (打印行 "  cqo")
                            (打印行 "  cdq")))
                    (打印行 "  idiv ~a" 寄存器_di)
                    (if (equal? (节点 '类型) "取模")
                        (打印行 "  mov %%rdx, %%rax")))
                   ((equal? (节点 '类型) "位与")
                    (打印行 "  and ~a, ~a" 寄存器_di 寄存器_ax))
                   ((equal? (节点 '类型) "位或")
                    (打印行 "  or ~a, ~a" 寄存器_di 寄存器_ax))
                   ((equal? (节点 '类型) "位异或")
                    (打印行 "  xor ~a, ~a" 寄存器_di 寄存器_ax))
                   ((member (节点 '类型) '("等于" "不等于" "小于" "小于等于"))
                    (打印行 "  cmp ~a, ~a" 寄存器_di 寄存器_ax)
                    (cond
                      ((equal? (节点 '类型) "等于")
                       (打印行 "  sete %%al"))
                      ((equal? (节点 '类型) "不等于")
                       (打印行 "  setne %%al"))
                      ((equal? (节点 '类型) "小于")
                       (if ((节点 '左 '类型) '是无符号)
                           (打印行 "  setb %%al")
                           (打印行 "  setl %%al")))
                      ((equal? (节点 '类型) "小于等于")
                       (if ((节点 '左 '类型) '是无符号)
                           (打印行 "  setbe %%al")
                           (打印行 "  setle %%al"))))
                    (打印行 "  movzb %%al, %%rax"))
                   ((equal? (节点 '类型) "左移")
                    (打印行 "  mov %%rdi, %%rcx")
                    (打印行 "  shl %%cl, ~a" 寄存器_ax))
                   ((equal? (节点 '类型) "右移")
                    (打印行 "  mov %%rdi, %%rcx")
                    (if ((节点 '左 '类型) '是无符号)
                        (打印行 "  shr %%cl, ~a" 寄存器_ax)
                        (打印行 "  sar %%cl, ~a" 寄存器_ax)))
                   (else
                    (错误_tok (节点 '标记) "无效表达式")))))))))

;; 生成给定语句的代码
(define (生成语句 节点)
  (打印行 "  .loc ~a ~a" ((节点 '标记) '文件 '文件编号) ((节点 '标记) '行号))
  (cond
    ((equal? (节点 '类型) "IF")
     (let ((计数 (计数)))
       (生成表达式 (节点 '条件))
       (比较零 (节点 '条件 '类型))
       (打印行 "  je .L.else.~a" 计数)
       (生成语句 (节点 '然后))
       (打印行 "  jmp .L.end.~a" 计数)
       (打印行 ".L.else.~a:" 计数)
       (if (节点 '否则)
           (生成语句 (节点 '否则)))
       (打印行 ".L.end.~a:" 计数)))
    ((equal? (节点 '类型) "FOR")
     (let ((计数 (计数)))
       (if (节点 '初始化)
           (生成语句 (节点 '初始化)))
       (打印行 ".L.begin.~a:" 计数)
       (if (节点 '条件)
           (begin
             (生成表达式 (节点 '条件))
             (比较零 (节点 '条件 '类型))
             (打印行 "  je ~a" (节点 '跳出标签))))
       (生成语句 (节点 '然后))
       (打印行 "~a:" (节点 '继续标签))
       (if (节点 '增量)
           (生成表达式 (节点 '增量)))
       (打印行 "  jmp .L.begin.~a" 计数)
       (打印行 "~a:" (节点 '跳出标签))))
    ((equal? (节点 '类型) "DO")
     (let ((计数 (计数)))
       (打印行 ".L.begin.~a:" 计数)
       (生成语句 (节点 '然后))
       (打印行 "~a:" (节点 '继续标签))
       (生成表达式 (节点 '条件))
       (比较零 (节点 '条件 '类型))
       (打印行 "  jne .L.begin.~a" 计数)
       (打印行 "~a:" (节点 '跳出标签))))
    ((equal? (节点 '类型) "SWITCH")
     (生成表达式 (节点 '条件))
     (for-each (lambda (n)
                 (let ((寄存器_ax (if (equal? ((节点 '条件 '类型) '大小) 8) "%rax" "%eax"))
                       (寄存器_di (if (equal? ((节点 '条件 '类型) '大小) 8) "%rdi" "%edi")))
                   (if (= (n '开始) (n '结束))
                       (begin
                         (打印行 "  cmp $~a, ~a" (n '开始) 寄存器_ax)
                         (打印行 "  je ~a" (n '标签)))
                       (begin
                         (打印行 "  mov ~a, ~a" 寄存器_ax 寄存器_di)
                         (打印行 "  sub $~a, ~a" (n '开始) 寄存器_di)
                         (打印行 "  cmp $~a, ~a" (- (n '结束) (n '开始)) 寄存器_di)
                         (打印行 "  jbe ~a" (n '标签))))))
               (节点 '下一个情况))
     (if (节点 '默认情况)
         (打印行 "  jmp ~a" ((节点 '默认情况) '标签)))
     (打印行 "  jmp ~a" (节点 '跳出标签))
     (生成语句 (节点 '然后))
     (打印行 "~a:" (节点 '跳出标签)))
    ((equal? (节点 '类型) "CASE")
     (打印行 "~a:" (节点 '标签))
     (生成语句 (节点 '左)))
    ((equal? (节点 '类型) "BLOCK")
     (for-each 生成语句 (节点 '主体)))
    ((equal? (节点 '类型) "GOTO")
     (打印行 "  jmp ~a" (节点 '唯一标签)))
    ((equal? (节点 '类型) "GOTO_EXPR")
     (生成表达式 (节点 '左))
     (打印行 "  jmp *%%rax"))
    ((equal? (节点 '类型) "LABEL")
     (打印行 "~a:" (节点 '唯一标签))
     (生成语句 (节点 '左)))
    ((equal? (节点 '类型) "RETURN")
     (if (节点 '左)
         (begin
           (生成表达式 (节点 '左))
           (let ((类型 (节点 '左 '类型)))
             (if (member (类型 '类型) '("结构体" "联合体"))
                 (if (<= (类型 '大小) 16)
                     (复制结构体寄存器)
                     (复制结构体内存))))))
     (打印行 "  jmp .L.return.~a" (当前函数 '名称)))
    ((equal? (节点 '类型) "表达式语句")
     (生成表达式 (节点 '左)))
    ((equal? (节点 '类型) "ASM")
     (打印行 "  ~a" (节点 '汇编字符串)))
    (else
     (错误_tok (节点 '标记) "无效语句"))))

;; 为局部变量分配偏移量
(define (分配局部变量偏移量 程序)
  (for-each (lambda (函数)
              (if (函数 '是函数)
                  (let ((顶部 16)
                        (底部 0)
                        (通用寄存器 0)
                        (浮点寄存器 0))
                    (for-each (lambda (变量)
                                (let ((类型 (变量 '类型)))
                                  (cond
                                    ((member (类型 '类型) '("结构体" "联合体"))
                                     (if (<= (类型 '大小) 16)
                                         (let ((浮点数1 (包含浮点数 类型 0 8 0))
                                               (浮点数2 (包含浮点数 类型 8 16 8)))
                                           (if (and (< (+ 浮点寄存器 浮点数1 浮点数2) 浮点寄存器最大数量)
                                                    (< (+ 通用寄存器 (not 浮点数1) (not 浮点数2)) 通用寄存器最大数量))
                                               (begin
                                                 (set! 浮点寄存器 (+ 浮点寄存器 浮点数1 浮点数2))
                                                 (set! 通用寄存器 (+ 通用寄存器 (not 浮点数1) (not 浮点数2))))
                                               (begin
                                                 (set! 顶部 (对齐到 顶部 8))
                                                 (set! (变量 '偏移) 顶部)
                                                 (set! 顶部 (+ 顶部 (类型 '大小))))))
                                         (begin
                                           (set! 顶部 (对齐到 顶部 8))
                                           (set! (变量 '偏移) 顶部)
                                           (set! 顶部 (+ 顶部 (类型 '大小))))))
                                    ((member (类型 '类型) '("浮点数" "双精度浮点数"))
                                     (if (< 浮点寄存器 浮点寄存器最大数量)
                                         (set! 浮点寄存器 (+ 浮点寄存器 1))
                                         (begin
                                           (set! 顶部 (对齐到 顶部 8))
                                           (set! (变量 '偏移) 顶部)
                                           (set! 顶部 (+ 顶部 (类型 '大小))))))
                                    ((equal? (类型 '类型) "长双精度浮点数")
                                     (begin
                                       (set! 顶部 (对齐到 顶部 8))
                                       (set! (变量 '偏移) 顶部)
                                       (set! 顶部 (+ 顶部 (类型 '大小)))))
                                    (else
                                     (if (< 通用寄存器 通用寄存器最大数量)
                                         (set! 通用寄存器 (+ 通用寄存器 1))
                                         (begin
                                           (set! 顶部 (对齐到 顶部 8))
                                           (set! (变量 '偏移) 顶部)
                                           (set! 顶部 (+ 顶部 (类型 '大小)))))))))
                              (函数 '参数))
                    (for-each (lambda (变量)
                                (if (变量 '偏移)
                                    #f
                                    (let ((对齐 (if (and (equal? ((变量 '类型) '类型) "数组") (>= ((变量 '类型) '大小) 16))
                                                    16
                                                    (变量 '对齐))))
                                      (set! 底部 (+ 底部 (变量 '类型 '大小)))
                                      (set! 底部 (对齐到 底部 对齐))
                                      (set! (变量 '偏移) (- 底部)))))
                              (函数 '局部变量))
                    (set! (函数 '栈大小) (对齐到 底部 16)))))
            (程序 '函数)))

;; 输出数据段
(define (输出数据段 程序)
  (for-each (lambda (变量)
              (if (and (not (变量 '是函数)) (变量 '是定义))
                  (begin
                    (if (变量 '是静态)
                        (打印行 "  .local ~a" (变量 '名称))
                        (打印行 "  .globl ~a" (变量 '名称)))
                    (let ((对齐 (if (and (equal? ((变量 '类型) '类型) "数组") (>= ((变量 '类型) '大小) 16))
                                     16
                                     (变量 '对齐))))
                      (if (and opt_fcommon (变量 '是暂定))
                          (打印行 "  .comm ~a, ~a, ~a" (变量 '名称) ((变量 '类型) '大小) 对齐)
                          (if (变量 '初始化数据)
                              (begin
                                (if (变量 '是线程局部)
                                    (打印行 "  .section .tdata,\"awT\",@progbits")
                                    (打印行 "  .data"))
                                (打印行 "  .type ~a, @object" (变量 '名称))
                                (打印行 "  .size ~a, ~a" (变量 '名称) ((变量 '类型) '大小))
                                (打印行 "  .align ~a" 对齐)
                                (打印行 "~a:" (变量 '名称))
                                (let ((重定位 (变量 '重定位))
                                      (位置 0))
                                  (while (< 位置 ((变量 '类型) '大小))
                                    (if (and 重定位 (= (重定位 '偏移) 位置))
                                        (begin
                                          (打印行 "  .quad ~a%+ld" (重定位 '标签) (重定位 '加数))
                                          (set! 重定位 (重定位 '下一个))
                                          (set! 位置 (+ 位置 8)))
                                        (begin
                                          (打印行 "  .byte ~a" (vector-ref (变量 '初始化数据) 位置))
                                          (set! 位置 (+ 位置 1)))))))
                              (begin
                                (if (变量 '是线程局部)
                                    (打印行 "  .section .tbss,\"awT\",@nobits")
                                    (打印行 "  .bss"))
                                (打印行 "  .align ~a" 对齐)
                                (打印行 "~a:" (变量 '名称))
                                (打印行 "  .zero ~a" ((变量 '类型) '大小)))))))))
            (程序 '变量)))

;; 存储浮点数寄存器
(define (存储浮点数寄存器 寄存器 偏移 大小)
  (cond
    ((= 大小 4)
     (打印行 "  movss %%xmm~a, ~a(%%rbp)" 寄存器 偏移))
    ((= 大小 8)
     (打印行 "  movsd %%xmm~a, ~a(%%rbp)" 寄存器 偏移))
    (else
     (error "不可达"))))

;; 存储通用寄存器
(define (存储通用寄存器 寄存器 偏移 大小)
  (cond 
    ((= 大小 1)
     (打印行 "  mov ~a, ~a(%%rbp)" (list-ref 参数寄存器8 寄存器) 偏移))
    ((= 大小 2)
     (打印行 "  mov ~a, ~a(%%rbp)" (list-ref 参数寄存器16 寄存器) 偏移))
    ((= 大小 4)
     (打印行 "  mov ~a, ~a(%%rbp)" (list-ref 参数寄存器32 寄存器) 偏移))
    ((= 大小 8)
     (打印行 "  mov ~a, ~a(%%rbp)" (list-ref 参数寄存器64 寄存器) 偏移))
    (else
     (for-each (lambda (i)
                 (打印行 "  mov ~a, ~a(%%rbp)" (list-ref 参数寄存器8 寄存器) (+ 偏移 i))
                 (打印行 "  shr $8, ~a" (list-ref 参数寄存器64 寄存器)))
               (iota 大小)))))

;; 输出代码段
(define (输出代码段 程序)
  (for-each (lambda (函数)
              (if (and (函数 '是函数) (函数 '是定义))
                  (begin
                    (if (not (函数 '是活跃))
                        #f
                        (begin
                          (if (函数 '是静态)
                              (打印行 "  .local ~a" (函数 '名称))
                              (打印行 "  .globl ~a" (函数 '名称)))
                          (打印行 "  .text")
                          (打印行 "  .type ~a, @function" (函数 '名称))
                          (打印行 "~a:" (函数 '名称))
                          (set! 当前函数 函数)
                          (打印行 "  push %%rbp")
                          (打印行 "  mov %%rsp, %%rbp")
                          (打印行 "  sub $~a, %%rsp" (函数 '栈大小))
                          (打印行 "  mov %%rsp, ~a(%%rbp)" ((函数 'alloca_bottom) '偏移))
                          (if (函数 'va_area)
                              (let ((通用寄存器 0)
                                    (浮点寄存器 0))
                                (for-each (lambda (变量)
                                            (if (是浮点数 (变量 '类型))
                                                (set! 浮点寄存器 (+ 浮点寄存器 1))
                                                (set! 通用寄存器 (+ 通用寄存器 1))))
                                          (函数 '参数))
                                (let ((偏移 ((函数 'va_area) '偏移)))
                                  (打印行 "  movl $~a, ~a(%%rbp)" (* 通用寄存器 8) 偏移)
                                  (打印行 "  movl $~a, ~a(%%rbp)" (+ (* 浮点寄存器 8) 48) (+ 偏移 4))
                                  (打印行 "  movq %%rbp, ~a(%%rbp)" (+ 偏移 8))
                                  (打印行 "  addq $16, ~a(%%rbp)" (+ 偏移 8))
                                  (打印行 "  movq %%rbp, ~a(%%rbp)" (+ 偏移 16))
                                  (打印行 "  addq $~a, ~a(%%rbp)" (+ 偏移 24) (+ 偏移 16))
                                  (打印行 "  movq %%rdi, ~a(%%rbp)" (+ 偏移 24))
                                  (打印行 "  movq %%rsi, ~a(%%rbp)" (+ 偏移 32))
                                  (打印行 "  movq %%rdx, ~a(%%rbp)" (+ 偏移 40))
                                  (打印行 "  movq %%rcx, ~a(%%rbp)" (+ 偏移 48))
                                  (打印行 "  movq %%r8, ~a(%%rbp)" (+ 偏移 56))
                                  (打印行 "  movq %%r9, ~a(%%rbp)" (+ 偏移 64))
                                  (打印行 "  movsd %%xmm0, ~a(%%rbp)" (+ 偏移 72))
                                  (打印行 "  movsd %%xmm1, ~a(%%rbp)" (+ 偏移 80))
                                  (打印行 "  movsd %%xmm2, ~a(%%rbp)" (+ 偏移 88))
                                  (打印行 "  movsd %%xmm3, ~a(%%rbp)" (+ 偏移 96))
                                  (打印行 "  movsd %%xmm4, ~a(%%rbp)" (+ 偏移 104))
                                  (打印行 "  movsd %%xmm5, ~a(%%rbp)" (+ 偏移 112))
                                  (打印行 "  movsd %%xmm6, ~a(%%rbp)" (+ 偏移 120))
                                  (打印行 "  movsd %%xmm7, ~a(%%rbp)" (+ 偏移 128)))))
                          (let ((通用寄存器 0)
                                (浮点寄存器 0))
                            (for-each (lambda (变量)
                                        (if (> (变量 '偏移) 0)
                                            #f
                                            (let ((类型 (变量 '类型)))
                                              (cond
                                                ((member (类型 '类型) '("结构体" "联合体"))
                                                 (if (<= (类型 '大小) 16)
                                                     (let ((浮点数1 (包含浮点数 类型 0 8 0))
                                                           (浮点数2 (包含浮点数 类型 8 16 8)))
                                                       (if (and (< (+ 浮点寄存器 浮点数1 浮点数2) 浮点寄存器最大数量)
                                                                (< (+ 通用寄存器 (not 浮点数1) (not 浮点数2)) 通用寄存器最大数量))
                                                           (begin
                                                             (if 浮点数1
                                                                 (存储浮点数寄存器 浮点寄存器 (变量 '偏移) (min 8 (类型 '大小)))
                                                                 (存储通用寄存器 通用寄存器 (变量 '偏移) (min 8 (类型 '大小))))
                                                             (set! 浮点寄存器 (+ 浮点寄存器 浮点数1 浮点数2))
                                                             (set! 通用寄存器 (+ 通用寄存器 (not 浮点数1) (not 浮点数2))))
                                                           #f))
                                                     #f))
                                                ((member (类型 '类型) '("浮点数" "双精度浮点数"))
                                                 (存储浮点数寄存器 浮点寄存器 (变量 '偏移) (类型 '大小))
                                                 (set! 浮点寄存器 (+ 浮点寄存器 1)))
                                                (else
                                                 (存储通用寄存器 通用寄存器 (变量 '偏移) (类型 '大小))
                                                 (set! 通用寄存器 (+ 通用寄存器 1)))))))
                                      (函数 '参数)))
                          (生成语句 (函数 '主体))
                          (assert (= 深度 0))
                          (if (equal? (函数 '名称) "main")
                              (打印行 "  mov $0, %%rax"))
                          (打印行 ".L.return.~a:" (函数 '名称))
                          (打印行 "  mov %%rbp, %%rsp")
                          (打印行 "  pop %%rbp")
                          (打印行 "  ret"))))))
            (程序 '函数)))

;; 代码生成
(define (代码生成 程序 输出文件)
  (set! 输出文件 输出文件)
  (let ((文件列表 (获取输入文件)))
    (for-each (lambda (文件)
                (if 文件
                    (打印行 "  .file ~a \"~a\"" (文件 '文件编号) (文件 '名称))))
              (map (lambda (i) (list-ref 文件列表 i)) (iota (length 文件列表)))))
  (分配局部变量偏移量 程序)
  (输出数据段 程序)
  (输出代码段 程序))
  
