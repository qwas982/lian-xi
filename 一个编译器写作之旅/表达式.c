#include "定义.h" // 引入自定义头文件 "定义.h"
#include "数据.h" // 引入自定义头文件 "数据.h"
#include "声明.h" // 引入自定义头文件 "声明.h"

//表达式的解析


// 解析一个句法因子并返回对应的 AST 节点
static struct 抽象句法树节点 *首要的(void) {
  struct 抽象句法树节点 *节点指针; // 定义一个 AST 节点指针

  // 对于整数字面量类型的 牌，创建对应的 AST 叶子节点，
  // 并扫描下一个 牌。否则，如果是其他类型的 牌，则报告句法错误。
  switch (大写_牌.牌) {
    case 牌子_整型字面: // 如果当前 牌 是整数字面量
      节点指针 = 制作抽象句法树叶子(抽象_整型字面, 大写_牌.整型值); // 创建一个对应的叶子节点
      扫描(&大写_牌); // 扫描下一个 牌
      return (节点指针); // 返回该节点的指针
    default: // 如果当前 牌 不是整数字面量
      fprintf(stderr, "句法错误在行: %d, 牌 %d\n", 行号, 大写_牌.牌); // 输出错误信息
      exit(1); // 退出程序
  }
}


// 将一个二元运算符的牌（牌）转换为抽象语法树（AST）操作。
static int 算术操作(int 牌类型) {
  switch (牌类型) { // 根据 牌 的值进行转换
    case 牌子_加号: // 如果 牌 是加号
      return (抽象_加); // 返回加法操作码
    case 牌子_减号: // 如果 牌 是减号
      return (抽象_减); // 返回减法操作码
    case 牌子_星号: // 如果 牌 是乘号
      return (抽象_乘); // 返回乘法操作码
    case 牌子_斜杠: // 如果 牌 是除号
      return (抽象_除); // 返回除法操作码
    default: // 如果 牌 是其他类型的 牌
      fprintf(stderr, "句法错误在行 %d, 牌 %d\n", 行号, 牌类型); // 输出错误信息
      exit(1); // 退出程序
  }
}

// 每个牌的运算符优先级
static int 运算符优先级[] = { 0, 10, 10, 20, 20, 0 }; //定义了一个静态数组 "OpPrec"，用于存储每个运算符的优先级。

// 检查是否为二元运算符并返回其优先级。
static int 运算符_优先级(int 牌类型) {
  // 获取给定牌的优先级
  int 短写_优先级 = 运算符优先级[牌类型];
  // 如果优先级为 0，说明该牌不是二元运算符，输出错误信息并退出程序
  if (短写_优先级 == 0) {
    fprintf(stderr, "句法错误在行 %d, 牌 %d\n", 行号, 牌类型);
    exit(1);
  }
  // 返回该运算符的优先级
  return (短写_优先级);
}

// 返回一个以二元操作符为根的AST树。
// 形参 前牌优 是前一个牌的优先级。
struct 抽象句法树节点 *二元表达式(int 前牌优) {
  struct 抽象句法树节点 *左子树, *右子树;
  int 牌类型;

  // 获取左边的整数字面值。
  // 同时获取下一个牌。
  左子树 = 首要的();

  // 如果我们遇到分号，则只返回左节点
  牌类型 = 大写_牌.牌;
  if (牌类型 == 牌子_分号)
    return (左子树);

  // 当前牌的优先级大于前一个牌的优先级时循环执行
  while (运算符_优先级(牌类型) > 前牌优) {
    // 获取下一个整数字面值
    扫描(&大写_牌);

    // 以我们的牌的优先级作为参数递归调用binexpr()来构建一个子树
    右子树 = 二元表达式(运算符优先级[牌类型]);

    // 将该子树与当前子树合并，并同时将牌转换为AST操作。
    左子树 = 制作抽象句法树节点(算术操作(牌类型), 左子树, 右子树, 0);

    // 更新当前牌的详细信息。
    // 如果我们遇到分号，则只返回左节点
    牌类型 = 大写_牌.牌;
    if (牌类型 == 牌子_分号)
      return (左子树);
  }

  // 当优先级相同或更低时返回当前树
  return (左子树);
}