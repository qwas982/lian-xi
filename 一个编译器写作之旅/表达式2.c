#include "定义.h" // 引入自定义头文件 "定义.h"
#include "数据.h" // 引入自定义头文件 "数据.h"
#include "声明.h" // 引入自定义头文件 "声明.h"

// 使用完全递归下降法解析表达式

// 解析主要因素并返回代表它的 AST 节点。
static struct 抽象句法树节点 *首要的(void) {
  struct 抽象句法树节点 *节点指针;

  // 对于 INTLIT 牌，创建一个叶子 AST 节点，并扫描下一个牌。否则，对于任何其他牌类型，会发生句法错误。
  switch (大写_牌.牌) {
    case 牌子_整型字面:
      节点指针 = 制作抽象句法树叶子(抽象_整型字面, 大写_牌.整型值); // 创建一个叶子节点，表示整型字面量
      扫描(&大写_牌); // 扫描下一个牌
      return (节点指针); // 返回该节点
    default:
      fprintf(stderr, "句法错误在行 %d, 牌 %d\n", 行号, 大写_牌.牌); // 输出错误信息
      exit(1); // 退出程序
  }
}

// 将二元运算符牌转换为 AST 操作符。
static int 算术操作(int 短写_牌) {
  switch (短写_牌) {
    case 牌子_加号:
      return (抽象_加); // 加法操作
    case 牌子_减号:
      return (抽象_减); // 减法操作
    case 牌子_星号:
      return (抽象_乘); // 乘法操作
    case 牌子_斜杠:
      return (抽象_除); // 除法操作
    default:
      fprintf(stderr, "句法错误在行 %d, 牌 %d\n", 行号, 短写_牌); // 输出错误信息
      exit(1); // 退出程序
  }
}

struct 抽象句法树节点 *加法_表达式(void);

// 返回一个根节点为 '*' 或 '/' 的二元操作符的 AST 树
struct 抽象句法树节点 *乘法_表达式(void) {
  struct 抽象句法树节点 *左子树, *右子树; // 声明指向 AST 节点的指针变量 左子树 和 右子树
  int 牌类型; // 声明一个表示牌类型的整型变量 牌类型

  // 获取左侧的整型字面量，并在此同时获取下一个牌
  左子树 = 首要的();

  // 如果没有剩余牌，则返回左节点
  牌类型 = 大写_牌.牌;
  if (牌类型 == 牌子_EOF)
    return (左子树);

  // 当牌为 '*' 或 '/' 时
  while ((牌类型 == 牌子_星号) || (牌类型 == 牌子_斜杠)) {
    // 获取下一个整型字面量
    扫描(&大写_牌);
    右子树 = 首要的();

    // 将右侧整型字面量与左侧整型字面量合并
    左子树 = 制作抽象句法树节点(算术操作(牌类型), 左子树, 右子树, 0);

    // 更新当前牌的详细信息
    // 如果没有剩余牌，则返回左节点
    牌类型 = 大写_牌.牌;
    if (牌类型 == 牌子_EOF)
      break;
  }

  // 返回已创建的 AST 树
  return (左子树);
}

// 返回一个根节点为 '+' 或 '-' 的二元操作符的 AST 树
struct 抽象句法树节点 *加法_表达式(void) {
  struct 抽象句法树节点 *左子树, *右子树; // 声明指向 AST 节点的指针变量 左子树 和 右子树
  int 牌类型; // 声明一个表示牌类型的整型变量 牌类型

  // 获取左子树，其优先级高于我们
  左子树 = 乘法_表达式();

  // 如果没有剩余牌，则返回左节点
  牌类型 = 大写_牌.牌;
  if (牌类型 == 牌子_EOF)
    return (左子树);

  // 缓存 '+' 或 '-' 的牌类型

  // 循环处理我们这一级别的牌
  while (1) {
    // 获取下一个整型字面量
    扫描(&大写_牌);

    // 获取右子树，其优先级高于我们
    右子树 = 乘法_表达式();

    // 使用低优先级操作符将两个子树连接起来
    左子树 = 制作抽象句法树节点(算术操作(牌类型), 左子树, 右子树, 0);

    // 获取下一个牌，其优先级与我们相同
    牌类型 = 大写_牌.牌;
    if (牌类型 == 牌子_EOF)
      break;
  }

  // 返回已创建的 AST 树
  return (左子树);
}

struct 抽象句法树节点 *二元表达式(int 节点指针) {
  return (加法_表达式());
}