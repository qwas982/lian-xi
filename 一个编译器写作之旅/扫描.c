#include "定义.h"
#include "数据.h"
#include "声明.h"

#include "wctype.h"
#include "wchar.h"

//词法扫描

// 返回字符串 s 中字符 c 的位置，如果 c 未找到则返回 -1
static int 字符位置(char *串, int 字符) {
  char *针;  // 定义一个字符指针 p

  针 = strchr(串, 字符);  // 使用库函数 strchr() 在字符串 s 中查找字符 c 的位置，返回字符指针
  return (针 ? 针 - 串 : -1);  // 如果找到了字符 c，返回字符指针 p 在字符串 s 中的位置，否则返回 -1
}

// 从输入文件中获取下一个字符
static int 下一个(void) {
  int 字符;

  if (放回) {  // 如果有放回的字符，则使用它
    字符 = 放回;
    放回 = 0;
    return (字符);
  }

  字符 = fgetc(入文件);  // 从输入文件中读取一个字符
  if ('\n' == 字符)
    行号++;  // 如果读取到的是换行符，则行数加一
  return (字符);
}

// 将一个不需要的字符放回到输入流中
static void 函_放回(int 字符) {
  放回 = 字符;  // 将字符 c 存储到全局变量 Putback 中
}

// 跳过不需要处理的输入，如空白符、换行符等。返回第一个需要处理的字符。
static int 跳过(void) {
  int 字符;

  字符 = 下一个();  // 获取下一个字符
  while (' ' == 字符 || '\t' == 字符 || '\n' == 字符 || '\r' == 字符 || '\f' == 字符) {  // 循环跳过空白符、制表符、换行符、回车符、换页符等
    字符 = 下一个();  // 获取下一个字符
  }
  return (字符);  // 返回第一个需要处理的字符
}

// 从输入流中扫描并返回一个整数字面量值，将该值存储为一个字符串
static int 扫描整数(int 字符) {
  int 键, 值 = 0;

  // 将每个字符转换为整数值
  while ((键 = 字符位置("0123456789", 字符)) >= 0) {
    值 = 值 * 10 + 键;  // 将当前字符转换为整数，并累加到 val 变量中
    字符 = 下一个();  // 获取下一个字符
  }

  // 遇到了一个非整数字符，将其放回
  函_放回(字符);
  return (值);  // 返回转换后的整数值
}


// 从输入文件中扫描标识符并将其存储在 标识符缓冲区[] 中，返回标识符的长度
static int 扫描标识(int 当前字符, char *标识符缓冲区, int 极限) {
  int 计数 = 0;

  // 允许数字、字母和下划线, 追加Unicode
  while (
        isalpha(当前字符) 
        || isdigit(当前字符) 
        || '_' == 当前字符 
        || iswalpha(当前字符) 
        || iswdigit(当前字符)
        ) {
    // 如果达到标识符长度限制，则报错，否则将字符添加到 标识符缓冲区[] 中并获取下一个字符
    if (极限 - 1 == 计数) {
      printf("标识符太长在行: %d\n", 行号);
      exit(1);
    } else if (计数 < 极限 - 1) {
      标识符缓冲区[计数++] = 当前字符;
    }
    当前字符 = 下一个();
  }
  // 遇到非法字符，将其放回。将 标识符缓冲区[] 设为 NUL 结尾并返回其长度
  函_放回(当前字符);
  标识符缓冲区[计数] = '\0';
  return (计数);
}

// 给定一个输入的单词，返回匹配的关键字牌号，如果不是关键字则返回 0。
// 根据单词的首字母进行判断，以避免使用 strcmp() 函数匹配所有的关键字。
static int 关键字(unsigned int *串) {
  switch (*串) {
    case 0x5370:
      if (!strcmp((const char*)串, "印"))
	return (牌子_印);
      break;
  }
  return (0);
}

// 扫描并返回输入流中找到的下一个 Token
// 如果 Token 有效，返回 1；如果没有 Token 了，返回 0。
int 扫描(struct 牌 *牌子) {
  int 字符, 牌类型;

  // 跳过空格
  字符 = 跳过();

  // 根据输入字符确定 Token
  switch (字符) {
  case EOF:
    牌子->牌 = 牌子_EOF;
    return (0);  // 没有 Token 了，返回 0
  case '+':
    牌子->牌 = 牌子_加号;
    break;
  case '-':
    牌子->牌 = 牌子_减号;
    break;
  case '*':
    牌子->牌 = 牌子_星号;
    break;
  case '/':
    牌子->牌 = 牌子_斜杠;
    break;
  default:

    // 如果是一个数字，则扫描其字面量整数值
    if (isdigit(字符) || iswdigit(字符)) {
      牌子->整型值 = 扫描整数(字符);
      牌子->牌 = 牌子_整型字面;
      break;
    } else if (isalpha(字符) || '_' == 字符 || iswalpha(字符)) {
    // 如果当前字符是字母或下划线，则读取一个关键字或标识符
    扫描标识(字符, 文本, 文本长度);

    // 如果它是一个已知的关键字，则返回该牌
    if (牌类型 == 关键字((unsigned int*)文本)) {
      牌子->牌 = 牌类型;
      break;
    }
    // 如果不是一个已知的关键字，则报错并退出程序
    printf("无法识别的符号 %s 在行 %d\n", 文本, 行号);
    exit(1);
  }
    // 字符不是任何一个已知的牌的一部分，错误
    printf("无法识别的字符 %c 在行 %d\n", 字符, 行号);
    exit(1);  // 遇到无法识别的字符，输出错误信息并退出程序
  }

  // 找到了一个 Token
  return (1);
}