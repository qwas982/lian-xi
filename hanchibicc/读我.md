#读我.md

#  chibicc: 一个小型C编译器

（旧版本已移至historical/old分支。这个是2020年9月上传的新版本。）

 chibicc是另一个实现了大多数C11特性的小型C编译器。
 尽管它仍然可能属于“玩具编译器”类别，就像其他小型编译器一样，
 但chibicc可以编译多个真实世界的程序，包括Git、SQLite、libpng和chibicc本身，
 而无需对编译后的程序进行修改。这些程序生成的可执行文件通过了相应的测试套件。
 因此，chibicc实际上支持各种C11特性，并能够正确编译数十万行真实世界的C代码。

 chibicc是我目前正在撰写的关于C编译器和低级编程的参考实现。
 本书采用了逐步增量的方法来涵盖广泛的主题；
 在第一章中，读者将实现一个“编译器”，它仅接受一个数字作为“语言”，
 然后每节书中都会逐步增加一个功能，直到编译器接受的语言与C11规范指定的语言相匹配。
 我从Abdulaziz Ghuloum的论文中借用了这种逐步增量的方法。

 每次提交都对应书中的一个章节。为此，不仅项目的最终状态，而且每次提交都经过精心编写，考虑了可读性。读者应该能够通过阅读一个或多个提交来了解如何实现 C 语言的某个特性。例如，这是如何实现 [while] 循环的提交:
 https://github.com/rui314/chibicc/commit/773115ab2a9c4b96f804311b95b20e9771f0190a
 这是如何实现[ [] ]运算符的提交:
 https://github.com/rui314/chibicc/commit/75fbd3dd6efde12eac8225d8b5723093836170a5
 这是如何实现[ ?: ]运算符的提交:
 https://github.com/rui314/chibicc/commit/1d0e942fd567a35d296d0f10b7693e98b3dd037c
 这是如何实现[线程局部变量]的提交:
 https://github.com/rui314/chibicc/commit/79644e54cc1805e54428cde68b20d6d493b76d34
 如果你有很多空闲时间，从[第一个提交]开始阅读可能会很有趣:
 https://github.com/rui314/chibicc/commit/0522e2d77e3ab82d3b80a5be8dbbdc8d4180561c

 如果你喜欢这个项目，请考虑在书籍发布时购买一本！😀我在这里发布源代码，让人们提前获取，因为我计划在出版书籍后以宽松的开源许可证进行发布。如果我不为源代码收费，对我来说将其保密没有太多意义。我希望在2021年出版这本书。
 你可以在这里注册，以在免费章节上线或书籍发布时收到通知:
 https://forms.gle/sgrMWHGeGjeeEJcX7

 我将 chibicc 读作 "chee bee cee cee"。"chibi" 在日语中表示 "mini" 或 "small"。"cc" 代表 C 编译器。

## 状态

 chibicc 支持几乎所有 C11 的必需特性和大部分可选特性，以及一些 GCC 的语言扩展。

 chibicc 支持的一些在小型编译器中经常缺失的特性包括（但不限于）：

 - 预处理器
 - float、double 和 long double（x87 80 位浮点数）
 - 位字段
 - alloca()
 - 可变长度数组
 - 复合字面量
 - 线程局部变量
 - 原子变量
 - 公共符号
 - 指定初始化器
 - L、u、U 和 u8 字符串字面量
 - 按值传递或返回结构体的函数，符合 x86-64 SystemV ABI 的规定

 chibicc 不支持复数、K&R 风格的函数原型和 GCC 风格的内联汇编。故意省略了双字符和三字符序列。

 当 chibicc 在源代码中发现错误时，会输出简单但友好的错误消息。

 chibicc 没有优化阶段。它生成的代码很糟糕，可能比 GCC 的输出慢两倍或更多。一旦前端完成，我计划添加一个优化阶段。

 我在 x86-64 的 Ubuntu 20.04 上作为开发平台。我对 chibicc 进行了一些小的修改，使其能在 Ubuntu 18.04、Fedora 32 和 Gentoo 2.6 上运行，但此时可移植性不是我的目标。它可能在除了 Ubuntu 20.04 之外的系统上工作或不工作。

## 内部

 chibicc 由以下阶段组成：

 chibicc 的内部结构如下：

 - Tokenize: 词法分析器将输入的字符串分解为标记列表并返回它们。

 - Preprocess: 预处理器以标记列表作为输入，并输出一个经过宏展开的新标记列表。它在展开宏的同时解释预处理指令。

 - Parse: 递归下降解析器从预处理器的输出中构建抽象语法树（AST）。它还为每个 AST 节点添加类型信息。

 - Codegen: 代码生成器为给定的 AST 节点生成汇编文本。

 chibicc 由这些阶段组成，每个阶段都有特定的功能，用于处理源代码并最终生成汇编文本。

##  贡献、参与



 当我在这个编译器中发现一个 bug 时，我会回到引入该 bug 的原始提交，并将提交历史重写，就好像从一开始就没有这个 bug。这是一种不寻常的修复 bug 的方式，但作为一本书的一部分，保持每个提交都没有 bug 是很重要的。

 因此，在这个仓库中，我不接受拉取请求。如果你发现了一个 bug，你可以给我发送一个拉取请求，但很可能我会阅读你的补丁，然后通过重写历史将其应用到我的之前的提交中。我会在某个地方署名你的名字，但你的修改将在提交到这个仓库之前被我重写。

 另外，请假设我会偶尔强制推送我的本地仓库到这个公共仓库以重写历史。如果你克隆了这个项目并在其基础上进行本地提交，当我强制推送新的提交时，你的修改将需要手动进行变基。

##  设计原则



 chibicc 的设计原则是简单性和源代码的可读性。为了实现这个目标，在编写代码时，我小心翼翼地避免过于聪明巧妙。让我解释一下这是什么意思。

 往往，当你熟悉代码库时，你会被诱惑着使用更多的抽象和巧妙的技巧来“改进”代码。但这种“改进”并不总是对初次阅读者来说更易读，实际上可能会降低可读性。我尽量避免这种陷阱。我编写这段代码不是为了自己，而是为了初次阅读者。

 如果你查看源代码，你会发现一些看起来很蠢的代码片段。这些代码是故意这样写的
 （但在某些地方我可能确实遗漏了一些东西）。以下是一些显著的例子：

-	 递归下降解析器包含许多看起来相似的函数，用于相似的生成语法规则。
	 你可能会想要通过使用高阶函数或宏来减少重复，从而“改进”它，
	 但我认为那样太复杂了。最好允许小的重复。

-	 chibicc在节省内存方面并不努力。例如，在标记器启动之前，整个输入源文件
	 首先被读取到内存中。

-	 如果我们知道n不会太大，那么慢速算法是可以接受的。
	 例如，在预处理器中，我们使用链表作为集合，因此成员检查的时间复杂度为O(n)，
	 其中n是集合的大小。但这没关系，因为我们知道n通常非常小。
	 即使n可能非常大，我仍然坚持使用简单的慢速算法，
	 直到基准测试证明这是一个瓶颈。

-	 每个AST节点类型仅使用`Node`结构的几个成员。
	 其他未使用的`Node`成员只会在运行时浪费内存。
	 我们可以使用共用体来节省内存，但我决定将所有内容都放在同一个结构体中。
	 我相信这种效率上的损失是可以忽略的。
	 即使它很重要，我们也可以随时更改代码以使用共用体。
	 我想避免过早优化。

-	 chibicc总是使用`calloc`来分配堆内存，`calloc`是`malloc`的变体，
	 它用零来清除内存。`calloc`比`malloc`稍微慢一些，但应该可以忽略不计。

-	 最后但并非最不重要的是，chibicc使用`calloc`分配内存，但从不调用`free`。
	 分配的堆内存直到进程退出后才被释放。
	 我确定这种内存管理策略（或者说缺乏策略）看起来非常奇怪，
	 但对于短期运行的程序（如编译器）来说是有道理的。
	 例如，D编程语言的编译器DMD出于相同的原因使用相同的内存管理方案。

##  关于作者

 我是Rui Ueyama。我是8cc的创建者，
 这是一个爱好级的C编译器，也是当前版本的LLVM lld链接器的原始创建者，
 它是各种操作系统和大规模构建系统使用的生产质量链接器。

##  引用

- [tcc](https://bellard.org/tcc/): 由Fabrice Bellard编写的小型C编译器。我从这个编译器中学到了很多，但是tcc和chibicc的设计有所不同。特别是，tcc是一种单遍编译器，而chibicc是一种多遍编译器。

- [lcc](https://github.com/drh/lcc): 另一个小型C编译器。创作者们还写了一本关于lcc内部实现的书，我发现这是一个很好的资源，可以了解编译器的实现方式。

- [An Incremental Approach to Compiler Construction]：《逐步构建编译器的方法》：这是一本关于编译器构建的渐进式方法的书籍。编译器是将高级编程语言转换为机器可执行代码的程序。这本书可能介绍了一种逐步构建编译器的方法。(http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf)

- [Rob Pike's 5 Rules of Programming]：《罗布·派克的编程五法则》：这是罗布·派克提出的关于编程的五个规则的书籍。罗布·派克是一位知名的计算机科学家，他在这本书中分享了他对编程的五个重要原则。这些原则可能包括编写简单、可读性强的代码、保持代码的清晰和模块化等方面的建议。(https://users.ece.utexas.edu/~adnan/pike.html)

[1] https://www.drdobbs.com/cpp/increasing-compiler-speed-by-over-75/240158941


DMD在内存分配上有一种巧妙的方式。由于编译器是短命的程序，并且速度至关重要，DMD只是简单地使用malloc进行内存分配，而不进行释放。

# 汉化与添加注释说明

一个热衷研究中文汉字汉语编程的业余打工人的实验施工作业,
我通过复制粘贴的方式,一个一个的函数复制到ChatGPT里,让它一行行地注释,
因为ChatGPT近段时间变得有些弱智,所以阅读者会看到各种注释风格的变化, 
这都是因为我给ChatGPT的提示在跟着它的智商掉线在不断调整,
因此有些注释和翻译我是人工添加的,并不是所有都依赖ChatGPT.