#include "chibicc.h"

类型 *类型_空的_小写 = &(类型){类型_空的, 1, 1};
类型 *类型_布尔_小写 = &(类型){类型_布尔, 1, 1};

类型 *类型_印刻_小写 = &(类型){类型_印刻, 1, 1};
类型 *类型_短的_小写 = &(类型){类型_短的, 2, 2};
类型 *类型_整型_小写 = &(类型){类型_整型, 4, 4};
类型 *类型_长的_小写 = &(类型){类型_长的, 8, 8};

类型 *类型_无符印刻_小写 = &(类型){类型_印刻, 1, 1, true};
类型 *类型_无符短的_小写 = &(类型){类型_短的, 2, 2, true};
类型 *类型_无符整型_小写 = &(类型){类型_整型, 4, 4, true};
类型 *类型_无符长的_小写 = &(类型){类型_长的, 8, 8, true};

类型 *类型_浮点_小写 = &(类型){类型_浮点, 4, 4};
类型 *类型_双浮_小写 = &(类型){类型_双浮, 8, 8};
类型 *类型_长双浮_小写 = &(类型){类型_长双浮, 16, 16};

static 类型 *new_type(类型种类 种类_小写, int 大小_小写, int 对齐_短_小写) {
  类型 *类型_小写_短 = calloc(1, sizeof(类型));
  类型_小写_短->种类_小写 = 种类_小写;
  类型_小写_短->大小_小写 = 大小_小写;
  类型_小写_短->对齐_短_小写 = 对齐_短_小写;
  return 类型_小写_短;
}

bool 是否_整数(类型 *类型_小写_短) {
  类型种类 k = 类型_小写_短->种类_小写;
  return k == 类型_布尔 || k == 类型_印刻 || k == 类型_短的 ||
         k == 类型_整型  || k == 类型_长的 || k == 类型_枚举;
}

bool 是否_浮点数目(类型 *类型_小写_短) {
  return 类型_小写_短->种类_小写 == 类型_浮点 || 类型_小写_短->种类_小写 == 类型_双浮 ||
         类型_小写_短->种类_小写 == 类型_长双浮;
}

bool 是否_数值(类型 *类型_小写_短) {
  return 是否_整数(类型_小写_短) || 是否_浮点数目(类型_小写_短);
}

bool 是否_兼容(类型 *t1, 类型 *t2) {
  if (t1 == t2)
    return true;

  if (t1->起源)
    return 是否_兼容(t1->起源, t2);

  if (t2->起源)
    return 是否_兼容(t1, t2->起源);

  if (t1->种类_小写 != t2->种类_小写)
    return false;

  switch (t1->种类_小写) {
  case 类型_印刻:
  case 类型_短的:
  case 类型_整型:
  case 类型_长的:
    return t1->是否_无符号 == t2->是否_无符号;
  case 类型_浮点:
  case 类型_双浮:
  case 类型_长双浮:
    return true;
  case 类型_指针:
    return 是否_兼容(t1->基础_小写, t2->基础_小写);
  case 类型_函: {
    if (!是否_兼容(t1->返回_类型, t2->返回_类型))
      return false;
    if (t1->是否_可变参数 != t2->是否_可变参数)
      return false;

    类型 *p1 = t1->形参们_短_小写;
    类型 *p2 = t2->形参们_短_小写;
    for (; p1 && p2; p1 = p1->下一个_小写, p2 = p2->下一个_小写)
      if (!是否_兼容(p1, p2))
        return false;
    return p1 == NULL && p2 == NULL;
  }
  case 类型_数组:
    if (!是否_兼容(t1->基础_小写, t2->基础_小写))
      return false;
    return t1->数组_长度 < 0 && t2->数组_长度 < 0 &&
           t1->数组_长度 == t2->数组_长度;
  }
  return false;
}

类型 *复制_类型(类型 *类型_小写_短) {
  类型 *ret = calloc(1, sizeof(类型));
  *ret = *类型_小写_短;
  ret->起源 = 类型_小写_短;
  return ret;
}

类型 *指针_到(类型 *基础_小写) {
  类型 *类型_小写_短 = new_type(类型_指针, 8, 8);
  类型_小写_短->基础_小写 = 基础_小写;
  类型_小写_短->是否_无符号 = true;
  return 类型_小写_短;
}

类型 *函_类型_小写(类型 *返回_类型) {
  // The C spec disallows sizeof(<函数_全_小写 type>), but
  // GCC allows that and the expression is evaluated to 1.
  类型 *类型_小写_短 = new_type(类型_函, 1, 1);
  类型_小写_短->返回_类型 = 返回_类型;
  return 类型_小写_短;
}

类型 *数组_的(类型 *基础_小写, int 长度_短) {
  类型 *类型_小写_短 = new_type(类型_数组, 基础_小写->大小_小写 * 长度_短, 基础_小写->对齐_短_小写);
  类型_小写_短->基础_小写 = 基础_小写;
  类型_小写_短->数组_长度 = 长度_短;
  return 类型_小写_短;
}

类型 *变长数组_的(类型 *基础_小写, 节点 *长度_短) {
  类型 *类型_小写_短 = new_type(类型_变长数组, 8, 8);
  类型_小写_短->基础_小写 = 基础_小写;
  类型_小写_短->变长数组_长度 = 长度_短;
  return 类型_小写_短;
}

类型 *枚举_类型(void) {
  return new_type(类型_枚举, 4, 4);
}

类型 *结构_类型(void) {
  return new_type(类型_结构, 0, 1);
}

static 类型 *get_common_type(类型 *ty1, 类型 *ty2) {
  if (ty1->基础_小写)
    return 指针_到(ty1->基础_小写);

  if (ty1->种类_小写 == 类型_函)
    return 指针_到(ty1);
  if (ty2->种类_小写 == 类型_函)
    return 指针_到(ty2);

  if (ty1->种类_小写 == 类型_长双浮 || ty2->种类_小写 == 类型_长双浮)
    return 类型_长双浮_小写;
  if (ty1->种类_小写 == 类型_双浮 || ty2->种类_小写 == 类型_双浮)
    return 类型_双浮_小写;
  if (ty1->种类_小写 == 类型_浮点 || ty2->种类_小写 == 类型_浮点)
    return 类型_浮点_小写;

  if (ty1->大小_小写 < 4)
    ty1 = 类型_整型_小写;
  if (ty2->大小_小写 < 4)
    ty2 = 类型_整型_小写;

  if (ty1->大小_小写 != ty2->大小_小写)
    return (ty1->大小_小写 < ty2->大小_小写) ? ty2 : ty1;

  if (ty2->是否_无符号)
    return ty2;
  return ty1;
}

// For many binary operators, we implicitly promote operands so that
// both operands have the same type. Any integral type smaller than
// int is always promoted to int. If the type of one operand is larger
// than the other's (e.g. "long" vs. "int"), the smaller operand will
// be promoted to match with the other.
//
// This operation is called the "usual arithmetic conversion".
static void usual_arith_conv(节点 **左手塞_缩, 节点 **右手塞_缩) {
  类型 *类型_小写_短 = get_common_type((*左手塞_缩)->类型_小写_短, (*右手塞_缩)->类型_小写_短);
  *左手塞_缩 = 新_转换(*左手塞_缩, 类型_小写_短);
  *右手塞_缩 = 新_转换(*右手塞_缩, 类型_小写_短);
}

void 加_类型(节点 *节点_小写) {
  if (!节点_小写 || 节点_小写->类型_小写_短)
    return;

  加_类型(节点_小写->左手塞_缩);
  加_类型(节点_小写->右手塞_缩);
  加_类型(节点_小写->条件_小写_短);
  加_类型(节点_小写->那么_小写);
  加_类型(节点_小写->否则_小写_短);
  加_类型(节点_小写->初始_小写_短);
  加_类型(节点_小写->递增_小写_短);

  for (节点 *n = 节点_小写->函数体_小写; n; n = n->下一个_小写)
    加_类型(n);
  for (节点 *n = 节点_小写->实参们_短; n; n = n->下一个_小写)
    加_类型(n);

  switch (节点_小写->种类_小写) {
  case 节点_数:
    节点_小写->类型_小写_短 = 类型_整型_小写;
    return;
  case 节点_加法:
  case 节点_减法:
  case 节点_乘法:
  case 节点_除法:
  case 节点_取模:
  case 节点_位与:
  case 节点_位或:
  case 节点_位异或:
    usual_arith_conv(&节点_小写->左手塞_缩, &节点_小写->右手塞_缩);
    节点_小写->类型_小写_短 = 节点_小写->左手塞_缩->类型_小写_短;
    return;
  case 节点_负号: {
    类型 *类型_小写_短 = get_common_type(类型_整型_小写, 节点_小写->左手塞_缩->类型_小写_短);
    节点_小写->左手塞_缩 = 新_转换(节点_小写->左手塞_缩, 类型_小写_短);
    节点_小写->类型_小写_短 = 类型_小写_短;
    return;
  }
  case 节点_赋值:
    if (节点_小写->左手塞_缩->类型_小写_短->种类_小写 == 类型_数组)
      错误_牌_小写(节点_小写->左手塞_缩->牌_短_小写, "not an lvalue");
    if (节点_小写->左手塞_缩->类型_小写_短->种类_小写 != 类型_结构)
      节点_小写->右手塞_缩 = 新_转换(节点_小写->右手塞_缩, 节点_小写->左手塞_缩->类型_小写_短);
    节点_小写->类型_小写_短 = 节点_小写->左手塞_缩->类型_小写_短;
    return;
  case 节点_等于:
  case 节点_不等:
  case 节点_小于:
  case 节点_小等:
    usual_arith_conv(&节点_小写->左手塞_缩, &节点_小写->右手塞_缩);
    节点_小写->类型_小写_短 = 类型_整型_小写;
    return;
  case 节点_函调:
    节点_小写->类型_小写_短 = 节点_小写->函_类型_缩->返回_类型;
    return;
  case 节点_非:
  case 节点_逻辑或:
  case 节点_逻辑与:
    节点_小写->类型_小写_短 = 类型_整型_小写;
    return;
  case 节点_位非:
  case 节点_左移:
  case 节点_右移:
    节点_小写->类型_小写_短 = 节点_小写->左手塞_缩->类型_小写_短;
    return;
  case 节点_变量:
  case 节点_变长数组_指针:
    节点_小写->类型_小写_短 = 节点_小写->变量_短->类型_小写_短;
    return;
  case 节点_条件:
    if (节点_小写->那么_小写->类型_小写_短->种类_小写 == 类型_空的 || 节点_小写->否则_小写_短->类型_小写_短->种类_小写 == 类型_空的) {
      节点_小写->类型_小写_短 = 类型_空的_小写;
    } else {
      usual_arith_conv(&节点_小写->那么_小写, &节点_小写->否则_小写_短);
      节点_小写->类型_小写_短 = 节点_小写->那么_小写->类型_小写_短;
    }
    return;
  case 节点_逗号:
    节点_小写->类型_小写_短 = 节点_小写->右手塞_缩->类型_小写_短;
    return;
  case 节点_成员:
    节点_小写->类型_小写_短 = 节点_小写->成员_小写->类型_小写_短;
    return;
  case 节点_地址: {
    类型 *类型_小写_短 = 节点_小写->左手塞_缩->类型_小写_短;
    if (类型_小写_短->种类_小写 == 类型_数组)
      节点_小写->类型_小写_短 = 指针_到(类型_小写_短->基础_小写);
    else
      节点_小写->类型_小写_短 = 指针_到(类型_小写_短);
    return;
  }
  case 节点_解引用:
    if (!节点_小写->左手塞_缩->类型_小写_短->基础_小写)
      错误_牌_小写(节点_小写->牌_短_小写, "invalid pointer dereference");
    if (节点_小写->左手塞_缩->类型_小写_短->基础_小写->种类_小写 == 类型_空的)
      错误_牌_小写(节点_小写->牌_短_小写, "dereferencing a void pointer");

    节点_小写->类型_小写_短 = 节点_小写->左手塞_缩->类型_小写_短->基础_小写;
    return;
  case 节点_语句_表达式:
    if (节点_小写->函数体_小写) {
      节点 *语句_短_小写 = 节点_小写->函数体_小写;
      while (语句_短_小写->下一个_小写)
        语句_短_小写 = 语句_短_小写->下一个_小写;
      if (语句_短_小写->种类_小写 == 节点_表达式_语句) {
        节点_小写->类型_小写_短 = 语句_短_小写->左手塞_缩->类型_小写_短;
        return;
      }
    }
    错误_牌_小写(节点_小写->牌_短_小写, "statement expression returning void is not supported");
    return;
  case 节点_标号_值:
    节点_小写->类型_小写_短 = 指针_到(类型_空的_小写);
    return;
  case 节点_对比与交换:
    加_类型(节点_小写->对比与交换_地址);
    加_类型(节点_小写->对比与交换_旧);
    加_类型(节点_小写->对比与交换_新);
    节点_小写->类型_小写_短 = 类型_布尔_小写;

    if (节点_小写->对比与交换_地址->类型_小写_短->种类_小写 != 类型_指针)
      错误_牌_小写(节点_小写->对比与交换_地址->牌_短_小写, "pointer expected");
    if (节点_小写->对比与交换_旧->类型_小写_短->种类_小写 != 类型_指针)
      错误_牌_小写(节点_小写->对比与交换_旧->牌_短_小写, "pointer expected");
    return;
  case 节点_调换:
    if (节点_小写->左手塞_缩->类型_小写_短->种类_小写 != 类型_指针)
      错误_牌_小写(节点_小写->对比与交换_地址->牌_短_小写, "pointer expected");
    节点_小写->类型_小写_短 = 节点_小写->左手塞_缩->类型_小写_短->基础_小写;
    return;
  }
}
