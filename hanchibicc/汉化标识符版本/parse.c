// This 文件_小写 contains a recursive descent parser for C.
//
// Most functions in this 文件_小写 are named after the symbols they are
// supposed to read from an input token list. For example, 语句_短_小写() is
// responsible for reading a statement from a token list. The 函数_全_小写
// 那么_小写 construct an AST 节点_小写 representing a statement.
//
// Each 函数_全_小写 conceptually returns two values, an AST 节点_小写 and
// remaining part of the input tokens. Since C doesn't support
// multiple return values, the remaining tokens are returned to the
// caller via a pointer argument.
//
// Input tokens are represented by a linked list. Unlike many recursive
// descent parsers, we don't have the notion of the "input token stream".
// Most parsing functions don't change the global state of the parser.
// So it is very easy to lookahead arbitrary number of tokens in this
// parser.

#include "chibicc.h"

// 作用域_大写 for local variables, global variables, typedefs
// or enum constants
typedef struct {
  对象_缩_大写 *变量_短;
  类型 *类型_定义_短_小写;
  类型 *枚举_类型_短;
  int 枚举_值_短;
} 变量作用域;

// Represents a block 作用域_小写.
typedef struct 作用域_大写 作用域_大写;
struct 作用域_大写 {
  作用域_大写 *下一个_小写;

  // C has two block scopes; one is for variables/typedefs and
  // the other is for struct/union/enum 标签们.
  哈希映射_驼峰名 变量们_短;
  哈希映射_驼峰名 标签们;
};

// Variable attributes such as typedef or extern.
typedef struct {
  bool 是否_类型定义;
  bool 是否_静态;
  bool 是否_外部;
  bool 是否_内联;
  bool 是否_传输层安全;
  int 对齐_短_小写;
} 变量属性_短;

// This struct represents a variable 初始化器_小写. Since initializers
// can be nested (e.g. `int x[2][2] = {{1, 2}, {3, 4}}`), this struct
// is a tree 数据_小写 structure.
typedef struct 初始化器 初始化器;
struct 初始化器 {
  初始化器 *下一个_小写;
  类型 *类型_小写_短;
  牌 *牌_短_小写;
  bool 是否_弹性;

  // If it's not an aggregate type and has an 初始化器_小写,
  // `表达式_短_小写` has an initialization expression.
  节点 *表达式_短_小写;

  // If it's an 初始化器_小写 for an aggregate type (e.g. array or struct),
  // `孩子们` has initializers for its 孩子们.
  初始化器 **孩子们;

  // Only one 成员_小写 can be initialized for a union.
  // `成员_短_小写` is 已用_小写 to clarify which 成员_小写 is initialized.
  成员 *成员_短_小写;
};

// For local variable 初始化器_小写.
typedef struct 初始设计_驼峰名 初始设计_驼峰名;
struct 初始设计_驼峰名 {
  初始设计_驼峰名 *下一个_小写;
  int 索引_缩;
  成员 *成员_小写;
  对象_缩_大写 *变量_短;
};

// All local variable instances created during parsing are
// accumulated to this list.
static 对象_缩_大写 *本地们_小写;

// Likewise, global variables are accumulated to this list.
static 对象_缩_大写 *全局们_小写;

static 作用域_大写 *作用域_小写 = &(作用域_大写){};

// Points to the 函数_全_小写 object the parser is currently parsing.
static 对象_缩_大写 *当前_函;

// Lists of all goto statements and 标号们_小写 in the curent 函数_全_小写.
static 节点 *去到们_小写;
static 节点 *标号们_小写;

// Current "goto" and "continue" jump targets.
static char *破坏_标号_缩;
static char *继续_标号_缩;

// Points to a 节点_小写 representing a switch if we are parsing
// a switch statement. Otherwise, NULL.
static 节点 *当前_切换;

static 对象_缩_大写 *内置_栈分配;

static bool 是否_类型名(牌 *牌_短_小写);
static 类型 *声明的说明(牌 **其余的, 牌 *牌_短_小写, 变量属性_短 *attr);
static 类型 *类型名_小写(牌 **其余的, 牌 *牌_短_小写);
static 类型 *枚举_说明符(牌 **其余的, 牌 *牌_短_小写);
static 类型 *求类型_说明符(牌 **其余的, 牌 *牌_短_小写);
static 类型 *类型_后缀(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短);
static 类型 *声明符_小写(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短);
static 节点 *声明整体_小写(牌 **其余的, 牌 *牌_短_小写, 类型 *基本类型_短, 变量属性_短 *attr);
static void 数组_初始化器2(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短, int i);
static void 结构_初始化器2(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短, 成员 *成员_短_小写);
static void 初始化器2_小写(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短);
static 初始化器 *初始化器_小写(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短, 类型 **new_ty);
static 节点 *本地变量_初始化器(牌 **其余的, 牌 *牌_短_小写, 对象_缩_大写 *变量_短);
static void 全局变量_初始化器(牌 **其余的, 牌 *牌_短_小写, 对象_缩_大写 *变量_短);
static 节点 *复合_语句_短(牌 **其余的, 牌 *牌_短_小写);
static 节点 *语句_短_小写(牌 **其余的, 牌 *牌_短_小写);
static 节点 *表达式_语句_短(牌 **其余的, 牌 *牌_短_小写);
static 节点 *表达式_短_小写(牌 **其余的, 牌 *牌_短_小写);
static int64_t 求值_小写(节点 *节点_小写);
static int64_t 求值2_小写(节点 *节点_小写, char ***标号_小写);
static int64_t 求值_右值(节点 *节点_小写, char ***标号_小写);
static bool 是否_常量_表达式(节点 *节点_小写);
static 节点 *赋值_短(牌 **其余的, 牌 *牌_短_小写);
static 节点 *逻辑或_小写(牌 **其余的, 牌 *牌_短_小写);
static double 求值_双浮_小写(节点 *节点_小写);
static 节点 *条件_全(牌 **其余的, 牌 *牌_短_小写);
static 节点 *逻辑与_小写(牌 **其余的, 牌 *牌_短_小写);
static 节点 *位或_小写(牌 **其余的, 牌 *牌_短_小写);
static 节点 *位异或_小写(牌 **其余的, 牌 *牌_短_小写);
static 节点 *位与_小写(牌 **其余的, 牌 *牌_短_小写);
static 节点 *相等_全(牌 **其余的, 牌 *牌_短_小写);
static 节点 *关系_全(牌 **其余的, 牌 *牌_短_小写);
static 节点 *移位_全(牌 **其余的, 牌 *牌_短_小写);
static 节点 *加_短_小写(牌 **其余的, 牌 *牌_短_小写);
static 节点 *新_加_短(节点 *左手塞_缩, 节点 *右手塞_缩, 牌 *牌_短_小写);
static 节点 *新_减_短(节点 *左手塞_缩, 节点 *右手塞_缩, 牌 *牌_短_小写);
static 节点 *乘_短_小写(牌 **其余的, 牌 *牌_短_小写);
static 节点 *类型转换_小写(牌 **其余的, 牌 *牌_短_小写);
static 成员 *获取_结构_成员(类型 *类型_小写_短, 牌 *牌_短_小写);
static 类型 *结构_声明_短(牌 **其余的, 牌 *牌_短_小写);
static 类型 *联合_声明_短(牌 **其余的, 牌 *牌_短_小写);
static 节点 *表达式后缀(牌 **其余的, 牌 *牌_短_小写);
static 节点 *函调用_小写(牌 **其余的, 牌 *牌_短_小写, 节点 *节点_小写);
static 节点 *一元运算_小写(牌 **其余的, 牌 *牌_短_小写);
static 节点 *首要的_小写(牌 **其余的, 牌 *牌_短_小写);
static 牌 *解析_类型定义(牌 *牌_短_小写, 类型 *基本类型_短);
static bool 是否_函数(牌 *牌_短_小写);
static 牌 *函数_全_小写(牌 *牌_短_小写, 类型 *基本类型_短, 变量属性_短 *attr);
static 牌 *全局_变量_全(牌 *牌_短_小写, 类型 *基本类型_短, 变量属性_短 *attr);

static int 对齐_下_小写(int n, int 对齐_短_小写) {
  return 对齐_到(n - 对齐_短_小写 + 1, 对齐_短_小写);
}

static void 进入_作用域(void) {
  作用域_大写 *sc = calloc(1, sizeof(作用域_大写));
  sc->下一个_小写 = 作用域_小写;
  作用域_小写 = sc;
}

static void 离开_作用域(void) {
  作用域_小写 = 作用域_小写->下一个_小写;
}

// Find a variable by 名称_小写.
static 变量作用域 *找_变量(牌 *牌_短_小写) {
  for (作用域_大写 *sc = 作用域_小写; sc; sc = sc->下一个_小写) {
    变量作用域 *sc2 = 哈希映射_获取2(&sc->变量们_短, 牌_短_小写->定位_小写_短, 牌_短_小写->长度_短);
    if (sc2)
      return sc2;
  }
  return NULL;
}

static 类型 *找_标签(牌 *牌_短_小写) {
  for (作用域_大写 *sc = 作用域_小写; sc; sc = sc->下一个_小写) {
    类型 *类型_小写_短 = 哈希映射_获取2(&sc->标签们, 牌_短_小写->定位_小写_短, 牌_短_小写->长度_短);
    if (类型_小写_短)
      return 类型_小写_短;
  }
  return NULL;
}

static 节点 *新_节点(节点种类 种类_小写, 牌 *牌_短_小写) {
  节点 *节点_小写 = calloc(1, sizeof(节点));
  节点_小写->种类_小写 = 种类_小写;
  节点_小写->牌_短_小写 = 牌_短_小写;
  return 节点_小写;
}

static 节点 *新_二元(节点种类 种类_小写, 节点 *左手塞_缩, 节点 *右手塞_缩, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(种类_小写, 牌_短_小写);
  节点_小写->左手塞_缩 = 左手塞_缩;
  节点_小写->右手塞_缩 = 右手塞_缩;
  return 节点_小写;
}

static 节点 *新_一元(节点种类 种类_小写, 节点 *表达式_短_小写, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(种类_小写, 牌_短_小写);
  节点_小写->左手塞_缩 = 表达式_短_小写;
  return 节点_小写;
}

static 节点 *新_数目(int64_t 值_小写_短, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(节点_数, 牌_短_小写);
  节点_小写->值_小写_短 = 值_小写_短;
  return 节点_小写;
}

static 节点 *新_长的(int64_t 值_小写_短, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(节点_数, 牌_短_小写);
  节点_小写->值_小写_短 = 值_小写_短;
  节点_小写->类型_小写_短 = 类型_长的_小写;
  return 节点_小写;
}

static 节点 *新_无符长的(long 值_小写_短, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(节点_数, 牌_短_小写);
  节点_小写->值_小写_短 = 值_小写_短;
  节点_小写->类型_小写_短 = 类型_无符长的_小写;
  return 节点_小写;
}

static 节点 *新_变量_节点(对象_缩_大写 *变量_短, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(节点_变量, 牌_短_小写);
  节点_小写->变量_短 = 变量_短;
  return 节点_小写;
}

static 节点 *新_变长数组_指针(对象_缩_大写 *变量_短, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(节点_变长数组_指针, 牌_短_小写);
  节点_小写->变量_短 = 变量_短;
  return 节点_小写;
}

节点 *新_转换(节点 *表达式_短_小写, 类型 *类型_小写_短) {
  加_类型(表达式_短_小写);

  节点 *节点_小写 = calloc(1, sizeof(节点));
  节点_小写->种类_小写 = 节点_类转;
  节点_小写->牌_短_小写 = 表达式_短_小写->牌_短_小写;
  节点_小写->左手塞_缩 = 表达式_短_小写;
  节点_小写->类型_小写_短 = 复制_类型(类型_小写_短);
  return 节点_小写;
}

static 变量作用域 *推_作用域(char *名称_小写) {
  变量作用域 *sc = calloc(1, sizeof(变量作用域));
  哈希映射_放置(&作用域_小写->变量们_短, 名称_小写, sc);
  return sc;
}

static 初始化器 *新_初始化器_小写(类型 *类型_小写_短, bool 是否_弹性) {
  初始化器 *初始_小写_短 = calloc(1, sizeof(初始化器));
  初始_小写_短->类型_小写_短 = 类型_小写_短;

  if (类型_小写_短->种类_小写 == 类型_数组) {
    if (是否_弹性 && 类型_小写_短->大小_小写 < 0) {
      初始_小写_短->是否_弹性 = true;
      return 初始_小写_短;
    }

    初始_小写_短->孩子们 = calloc(类型_小写_短->数组_长度, sizeof(初始化器 *));
    for (int i = 0; i < 类型_小写_短->数组_长度; i++)
      初始_小写_短->孩子们[i] = 新_初始化器_小写(类型_小写_短->基础_小写, false);
    return 初始_小写_短;
  }

  if (类型_小写_短->种类_小写 == 类型_结构 || 类型_小写_短->种类_小写 == 类型_联合) {
    // Count the number of struct 成员们_小写.
    int 长度_短 = 0;
    for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写)
      长度_短++;

    初始_小写_短->孩子们 = calloc(长度_短, sizeof(初始化器 *));

    for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写) {
      if (是否_弹性 && 类型_小写_短->是否_弹性 && !成员_短_小写->下一个_小写) {
        初始化器 *child = calloc(1, sizeof(初始化器));
        child->类型_小写_短 = 成员_短_小写->类型_小写_短;
        child->是否_弹性 = true;
        初始_小写_短->孩子们[成员_短_小写->索引_缩] = child;
      } else {
        初始_小写_短->孩子们[成员_短_小写->索引_缩] = 新_初始化器_小写(成员_短_小写->类型_小写_短, false);
      }
    }
    return 初始_小写_短;
  }

  return 初始_小写_短;
}

static 对象_缩_大写 *新_变量_小写(char *名称_小写, 类型 *类型_小写_短) {
  对象_缩_大写 *变量_短 = calloc(1, sizeof(对象_缩_大写));
  变量_短->名称_小写 = 名称_小写;
  变量_短->类型_小写_短 = 类型_小写_短;
  变量_短->对齐_短_小写 = 类型_小写_短->对齐_短_小写;
  推_作用域(名称_小写)->变量_短 = 变量_短;
  return 变量_短;
}

static 对象_缩_大写 *新_本地变量(char *名称_小写, 类型 *类型_小写_短) {
  对象_缩_大写 *变量_短 = 新_变量_小写(名称_小写, 类型_小写_短);
  变量_短->是否_本地 = true;
  变量_短->下一个_小写 = 本地们_小写;
  本地们_小写 = 变量_短;
  return 变量_短;
}

static 对象_缩_大写 *新_全局变量(char *名称_小写, 类型 *类型_小写_短) {
  对象_缩_大写 *变量_短 = 新_变量_小写(名称_小写, 类型_小写_短);
  变量_短->下一个_小写 = 全局们_小写;
  变量_短->是否_静态 = true;
  变量_短->是否_定义 = true;
  全局们_小写 = 变量_短;
  return 变量_短;
}

static char *新_唯一_名称(void) {
  static int id = 0;
  return 格式化_函(".L..%d", id++);
}

static 对象_缩_大写 *新_匿名_全局变量(类型 *类型_小写_短) {
  return 新_全局变量(新_唯一_名称(), 类型_小写_短);
}

static 对象_缩_大写 *新_字符串_字面(char *p, 类型 *类型_小写_短) {
  对象_缩_大写 *变量_短 = 新_匿名_全局变量(类型_小写_短);
  变量_短->初始_数据 = p;
  return 变量_短;
}

static char *获取_标识(牌 *牌_短_小写) {
  if (牌_短_小写->种类_小写 != 牌_标识)
    错误_牌_小写(牌_短_小写, "expected an identifier");
  return strndup(牌_短_小写->定位_小写_短, 牌_短_小写->长度_短);
}

static 类型 *找_类型定义(牌 *牌_短_小写) {
  if (牌_短_小写->种类_小写 == 牌_标识) {
    变量作用域 *sc = 找_变量(牌_短_小写);
    if (sc)
      return sc->类型_定义_短_小写;
  }
  return NULL;
}

static void 推_标签_作用域(牌 *牌_短_小写, 类型 *类型_小写_短) {
  哈希映射_放置2(&作用域_小写->标签们, 牌_短_小写->定位_小写_短, 牌_短_小写->长度_短, 类型_小写_短);
}

// 声明的说明 = ("void" | "_Bool" | "char" | "short" | "int" | "long"
//             | "typedef" | "static" | "extern" | "inline"
//             | "_Thread_local" | "__thread"
//             | "signed" | "unsigned"
//             | struct-decl | union-decl | typedef-名称_小写
//             | enum-specifier | typeof-specifier
//             | "const" | "volatile" | "auto" | "register" | "restrict"
//             | "__restrict" | "__restrict__" | "_Noreturn")+
//
// The order of typenames in a type-specifier doesn't matter. For
// example, `int long static` means the same as `static long int`.
// That can also be written as `static long` because you can omit
// `int` if `long` or `short` are specified. However, something like
// `char int` is not a valid type specifier. We have to accept only a
// limited combinations of the typenames.
//
// In this 函数_全_小写, we count the number of occurrences of each 类型名_小写
// while keeping the "current" type object that the typenames up
// until that point represent. When we reach a non-类型名_小写 token,
// we returns the current type object.
static 类型 *声明的说明(牌 **其余的, 牌 *牌_短_小写, 变量属性_短 *attr) {
  // We use a single integer as counters for all typenames.
  // For example, bits 0 and 1 represents how many times we saw the
  // keyword "void" so far. With this, we can use a switch statement
  // as you can see below.
  enum {
    空的_大写     = 1 << 0,
    布尔_大写     = 1 << 2,
    印刻_大写     = 1 << 4,
    短型_大写    = 1 << 6,
    整型_大写      = 1 << 8,
    长型_大写     = 1 << 10,
    浮点_大写    = 1 << 12,
    双浮_大写   = 1 << 14,
    其它_大写    = 1 << 16,
    符号_大写   = 1 << 17,
    无符号_大写  = 1 << 18,
  };

  类型 *类型_小写_短 = 类型_整型_小写;
  int 计数器_小写 = 0;
  bool 是否_原子 = false;

  while (是否_类型名(牌_短_小写)) {
    // Handle storage class specifiers.
    if (相等吗_小写(牌_短_小写, "typedef") || 相等吗_小写(牌_短_小写, "static") || 相等吗_小写(牌_短_小写, "extern") ||
        相等吗_小写(牌_短_小写, "inline") || 相等吗_小写(牌_短_小写, "_Thread_local") || 相等吗_小写(牌_短_小写, "__thread")) {
      if (!attr)
        错误_牌_小写(牌_短_小写, "storage class specifier is not allowed in this context");

      if (相等吗_小写(牌_短_小写, "typedef"))
        attr->是否_类型定义 = true;
      else if (相等吗_小写(牌_短_小写, "static"))
        attr->是否_静态 = true;
      else if (相等吗_小写(牌_短_小写, "extern"))
        attr->是否_外部 = true;
      else if (相等吗_小写(牌_短_小写, "inline"))
        attr->是否_内联 = true;
      else
        attr->是否_传输层安全 = true;

      if (attr->是否_类型定义 &&
          attr->是否_静态 + attr->是否_外部 + attr->是否_内联 + attr->是否_传输层安全 > 1)
        错误_牌_小写(牌_短_小写, "typedef may not be 已用_小写 together with static,"
                  " extern, inline, __thread or _Thread_local");
      牌_短_小写 = 牌_短_小写->下一个_小写;
      continue;
    }

    // These keywords are recognized but ignored.
    if (消耗吗_小写(&牌_短_小写, 牌_短_小写, "const") || 消耗吗_小写(&牌_短_小写, 牌_短_小写, "volatile") ||
        消耗吗_小写(&牌_短_小写, 牌_短_小写, "auto") || 消耗吗_小写(&牌_短_小写, 牌_短_小写, "register") ||
        消耗吗_小写(&牌_短_小写, 牌_短_小写, "restrict") || 消耗吗_小写(&牌_短_小写, 牌_短_小写, "__restrict") ||
        消耗吗_小写(&牌_短_小写, 牌_短_小写, "__restrict__") || 消耗吗_小写(&牌_短_小写, 牌_短_小写, "_Noreturn"))
      continue;

    if (相等吗_小写(牌_短_小写, "_Atomic")) {
      牌_短_小写 = 牌_短_小写->下一个_小写;
      if (相等吗_小写(牌_短_小写 , "(")) {
        类型_小写_短 = 类型名_小写(&牌_短_小写, 牌_短_小写->下一个_小写);
        牌_短_小写 = 跳过_小写(牌_短_小写, ")");
      }
      是否_原子 = true;
      continue;
    }

    if (相等吗_小写(牌_短_小写, "_Alignas")) {
      if (!attr)
        错误_牌_小写(牌_短_小写, "_Alignas is not allowed in this context");
      牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");

      if (是否_类型名(牌_短_小写))
        attr->对齐_短_小写 = 类型名_小写(&牌_短_小写, 牌_短_小写)->对齐_短_小写;
      else
        attr->对齐_短_小写 = 常量_表达式_短(&牌_短_小写, 牌_短_小写);
      牌_短_小写 = 跳过_小写(牌_短_小写, ")");
      continue;
    }

    // Handle user-defined types.
    类型 *ty2 = 找_类型定义(牌_短_小写);
    if (相等吗_小写(牌_短_小写, "struct") || 相等吗_小写(牌_短_小写, "union") || 相等吗_小写(牌_短_小写, "enum") ||
        相等吗_小写(牌_短_小写, "typeof") || ty2) {
      if (计数器_小写)
        break;

      if (相等吗_小写(牌_短_小写, "struct")) {
        类型_小写_短 = 结构_声明_短(&牌_短_小写, 牌_短_小写->下一个_小写);
      } else if (相等吗_小写(牌_短_小写, "union")) {
        类型_小写_短 = 联合_声明_短(&牌_短_小写, 牌_短_小写->下一个_小写);
      } else if (相等吗_小写(牌_短_小写, "enum")) {
        类型_小写_短 = 枚举_说明符(&牌_短_小写, 牌_短_小写->下一个_小写);
      } else if (相等吗_小写(牌_短_小写, "typeof")) {
        类型_小写_短 = 求类型_说明符(&牌_短_小写, 牌_短_小写->下一个_小写);
      } else {
        类型_小写_短 = ty2;
        牌_短_小写 = 牌_短_小写->下一个_小写;
      }

      计数器_小写 += 其它_大写;
      continue;
    }

    // Handle built-in types.
    if (相等吗_小写(牌_短_小写, "void"))
      计数器_小写 += 空的_大写;
    else if (相等吗_小写(牌_短_小写, "_Bool"))
      计数器_小写 += 布尔_大写;
    else if (相等吗_小写(牌_短_小写, "char"))
      计数器_小写 += 印刻_大写;
    else if (相等吗_小写(牌_短_小写, "short"))
      计数器_小写 += 短型_大写;
    else if (相等吗_小写(牌_短_小写, "int"))
      计数器_小写 += 整型_大写;
    else if (相等吗_小写(牌_短_小写, "long"))
      计数器_小写 += 长型_大写;
    else if (相等吗_小写(牌_短_小写, "float"))
      计数器_小写 += 浮点_大写;
    else if (相等吗_小写(牌_短_小写, "double"))
      计数器_小写 += 双浮_大写;
    else if (相等吗_小写(牌_短_小写, "signed"))
      计数器_小写 |= 符号_大写;
    else if (相等吗_小写(牌_短_小写, "unsigned"))
      计数器_小写 |= 无符号_大写;
    else
      无法到达();

    switch (计数器_小写) {
    case 空的_大写:
      类型_小写_短 = 类型_空的_小写;
      break;
    case 布尔_大写:
      类型_小写_短 = 类型_布尔_小写;
      break;
    case 印刻_大写:
    case 符号_大写 + 印刻_大写:
      类型_小写_短 = 类型_印刻_小写;
      break;
    case 无符号_大写 + 印刻_大写:
      类型_小写_短 = 类型_无符印刻_小写;
      break;
    case 短型_大写:
    case 短型_大写 + 整型_大写:
    case 符号_大写 + 短型_大写:
    case 符号_大写 + 短型_大写 + 整型_大写:
      类型_小写_短 = 类型_短的_小写;
      break;
    case 无符号_大写 + 短型_大写:
    case 无符号_大写 + 短型_大写 + 整型_大写:
      类型_小写_短 = 类型_无符短的_小写;
      break;
    case 整型_大写:
    case 符号_大写:
    case 符号_大写 + 整型_大写:
      类型_小写_短 = 类型_整型_小写;
      break;
    case 无符号_大写:
    case 无符号_大写 + 整型_大写:
      类型_小写_短 = 类型_无符整型_小写;
      break;
    case 长型_大写:
    case 长型_大写 + 整型_大写:
    case 长型_大写 + 长型_大写:
    case 长型_大写 + 长型_大写 + 整型_大写:
    case 符号_大写 + 长型_大写:
    case 符号_大写 + 长型_大写 + 整型_大写:
    case 符号_大写 + 长型_大写 + 长型_大写:
    case 符号_大写 + 长型_大写 + 长型_大写 + 整型_大写:
      类型_小写_短 = 类型_长的_小写;
      break;
    case 无符号_大写 + 长型_大写:
    case 无符号_大写 + 长型_大写 + 整型_大写:
    case 无符号_大写 + 长型_大写 + 长型_大写:
    case 无符号_大写 + 长型_大写 + 长型_大写 + 整型_大写:
      类型_小写_短 = 类型_无符长的_小写;
      break;
    case 浮点_大写:
      类型_小写_短 = 类型_浮点_小写;
      break;
    case 双浮_大写:
      类型_小写_短 = 类型_双浮_小写;
      break;
    case 长型_大写 + 双浮_大写:
      类型_小写_短 = 类型_长双浮_小写;
      break;
    default:
      错误_牌_小写(牌_短_小写, "invalid type");
    }

    牌_短_小写 = 牌_短_小写->下一个_小写;
  }

  if (是否_原子) {
    类型_小写_短 = 复制_类型(类型_小写_短);
    类型_小写_短->是否_原子 = true;
  }

  *其余的 = 牌_短_小写;
  return 类型_小写_短;
}

// func-形参们_短_小写 = ("void" | param ("," param)* ("," "...")?)? ")"
// param       = 声明的说明 声明符_小写
static 类型 *函_形参们(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短) {
  if (相等吗_小写(牌_短_小写, "void") && 相等吗_小写(牌_短_小写->下一个_小写, ")")) {
    *其余的 = 牌_短_小写->下一个_小写->下一个_小写;
    return 函_类型_小写(类型_小写_短);
  }

  类型 head = {};
  类型 *当前_短 = &head;
  bool 是否_可变参数 = false;

  while (!相等吗_小写(牌_短_小写, ")")) {
    if (当前_短 != &head)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");

    if (相等吗_小写(牌_短_小写, "...")) {
      是否_可变参数 = true;
      牌_短_小写 = 牌_短_小写->下一个_小写;
      跳过_小写(牌_短_小写, ")");
      break;
    }

    类型 *ty2 = 声明的说明(&牌_短_小写, 牌_短_小写, NULL);
    ty2 = 声明符_小写(&牌_短_小写, 牌_短_小写, ty2);

    牌 *名称_小写 = ty2->名称_小写;

    if (ty2->种类_小写 == 类型_数组) {
      // "array of T" is converted to "pointer to T" only in the parameter
      // context. For example, *argv[] is converted to **argv by this.
      ty2 = 指针_到(ty2->基础_小写);
      ty2->名称_小写 = 名称_小写;
    } else if (ty2->种类_小写 == 类型_函) {
      // Likewise, a 函数_全_小写 is converted to a pointer to a 函数_全_小写
      // only in the parameter context.
      ty2 = 指针_到(ty2);
      ty2->名称_小写 = 名称_小写;
    }

    当前_短 = 当前_短->下一个_小写 = 复制_类型(ty2);
  }

  if (当前_短 == &head)
    是否_可变参数 = true;

  类型_小写_短 = 函_类型_小写(类型_小写_短);
  类型_小写_短->形参们_短_小写 = head.下一个_小写;
  类型_小写_短->是否_可变参数 = 是否_可变参数;
  *其余的 = 牌_短_小写->下一个_小写;
  return 类型_小写_短;
}

// array-dimensions = ("static" | "restrict")* const-表达式_短_小写? "]" type-suffix
static 类型 *数组_维度们(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短) {
  while (相等吗_小写(牌_短_小写, "static") || 相等吗_小写(牌_短_小写, "restrict"))
    牌_短_小写 = 牌_短_小写->下一个_小写;

  if (相等吗_小写(牌_短_小写, "]")) {
    类型_小写_短 = 类型_后缀(其余的, 牌_短_小写->下一个_小写, 类型_小写_短);
    return 数组_的(类型_小写_短, -1);
  }

  节点 *表达式_短_小写 = 条件_全(&牌_短_小写, 牌_短_小写);
  牌_短_小写 = 跳过_小写(牌_短_小写, "]");
  类型_小写_短 = 类型_后缀(其余的, 牌_短_小写, 类型_小写_短);

  if (类型_小写_短->种类_小写 == 类型_变长数组 || !是否_常量_表达式(表达式_短_小写))
    return 变长数组_的(类型_小写_短, 表达式_短_小写);
  return 数组_的(类型_小写_短, 求值_小写(表达式_短_小写));
}

// type-suffix = "(" func-形参们_短_小写
//             | "[" array-dimensions
//             | ε
static 类型 *类型_后缀(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短) {
  if (相等吗_小写(牌_短_小写, "("))
    return 函_形参们(其余的, 牌_短_小写->下一个_小写, 类型_小写_短);

  if (相等吗_小写(牌_短_小写, "["))
    return 数组_维度们(其余的, 牌_短_小写->下一个_小写, 类型_小写_短);

  *其余的 = 牌_短_小写;
  return 类型_小写_短;
}

// 指针们 = ("*" ("const" | "volatile" | "restrict")*)*
static 类型 *指针们(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短) {
  while (消耗吗_小写(&牌_短_小写, 牌_短_小写, "*")) {
    类型_小写_短 = 指针_到(类型_小写_短);
    while (相等吗_小写(牌_短_小写, "const") || 相等吗_小写(牌_短_小写, "volatile") || 相等吗_小写(牌_短_小写, "restrict") ||
           相等吗_小写(牌_短_小写, "__restrict") || 相等吗_小写(牌_短_小写, "__restrict__"))
      牌_短_小写 = 牌_短_小写->下一个_小写;
  }
  *其余的 = 牌_短_小写;
  return 类型_小写_短;
}

// 声明符_小写 = 指针们 ("(" ident ")" | "(" 声明符_小写 ")" | ident) type-suffix
static 类型 *声明符_小写(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短) {
  类型_小写_短 = 指针们(&牌_短_小写, 牌_短_小写, 类型_小写_短);

  if (相等吗_小写(牌_短_小写, "(")) {
    牌 *开起 = 牌_短_小写;
    类型 dummy = {};
    声明符_小写(&牌_短_小写, 开起->下一个_小写, &dummy);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");
    类型_小写_短 = 类型_后缀(其余的, 牌_短_小写, 类型_小写_短);
    return 声明符_小写(&牌_短_小写, 开起->下一个_小写, 类型_小写_短);
  }

  牌 *名称_小写 = NULL;
  牌 *名称_位置 = 牌_短_小写;

  if (牌_短_小写->种类_小写 == 牌_标识) {
    名称_小写 = 牌_短_小写;
    牌_短_小写 = 牌_短_小写->下一个_小写;
  }

  类型_小写_短 = 类型_后缀(其余的, 牌_短_小写, 类型_小写_短);
  类型_小写_短->名称_小写 = 名称_小写;
  类型_小写_短->名称_位置 = 名称_位置;
  return 类型_小写_短;
}

// abstract-声明符_小写 = 指针们 ("(" abstract-声明符_小写 ")")? type-suffix
static 类型 *抽象_声明符(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短) {
  类型_小写_短 = 指针们(&牌_短_小写, 牌_短_小写, 类型_小写_短);

  if (相等吗_小写(牌_短_小写, "(")) {
    牌 *开起 = 牌_短_小写;
    类型 dummy = {};
    抽象_声明符(&牌_短_小写, 开起->下一个_小写, &dummy);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");
    类型_小写_短 = 类型_后缀(其余的, 牌_短_小写, 类型_小写_短);
    return 抽象_声明符(&牌_短_小写, 开起->下一个_小写, 类型_小写_短);
  }

  return 类型_后缀(其余的, 牌_短_小写, 类型_小写_短);
}

// type-名称_小写 = 声明的说明 abstract-声明符_小写
static 类型 *类型名_小写(牌 **其余的, 牌 *牌_短_小写) {
  类型 *类型_小写_短 = 声明的说明(&牌_短_小写, 牌_短_小写, NULL);
  return 抽象_声明符(其余的, 牌_短_小写, 类型_小写_短);
}

static bool 是否_终(牌 *牌_短_小写) {
  return 相等吗_小写(牌_短_小写, "}") || (相等吗_小写(牌_短_小写, ",") && 相等吗_小写(牌_短_小写->下一个_小写, "}"));
}

static bool 消耗_终(牌 **其余的, 牌 *牌_短_小写) {
  if (相等吗_小写(牌_短_小写, "}")) {
    *其余的 = 牌_短_小写->下一个_小写;
    return true;
  }

  if (相等吗_小写(牌_短_小写, ",") && 相等吗_小写(牌_短_小写->下一个_小写, "}")) {
    *其余的 = 牌_短_小写->下一个_小写->下一个_小写;
    return true;
  }

  return false;
}

// enum-specifier = ident? "{" enum-list? "}"
//                | ident ("{" enum-list? "}")?
//
// enum-list      = ident ("=" num)? ("," ident ("=" num)?)* ","?
static 类型 *枚举_说明符(牌 **其余的, 牌 *牌_短_小写) {
  类型 *类型_小写_短 = 枚举_类型();

  // Read a struct tag.
  牌 *tag = NULL;
  if (牌_短_小写->种类_小写 == 牌_标识) {
    tag = 牌_短_小写;
    牌_短_小写 = 牌_短_小写->下一个_小写;
  }

  if (tag && !相等吗_小写(牌_短_小写, "{")) {
    类型 *类型_小写_短 = 找_标签(tag);
    if (!类型_小写_短)
      错误_牌_小写(tag, "unknown enum type");
    if (类型_小写_短->种类_小写 != 类型_枚举)
      错误_牌_小写(tag, "not an enum tag");
    *其余的 = 牌_短_小写;
    return 类型_小写_短;
  }

  牌_短_小写 = 跳过_小写(牌_短_小写, "{");

  // Read an enum-list.
  int i = 0;
  int 值_小写_短 = 0;
  while (!消耗_终(其余的, 牌_短_小写)) {
    if (i++ > 0)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");

    char *名称_小写 = 获取_标识(牌_短_小写);
    牌_短_小写 = 牌_短_小写->下一个_小写;

    if (相等吗_小写(牌_短_小写, "="))
      值_小写_短 = 常量_表达式_短(&牌_短_小写, 牌_短_小写->下一个_小写);

    变量作用域 *sc = 推_作用域(名称_小写);
    sc->枚举_类型_短 = 类型_小写_短;
    sc->枚举_值_短 = 值_小写_短++;
  }

  if (tag)
    推_标签_作用域(tag, 类型_小写_短);
  return 类型_小写_短;
}

// typeof-specifier = "(" (表达式_短_小写 | 类型名_小写) ")"
static 类型 *求类型_说明符(牌 **其余的, 牌 *牌_短_小写) {
  牌_短_小写 = 跳过_小写(牌_短_小写, "(");

  类型 *类型_小写_短;
  if (是否_类型名(牌_短_小写)) {
    类型_小写_短 = 类型名_小写(&牌_短_小写, 牌_短_小写);
  } else {
    节点 *节点_小写 = 表达式_短_小写(&牌_短_小写, 牌_短_小写);
    加_类型(节点_小写);
    类型_小写_短 = 节点_小写->类型_小写_短;
  }
  *其余的 = 跳过_小写(牌_短_小写, ")");
  return 类型_小写_短;
}

// Generate code for computing a VLA 大小_小写.
static 节点 *计算_变长数组_大小(类型 *类型_小写_短, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(节点_空指针_表达式, 牌_短_小写);
  if (类型_小写_短->基础_小写)
    节点_小写 = 新_二元(节点_逗号, 节点_小写, 计算_变长数组_大小(类型_小写_短->基础_小写, 牌_短_小写), 牌_短_小写);

  if (类型_小写_短->种类_小写 != 类型_变长数组)
    return 节点_小写;

  节点 *base_sz;
  if (类型_小写_短->基础_小写->种类_小写 == 类型_变长数组)
    base_sz = 新_变量_节点(类型_小写_短->基础_小写->变长数组_大小, 牌_短_小写);
  else
    base_sz = 新_数目(类型_小写_短->基础_小写->大小_小写, 牌_短_小写);

  类型_小写_短->变长数组_大小 = 新_本地变量("", 类型_无符长的_小写);
  节点 *表达式_短_小写 = 新_二元(节点_赋值, 新_变量_节点(类型_小写_短->变长数组_大小, 牌_短_小写),
                          新_二元(节点_乘法, 类型_小写_短->变长数组_长度, base_sz, 牌_短_小写),
                          牌_短_小写);
  return 新_二元(节点_逗号, 节点_小写, 表达式_短_小写, 牌_短_小写);
}

static 节点 *新_动态分配内存(节点 *sz) {
  节点 *节点_小写 = 新_一元(节点_函调, 新_变量_节点(内置_栈分配, sz->牌_短_小写), sz->牌_短_小写);
  节点_小写->函_类型_缩 = 内置_栈分配->类型_小写_短;
  节点_小写->类型_小写_短 = 内置_栈分配->类型_小写_短->返回_类型;
  节点_小写->实参们_短 = sz;
  加_类型(sz);
  return 节点_小写;
}

// 声明整体_小写 = 声明的说明 (声明符_小写 ("=" 表达式_短_小写)? ("," 声明符_小写 ("=" 表达式_短_小写)?)*)? ";"
static 节点 *声明整体_小写(牌 **其余的, 牌 *牌_短_小写, 类型 *基本类型_短, 变量属性_短 *attr) {
  节点 head = {};
  节点 *当前_短 = &head;
  int i = 0;

  while (!相等吗_小写(牌_短_小写, ";")) {
    if (i++ > 0)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");

    类型 *类型_小写_短 = 声明符_小写(&牌_短_小写, 牌_短_小写, 基本类型_短);
    if (类型_小写_短->种类_小写 == 类型_空的)
      错误_牌_小写(牌_短_小写, "variable declared void");
    if (!类型_小写_短->名称_小写)
      错误_牌_小写(类型_小写_短->名称_位置, "variable 名称_小写 omitted");

    if (attr && attr->是否_静态) {
      // static local variable
      对象_缩_大写 *变量_短 = 新_匿名_全局变量(类型_小写_短);
      推_作用域(获取_标识(类型_小写_短->名称_小写))->变量_短 = 变量_短;
      if (相等吗_小写(牌_短_小写, "="))
        全局变量_初始化器(&牌_短_小写, 牌_短_小写->下一个_小写, 变量_短);
      continue;
    }

    // Generate code for computing a VLA 大小_小写. We need to do this
    // even if 类型_小写_短 is not VLA because 类型_小写_短 may be a pointer to VLA
    // (e.g. int (*foo)[n][m] where n and m are variables.)
    当前_短 = 当前_短->下一个_小写 = 新_一元(节点_表达式_语句, 计算_变长数组_大小(类型_小写_短, 牌_短_小写), 牌_短_小写);

    if (类型_小写_短->种类_小写 == 类型_变长数组) {
      if (相等吗_小写(牌_短_小写, "="))
        错误_牌_小写(牌_短_小写, "variable-sized object may not be initialized");

      // Variable length arrays (VLAs) are translated to alloca() calls.
      // For example, `int x[n+2]` is translated to `tmp = n + 2,
      // x = alloca(tmp)`.
      对象_缩_大写 *变量_短 = 新_本地变量(获取_标识(类型_小写_短->名称_小写), 类型_小写_短);
      牌 *牌_短_小写 = 类型_小写_短->名称_小写;
      节点 *表达式_短_小写 = 新_二元(节点_赋值, 新_变长数组_指针(变量_短, 牌_短_小写),
                              新_动态分配内存(新_变量_节点(类型_小写_短->变长数组_大小, 牌_短_小写)),
                              牌_短_小写);

      当前_短 = 当前_短->下一个_小写 = 新_一元(节点_表达式_语句, 表达式_短_小写, 牌_短_小写);
      continue;
    }

    对象_缩_大写 *变量_短 = 新_本地变量(获取_标识(类型_小写_短->名称_小写), 类型_小写_短);
    if (attr && attr->对齐_短_小写)
      变量_短->对齐_短_小写 = attr->对齐_短_小写;

    if (相等吗_小写(牌_短_小写, "=")) {
      节点 *表达式_短_小写 = 本地变量_初始化器(&牌_短_小写, 牌_短_小写->下一个_小写, 变量_短);
      当前_短 = 当前_短->下一个_小写 = 新_一元(节点_表达式_语句, 表达式_短_小写, 牌_短_小写);
    }

    if (变量_短->类型_小写_短->大小_小写 < 0)
      错误_牌_小写(类型_小写_短->名称_小写, "variable has incomplete type");
    if (变量_短->类型_小写_短->种类_小写 == 类型_空的)
      错误_牌_小写(类型_小写_短->名称_小写, "variable declared void");
  }

  节点 *节点_小写 = 新_节点(节点_块, 牌_短_小写);
  节点_小写->函数体_小写 = head.下一个_小写;
  *其余的 = 牌_短_小写->下一个_小写;
  return 节点_小写;
}

static 牌 *跳过_过度_元素(牌 *牌_短_小写) {
  if (相等吗_小写(牌_短_小写, "{")) {
    牌_短_小写 = 跳过_过度_元素(牌_短_小写->下一个_小写);
    return 跳过_小写(牌_短_小写, "}");
  }

  赋值_短(&牌_短_小写, 牌_短_小写);
  return 牌_短_小写;
}

// string-初始化器_小写 = string-literal
static void 字符串_初始化器(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短) {
  if (初始_小写_短->是否_弹性)
    *初始_小写_短 = *新_初始化器_小写(数组_的(初始_小写_短->类型_小写_短->基础_小写, 牌_短_小写->类型_小写_短->数组_长度), false);

  int 长度_短 = 最小_大写(初始_小写_短->类型_小写_短->数组_长度, 牌_短_小写->类型_小写_短->数组_长度);

  switch (初始_小写_短->类型_小写_短->基础_小写->大小_小写) {
  case 1: {
    char *串_小写_短 = 牌_短_小写->串_小写_短;
    for (int i = 0; i < 长度_短; i++)
      初始_小写_短->孩子们[i]->表达式_短_小写 = 新_数目(串_小写_短[i], 牌_短_小写);
    break;
  }
  case 2: {
    uint16_t *串_小写_短 = (uint16_t *)牌_短_小写->串_小写_短;
    for (int i = 0; i < 长度_短; i++)
      初始_小写_短->孩子们[i]->表达式_短_小写 = 新_数目(串_小写_短[i], 牌_短_小写);
    break;
  }
  case 4: {
    uint32_t *串_小写_短 = (uint32_t *)牌_短_小写->串_小写_短;
    for (int i = 0; i < 长度_短; i++)
      初始_小写_短->孩子们[i]->表达式_短_小写 = 新_数目(串_小写_短[i], 牌_短_小写);
    break;
  }
  default:
    无法到达();
  }

  *其余的 = 牌_短_小写->下一个_小写;
}

// array-designator = "[" const-表达式_短_小写 "]"
//
// C99 added the designated 初始化器_小写 to the language, which allows
// programmers to move the "cursor" of an 初始化器_小写 to any element.
// The syntax looks like this:
//
//   int x[10] = { 1, 2, [5]=3, 4, 5, 6, 7 };
//
// `[5]` moves the cursor to the 5th element, so the 5th element of x
// is set to 3. Initialization 那么_小写 continues forward in order, so
// 6th, 7th, 8th and 9th elements are initialized with 4, 5, 6 and 7,
// respectively. Unspecified elements (in this case, 3rd and 4th
// elements) are initialized with zero.
//
// Nesting is allowed, so the following 初始化器_小写 is valid:
//
//   int x[5][10] = { [5][8]=1, 2, 3 };
//
// It sets x[5][8], x[5][9] and x[6][0] to 1, 2 and 3, respectively.
//
// Use `.fieldname` to move the cursor for a struct 初始化器_小写. E.g.
//
//   struct { int a, b, c; } x = { .c=5 };
//
// The above 初始化器_小写 sets x.c to 5.
static void 数组_指示器(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短, int *开头_小写, int *终_小写) {
  *开头_小写 = 常量_表达式_短(&牌_短_小写, 牌_短_小写->下一个_小写);
  if (*开头_小写 >= 类型_小写_短->数组_长度)
    错误_牌_小写(牌_短_小写, "array designator index exceeds array bounds");

  if (相等吗_小写(牌_短_小写, "...")) {
    *终_小写 = 常量_表达式_短(&牌_短_小写, 牌_短_小写->下一个_小写);
    if (*终_小写 >= 类型_小写_短->数组_长度)
      错误_牌_小写(牌_短_小写, "array designator index exceeds array bounds");
    if (*终_小写 < *开头_小写)
      错误_牌_小写(牌_短_小写, "array designator range [%d, %d] is empty", *开头_小写, *终_小写);
  } else {
    *终_小写 = *开头_小写;
  }

  *其余的 = 跳过_小写(牌_短_小写, "]");
}

// struct-designator = "." ident
static 成员 *结构_指示符(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短) {
  牌 *开起 = 牌_短_小写;
  牌_短_小写 = 跳过_小写(牌_短_小写, ".");
  if (牌_短_小写->种类_小写 != 牌_标识)
    错误_牌_小写(牌_短_小写, "expected a field designator");

  for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写) {
    // Anonymous struct 成员_小写
    if (成员_短_小写->类型_小写_短->种类_小写 == 类型_结构 && !成员_短_小写->名称_小写) {
      if (获取_结构_成员(成员_短_小写->类型_小写_短, 牌_短_小写)) {
        *其余的 = 开起;
        return 成员_短_小写;
      }
      continue;
    }

    // Regular struct 成员_小写
    if (成员_短_小写->名称_小写->长度_短 == 牌_短_小写->长度_短 && !strncmp(成员_短_小写->名称_小写->定位_小写_短, 牌_短_小写->定位_小写_短, 牌_短_小写->长度_短)) {
      *其余的 = 牌_短_小写->下一个_小写;
      return 成员_短_小写;
    }
  }

  错误_牌_小写(牌_短_小写, "struct has no such 成员_小写");
}

// 指定_小写 = ("[" const-表达式_短_小写 "]" | "." ident)* "="? 初始化器_小写
static void 指定_小写(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短) {
  if (相等吗_小写(牌_短_小写, "[")) {
    if (初始_小写_短->类型_小写_短->种类_小写 != 类型_数组)
      错误_牌_小写(牌_短_小写, "array index in non-array 初始化器_小写");

    int 开头_小写, 终_小写;
    数组_指示器(&牌_短_小写, 牌_短_小写, 初始_小写_短->类型_小写_短, &开头_小写, &终_小写);

    牌 *tok2;
    for (int i = 开头_小写; i <= 终_小写; i++)
      指定_小写(&tok2, 牌_短_小写, 初始_小写_短->孩子们[i]);
    数组_初始化器2(其余的, tok2, 初始_小写_短, 开头_小写 + 1);
    return;
  }

  if (相等吗_小写(牌_短_小写, ".") && 初始_小写_短->类型_小写_短->种类_小写 == 类型_结构) {
    成员 *成员_短_小写 = 结构_指示符(&牌_短_小写, 牌_短_小写, 初始_小写_短->类型_小写_短);
    指定_小写(&牌_短_小写, 牌_短_小写, 初始_小写_短->孩子们[成员_短_小写->索引_缩]);
    初始_小写_短->表达式_短_小写 = NULL;
    结构_初始化器2(其余的, 牌_短_小写, 初始_小写_短, 成员_短_小写->下一个_小写);
    return;
  }

  if (相等吗_小写(牌_短_小写, ".") && 初始_小写_短->类型_小写_短->种类_小写 == 类型_联合) {
    成员 *成员_短_小写 = 结构_指示符(&牌_短_小写, 牌_短_小写, 初始_小写_短->类型_小写_短);
    初始_小写_短->成员_短_小写 = 成员_短_小写;
    指定_小写(其余的, 牌_短_小写, 初始_小写_短->孩子们[成员_短_小写->索引_缩]);
    return;
  }

  if (相等吗_小写(牌_短_小写, "."))
    错误_牌_小写(牌_短_小写, "field 名称_小写 not in struct or union 初始化器_小写");

  if (相等吗_小写(牌_短_小写, "="))
    牌_短_小写 = 牌_短_小写->下一个_小写;
  初始化器2_小写(其余的, 牌_短_小写, 初始_小写_短);
}

// An array length can be omitted if an array has an 初始化器_小写
// (e.g. `int x[] = {1,2,3}`). If it's omitted, count the number
// of 初始化器_小写 elements.
static int 计数_数组_初始_元素们(牌 *牌_短_小写, 类型 *类型_小写_短) {
  bool first = true;
  初始化器 *dummy = 新_初始化器_小写(类型_小写_短->基础_小写, true);

  int i = 0, max = 0;

  while (!消耗_终(&牌_短_小写, 牌_短_小写)) {
    if (!first)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    first = false;

    if (相等吗_小写(牌_短_小写, "[")) {
      i = 常量_表达式_短(&牌_短_小写, 牌_短_小写->下一个_小写);
      if (相等吗_小写(牌_短_小写, "..."))
        i = 常量_表达式_短(&牌_短_小写, 牌_短_小写->下一个_小写);
      牌_短_小写 = 跳过_小写(牌_短_小写, "]");
      指定_小写(&牌_短_小写, 牌_短_小写, dummy);
    } else {
      初始化器2_小写(&牌_短_小写, 牌_短_小写, dummy);
    }

    i++;
    max = 最大_大写(max, i);
  }
  return max;
}

// array-initializer1 = "{" 初始化器_小写 ("," 初始化器_小写)* ","? "}"
static void 数组_初始化器1(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短) {
  牌_短_小写 = 跳过_小写(牌_短_小写, "{");

  if (初始_小写_短->是否_弹性) {
    int 长度_短 = 计数_数组_初始_元素们(牌_短_小写, 初始_小写_短->类型_小写_短);
    *初始_小写_短 = *新_初始化器_小写(数组_的(初始_小写_短->类型_小写_短->基础_小写, 长度_短), false);
  }

  bool first = true;

  if (初始_小写_短->是否_弹性) {
    int 长度_短 = 计数_数组_初始_元素们(牌_短_小写, 初始_小写_短->类型_小写_短);
    *初始_小写_短 = *新_初始化器_小写(数组_的(初始_小写_短->类型_小写_短->基础_小写, 长度_短), false);
  }

  for (int i = 0; !消耗_终(其余的, 牌_短_小写); i++) {
    if (!first)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    first = false;

    if (相等吗_小写(牌_短_小写, "[")) {
      int 开头_小写, 终_小写;
      数组_指示器(&牌_短_小写, 牌_短_小写, 初始_小写_短->类型_小写_短, &开头_小写, &终_小写);

      牌 *tok2;
      for (int j = 开头_小写; j <= 终_小写; j++)
        指定_小写(&tok2, 牌_短_小写, 初始_小写_短->孩子们[j]);
      牌_短_小写 = tok2;
      i = 终_小写;
      continue;
    }

    if (i < 初始_小写_短->类型_小写_短->数组_长度)
      初始化器2_小写(&牌_短_小写, 牌_短_小写, 初始_小写_短->孩子们[i]);
    else
      牌_短_小写 = 跳过_过度_元素(牌_短_小写);
  }
}

// array-初始化器2_小写 = 初始化器_小写 ("," 初始化器_小写)*
static void 数组_初始化器2(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短, int i) {
  if (初始_小写_短->是否_弹性) {
    int 长度_短 = 计数_数组_初始_元素们(牌_短_小写, 初始_小写_短->类型_小写_短);
    *初始_小写_短 = *新_初始化器_小写(数组_的(初始_小写_短->类型_小写_短->基础_小写, 长度_短), false);
  }

  for (; i < 初始_小写_短->类型_小写_短->数组_长度 && !是否_终(牌_短_小写); i++) {
    牌 *开起 = 牌_短_小写;
    if (i > 0)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");

    if (相等吗_小写(牌_短_小写, "[") || 相等吗_小写(牌_短_小写, ".")) {
      *其余的 = 开起;
      return;
    }

    初始化器2_小写(&牌_短_小写, 牌_短_小写, 初始_小写_短->孩子们[i]);
  }
  *其余的 = 牌_短_小写;
}

// struct-initializer1 = "{" 初始化器_小写 ("," 初始化器_小写)* ","? "}"
static void 结构_初始化器1(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短) {
  牌_短_小写 = 跳过_小写(牌_短_小写, "{");

  成员 *成员_短_小写 = 初始_小写_短->类型_小写_短->成员们_小写;
  bool first = true;

  while (!消耗_终(其余的, 牌_短_小写)) {
    if (!first)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    first = false;

    if (相等吗_小写(牌_短_小写, ".")) {
      成员_短_小写 = 结构_指示符(&牌_短_小写, 牌_短_小写, 初始_小写_短->类型_小写_短);
      指定_小写(&牌_短_小写, 牌_短_小写, 初始_小写_短->孩子们[成员_短_小写->索引_缩]);
      成员_短_小写 = 成员_短_小写->下一个_小写;
      continue;
    }

    if (成员_短_小写) {
      初始化器2_小写(&牌_短_小写, 牌_短_小写, 初始_小写_短->孩子们[成员_短_小写->索引_缩]);
      成员_短_小写 = 成员_短_小写->下一个_小写;
    } else {
      牌_短_小写 = 跳过_过度_元素(牌_短_小写);
    }
  }
}

// struct-初始化器2_小写 = 初始化器_小写 ("," 初始化器_小写)*
static void 结构_初始化器2(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短, 成员 *成员_短_小写) {
  bool first = true;

  for (; 成员_短_小写 && !是否_终(牌_短_小写); 成员_短_小写 = 成员_短_小写->下一个_小写) {
    牌 *开起 = 牌_短_小写;

    if (!first)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    first = false;

    if (相等吗_小写(牌_短_小写, "[") || 相等吗_小写(牌_短_小写, ".")) {
      *其余的 = 开起;
      return;
    }

    初始化器2_小写(&牌_短_小写, 牌_短_小写, 初始_小写_短->孩子们[成员_短_小写->索引_缩]);
  }
  *其余的 = 牌_短_小写;
}

static void 联合_初始化器(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短) {
  // Unlike structs, union initializers take only one 初始化器_小写,
  // and that initializes the first union 成员_小写 by default.
  // You can initialize other 成员_小写 using a designated 初始化器_小写.
  if (相等吗_小写(牌_短_小写, "{") && 相等吗_小写(牌_短_小写->下一个_小写, ".")) {
    成员 *成员_短_小写 = 结构_指示符(&牌_短_小写, 牌_短_小写->下一个_小写, 初始_小写_短->类型_小写_短);
    初始_小写_短->成员_短_小写 = 成员_短_小写;
    指定_小写(&牌_短_小写, 牌_短_小写, 初始_小写_短->孩子们[成员_短_小写->索引_缩]);
    *其余的 = 跳过_小写(牌_短_小写, "}");
    return;
  }

  初始_小写_短->成员_短_小写 = 初始_小写_短->类型_小写_短->成员们_小写;

  if (相等吗_小写(牌_短_小写, "{")) {
    初始化器2_小写(&牌_短_小写, 牌_短_小写->下一个_小写, 初始_小写_短->孩子们[0]);
    消耗吗_小写(&牌_短_小写, 牌_短_小写, ",");
    *其余的 = 跳过_小写(牌_短_小写, "}");
  } else {
    初始化器2_小写(其余的, 牌_短_小写, 初始_小写_短->孩子们[0]);
  }
}

// 初始化器_小写 = string-初始化器_小写 | array-初始化器_小写
//             | struct-初始化器_小写 | union-初始化器_小写
//             | 赋值_短
static void 初始化器2_小写(牌 **其余的, 牌 *牌_短_小写, 初始化器 *初始_小写_短) {
  if (初始_小写_短->类型_小写_短->种类_小写 == 类型_数组 && 牌_短_小写->种类_小写 == 牌_串字面) {
    字符串_初始化器(其余的, 牌_短_小写, 初始_小写_短);
    return;
  }

  if (初始_小写_短->类型_小写_短->种类_小写 == 类型_数组) {
    if (相等吗_小写(牌_短_小写, "{"))
      数组_初始化器1(其余的, 牌_短_小写, 初始_小写_短);
    else
      数组_初始化器2(其余的, 牌_短_小写, 初始_小写_短, 0);
    return;
  }

  if (初始_小写_短->类型_小写_短->种类_小写 == 类型_结构) {
    if (相等吗_小写(牌_短_小写, "{")) {
      结构_初始化器1(其余的, 牌_短_小写, 初始_小写_短);
      return;
    }

    // A struct can be initialized with another struct. E.g.
    // `struct T x = y;` where y is a variable of type `struct T`.
    // Handle that case first.
    节点 *表达式_短_小写 = 赋值_短(其余的, 牌_短_小写);
    加_类型(表达式_短_小写);
    if (表达式_短_小写->类型_小写_短->种类_小写 == 类型_结构) {
      初始_小写_短->表达式_短_小写 = 表达式_短_小写;
      return;
    }

    结构_初始化器2(其余的, 牌_短_小写, 初始_小写_短, 初始_小写_短->类型_小写_短->成员们_小写);
    return;
  }

  if (初始_小写_短->类型_小写_短->种类_小写 == 类型_联合) {
    联合_初始化器(其余的, 牌_短_小写, 初始_小写_短);
    return;
  }

  if (相等吗_小写(牌_短_小写, "{")) {
    // An 初始化器_小写 for a scalar variable can be surrounded by
    // braces. E.g. `int x = {3};`. Handle that case.
    初始化器2_小写(&牌_短_小写, 牌_短_小写->下一个_小写, 初始_小写_短);
    *其余的 = 跳过_小写(牌_短_小写, "}");
    return;
  }

  初始_小写_短->表达式_短_小写 = 赋值_短(其余的, 牌_短_小写);
}

static 类型 *复制_结构_类型(类型 *类型_小写_短) {
  类型_小写_短 = 复制_类型(类型_小写_短);

  成员 head = {};
  成员 *当前_短 = &head;
  for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写) {
    成员 *m = calloc(1, sizeof(成员));
    *m = *成员_短_小写;
    当前_短 = 当前_短->下一个_小写 = m;
  }

  类型_小写_短->成员们_小写 = head.下一个_小写;
  return 类型_小写_短;
}

static 初始化器 *初始化器_小写(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短, 类型 **new_ty) {
  初始化器 *初始_小写_短 = 新_初始化器_小写(类型_小写_短, true);
  初始化器2_小写(其余的, 牌_短_小写, 初始_小写_短);

  if ((类型_小写_短->种类_小写 == 类型_结构 || 类型_小写_短->种类_小写 == 类型_联合) && 类型_小写_短->是否_弹性) {
    类型_小写_短 = 复制_结构_类型(类型_小写_短);

    成员 *成员_短_小写 = 类型_小写_短->成员们_小写;
    while (成员_短_小写->下一个_小写)
      成员_短_小写 = 成员_短_小写->下一个_小写;
    成员_短_小写->类型_小写_短 = 初始_小写_短->孩子们[成员_短_小写->索引_缩]->类型_小写_短;
    类型_小写_短->大小_小写 += 成员_短_小写->类型_小写_短->大小_小写;

    *new_ty = 类型_小写_短;
    return 初始_小写_短;
  }

  *new_ty = 初始_小写_短->类型_小写_短;
  return 初始_小写_短;
}

static 节点 *初始_指定_表达式(初始设计_驼峰名 *desg, 牌 *牌_短_小写) {
  if (desg->变量_短)
    return 新_变量_节点(desg->变量_短, 牌_短_小写);

  if (desg->成员_小写) {
    节点 *节点_小写 = 新_一元(节点_成员, 初始_指定_表达式(desg->下一个_小写, 牌_短_小写), 牌_短_小写);
    节点_小写->成员_小写 = desg->成员_小写;
    return 节点_小写;
  }

  节点 *左手塞_缩 = 初始_指定_表达式(desg->下一个_小写, 牌_短_小写);
  节点 *右手塞_缩 = 新_数目(desg->索引_缩, 牌_短_小写);
  return 新_一元(节点_解引用, 新_加_短(左手塞_缩, 右手塞_缩, 牌_短_小写), 牌_短_小写);
}

static 节点 *创建_本地变量_初始(初始化器 *初始_小写_短, 类型 *类型_小写_短, 初始设计_驼峰名 *desg, 牌 *牌_短_小写) {
  if (类型_小写_短->种类_小写 == 类型_数组) {
    节点 *节点_小写 = 新_节点(节点_空指针_表达式, 牌_短_小写);
    for (int i = 0; i < 类型_小写_短->数组_长度; i++) {
      初始设计_驼峰名 desg2 = {desg, i};
      节点 *右手塞_缩 = 创建_本地变量_初始(初始_小写_短->孩子们[i], 类型_小写_短->基础_小写, &desg2, 牌_短_小写);
      节点_小写 = 新_二元(节点_逗号, 节点_小写, 右手塞_缩, 牌_短_小写);
    }
    return 节点_小写;
  }

  if (类型_小写_短->种类_小写 == 类型_结构 && !初始_小写_短->表达式_短_小写) {
    节点 *节点_小写 = 新_节点(节点_空指针_表达式, 牌_短_小写);

    for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写) {
      初始设计_驼峰名 desg2 = {desg, 0, 成员_短_小写};
      节点 *右手塞_缩 = 创建_本地变量_初始(初始_小写_短->孩子们[成员_短_小写->索引_缩], 成员_短_小写->类型_小写_短, &desg2, 牌_短_小写);
      节点_小写 = 新_二元(节点_逗号, 节点_小写, 右手塞_缩, 牌_短_小写);
    }
    return 节点_小写;
  }

  if (类型_小写_短->种类_小写 == 类型_联合) {
    成员 *成员_短_小写 = 初始_小写_短->成员_短_小写 ? 初始_小写_短->成员_短_小写 : 类型_小写_短->成员们_小写;
    初始设计_驼峰名 desg2 = {desg, 0, 成员_短_小写};
    return 创建_本地变量_初始(初始_小写_短->孩子们[成员_短_小写->索引_缩], 成员_短_小写->类型_小写_短, &desg2, 牌_短_小写);
  }

  if (!初始_小写_短->表达式_短_小写)
    return 新_节点(节点_空指针_表达式, 牌_短_小写);

  节点 *左手塞_缩 = 初始_指定_表达式(desg, 牌_短_小写);
  return 新_二元(节点_赋值, 左手塞_缩, 初始_小写_短->表达式_短_小写, 牌_短_小写);
}

// A variable definition with an 初始化器_小写 is a shorthand notation
// for a variable definition followed by assignments. This 函数_全_小写
// generates assignment expressions for an 初始化器_小写. For example,
// `int x[2][2] = {{6, 7}, {8, 9}}` is converted to the following
// expressions:
//
//   x[0][0] = 6;
//   x[0][1] = 7;
//   x[1][0] = 8;
//   x[1][1] = 9;
static 节点 *本地变量_初始化器(牌 **其余的, 牌 *牌_短_小写, 对象_缩_大写 *变量_短) {
  初始化器 *初始_小写_短 = 初始化器_小写(其余的, 牌_短_小写, 变量_短->类型_小写_短, &变量_短->类型_小写_短);
  初始设计_驼峰名 desg = {NULL, 0, NULL, 变量_短};

  // If a partial 初始化器_小写 list is given, the standard requires
  // that unspecified elements are set to 0. Here, we simply
  // zero-initialize the entire memory region of a variable before
  // initializing it with user-supplied values.
  节点 *左手塞_缩 = 新_节点(节点_内存归零, 牌_短_小写);
  左手塞_缩->变量_短 = 变量_短;

  节点 *右手塞_缩 = 创建_本地变量_初始(初始_小写_短, 变量_短->类型_小写_短, &desg, 牌_短_小写);
  return 新_二元(节点_逗号, 左手塞_缩, 右手塞_缩, 牌_短_小写);
}

static uint64_t 读_缓冲_短(char *buf, int sz) {
  if (sz == 1)
    return *buf;
  if (sz == 2)
    return *(uint16_t *)buf;
  if (sz == 4)
    return *(uint32_t *)buf;
  if (sz == 8)
    return *(uint64_t *)buf;
  无法到达();
}

static void 写_缓冲_短(char *buf, uint64_t 值_小写_短, int sz) {
  if (sz == 1)
    *buf = 值_小写_短;
  else if (sz == 2)
    *(uint16_t *)buf = 值_小写_短;
  else if (sz == 4)
    *(uint32_t *)buf = 值_小写_短;
  else if (sz == 8)
    *(uint64_t *)buf = 值_小写_短;
  else
    无法到达();
}

static 重定位 *
写_全局变量_数据(重定位 *当前_短, 初始化器 *初始_小写_短, 类型 *类型_小写_短, char *buf, int 偏移_小写) {
  if (类型_小写_短->种类_小写 == 类型_数组) {
    int sz = 类型_小写_短->基础_小写->大小_小写;
    for (int i = 0; i < 类型_小写_短->数组_长度; i++)
      当前_短 = 写_全局变量_数据(当前_短, 初始_小写_短->孩子们[i], 类型_小写_短->基础_小写, buf, 偏移_小写 + sz * i);
    return 当前_短;
  }

  if (类型_小写_短->种类_小写 == 类型_结构) {
    for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写) {
      if (成员_短_小写->是否_位字段) {
        节点 *表达式_短_小写 = 初始_小写_短->孩子们[成员_短_小写->索引_缩]->表达式_短_小写;
        if (!表达式_短_小写)
          break;

        char *定位_小写_短 = buf + 偏移_小写 + 成员_短_小写->偏移_小写;
        uint64_t oldval = 读_缓冲_短(定位_小写_短, 成员_短_小写->类型_小写_短->大小_小写);
        uint64_t newval = 求值_小写(表达式_短_小写);
        uint64_t mask = (1L << 成员_短_小写->位_宽度) - 1;
        uint64_t combined = oldval | ((newval & mask) << 成员_短_小写->位_偏移);
        写_缓冲_短(定位_小写_短, combined, 成员_短_小写->类型_小写_短->大小_小写);
      } else {
        当前_短 = 写_全局变量_数据(当前_短, 初始_小写_短->孩子们[成员_短_小写->索引_缩], 成员_短_小写->类型_小写_短, buf,
                              偏移_小写 + 成员_短_小写->偏移_小写);
      }
    }
    return 当前_短;
  }

  if (类型_小写_短->种类_小写 == 类型_联合) {
    if (!初始_小写_短->成员_短_小写)
      return 当前_短;
    return 写_全局变量_数据(当前_短, 初始_小写_短->孩子们[初始_小写_短->成员_短_小写->索引_缩],
                           初始_小写_短->成员_短_小写->类型_小写_短, buf, 偏移_小写);
  }

  if (!初始_小写_短->表达式_短_小写)
    return 当前_短;

  if (类型_小写_短->种类_小写 == 类型_浮点) {
    *(float *)(buf + 偏移_小写) = 求值_双浮_小写(初始_小写_短->表达式_短_小写);
    return 当前_短;
  }

  if (类型_小写_短->种类_小写 == 类型_双浮) {
    *(double *)(buf + 偏移_小写) = 求值_双浮_小写(初始_小写_短->表达式_短_小写);
    return 当前_短;
  }

  char **标号_小写 = NULL;
  uint64_t 值_小写_短 = 求值2_小写(初始_小写_短->表达式_短_小写, &标号_小写);

  if (!标号_小写) {
    写_缓冲_短(buf + 偏移_小写, 值_小写_短, 类型_小写_短->大小_小写);
    return 当前_短;
  }

  重定位 *重定位_缩 = calloc(1, sizeof(重定位));
  重定位_缩->偏移_小写 = 偏移_小写;
  重定位_缩->标号_小写 = 标号_小写;
  重定位_缩->加终_小写_短 = 值_小写_短;
  当前_短->下一个_小写 = 重定位_缩;
  return 当前_短->下一个_小写;
}

// Initializers for global variables are evaluated at compile-time and
// embedded to .数据_小写 section. This 函数_全_小写 serializes 初始化器
// objects to a flat byte array. It is a compile 错误_小写 if an
// 初始化器_小写 list contains a non-constant expression.
static void 全局变量_初始化器(牌 **其余的, 牌 *牌_短_小写, 对象_缩_大写 *变量_短) {
  初始化器 *初始_小写_短 = 初始化器_小写(其余的, 牌_短_小写, 变量_短->类型_小写_短, &变量_短->类型_小写_短);

  重定位 head = {};
  char *buf = calloc(1, 变量_短->类型_小写_短->大小_小写);
  写_全局变量_数据(&head, 初始_小写_短, 变量_短->类型_小写_短, buf, 0);
  变量_短->初始_数据 = buf;
  变量_短->重定位_缩 = head.下一个_小写;
}

// Returns true if a given token represents a type.
static bool 是否_类型名(牌 *牌_短_小写) {
  static 哈希映射_驼峰名 映射_小写;

  if (映射_小写.容量 == 0) {
    static char *关键字_缩[] = {
      "void", "_Bool", "char", "short", "int", "long", "struct", "union",
      "typedef", "enum", "static", "extern", "_Alignas", "signed", "unsigned",
      "const", "volatile", "auto", "register", "restrict", "__restrict",
      "__restrict__", "_Noreturn", "float", "double", "typeof", "inline",
      "_Thread_local", "__thread", "_Atomic",
    };

    for (int i = 0; i < sizeof(关键字_缩) / sizeof(*关键字_缩); i++)
      哈希映射_放置(&映射_小写, 关键字_缩[i], (void *)1);
  }

  return 哈希映射_获取2(&映射_小写, 牌_短_小写->定位_小写_短, 牌_短_小写->长度_短) || 找_类型定义(牌_短_小写);
}

// asm-语句_短_小写 = "asm" ("volatile" | "inline")* "(" string-literal ")"
static 节点 *汇编_语句_短(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(节点_汇编, 牌_短_小写);
  牌_短_小写 = 牌_短_小写->下一个_小写;

  while (相等吗_小写(牌_短_小写, "volatile") || 相等吗_小写(牌_短_小写, "inline"))
    牌_短_小写 = 牌_短_小写->下一个_小写;

  牌_短_小写 = 跳过_小写(牌_短_小写, "(");
  if (牌_短_小写->种类_小写 != 牌_串字面 || 牌_短_小写->类型_小写_短->基础_小写->种类_小写 != 类型_印刻)
    错误_牌_小写(牌_短_小写, "expected string literal");
  节点_小写->汇编_串_短 = 牌_短_小写->串_小写_短;
  *其余的 = 跳过_小写(牌_短_小写->下一个_小写, ")");
  return 节点_小写;
}

// 语句_短_小写 = "return" 表达式_短_小写? ";"
//      | "if" "(" 表达式_短_小写 ")" 语句_短_小写 ("else" 语句_短_小写)?
//      | "switch" "(" 表达式_短_小写 ")" 语句_短_小写
//      | "case" const-表达式_短_小写 ("..." const-表达式_短_小写)? ":" 语句_短_小写
//      | "default" ":" 语句_短_小写
//      | "for" "(" 表达式_短_小写-语句_短_小写 表达式_短_小写? ";" 表达式_短_小写? ")" 语句_短_小写
//      | "while" "(" 表达式_短_小写 ")" 语句_短_小写
//      | "do" 语句_短_小写 "while" "(" 表达式_短_小写 ")" ";"
//      | "asm" asm-语句_短_小写
//      | "goto" (ident | "*" 表达式_短_小写) ";"
//      | "break" ";"
//      | "continue" ";"
//      | ident ":" 语句_短_小写
//      | "{" compound-语句_短_小写
//      | 表达式_短_小写-语句_短_小写
static 节点 *语句_短_小写(牌 **其余的, 牌 *牌_短_小写) {
  if (相等吗_小写(牌_短_小写, "return")) {
    节点 *节点_小写 = 新_节点(节点_返回, 牌_短_小写);
    if (消耗吗_小写(其余的, 牌_短_小写->下一个_小写, ";"))
      return 节点_小写;

    节点 *exp = 表达式_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写);
    *其余的 = 跳过_小写(牌_短_小写, ";");

    加_类型(exp);
    类型 *类型_小写_短 = 当前_函->类型_小写_短->返回_类型;
    if (类型_小写_短->种类_小写 != 类型_结构 && 类型_小写_短->种类_小写 != 类型_联合)
      exp = 新_转换(exp, 当前_函->类型_小写_短->返回_类型);

    节点_小写->左手塞_缩 = exp;
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "if")) {
    节点 *节点_小写 = 新_节点(节点_若, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");
    节点_小写->条件_小写_短 = 表达式_短_小写(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");
    节点_小写->那么_小写 = 语句_短_小写(&牌_短_小写, 牌_短_小写);
    if (相等吗_小写(牌_短_小写, "else"))
      节点_小写->否则_小写_短 = 语句_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写);
    *其余的 = 牌_短_小写;
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "switch")) {
    节点 *节点_小写 = 新_节点(节点_切换, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");
    节点_小写->条件_小写_短 = 表达式_短_小写(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");

    节点 *sw = 当前_切换;
    当前_切换 = 节点_小写;

    char *brk = 破坏_标号_缩;
    破坏_标号_缩 = 节点_小写->破坏_标号_缩 = 新_唯一_名称();

    节点_小写->那么_小写 = 语句_短_小写(其余的, 牌_短_小写);

    当前_切换 = sw;
    破坏_标号_缩 = brk;
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "case")) {
    if (!当前_切换)
      错误_牌_小写(牌_短_小写, "stray case");

    节点 *节点_小写 = 新_节点(节点_情况, 牌_短_小写);
    int 开头_小写 = 常量_表达式_短(&牌_短_小写, 牌_短_小写->下一个_小写);
    int 终_小写;

    if (相等吗_小写(牌_短_小写, "...")) {
      // [GNU] Case ranges, e.g. "case 1 ... 5:"
      终_小写 = 常量_表达式_短(&牌_短_小写, 牌_短_小写->下一个_小写);
      if (终_小写 < 开头_小写)
        错误_牌_小写(牌_短_小写, "empty case range specified");
    } else {
      终_小写 = 开头_小写;
    }

    牌_短_小写 = 跳过_小写(牌_短_小写, ":");
    节点_小写->标号_小写 = 新_唯一_名称();
    节点_小写->左手塞_缩 = 语句_短_小写(其余的, 牌_短_小写);
    节点_小写->开头_小写 = 开头_小写;
    节点_小写->终_小写 = 终_小写;
    节点_小写->情况_下一个 = 当前_切换->情况_下一个;
    当前_切换->情况_下一个 = 节点_小写;
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "default")) {
    if (!当前_切换)
      错误_牌_小写(牌_短_小写, "stray default");

    节点 *节点_小写 = 新_节点(节点_情况, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, ":");
    节点_小写->标号_小写 = 新_唯一_名称();
    节点_小写->左手塞_缩 = 语句_短_小写(其余的, 牌_短_小写);
    当前_切换->默认_情况 = 节点_小写;
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "for")) {
    节点 *节点_小写 = 新_节点(节点_为, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");

    进入_作用域();

    char *brk = 破坏_标号_缩;
    char *cont = 继续_标号_缩;
    破坏_标号_缩 = 节点_小写->破坏_标号_缩 = 新_唯一_名称();
    继续_标号_缩 = 节点_小写->继续_标号_缩 = 新_唯一_名称();

    if (是否_类型名(牌_短_小写)) {
      类型 *基本类型_短 = 声明的说明(&牌_短_小写, 牌_短_小写, NULL);
      节点_小写->初始_小写_短 = 声明整体_小写(&牌_短_小写, 牌_短_小写, 基本类型_短, NULL);
    } else {
      节点_小写->初始_小写_短 = 表达式_语句_短(&牌_短_小写, 牌_短_小写);
    }

    if (!相等吗_小写(牌_短_小写, ";"))
      节点_小写->条件_小写_短 = 表达式_短_小写(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ";");

    if (!相等吗_小写(牌_短_小写, ")"))
      节点_小写->递增_小写_短 = 表达式_短_小写(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");

    节点_小写->那么_小写 = 语句_短_小写(其余的, 牌_短_小写);

    离开_作用域();
    破坏_标号_缩 = brk;
    继续_标号_缩 = cont;
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "while")) {
    节点 *节点_小写 = 新_节点(节点_为, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");
    节点_小写->条件_小写_短 = 表达式_短_小写(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");

    char *brk = 破坏_标号_缩;
    char *cont = 继续_标号_缩;
    破坏_标号_缩 = 节点_小写->破坏_标号_缩 = 新_唯一_名称();
    继续_标号_缩 = 节点_小写->继续_标号_缩 = 新_唯一_名称();

    节点_小写->那么_小写 = 语句_短_小写(其余的, 牌_短_小写);

    破坏_标号_缩 = brk;
    继续_标号_缩 = cont;
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "do")) {
    节点 *节点_小写 = 新_节点(节点_做, 牌_短_小写);

    char *brk = 破坏_标号_缩;
    char *cont = 继续_标号_缩;
    破坏_标号_缩 = 节点_小写->破坏_标号_缩 = 新_唯一_名称();
    继续_标号_缩 = 节点_小写->继续_标号_缩 = 新_唯一_名称();

    节点_小写->那么_小写 = 语句_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写);

    破坏_标号_缩 = brk;
    继续_标号_缩 = cont;

    牌_短_小写 = 跳过_小写(牌_短_小写, "while");
    牌_短_小写 = 跳过_小写(牌_短_小写, "(");
    节点_小写->条件_小写_短 = 表达式_短_小写(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");
    *其余的 = 跳过_小写(牌_短_小写, ";");
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "asm"))
    return 汇编_语句_短(其余的, 牌_短_小写);

  if (相等吗_小写(牌_短_小写, "goto")) {
    if (相等吗_小写(牌_短_小写->下一个_小写, "*")) {
      // [GNU] `goto *ptr` jumps to the address specified by `ptr`.
      节点 *节点_小写 = 新_节点(节点_去到_表达式, 牌_短_小写);
      节点_小写->左手塞_缩 = 表达式_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写->下一个_小写);
      *其余的 = 跳过_小写(牌_短_小写, ";");
      return 节点_小写;
    }

    节点 *节点_小写 = 新_节点(节点_去到, 牌_短_小写);
    节点_小写->标号_小写 = 获取_标识(牌_短_小写->下一个_小写);
    节点_小写->去到_下一个 = 去到们_小写;
    去到们_小写 = 节点_小写;
    *其余的 = 跳过_小写(牌_短_小写->下一个_小写->下一个_小写, ";");
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "break")) {
    if (!破坏_标号_缩)
      错误_牌_小写(牌_短_小写, "stray break");
    节点 *节点_小写 = 新_节点(节点_去到, 牌_短_小写);
    节点_小写->唯一_标号 = 破坏_标号_缩;
    *其余的 = 跳过_小写(牌_短_小写->下一个_小写, ";");
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "continue")) {
    if (!继续_标号_缩)
      错误_牌_小写(牌_短_小写, "stray continue");
    节点 *节点_小写 = 新_节点(节点_去到, 牌_短_小写);
    节点_小写->唯一_标号 = 继续_标号_缩;
    *其余的 = 跳过_小写(牌_短_小写->下一个_小写, ";");
    return 节点_小写;
  }

  if (牌_短_小写->种类_小写 == 牌_标识 && 相等吗_小写(牌_短_小写->下一个_小写, ":")) {
    节点 *节点_小写 = 新_节点(节点_标号, 牌_短_小写);
    节点_小写->标号_小写 = strndup(牌_短_小写->定位_小写_短, 牌_短_小写->长度_短);
    节点_小写->唯一_标号 = 新_唯一_名称();
    节点_小写->左手塞_缩 = 语句_短_小写(其余的, 牌_短_小写->下一个_小写->下一个_小写);
    节点_小写->去到_下一个 = 标号们_小写;
    标号们_小写 = 节点_小写;
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "{"))
    return 复合_语句_短(其余的, 牌_短_小写->下一个_小写);

  return 表达式_语句_短(其余的, 牌_短_小写);
}

// compound-语句_短_小写 = (typedef | 声明整体_小写 | 语句_短_小写)* "}"
static 节点 *复合_语句_短(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 新_节点(节点_块, 牌_短_小写);
  节点 head = {};
  节点 *当前_短 = &head;

  进入_作用域();

  while (!相等吗_小写(牌_短_小写, "}")) {
    if (是否_类型名(牌_短_小写) && !相等吗_小写(牌_短_小写->下一个_小写, ":")) {
      变量属性_短 attr = {};
      类型 *基本类型_短 = 声明的说明(&牌_短_小写, 牌_短_小写, &attr);

      if (attr.是否_类型定义) {
        牌_短_小写 = 解析_类型定义(牌_短_小写, 基本类型_短);
        continue;
      }

      if (是否_函数(牌_短_小写)) {
        牌_短_小写 = 函数_全_小写(牌_短_小写, 基本类型_短, &attr);
        continue;
      }

      if (attr.是否_外部) {
        牌_短_小写 = 全局_变量_全(牌_短_小写, 基本类型_短, &attr);
        continue;
      }

      当前_短 = 当前_短->下一个_小写 = 声明整体_小写(&牌_短_小写, 牌_短_小写, 基本类型_短, &attr);
    } else {
      当前_短 = 当前_短->下一个_小写 = 语句_短_小写(&牌_短_小写, 牌_短_小写);
    }
    加_类型(当前_短);
  }

  离开_作用域();

  节点_小写->函数体_小写 = head.下一个_小写;
  *其余的 = 牌_短_小写->下一个_小写;
  return 节点_小写;
}

// 表达式_短_小写-语句_短_小写 = 表达式_短_小写? ";"
static 节点 *表达式_语句_短(牌 **其余的, 牌 *牌_短_小写) {
  if (相等吗_小写(牌_短_小写, ";")) {
    *其余的 = 牌_短_小写->下一个_小写;
    return 新_节点(节点_块, 牌_短_小写);
  }

  节点 *节点_小写 = 新_节点(节点_表达式_语句, 牌_短_小写);
  节点_小写->左手塞_缩 = 表达式_短_小写(&牌_短_小写, 牌_短_小写);
  *其余的 = 跳过_小写(牌_短_小写, ";");
  return 节点_小写;
}

// 表达式_短_小写 = 赋值_短 ("," 表达式_短_小写)?
static 节点 *表达式_短_小写(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 赋值_短(&牌_短_小写, 牌_短_小写);

  if (相等吗_小写(牌_短_小写, ","))
    return 新_二元(节点_逗号, 节点_小写, 表达式_短_小写(其余的, 牌_短_小写->下一个_小写), 牌_短_小写);

  *其余的 = 牌_短_小写;
  return 节点_小写;
}

static int64_t 求值_小写(节点 *节点_小写) {
  return 求值2_小写(节点_小写, NULL);
}

// Evaluate a given 节点_小写 as a constant expression.
//
// A constant expression is either just a number or ptr+n where ptr
// is a pointer to a global variable and n is a postiive/negative
// number. The latter form is accepted only as an initialization
// expression for a global variable.
static int64_t 求值2_小写(节点 *节点_小写, char ***标号_小写) {
  加_类型(节点_小写);

  if (是否_浮点数目(节点_小写->类型_小写_短))
    return 求值_双浮_小写(节点_小写);

  switch (节点_小写->种类_小写) {
  case 节点_加法:
    return 求值2_小写(节点_小写->左手塞_缩, 标号_小写) + 求值_小写(节点_小写->右手塞_缩);
  case 节点_减法:
    return 求值2_小写(节点_小写->左手塞_缩, 标号_小写) - 求值_小写(节点_小写->右手塞_缩);
  case 节点_乘法:
    return 求值_小写(节点_小写->左手塞_缩) * 求值_小写(节点_小写->右手塞_缩);
  case 节点_除法:
    if (节点_小写->类型_小写_短->是否_无符号)
      return (uint64_t)求值_小写(节点_小写->左手塞_缩) / 求值_小写(节点_小写->右手塞_缩);
    return 求值_小写(节点_小写->左手塞_缩) / 求值_小写(节点_小写->右手塞_缩);
  case 节点_负号:
    return -求值_小写(节点_小写->左手塞_缩);
  case 节点_取模:
    if (节点_小写->类型_小写_短->是否_无符号)
      return (uint64_t)求值_小写(节点_小写->左手塞_缩) % 求值_小写(节点_小写->右手塞_缩);
    return 求值_小写(节点_小写->左手塞_缩) % 求值_小写(节点_小写->右手塞_缩);
  case 节点_位与:
    return 求值_小写(节点_小写->左手塞_缩) & 求值_小写(节点_小写->右手塞_缩);
  case 节点_位或:
    return 求值_小写(节点_小写->左手塞_缩) | 求值_小写(节点_小写->右手塞_缩);
  case 节点_位异或:
    return 求值_小写(节点_小写->左手塞_缩) ^ 求值_小写(节点_小写->右手塞_缩);
  case 节点_左移:
    return 求值_小写(节点_小写->左手塞_缩) << 求值_小写(节点_小写->右手塞_缩);
  case 节点_右移:
    if (节点_小写->类型_小写_短->是否_无符号 && 节点_小写->类型_小写_短->大小_小写 == 8)
      return (uint64_t)求值_小写(节点_小写->左手塞_缩) >> 求值_小写(节点_小写->右手塞_缩);
    return 求值_小写(节点_小写->左手塞_缩) >> 求值_小写(节点_小写->右手塞_缩);
  case 节点_等于:
    return 求值_小写(节点_小写->左手塞_缩) == 求值_小写(节点_小写->右手塞_缩);
  case 节点_不等:
    return 求值_小写(节点_小写->左手塞_缩) != 求值_小写(节点_小写->右手塞_缩);
  case 节点_小于:
    if (节点_小写->左手塞_缩->类型_小写_短->是否_无符号)
      return (uint64_t)求值_小写(节点_小写->左手塞_缩) < 求值_小写(节点_小写->右手塞_缩);
    return 求值_小写(节点_小写->左手塞_缩) < 求值_小写(节点_小写->右手塞_缩);
  case 节点_小等:
    if (节点_小写->左手塞_缩->类型_小写_短->是否_无符号)
      return (uint64_t)求值_小写(节点_小写->左手塞_缩) <= 求值_小写(节点_小写->右手塞_缩);
    return 求值_小写(节点_小写->左手塞_缩) <= 求值_小写(节点_小写->右手塞_缩);
  case 节点_条件:
    return 求值_小写(节点_小写->条件_小写_短) ? 求值2_小写(节点_小写->那么_小写, 标号_小写) : 求值2_小写(节点_小写->否则_小写_短, 标号_小写);
  case 节点_逗号:
    return 求值2_小写(节点_小写->右手塞_缩, 标号_小写);
  case 节点_非:
    return !求值_小写(节点_小写->左手塞_缩);
  case 节点_位非:
    return ~求值_小写(节点_小写->左手塞_缩);
  case 节点_逻辑与:
    return 求值_小写(节点_小写->左手塞_缩) && 求值_小写(节点_小写->右手塞_缩);
  case 节点_逻辑或:
    return 求值_小写(节点_小写->左手塞_缩) || 求值_小写(节点_小写->右手塞_缩);
  case 节点_类转: {
    int64_t 值_小写_短 = 求值2_小写(节点_小写->左手塞_缩, 标号_小写);
    if (是否_整数(节点_小写->类型_小写_短)) {
      switch (节点_小写->类型_小写_短->大小_小写) {
      case 1: return 节点_小写->类型_小写_短->是否_无符号 ? (uint8_t)值_小写_短 : (int8_t)值_小写_短;
      case 2: return 节点_小写->类型_小写_短->是否_无符号 ? (uint16_t)值_小写_短 : (int16_t)值_小写_短;
      case 4: return 节点_小写->类型_小写_短->是否_无符号 ? (uint32_t)值_小写_短 : (int32_t)值_小写_短;
      }
    }
    return 值_小写_短;
  }
  case 节点_地址:
    return 求值_右值(节点_小写->左手塞_缩, 标号_小写);
  case 节点_标号_值:
    *标号_小写 = &节点_小写->唯一_标号;
    return 0;
  case 节点_成员:
    if (!标号_小写)
      错误_牌_小写(节点_小写->牌_短_小写, "not a compile-time constant");
    if (节点_小写->类型_小写_短->种类_小写 != 类型_数组)
      错误_牌_小写(节点_小写->牌_短_小写, "invalid 初始化器_小写");
    return 求值_右值(节点_小写->左手塞_缩, 标号_小写) + 节点_小写->成员_小写->偏移_小写;
  case 节点_变量:
    if (!标号_小写)
      错误_牌_小写(节点_小写->牌_短_小写, "not a compile-time constant");
    if (节点_小写->变量_短->类型_小写_短->种类_小写 != 类型_数组 && 节点_小写->变量_短->类型_小写_短->种类_小写 != 类型_函)
      错误_牌_小写(节点_小写->牌_短_小写, "invalid 初始化器_小写");
    *标号_小写 = &节点_小写->变量_短->名称_小写;
    return 0;
  case 节点_数:
    return 节点_小写->值_小写_短;
  }

  错误_牌_小写(节点_小写->牌_短_小写, "not a compile-time constant");
}

static int64_t 求值_右值(节点 *节点_小写, char ***标号_小写) {
  switch (节点_小写->种类_小写) {
  case 节点_变量:
    if (节点_小写->变量_短->是否_本地)
      错误_牌_小写(节点_小写->牌_短_小写, "not a compile-time constant");
    *标号_小写 = &节点_小写->变量_短->名称_小写;
    return 0;
  case 节点_解引用:
    return 求值2_小写(节点_小写->左手塞_缩, 标号_小写);
  case 节点_成员:
    return 求值_右值(节点_小写->左手塞_缩, 标号_小写) + 节点_小写->成员_小写->偏移_小写;
  }

  错误_牌_小写(节点_小写->牌_短_小写, "invalid 初始化器_小写");
}

static bool 是否_常量_表达式(节点 *节点_小写) {
  加_类型(节点_小写);

  switch (节点_小写->种类_小写) {
  case 节点_加法:
  case 节点_减法:
  case 节点_乘法:
  case 节点_除法:
  case 节点_位与:
  case 节点_位或:
  case 节点_位异或:
  case 节点_左移:
  case 节点_右移:
  case 节点_等于:
  case 节点_不等:
  case 节点_小于:
  case 节点_小等:
  case 节点_逻辑与:
  case 节点_逻辑或:
    return 是否_常量_表达式(节点_小写->左手塞_缩) && 是否_常量_表达式(节点_小写->右手塞_缩);
  case 节点_条件:
    if (!是否_常量_表达式(节点_小写->条件_小写_短))
      return false;
    return 是否_常量_表达式(求值_小写(节点_小写->条件_小写_短) ? 节点_小写->那么_小写 : 节点_小写->否则_小写_短);
  case 节点_逗号:
    return 是否_常量_表达式(节点_小写->右手塞_缩);
  case 节点_负号:
  case 节点_非:
  case 节点_位非:
  case 节点_类转:
    return 是否_常量_表达式(节点_小写->左手塞_缩);
  case 节点_数:
    return true;
  }

  return false;
}

int64_t 常量_表达式_短(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 条件_全(其余的, 牌_短_小写);
  return 求值_小写(节点_小写);
}

static double 求值_双浮_小写(节点 *节点_小写) {
  加_类型(节点_小写);

  if (是否_整数(节点_小写->类型_小写_短)) {
    if (节点_小写->类型_小写_短->是否_无符号)
      return (unsigned long)求值_小写(节点_小写);
    return 求值_小写(节点_小写);
  }

  switch (节点_小写->种类_小写) {
  case 节点_加法:
    return 求值_双浮_小写(节点_小写->左手塞_缩) + 求值_双浮_小写(节点_小写->右手塞_缩);
  case 节点_减法:
    return 求值_双浮_小写(节点_小写->左手塞_缩) - 求值_双浮_小写(节点_小写->右手塞_缩);
  case 节点_乘法:
    return 求值_双浮_小写(节点_小写->左手塞_缩) * 求值_双浮_小写(节点_小写->右手塞_缩);
  case 节点_除法:
    return 求值_双浮_小写(节点_小写->左手塞_缩) / 求值_双浮_小写(节点_小写->右手塞_缩);
  case 节点_负号:
    return -求值_双浮_小写(节点_小写->左手塞_缩);
  case 节点_条件:
    return 求值_双浮_小写(节点_小写->条件_小写_短) ? 求值_双浮_小写(节点_小写->那么_小写) : 求值_双浮_小写(节点_小写->否则_小写_短);
  case 节点_逗号:
    return 求值_双浮_小写(节点_小写->右手塞_缩);
  case 节点_类转:
    if (是否_浮点数目(节点_小写->左手塞_缩->类型_小写_短))
      return 求值_双浮_小写(节点_小写->左手塞_缩);
    return 求值_小写(节点_小写->左手塞_缩);
  case 节点_数:
    return 节点_小写->浮点值_小写_短;
  }

  错误_牌_小写(节点_小写->牌_短_小写, "not a compile-time constant");
}

// Convert op= operators to expressions containing an assignment.
//
// In general, `A op= C` is converted to ``tmp = &A, *tmp = *tmp op B`.
// However, if a given expression is of form `A.x op= C`, the input is
// converted to `tmp = &A, (*tmp).x = (*tmp).x op C` to handle assignments
// to bitfields.
static 节点 *到_赋值_短(节点 *binary) {
  加_类型(binary->左手塞_缩);
  加_类型(binary->右手塞_缩);
  牌 *牌_短_小写 = binary->牌_短_小写;

  // Convert `A.x op= C` to `tmp = &A, (*tmp).x = (*tmp).x op C`.
  if (binary->左手塞_缩->种类_小写 == 节点_成员) {
    对象_缩_大写 *变量_短 = 新_本地变量("", 指针_到(binary->左手塞_缩->左手塞_缩->类型_小写_短));

    节点 *expr1 = 新_二元(节点_赋值, 新_变量_节点(变量_短, 牌_短_小写),
                             新_一元(节点_地址, binary->左手塞_缩->左手塞_缩, 牌_短_小写), 牌_短_小写);

    节点 *expr2 = 新_一元(节点_成员,
                            新_一元(节点_解引用, 新_变量_节点(变量_短, 牌_短_小写), 牌_短_小写),
                            牌_短_小写);
    expr2->成员_小写 = binary->左手塞_缩->成员_小写;

    节点 *expr3 = 新_一元(节点_成员,
                            新_一元(节点_解引用, 新_变量_节点(变量_短, 牌_短_小写), 牌_短_小写),
                            牌_短_小写);
    expr3->成员_小写 = binary->左手塞_缩->成员_小写;

    节点 *expr4 = 新_二元(节点_赋值, expr2,
                             新_二元(binary->种类_小写, expr3, binary->右手塞_缩, 牌_短_小写),
                             牌_短_小写);

    return 新_二元(节点_逗号, expr1, expr4, 牌_短_小写);
  }

  // If A is an atomic type, Convert `A op= B` to
  //
  // ({
  //   T1 *addr = &A; T2 值_小写_短 = (B); T1 old = *addr; T1 new;
  //   do {
  //    new = old op 值_小写_短;
  //   } while (!atomic_compare_exchange_strong(addr, &old, new));
  //   new;
  // })
  if (binary->左手塞_缩->类型_小写_短->是否_原子) {
    节点 head = {};
    节点 *当前_短 = &head;

    对象_缩_大写 *addr = 新_本地变量("", 指针_到(binary->左手塞_缩->类型_小写_短));
    对象_缩_大写 *值_小写_短 = 新_本地变量("", binary->右手塞_缩->类型_小写_短);
    对象_缩_大写 *old = 新_本地变量("", binary->左手塞_缩->类型_小写_短);
    对象_缩_大写 *new = 新_本地变量("", binary->左手塞_缩->类型_小写_短);

    当前_短 = 当前_短->下一个_小写 =
      新_一元(节点_表达式_语句,
                新_二元(节点_赋值, 新_变量_节点(addr, 牌_短_小写),
                           新_一元(节点_地址, binary->左手塞_缩, 牌_短_小写), 牌_短_小写),
                牌_短_小写);

    当前_短 = 当前_短->下一个_小写 =
      新_一元(节点_表达式_语句,
                新_二元(节点_赋值, 新_变量_节点(值_小写_短, 牌_短_小写), binary->右手塞_缩, 牌_短_小写),
                牌_短_小写);

    当前_短 = 当前_短->下一个_小写 =
      新_一元(节点_表达式_语句,
                新_二元(节点_赋值, 新_变量_节点(old, 牌_短_小写),
                           新_一元(节点_解引用, 新_变量_节点(addr, 牌_短_小写), 牌_短_小写), 牌_短_小写),
                牌_短_小写);

    节点 *loop = 新_节点(节点_做, 牌_短_小写);
    loop->破坏_标号_缩 = 新_唯一_名称();
    loop->继续_标号_缩 = 新_唯一_名称();

    节点 *函数体_小写 = 新_二元(节点_赋值,
                            新_变量_节点(new, 牌_短_小写),
                            新_二元(binary->种类_小写, 新_变量_节点(old, 牌_短_小写),
                                       新_变量_节点(值_小写_短, 牌_短_小写), 牌_短_小写),
                            牌_短_小写);

    loop->那么_小写 = 新_节点(节点_块, 牌_短_小写);
    loop->那么_小写->函数体_小写 = 新_一元(节点_表达式_语句, 函数体_小写, 牌_短_小写);

    节点 *cas = 新_节点(节点_对比与交换, 牌_短_小写);
    cas->对比与交换_地址 = 新_变量_节点(addr, 牌_短_小写);
    cas->对比与交换_旧 = 新_一元(节点_地址, 新_变量_节点(old, 牌_短_小写), 牌_短_小写);
    cas->对比与交换_新 = 新_变量_节点(new, 牌_短_小写);
    loop->条件_小写_短 = 新_一元(节点_非, cas, 牌_短_小写);

    当前_短 = 当前_短->下一个_小写 = loop;
    当前_短 = 当前_短->下一个_小写 = 新_一元(节点_表达式_语句, 新_变量_节点(new, 牌_短_小写), 牌_短_小写);

    节点 *节点_小写 = 新_节点(节点_语句_表达式, 牌_短_小写);
    节点_小写->函数体_小写 = head.下一个_小写;
    return 节点_小写;
  }

  // Convert `A op= B` to ``tmp = &A, *tmp = *tmp op B`.
  对象_缩_大写 *变量_短 = 新_本地变量("", 指针_到(binary->左手塞_缩->类型_小写_短));

  节点 *expr1 = 新_二元(节点_赋值, 新_变量_节点(变量_短, 牌_短_小写),
                           新_一元(节点_地址, binary->左手塞_缩, 牌_短_小写), 牌_短_小写);

  节点 *expr2 =
    新_二元(节点_赋值,
               新_一元(节点_解引用, 新_变量_节点(变量_短, 牌_短_小写), 牌_短_小写),
               新_二元(binary->种类_小写,
                          新_一元(节点_解引用, 新_变量_节点(变量_短, 牌_短_小写), 牌_短_小写),
                          binary->右手塞_缩,
                          牌_短_小写),
               牌_短_小写);

  return 新_二元(节点_逗号, expr1, expr2, 牌_短_小写);
}

// 赋值_短    = 条件_全 (赋值_短-op 赋值_短)?
// 赋值_短-op = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^="
//           | "<<=" | ">>="
static 节点 *赋值_短(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 条件_全(&牌_短_小写, 牌_短_小写);

  if (相等吗_小写(牌_短_小写, "="))
    return 新_二元(节点_赋值, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写);

  if (相等吗_小写(牌_短_小写, "+="))
    return 到_赋值_短(新_加_短(节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, "-="))
    return 到_赋值_短(新_减_短(节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, "*="))
    return 到_赋值_短(新_二元(节点_乘法, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, "/="))
    return 到_赋值_短(新_二元(节点_除法, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, "%="))
    return 到_赋值_短(新_二元(节点_取模, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, "&="))
    return 到_赋值_短(新_二元(节点_位与, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, "|="))
    return 到_赋值_短(新_二元(节点_位或, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, "^="))
    return 到_赋值_短(新_二元(节点_位异或, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, "<<="))
    return 到_赋值_短(新_二元(节点_左移, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  if (相等吗_小写(牌_短_小写, ">>="))
    return 到_赋值_短(新_二元(节点_右移, 节点_小写, 赋值_短(其余的, 牌_短_小写->下一个_小写), 牌_短_小写));

  *其余的 = 牌_短_小写;
  return 节点_小写;
}

// 条件_全 = 逻辑或_小写 ("?" 表达式_短_小写? ":" 条件_全)?
static 节点 *条件_全(牌 **其余的, 牌 *牌_短_小写) {
  节点 *条件_小写_短 = 逻辑或_小写(&牌_短_小写, 牌_短_小写);

  if (!相等吗_小写(牌_短_小写, "?")) {
    *其余的 = 牌_短_小写;
    return 条件_小写_短;
  }

  if (相等吗_小写(牌_短_小写->下一个_小写, ":")) {
    // [GNU] Compile `a ?: b` as `tmp = a, tmp ? tmp : b`.
    加_类型(条件_小写_短);
    对象_缩_大写 *变量_短 = 新_本地变量("", 条件_小写_短->类型_小写_短);
    节点 *左手塞_缩 = 新_二元(节点_赋值, 新_变量_节点(变量_短, 牌_短_小写), 条件_小写_短, 牌_短_小写);
    节点 *右手塞_缩 = 新_节点(节点_条件, 牌_短_小写);
    右手塞_缩->条件_小写_短 = 新_变量_节点(变量_短, 牌_短_小写);
    右手塞_缩->那么_小写 = 新_变量_节点(变量_短, 牌_短_小写);
    右手塞_缩->否则_小写_短 = 条件_全(其余的, 牌_短_小写->下一个_小写->下一个_小写);
    return 新_二元(节点_逗号, 左手塞_缩, 右手塞_缩, 牌_短_小写);
  }

  节点 *节点_小写 = 新_节点(节点_条件, 牌_短_小写);
  节点_小写->条件_小写_短 = 条件_小写_短;
  节点_小写->那么_小写 = 表达式_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写);
  牌_短_小写 = 跳过_小写(牌_短_小写, ":");
  节点_小写->否则_小写_短 = 条件_全(其余的, 牌_短_小写);
  return 节点_小写;
}

// 逻辑或_小写 = 逻辑与_小写 ("||" 逻辑与_小写)*
static 节点 *逻辑或_小写(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 逻辑与_小写(&牌_短_小写, 牌_短_小写);
  while (相等吗_小写(牌_短_小写, "||")) {
    牌 *开起 = 牌_短_小写;
    节点_小写 = 新_二元(节点_逻辑或, 节点_小写, 逻辑与_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
  }
  *其余的 = 牌_短_小写;
  return 节点_小写;
}

// 逻辑与_小写 = 位或_小写 ("&&" 位或_小写)*
static 节点 *逻辑与_小写(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 位或_小写(&牌_短_小写, 牌_短_小写);
  while (相等吗_小写(牌_短_小写, "&&")) {
    牌 *开起 = 牌_短_小写;
    节点_小写 = 新_二元(节点_逻辑与, 节点_小写, 位或_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
  }
  *其余的 = 牌_短_小写;
  return 节点_小写;
}

// 位或_小写 = 位异或_小写 ("|" 位异或_小写)*
static 节点 *位或_小写(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 位异或_小写(&牌_短_小写, 牌_短_小写);
  while (相等吗_小写(牌_短_小写, "|")) {
    牌 *开起 = 牌_短_小写;
    节点_小写 = 新_二元(节点_位或, 节点_小写, 位异或_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
  }
  *其余的 = 牌_短_小写;
  return 节点_小写;
}

// 位异或_小写 = 位与_小写 ("^" 位与_小写)*
static 节点 *位异或_小写(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 位与_小写(&牌_短_小写, 牌_短_小写);
  while (相等吗_小写(牌_短_小写, "^")) {
    牌 *开起 = 牌_短_小写;
    节点_小写 = 新_二元(节点_位异或, 节点_小写, 位与_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
  }
  *其余的 = 牌_短_小写;
  return 节点_小写;
}

// 位与_小写 = 相等_全 ("&" 相等_全)*
static 节点 *位与_小写(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 相等_全(&牌_短_小写, 牌_短_小写);
  while (相等吗_小写(牌_短_小写, "&")) {
    牌 *开起 = 牌_短_小写;
    节点_小写 = 新_二元(节点_位与, 节点_小写, 相等_全(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
  }
  *其余的 = 牌_短_小写;
  return 节点_小写;
}

// 相等_全 = 关系_全 ("==" 关系_全 | "!=" 关系_全)*
static 节点 *相等_全(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 关系_全(&牌_短_小写, 牌_短_小写);

  for (;;) {
    牌 *开起 = 牌_短_小写;

    if (相等吗_小写(牌_短_小写, "==")) {
      节点_小写 = 新_二元(节点_等于, 节点_小写, 关系_全(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, "!=")) {
      节点_小写 = 新_二元(节点_不等, 节点_小写, 关系_全(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    *其余的 = 牌_短_小写;
    return 节点_小写;
  }
}

// 关系_全 = 移位_全 ("<" 移位_全 | "<=" 移位_全 | ">" 移位_全 | ">=" 移位_全)*
static 节点 *关系_全(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 移位_全(&牌_短_小写, 牌_短_小写);

  for (;;) {
    牌 *开起 = 牌_短_小写;

    if (相等吗_小写(牌_短_小写, "<")) {
      节点_小写 = 新_二元(节点_小于, 节点_小写, 移位_全(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, "<=")) {
      节点_小写 = 新_二元(节点_小等, 节点_小写, 移位_全(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, ">")) {
      节点_小写 = 新_二元(节点_小于, 移位_全(&牌_短_小写, 牌_短_小写->下一个_小写), 节点_小写, 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, ">=")) {
      节点_小写 = 新_二元(节点_小等, 移位_全(&牌_短_小写, 牌_短_小写->下一个_小写), 节点_小写, 开起);
      continue;
    }

    *其余的 = 牌_短_小写;
    return 节点_小写;
  }
}

// 移位_全 = 加_短_小写 ("<<" 加_短_小写 | ">>" 加_短_小写)*
static 节点 *移位_全(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 加_短_小写(&牌_短_小写, 牌_短_小写);

  for (;;) {
    牌 *开起 = 牌_短_小写;

    if (相等吗_小写(牌_短_小写, "<<")) {
      节点_小写 = 新_二元(节点_左移, 节点_小写, 加_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, ">>")) {
      节点_小写 = 新_二元(节点_右移, 节点_小写, 加_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    *其余的 = 牌_短_小写;
    return 节点_小写;
  }
}

// In C, `+` operator is overloaded to perform the pointer arithmetic.
// If p is a pointer, p+n adds not n but sizeof(*p)*n to the value of p,
// so that p+n points to the location n elements (not bytes) ahead of p.
// In other words, we need to scale an integer value before adding to a
// pointer value. This 函数_全_小写 takes care of the scaling.
static 节点 *新_加_短(节点 *左手塞_缩, 节点 *右手塞_缩, 牌 *牌_短_小写) {
  加_类型(左手塞_缩);
  加_类型(右手塞_缩);

  // num + num
  if (是否_数值(左手塞_缩->类型_小写_短) && 是否_数值(右手塞_缩->类型_小写_短))
    return 新_二元(节点_加法, 左手塞_缩, 右手塞_缩, 牌_短_小写);

  if (左手塞_缩->类型_小写_短->基础_小写 && 右手塞_缩->类型_小写_短->基础_小写)
    错误_牌_小写(牌_短_小写, "invalid operands");

  // Canonicalize `num + ptr` to `ptr + num`.
  if (!左手塞_缩->类型_小写_短->基础_小写 && 右手塞_缩->类型_小写_短->基础_小写) {
    节点 *tmp = 左手塞_缩;
    左手塞_缩 = 右手塞_缩;
    右手塞_缩 = tmp;
  }

  // VLA + num
  if (左手塞_缩->类型_小写_短->基础_小写->种类_小写 == 类型_变长数组) {
    右手塞_缩 = 新_二元(节点_乘法, 右手塞_缩, 新_变量_节点(左手塞_缩->类型_小写_短->基础_小写->变长数组_大小, 牌_短_小写), 牌_短_小写);
    return 新_二元(节点_加法, 左手塞_缩, 右手塞_缩, 牌_短_小写);
  }

  // ptr + num
  右手塞_缩 = 新_二元(节点_乘法, 右手塞_缩, 新_长的(左手塞_缩->类型_小写_短->基础_小写->大小_小写, 牌_短_小写), 牌_短_小写);
  return 新_二元(节点_加法, 左手塞_缩, 右手塞_缩, 牌_短_小写);
}

// Like `+`, `-` is overloaded for the pointer type.
static 节点 *新_减_短(节点 *左手塞_缩, 节点 *右手塞_缩, 牌 *牌_短_小写) {
  加_类型(左手塞_缩);
  加_类型(右手塞_缩);

  // num - num
  if (是否_数值(左手塞_缩->类型_小写_短) && 是否_数值(右手塞_缩->类型_小写_短))
    return 新_二元(节点_减法, 左手塞_缩, 右手塞_缩, 牌_短_小写);

  // VLA + num
  if (左手塞_缩->类型_小写_短->基础_小写->种类_小写 == 类型_变长数组) {
    右手塞_缩 = 新_二元(节点_乘法, 右手塞_缩, 新_变量_节点(左手塞_缩->类型_小写_短->基础_小写->变长数组_大小, 牌_短_小写), 牌_短_小写);
    加_类型(右手塞_缩);
    节点 *节点_小写 = 新_二元(节点_减法, 左手塞_缩, 右手塞_缩, 牌_短_小写);
    节点_小写->类型_小写_短 = 左手塞_缩->类型_小写_短;
    return 节点_小写;
  }

  // ptr - num
  if (左手塞_缩->类型_小写_短->基础_小写 && 是否_整数(右手塞_缩->类型_小写_短)) {
    右手塞_缩 = 新_二元(节点_乘法, 右手塞_缩, 新_长的(左手塞_缩->类型_小写_短->基础_小写->大小_小写, 牌_短_小写), 牌_短_小写);
    加_类型(右手塞_缩);
    节点 *节点_小写 = 新_二元(节点_减法, 左手塞_缩, 右手塞_缩, 牌_短_小写);
    节点_小写->类型_小写_短 = 左手塞_缩->类型_小写_短;
    return 节点_小写;
  }

  // ptr - ptr, which returns how many elements are between the two.
  if (左手塞_缩->类型_小写_短->基础_小写 && 右手塞_缩->类型_小写_短->基础_小写) {
    节点 *节点_小写 = 新_二元(节点_减法, 左手塞_缩, 右手塞_缩, 牌_短_小写);
    节点_小写->类型_小写_短 = 类型_长的_小写;
    return 新_二元(节点_除法, 节点_小写, 新_数目(左手塞_缩->类型_小写_短->基础_小写->大小_小写, 牌_短_小写), 牌_短_小写);
  }

  错误_牌_小写(牌_短_小写, "invalid operands");
}

// 加_短_小写 = 乘_短_小写 ("+" 乘_短_小写 | "-" 乘_短_小写)*
static 节点 *加_短_小写(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 乘_短_小写(&牌_短_小写, 牌_短_小写);

  for (;;) {
    牌 *开起 = 牌_短_小写;

    if (相等吗_小写(牌_短_小写, "+")) {
      节点_小写 = 新_加_短(节点_小写, 乘_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, "-")) {
      节点_小写 = 新_减_短(节点_小写, 乘_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    *其余的 = 牌_短_小写;
    return 节点_小写;
  }
}

// 乘_短_小写 = 类型转换_小写 ("*" 类型转换_小写 | "/" 类型转换_小写 | "%" 类型转换_小写)*
static 节点 *乘_短_小写(牌 **其余的, 牌 *牌_短_小写) {
  节点 *节点_小写 = 类型转换_小写(&牌_短_小写, 牌_短_小写);

  for (;;) {
    牌 *开起 = 牌_短_小写;

    if (相等吗_小写(牌_短_小写, "*")) {
      节点_小写 = 新_二元(节点_乘法, 节点_小写, 类型转换_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, "/")) {
      节点_小写 = 新_二元(节点_除法, 节点_小写, 类型转换_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, "%")) {
      节点_小写 = 新_二元(节点_取模, 节点_小写, 类型转换_小写(&牌_短_小写, 牌_短_小写->下一个_小写), 开起);
      continue;
    }

    *其余的 = 牌_短_小写;
    return 节点_小写;
  }
}

// 类型转换_小写 = "(" type-名称_小写 ")" 类型转换_小写 | 一元运算_小写
static 节点 *类型转换_小写(牌 **其余的, 牌 *牌_短_小写) {
  if (相等吗_小写(牌_短_小写, "(") && 是否_类型名(牌_短_小写->下一个_小写)) {
    牌 *开起 = 牌_短_小写;
    类型 *类型_小写_短 = 类型名_小写(&牌_短_小写, 牌_短_小写->下一个_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");

    // compound literal
    if (相等吗_小写(牌_短_小写, "{"))
      return 一元运算_小写(其余的, 开起);

    // type 类型转换_小写
    节点 *节点_小写 = 新_转换(类型转换_小写(其余的, 牌_短_小写), 类型_小写_短);
    节点_小写->牌_短_小写 = 开起;
    return 节点_小写;
  }

  return 一元运算_小写(其余的, 牌_短_小写);
}

// 一元运算_小写 = ("+" | "-" | "*" | "&" | "!" | "~") 类型转换_小写
//       | ("++" | "--") 一元运算_小写
//       | "&&" ident
//       | 表达式后缀
static 节点 *一元运算_小写(牌 **其余的, 牌 *牌_短_小写) {
  if (相等吗_小写(牌_短_小写, "+"))
    return 类型转换_小写(其余的, 牌_短_小写->下一个_小写);

  if (相等吗_小写(牌_短_小写, "-"))
    return 新_一元(节点_负号, 类型转换_小写(其余的, 牌_短_小写->下一个_小写), 牌_短_小写);

  if (相等吗_小写(牌_短_小写, "&")) {
    节点 *左手塞_缩 = 类型转换_小写(其余的, 牌_短_小写->下一个_小写);
    加_类型(左手塞_缩);
    if (左手塞_缩->种类_小写 == 节点_成员 && 左手塞_缩->成员_小写->是否_位字段)
      错误_牌_小写(牌_短_小写, "cannot take address of bitfield");
    return 新_一元(节点_地址, 左手塞_缩, 牌_短_小写);
  }

  if (相等吗_小写(牌_短_小写, "*")) {
    // [https://www.sigbus.info/n1570#6.5.3.2p4] This is an oddity
    // in the C spec, but dereferencing a 函数_全_小写 shouldn't do
    // anything. If foo is a 函数_全_小写, `*foo`, `**foo` or `*****foo`
    // are all equivalent to just `foo`.
    节点 *节点_小写 = 类型转换_小写(其余的, 牌_短_小写->下一个_小写);
    加_类型(节点_小写);
    if (节点_小写->类型_小写_短->种类_小写 == 类型_函)
      return 节点_小写;
    return 新_一元(节点_解引用, 节点_小写, 牌_短_小写);
  }

  if (相等吗_小写(牌_短_小写, "!"))
    return 新_一元(节点_非, 类型转换_小写(其余的, 牌_短_小写->下一个_小写), 牌_短_小写);

  if (相等吗_小写(牌_短_小写, "~"))
    return 新_一元(节点_位非, 类型转换_小写(其余的, 牌_短_小写->下一个_小写), 牌_短_小写);

  // Read ++i as i+=1
  if (相等吗_小写(牌_短_小写, "++"))
    return 到_赋值_短(新_加_短(一元运算_小写(其余的, 牌_短_小写->下一个_小写), 新_数目(1, 牌_短_小写), 牌_短_小写));

  // Read --i as i-=1
  if (相等吗_小写(牌_短_小写, "--"))
    return 到_赋值_短(新_减_短(一元运算_小写(其余的, 牌_短_小写->下一个_小写), 新_数目(1, 牌_短_小写), 牌_短_小写));

  // [GNU] 标号们_小写-as-values
  if (相等吗_小写(牌_短_小写, "&&")) {
    节点 *节点_小写 = 新_节点(节点_标号_值, 牌_短_小写);
    节点_小写->标号_小写 = 获取_标识(牌_短_小写->下一个_小写);
    节点_小写->去到_下一个 = 去到们_小写;
    去到们_小写 = 节点_小写;
    *其余的 = 牌_短_小写->下一个_小写->下一个_小写;
    return 节点_小写;
  }

  return 表达式后缀(其余的, 牌_短_小写);
}

// struct-成员们_小写 = (声明的说明 声明符_小写 (","  声明符_小写)* ";")*
static void 结构_成员们(牌 **其余的, 牌 *牌_短_小写, 类型 *类型_小写_短) {
  成员 head = {};
  成员 *当前_短 = &head;
  int 索引_缩 = 0;

  while (!相等吗_小写(牌_短_小写, "}")) {
    变量属性_短 attr = {};
    类型 *基本类型_短 = 声明的说明(&牌_短_小写, 牌_短_小写, &attr);
    bool first = true;

    // Anonymous struct 成员_小写
    if ((基本类型_短->种类_小写 == 类型_结构 || 基本类型_短->种类_小写 == 类型_联合) &&
        消耗吗_小写(&牌_短_小写, 牌_短_小写, ";")) {
      成员 *成员_短_小写 = calloc(1, sizeof(成员));
      成员_短_小写->类型_小写_短 = 基本类型_短;
      成员_短_小写->索引_缩 = 索引_缩++;
      成员_短_小写->对齐_短_小写 = attr.对齐_短_小写 ? attr.对齐_短_小写 : 成员_短_小写->类型_小写_短->对齐_短_小写;
      当前_短 = 当前_短->下一个_小写 = 成员_短_小写;
      continue;
    }

    // Regular struct 成员们_小写
    while (!消耗吗_小写(&牌_短_小写, 牌_短_小写, ";")) {
      if (!first)
        牌_短_小写 = 跳过_小写(牌_短_小写, ",");
      first = false;

      成员 *成员_短_小写 = calloc(1, sizeof(成员));
      成员_短_小写->类型_小写_短 = 声明符_小写(&牌_短_小写, 牌_短_小写, 基本类型_短);
      成员_短_小写->名称_小写 = 成员_短_小写->类型_小写_短->名称_小写;
      成员_短_小写->索引_缩 = 索引_缩++;
      成员_短_小写->对齐_短_小写 = attr.对齐_短_小写 ? attr.对齐_短_小写 : 成员_短_小写->类型_小写_短->对齐_短_小写;

      if (消耗吗_小写(&牌_短_小写, 牌_短_小写, ":")) {
        成员_短_小写->是否_位字段 = true;
        成员_短_小写->位_宽度 = 常量_表达式_短(&牌_短_小写, 牌_短_小写);
      }

      当前_短 = 当前_短->下一个_小写 = 成员_短_小写;
    }
  }

  // If the last element is an array of incomplete type, it's
  // called a "flexible array 成员_小写". It should behave as if
  // if were a zero-sized array.
  if (当前_短 != &head && 当前_短->类型_小写_短->种类_小写 == 类型_数组 && 当前_短->类型_小写_短->数组_长度 < 0) {
    当前_短->类型_小写_短 = 数组_的(当前_短->类型_小写_短->基础_小写, 0);
    类型_小写_短->是否_弹性 = true;
  }

  *其余的 = 牌_短_小写->下一个_小写;
  类型_小写_短->成员们_小写 = head.下一个_小写;
}

// attribute = ("__attribute__" "(" "(" "packed" ")" ")")*
static 牌 *属性_列表_特征(牌 *牌_短_小写, 类型 *类型_小写_短) {
  while (消耗吗_小写(&牌_短_小写, 牌_短_小写, "__attribute__")) {
    牌_短_小写 = 跳过_小写(牌_短_小写, "(");
    牌_短_小写 = 跳过_小写(牌_短_小写, "(");

    bool first = true;

    while (!消耗吗_小写(&牌_短_小写, 牌_短_小写, ")")) {
      if (!first)
        牌_短_小写 = 跳过_小写(牌_短_小写, ",");
      first = false;

      if (消耗吗_小写(&牌_短_小写, 牌_短_小写, "packed")) {
        类型_小写_短->是否_已打包 = true;
        continue;
      }

      if (消耗吗_小写(&牌_短_小写, 牌_短_小写, "aligned")) {
        牌_短_小写 = 跳过_小写(牌_短_小写, "(");
        类型_小写_短->对齐_短_小写 = 常量_表达式_短(&牌_短_小写, 牌_短_小写);
        牌_短_小写 = 跳过_小写(牌_短_小写, ")");
        continue;
      }

      错误_牌_小写(牌_短_小写, "unknown attribute");
    }

    牌_短_小写 = 跳过_小写(牌_短_小写, ")");
  }

  return 牌_短_小写;
}

// struct-union-decl = attribute? ident? ("{" struct-成员们_小写)?
static 类型 *结构_联合_声明_短(牌 **其余的, 牌 *牌_短_小写) {
  类型 *类型_小写_短 = 结构_类型();
  牌_短_小写 = 属性_列表_特征(牌_短_小写, 类型_小写_短);

  // Read a tag.
  牌 *tag = NULL;
  if (牌_短_小写->种类_小写 == 牌_标识) {
    tag = 牌_短_小写;
    牌_短_小写 = 牌_短_小写->下一个_小写;
  }

  if (tag && !相等吗_小写(牌_短_小写, "{")) {
    *其余的 = 牌_短_小写;

    类型 *ty2 = 找_标签(tag);
    if (ty2)
      return ty2;

    类型_小写_短->大小_小写 = -1;
    推_标签_作用域(tag, 类型_小写_短);
    return 类型_小写_短;
  }

  牌_短_小写 = 跳过_小写(牌_短_小写, "{");

  // Construct a struct object.
  结构_成员们(&牌_短_小写, 牌_短_小写, 类型_小写_短);
  *其余的 = 属性_列表_特征(牌_短_小写, 类型_小写_短);

  if (tag) {
    // If this is a redefinition, overwrite a previous type.
    // Otherwise, register the struct type.
    类型 *ty2 = 哈希映射_获取2(&作用域_小写->标签们, tag->定位_小写_短, tag->长度_短);
    if (ty2) {
      *ty2 = *类型_小写_短;
      return ty2;
    }

    推_标签_作用域(tag, 类型_小写_短);
  }

  return 类型_小写_短;
}

// struct-decl = struct-union-decl
static 类型 *结构_声明_短(牌 **其余的, 牌 *牌_短_小写) {
  类型 *类型_小写_短 = 结构_联合_声明_短(其余的, 牌_短_小写);
  类型_小写_短->种类_小写 = 类型_结构;

  if (类型_小写_短->大小_小写 < 0)
    return 类型_小写_短;

  // Assign offsets within the struct to 成员们_小写.
  int bits = 0;

  for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写) {
    if (成员_短_小写->是否_位字段 && 成员_短_小写->位_宽度 == 0) {
      // Zero-width anonymous bitfield has a special meaning.
      // It affects only alignment.
      bits = 对齐_到(bits, 成员_短_小写->类型_小写_短->大小_小写 * 8);
    } else if (成员_短_小写->是否_位字段) {
      int sz = 成员_短_小写->类型_小写_短->大小_小写;
      if (bits / (sz * 8) != (bits + 成员_短_小写->位_宽度 - 1) / (sz * 8))
        bits = 对齐_到(bits, sz * 8);

      成员_短_小写->偏移_小写 = 对齐_下_小写(bits / 8, sz);
      成员_短_小写->位_偏移 = bits % (sz * 8);
      bits += 成员_短_小写->位_宽度;
    } else {
      if (!类型_小写_短->是否_已打包)
        bits = 对齐_到(bits, 成员_短_小写->对齐_短_小写 * 8);
      成员_短_小写->偏移_小写 = bits / 8;
      bits += 成员_短_小写->类型_小写_短->大小_小写 * 8;
    }

    if (!类型_小写_短->是否_已打包 && 类型_小写_短->对齐_短_小写 < 成员_短_小写->对齐_短_小写)
      类型_小写_短->对齐_短_小写 = 成员_短_小写->对齐_短_小写;
  }

  类型_小写_短->大小_小写 = 对齐_到(bits, 类型_小写_短->对齐_短_小写 * 8) / 8;
  return 类型_小写_短;
}

// union-decl = struct-union-decl
static 类型 *联合_声明_短(牌 **其余的, 牌 *牌_短_小写) {
  类型 *类型_小写_短 = 结构_联合_声明_短(其余的, 牌_短_小写);
  类型_小写_短->种类_小写 = 类型_联合;

  if (类型_小写_短->大小_小写 < 0)
    return 类型_小写_短;

  // If union, we don't have to 赋值_短 offsets because they
  // are already initialized to zero. We need to compute the
  // alignment and the 大小_小写 though.
  for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写) {
    if (类型_小写_短->对齐_短_小写 < 成员_短_小写->对齐_短_小写)
      类型_小写_短->对齐_短_小写 = 成员_短_小写->对齐_短_小写;
    if (类型_小写_短->大小_小写 < 成员_短_小写->类型_小写_短->大小_小写)
      类型_小写_短->大小_小写 = 成员_短_小写->类型_小写_短->大小_小写;
  }
  类型_小写_短->大小_小写 = 对齐_到(类型_小写_短->大小_小写, 类型_小写_短->对齐_短_小写);
  return 类型_小写_短;
}

// Find a struct 成员_小写 by 名称_小写.
static 成员 *获取_结构_成员(类型 *类型_小写_短, 牌 *牌_短_小写) {
  for (成员 *成员_短_小写 = 类型_小写_短->成员们_小写; 成员_短_小写; 成员_短_小写 = 成员_短_小写->下一个_小写) {
    // Anonymous struct 成员_小写
    if ((成员_短_小写->类型_小写_短->种类_小写 == 类型_结构 || 成员_短_小写->类型_小写_短->种类_小写 == 类型_联合) &&
        !成员_短_小写->名称_小写) {
      if (获取_结构_成员(成员_短_小写->类型_小写_短, 牌_短_小写))
        return 成员_短_小写;
      continue;
    }

    // Regular struct 成员_小写
    if (成员_短_小写->名称_小写->长度_短 == 牌_短_小写->长度_短 &&
        !strncmp(成员_短_小写->名称_小写->定位_小写_短, 牌_短_小写->定位_小写_短, 牌_短_小写->长度_短))
      return 成员_短_小写;
  }
  return NULL;
}

// Create a 节点_小写 representing a struct 成员_小写 access, such as foo.bar
// where foo is a struct and bar is a 成员_小写 名称_小写.
//
// C has a feature called "anonymous struct" which allows a struct to
// have another unnamed struct as a 成员_小写 like this:
//
//   struct { struct { int a; }; int b; } x;
//
// The 成员们_小写 of an anonymous struct belong to the outer struct's
// 成员_小写 namespace. Therefore, in the above example, you can access
// 成员_小写 "a" of the anonymous struct as "x.a".
//
// This 函数_全_小写 takes care of anonymous structs.
static 节点 *结构_引用_短(节点 *节点_小写, 牌 *牌_短_小写) {
  加_类型(节点_小写);
  if (节点_小写->类型_小写_短->种类_小写 != 类型_结构 && 节点_小写->类型_小写_短->种类_小写 != 类型_联合)
    错误_牌_小写(节点_小写->牌_短_小写, "not a struct nor a union");

  类型 *类型_小写_短 = 节点_小写->类型_小写_短;

  for (;;) {
    成员 *成员_短_小写 = 获取_结构_成员(类型_小写_短, 牌_短_小写);
    if (!成员_短_小写)
      错误_牌_小写(牌_短_小写, "no such 成员_小写");
    节点_小写 = 新_一元(节点_成员, 节点_小写, 牌_短_小写);
    节点_小写->成员_小写 = 成员_短_小写;
    if (成员_短_小写->名称_小写)
      break;
    类型_小写_短 = 成员_短_小写->类型_小写_短;
  }
  return 节点_小写;
}

// Convert A++ to `(typeof A)((A += 1) - 1)`
static 节点 *新_递增_递减_短(节点 *节点_小写, 牌 *牌_短_小写, int 加终_小写_短) {
  加_类型(节点_小写);
  return 新_转换(新_加_短(到_赋值_短(新_加_短(节点_小写, 新_数目(加终_小写_短, 牌_短_小写), 牌_短_小写)),
                          新_数目(-加终_小写_短, 牌_短_小写), 牌_短_小写),
                  节点_小写->类型_小写_短);
}

// 表达式后缀 = "(" type-名称_小写 ")" "{" 初始化器_小写-list "}"
//         = ident "(" func-实参们_短 ")" 表达式后缀-tail*
//         | 首要的_小写 表达式后缀-tail*
//
// 表达式后缀-tail = "[" 表达式_短_小写 "]"
//              | "(" func-实参们_短 ")"
//              | "." ident
//              | "->" ident
//              | "++"
//              | "--"
static 节点 *表达式后缀(牌 **其余的, 牌 *牌_短_小写) {
  if (相等吗_小写(牌_短_小写, "(") && 是否_类型名(牌_短_小写->下一个_小写)) {
    // Compound literal
    牌 *开起 = 牌_短_小写;
    类型 *类型_小写_短 = 类型名_小写(&牌_短_小写, 牌_短_小写->下一个_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ")");

    if (作用域_小写->下一个_小写 == NULL) {
      对象_缩_大写 *变量_短 = 新_匿名_全局变量(类型_小写_短);
      全局变量_初始化器(其余的, 牌_短_小写, 变量_短);
      return 新_变量_节点(变量_短, 开起);
    }

    对象_缩_大写 *变量_短 = 新_本地变量("", 类型_小写_短);
    节点 *左手塞_缩 = 本地变量_初始化器(其余的, 牌_短_小写, 变量_短);
    节点 *右手塞_缩 = 新_变量_节点(变量_短, 牌_短_小写);
    return 新_二元(节点_逗号, 左手塞_缩, 右手塞_缩, 开起);
  }

  节点 *节点_小写 = 首要的_小写(&牌_短_小写, 牌_短_小写);

  for (;;) {
    if (相等吗_小写(牌_短_小写, "(")) {
      节点_小写 = 函调用_小写(&牌_短_小写, 牌_短_小写->下一个_小写, 节点_小写);
      continue;
    }

    if (相等吗_小写(牌_短_小写, "[")) {
      // x[y] is short for *(x+y)
      牌 *开起 = 牌_短_小写;
      节点 *索引_缩 = 表达式_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写);
      牌_短_小写 = 跳过_小写(牌_短_小写, "]");
      节点_小写 = 新_一元(节点_解引用, 新_加_短(节点_小写, 索引_缩, 开起), 开起);
      continue;
    }

    if (相等吗_小写(牌_短_小写, ".")) {
      节点_小写 = 结构_引用_短(节点_小写, 牌_短_小写->下一个_小写);
      牌_短_小写 = 牌_短_小写->下一个_小写->下一个_小写;
      continue;
    }

    if (相等吗_小写(牌_短_小写, "->")) {
      // x->y is short for (*x).y
      节点_小写 = 新_一元(节点_解引用, 节点_小写, 牌_短_小写);
      节点_小写 = 结构_引用_短(节点_小写, 牌_短_小写->下一个_小写);
      牌_短_小写 = 牌_短_小写->下一个_小写->下一个_小写;
      continue;
    }

    if (相等吗_小写(牌_短_小写, "++")) {
      节点_小写 = 新_递增_递减_短(节点_小写, 牌_短_小写, 1);
      牌_短_小写 = 牌_短_小写->下一个_小写;
      continue;
    }

    if (相等吗_小写(牌_短_小写, "--")) {
      节点_小写 = 新_递增_递减_短(节点_小写, 牌_短_小写, -1);
      牌_短_小写 = 牌_短_小写->下一个_小写;
      continue;
    }

    *其余的 = 牌_短_小写;
    return 节点_小写;
  }
}

// 函调用_小写 = (赋值_短 ("," 赋值_短)*)? ")"
static 节点 *函调用_小写(牌 **其余的, 牌 *牌_短_小写, 节点 *fn) {
  加_类型(fn);

  if (fn->类型_小写_短->种类_小写 != 类型_函 &&
      (fn->类型_小写_短->种类_小写 != 类型_指针 || fn->类型_小写_短->基础_小写->种类_小写 != 类型_函))
    错误_牌_小写(fn->牌_短_小写, "not a 函数_全_小写");

  类型 *类型_小写_短 = (fn->类型_小写_短->种类_小写 == 类型_函) ? fn->类型_小写_短 : fn->类型_小写_短->基础_小写;
  类型 *param_ty = 类型_小写_短->形参们_短_小写;

  节点 head = {};
  节点 *当前_短 = &head;

  while (!相等吗_小写(牌_短_小写, ")")) {
    if (当前_短 != &head)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");

    节点 *arg = 赋值_短(&牌_短_小写, 牌_短_小写);
    加_类型(arg);

    if (!param_ty && !类型_小写_短->是否_可变参数)
      错误_牌_小写(牌_短_小写, "too many arguments");

    if (param_ty) {
      if (param_ty->种类_小写 != 类型_结构 && param_ty->种类_小写 != 类型_联合)
        arg = 新_转换(arg, param_ty);
      param_ty = param_ty->下一个_小写;
    } else if (arg->类型_小写_短->种类_小写 == 类型_浮点) {
      // If parameter type is omitted (e.g. in "..."), float
      // arguments are promoted to double.
      arg = 新_转换(arg, 类型_双浮_小写);
    }

    当前_短 = 当前_短->下一个_小写 = arg;
  }

  if (param_ty)
    错误_牌_小写(牌_短_小写, "too few arguments");

  *其余的 = 跳过_小写(牌_短_小写, ")");

  节点 *节点_小写 = 新_一元(节点_函调, fn, 牌_短_小写);
  节点_小写->函_类型_缩 = 类型_小写_短;
  节点_小写->类型_小写_短 = 类型_小写_短->返回_类型;
  节点_小写->实参们_短 = head.下一个_小写;

  // If a 函数_全_小写 returns a struct, it is caller's responsibility
  // to allocate a space for the return value.
  if (节点_小写->类型_小写_短->种类_小写 == 类型_结构 || 节点_小写->类型_小写_短->种类_小写 == 类型_联合)
    节点_小写->返回_缓冲区 = 新_本地变量("", 节点_小写->类型_小写_短);
  return 节点_小写;
}

// generic-selection = "(" 赋值_短 "," generic-assoc ("," generic-assoc)* ")"
//
// generic-assoc = type-名称_小写 ":" 赋值_短
//               | "default" ":" 赋值_短
static 节点 *泛型_选择(牌 **其余的, 牌 *牌_短_小写) {
  牌 *开起 = 牌_短_小写;
  牌_短_小写 = 跳过_小写(牌_短_小写, "(");

  节点 *ctrl = 赋值_短(&牌_短_小写, 牌_短_小写);
  加_类型(ctrl);

  类型 *t1 = ctrl->类型_小写_短;
  if (t1->种类_小写 == 类型_函)
    t1 = 指针_到(t1);
  else if (t1->种类_小写 == 类型_数组)
    t1 = 指针_到(t1->基础_小写);

  节点 *ret = NULL;

  while (!消耗吗_小写(其余的, 牌_短_小写, ")")) {
    牌_短_小写 = 跳过_小写(牌_短_小写, ",");

    if (相等吗_小写(牌_短_小写, "default")) {
      牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, ":");
      节点 *节点_小写 = 赋值_短(&牌_短_小写, 牌_短_小写);
      if (!ret)
        ret = 节点_小写;
      continue;
    }

    类型 *t2 = 类型名_小写(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ":");
    节点 *节点_小写 = 赋值_短(&牌_短_小写, 牌_短_小写);
    if (是否_兼容(t1, t2))
      ret = 节点_小写;
  }

  if (!ret)
    错误_牌_小写(开起, "controlling expression type not compatible with"
              " any generic association type");
  return ret;
}

// 首要的_小写 = "(" "{" 语句_短_小写+ "}" ")"
//         | "(" 表达式_短_小写 ")"
//         | "sizeof" "(" type-名称_小写 ")"
//         | "sizeof" 一元运算_小写
//         | "_Alignof" "(" type-名称_小写 ")"
//         | "_Alignof" 一元运算_小写
//         | "_Generic" generic-selection
//         | "__builtin_types_compatible_p" "(" type-名称_小写, type-名称_小写, ")"
//         | "__builtin_reg_class" "(" type-名称_小写 ")"
//         | ident
//         | 串_小写_短
//         | num
static 节点 *首要的_小写(牌 **其余的, 牌 *牌_短_小写) {
  牌 *开起 = 牌_短_小写;

  if (相等吗_小写(牌_短_小写, "(") && 相等吗_小写(牌_短_小写->下一个_小写, "{")) {
    // This is a GNU statement expresssion.
    节点 *节点_小写 = 新_节点(节点_语句_表达式, 牌_短_小写);
    节点_小写->函数体_小写 = 复合_语句_短(&牌_短_小写, 牌_短_小写->下一个_小写->下一个_小写)->函数体_小写;
    *其余的 = 跳过_小写(牌_短_小写, ")");
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "(")) {
    节点 *节点_小写 = 表达式_短_小写(&牌_短_小写, 牌_短_小写->下一个_小写);
    *其余的 = 跳过_小写(牌_短_小写, ")");
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "sizeof") && 相等吗_小写(牌_短_小写->下一个_小写, "(") && 是否_类型名(牌_短_小写->下一个_小写->下一个_小写)) {
    类型 *类型_小写_短 = 类型名_小写(&牌_短_小写, 牌_短_小写->下一个_小写->下一个_小写);
    *其余的 = 跳过_小写(牌_短_小写, ")");

    if (类型_小写_短->种类_小写 == 类型_变长数组) {
      if (类型_小写_短->变长数组_大小)
        return 新_变量_节点(类型_小写_短->变长数组_大小, 牌_短_小写);

      节点 *左手塞_缩 = 计算_变长数组_大小(类型_小写_短, 牌_短_小写);
      节点 *右手塞_缩 = 新_变量_节点(类型_小写_短->变长数组_大小, 牌_短_小写);
      return 新_二元(节点_逗号, 左手塞_缩, 右手塞_缩, 牌_短_小写);
    }

    return 新_无符长的(类型_小写_短->大小_小写, 开起);
  }

  if (相等吗_小写(牌_短_小写, "sizeof")) {
    节点 *节点_小写 = 一元运算_小写(其余的, 牌_短_小写->下一个_小写);
    加_类型(节点_小写);
    if (节点_小写->类型_小写_短->种类_小写 == 类型_变长数组)
      return 新_变量_节点(节点_小写->类型_小写_短->变长数组_大小, 牌_短_小写);
    return 新_无符长的(节点_小写->类型_小写_短->大小_小写, 牌_短_小写);
  }

  if (相等吗_小写(牌_短_小写, "_Alignof") && 相等吗_小写(牌_短_小写->下一个_小写, "(") && 是否_类型名(牌_短_小写->下一个_小写->下一个_小写)) {
    类型 *类型_小写_短 = 类型名_小写(&牌_短_小写, 牌_短_小写->下一个_小写->下一个_小写);
    *其余的 = 跳过_小写(牌_短_小写, ")");
    return 新_无符长的(类型_小写_短->对齐_短_小写, 牌_短_小写);
  }

  if (相等吗_小写(牌_短_小写, "_Alignof")) {
    节点 *节点_小写 = 一元运算_小写(其余的, 牌_短_小写->下一个_小写);
    加_类型(节点_小写);
    return 新_无符长的(节点_小写->类型_小写_短->对齐_短_小写, 牌_短_小写);
  }

  if (相等吗_小写(牌_短_小写, "_Generic"))
    return 泛型_选择(其余的, 牌_短_小写->下一个_小写);

  if (相等吗_小写(牌_短_小写, "__builtin_types_compatible_p")) {
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");
    类型 *t1 = 类型名_小写(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    类型 *t2 = 类型名_小写(&牌_短_小写, 牌_短_小写);
    *其余的 = 跳过_小写(牌_短_小写, ")");
    return 新_数目(是否_兼容(t1, t2), 开起);
  }

  if (相等吗_小写(牌_短_小写, "__builtin_reg_class")) {
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");
    类型 *类型_小写_短 = 类型名_小写(&牌_短_小写, 牌_短_小写);
    *其余的 = 跳过_小写(牌_短_小写, ")");

    if (是否_整数(类型_小写_短) || 类型_小写_短->种类_小写 == 类型_指针)
      return 新_数目(0, 开起);
    if (是否_浮点数目(类型_小写_短))
      return 新_数目(1, 开起);
    return 新_数目(2, 开起);
  }

  if (相等吗_小写(牌_短_小写, "__builtin_compare_and_swap")) {
    节点 *节点_小写 = 新_节点(节点_对比与交换, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");
    节点_小写->对比与交换_地址 = 赋值_短(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    节点_小写->对比与交换_旧 = 赋值_短(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    节点_小写->对比与交换_新 = 赋值_短(&牌_短_小写, 牌_短_小写);
    *其余的 = 跳过_小写(牌_短_小写, ")");
    return 节点_小写;
  }

  if (相等吗_小写(牌_短_小写, "__builtin_atomic_exchange")) {
    节点 *节点_小写 = 新_节点(节点_调换, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写->下一个_小写, "(");
    节点_小写->左手塞_缩 = 赋值_短(&牌_短_小写, 牌_短_小写);
    牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    节点_小写->右手塞_缩 = 赋值_短(&牌_短_小写, 牌_短_小写);
    *其余的 = 跳过_小写(牌_短_小写, ")");
    return 节点_小写;
  }

  if (牌_短_小写->种类_小写 == 牌_标识) {
    // Variable or enum constant
    变量作用域 *sc = 找_变量(牌_短_小写);
    *其余的 = 牌_短_小写->下一个_小写;

    // For "static inline" 函数_全_小写
    if (sc && sc->变量_短 && sc->变量_短->是否_函数) {
      if (当前_函)
        串数组_推(&当前_函->引用们_缩_小写, sc->变量_短->名称_小写);
      else
        sc->变量_短->是否_根部 = true;
    }

    if (sc) {
      if (sc->变量_短)
        return 新_变量_节点(sc->变量_短, 牌_短_小写);
      if (sc->枚举_类型_短)
        return 新_数目(sc->枚举_值_短, 牌_短_小写);
    }

    if (相等吗_小写(牌_短_小写->下一个_小写, "("))
      错误_牌_小写(牌_短_小写, "implicit 声明整体_小写 of a 函数_全_小写");
    错误_牌_小写(牌_短_小写, "undefined variable");
  }

  if (牌_短_小写->种类_小写 == 牌_串字面) {
    对象_缩_大写 *变量_短 = 新_字符串_字面(牌_短_小写->串_小写_短, 牌_短_小写->类型_小写_短);
    *其余的 = 牌_短_小写->下一个_小写;
    return 新_变量_节点(变量_短, 牌_短_小写);
  }

  if (牌_短_小写->种类_小写 == 牌_数值字面) {
    节点 *节点_小写;
    if (是否_浮点数目(牌_短_小写->类型_小写_短)) {
      节点_小写 = 新_节点(节点_数, 牌_短_小写);
      节点_小写->浮点值_小写_短 = 牌_短_小写->浮点值_小写_短;
    } else {
      节点_小写 = 新_数目(牌_短_小写->值_小写_短, 牌_短_小写);
    }

    节点_小写->类型_小写_短 = 牌_短_小写->类型_小写_短;
    *其余的 = 牌_短_小写->下一个_小写;
    return 节点_小写;
  }

  错误_牌_小写(牌_短_小写, "expected an expression");
}

static 牌 *解析_类型定义(牌 *牌_短_小写, 类型 *基本类型_短) {
  bool first = true;

  while (!消耗吗_小写(&牌_短_小写, 牌_短_小写, ";")) {
    if (!first)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    first = false;

    类型 *类型_小写_短 = 声明符_小写(&牌_短_小写, 牌_短_小写, 基本类型_短);
    if (!类型_小写_短->名称_小写)
      错误_牌_小写(类型_小写_短->名称_位置, "typedef 名称_小写 omitted");
    推_作用域(获取_标识(类型_小写_短->名称_小写))->类型_定义_短_小写 = 类型_小写_短;
  }
  return 牌_短_小写;
}

static void 创建_形参_本地变量们(类型 *param) {
  if (param) {
    创建_形参_本地变量们(param->下一个_小写);
    if (!param->名称_小写)
      错误_牌_小写(param->名称_位置, "parameter 名称_小写 omitted");
    新_本地变量(获取_标识(param->名称_小写), param);
  }
}

// This 函数_全_小写 matches 去到们_小写 or 标号们_小写-as-values with 标号们_小写.
//
// We cannot resolve 去到们_小写 as we 解析_小写 a 函数_全_小写 because 去到们_小写
// can refer a 标号_小写 that appears later in the 函数_全_小写.
// So, we need to do this after we 解析_小写 the entire 函数_全_小写.
static void 解决_去到_标号们(void) {
  for (节点 *x = 去到们_小写; x; x = x->去到_下一个) {
    for (节点 *y = 标号们_小写; y; y = y->去到_下一个) {
      if (!strcmp(x->标号_小写, y->标号_小写)) {
        x->唯一_标号 = y->唯一_标号;
        break;
      }
    }

    if (x->唯一_标号 == NULL)
      错误_牌_小写(x->牌_短_小写->下一个_小写, "use of undeclared 标号_小写");
  }

  去到们_小写 = 标号们_小写 = NULL;
}

static 对象_缩_大写 *找_函_短(char *名称_小写) {
  作用域_大写 *sc = 作用域_小写;
  while (sc->下一个_小写)
    sc = sc->下一个_小写;

  变量作用域 *sc2 = 哈希映射_获取(&sc->变量们_短, 名称_小写);
  if (sc2 && sc2->变量_短 && sc2->变量_短->是否_函数)
    return sc2->变量_短;
  return NULL;
}

static void 记号_存活(对象_缩_大写 *变量_短) {
  if (!变量_短->是否_函数 || 变量_短->是否_存活)
    return;
  变量_短->是否_存活 = true;

  for (int i = 0; i < 变量_短->引用们_缩_小写.长度_短; i++) {
    对象_缩_大写 *fn = 找_函_短(变量_短->引用们_缩_小写.数据_小写[i]);
    if (fn)
      记号_存活(fn);
  }
}

static 牌 *函数_全_小写(牌 *牌_短_小写, 类型 *基本类型_短, 变量属性_短 *attr) {
  类型 *类型_小写_短 = 声明符_小写(&牌_短_小写, 牌_短_小写, 基本类型_短);
  if (!类型_小写_短->名称_小写)
    错误_牌_小写(类型_小写_短->名称_位置, "函数_全_小写 名称_小写 omitted");
  char *name_str = 获取_标识(类型_小写_短->名称_小写);

  对象_缩_大写 *fn = 找_函_短(name_str);
  if (fn) {
    // Redeclaration
    if (!fn->是否_函数)
      错误_牌_小写(牌_短_小写, "redeclared as a different 种类_小写 of symbol");
    if (fn->是否_定义 && 相等吗_小写(牌_短_小写, "{"))
      错误_牌_小写(牌_短_小写, "redefinition of %s", name_str);
    if (!fn->是否_静态 && attr->是否_静态)
      错误_牌_小写(牌_短_小写, "static 声明整体_小写 follows a non-static 声明整体_小写");
    fn->是否_定义 = fn->是否_定义 || 相等吗_小写(牌_短_小写, "{");
  } else {
    fn = 新_全局变量(name_str, 类型_小写_短);
    fn->是否_函数 = true;
    fn->是否_定义 = 相等吗_小写(牌_短_小写, "{");
    fn->是否_静态 = attr->是否_静态 || (attr->是否_内联 && !attr->是否_外部);
    fn->是否_内联 = attr->是否_内联;
  }

  fn->是否_根部 = !(fn->是否_静态 && fn->是否_内联);

  if (消耗吗_小写(&牌_短_小写, 牌_短_小写, ";"))
    return 牌_短_小写;

  当前_函 = fn;
  本地们_小写 = NULL;
  进入_作用域();
  创建_形参_本地变量们(类型_小写_短->形参们_短_小写);

  // A buffer for a struct/union return value is passed
  // as the hidden first parameter.
  类型 *rty = 类型_小写_短->返回_类型;
  if ((rty->种类_小写 == 类型_结构 || rty->种类_小写 == 类型_联合) && rty->大小_小写 > 16)
    新_本地变量("", 指针_到(rty));

  fn->形参们_短_小写 = 本地们_小写;

  if (类型_小写_短->是否_可变参数)
    fn->变量_缩_区域 = 新_本地变量("__va_area__", 数组_的(类型_印刻_小写, 136));
  fn->动态分配_底部 = 新_本地变量("__alloca_size__", 指针_到(类型_印刻_小写));

  牌_短_小写 = 跳过_小写(牌_短_小写, "{");

  // [https://www.sigbus.info/n1570#6.4.2.2p1] "__func__" is
  // automatically defined as a local variable containing the
  // current 函数_全_小写 名称_小写.
  推_作用域("__func__")->变量_短 =
    新_字符串_字面(fn->名称_小写, 数组_的(类型_印刻_小写, strlen(fn->名称_小写) + 1));

  // [GNU] __FUNCTION__ is yet another 名称_小写 of __func__.
  推_作用域("__FUNCTION__")->变量_短 =
    新_字符串_字面(fn->名称_小写, 数组_的(类型_印刻_小写, strlen(fn->名称_小写) + 1));

  fn->函数体_小写 = 复合_语句_短(&牌_短_小写, 牌_短_小写);
  fn->本地们_小写 = 本地们_小写;
  离开_作用域();
  解决_去到_标号们();
  return 牌_短_小写;
}

static 牌 *全局_变量_全(牌 *牌_短_小写, 类型 *基本类型_短, 变量属性_短 *attr) {
  bool first = true;

  while (!消耗吗_小写(&牌_短_小写, 牌_短_小写, ";")) {
    if (!first)
      牌_短_小写 = 跳过_小写(牌_短_小写, ",");
    first = false;

    类型 *类型_小写_短 = 声明符_小写(&牌_短_小写, 牌_短_小写, 基本类型_短);
    if (!类型_小写_短->名称_小写)
      错误_牌_小写(类型_小写_短->名称_位置, "variable 名称_小写 omitted");

    对象_缩_大写 *变量_短 = 新_全局变量(获取_标识(类型_小写_短->名称_小写), 类型_小写_短);
    变量_短->是否_定义 = !attr->是否_外部;
    变量_短->是否_静态 = attr->是否_静态;
    变量_短->是否_传输层安全 = attr->是否_传输层安全;
    if (attr->对齐_短_小写)
      变量_短->对齐_短_小写 = attr->对齐_短_小写;

    if (相等吗_小写(牌_短_小写, "="))
      全局变量_初始化器(&牌_短_小写, 牌_短_小写->下一个_小写, 变量_短);
    else if (!attr->是否_外部 && !attr->是否_传输层安全)
      变量_短->是否_试探性 = true;
  }
  return 牌_短_小写;
}

// Lookahead tokens and returns true if a given token is a 开起
// of a 函数_全_小写 definition or 声明整体_小写.
static bool 是否_函数(牌 *牌_短_小写) {
  if (相等吗_小写(牌_短_小写, ";"))
    return false;

  类型 dummy = {};
  类型 *类型_小写_短 = 声明符_小写(&牌_短_小写, 牌_短_小写, &dummy);
  return 类型_小写_短->种类_小写 == 类型_函;
}

// Remove redundant tentative definitions.
static void 扫描_全局们(void) {
  对象_缩_大写 head;
  对象_缩_大写 *当前_短 = &head;

  for (对象_缩_大写 *变量_短 = 全局们_小写; 变量_短; 变量_短 = 变量_短->下一个_小写) {
    if (!变量_短->是否_试探性) {
      当前_短 = 当前_短->下一个_小写 = 变量_短;
      continue;
    }

    // Find another definition of the same identifier.
    对象_缩_大写 *var2 = 全局们_小写;
    for (; var2; var2 = var2->下一个_小写)
      if (变量_短 != var2 && var2->是否_定义 && !strcmp(变量_短->名称_小写, var2->名称_小写))
        break;

    // If there's another definition, the tentative definition
    // is redundant
    if (!var2)
      当前_短 = 当前_短->下一个_小写 = 变量_短;
  }

  当前_短->下一个_小写 = NULL;
  全局们_小写 = head.下一个_小写;
}

static void 声明_内置_函数们(void) {
  类型 *类型_小写_短 = 函_类型_小写(指针_到(类型_空的_小写));
  类型_小写_短->形参们_短_小写 = 复制_类型(类型_整型_小写);
  内置_栈分配 = 新_全局变量("alloca", 类型_小写_短);
  内置_栈分配->是否_定义 = false;
}

// program = (typedef | 函数_全_小写-definition | global-variable)*
对象_缩_大写 *解析_小写(牌 *牌_短_小写) {
  声明_内置_函数们();
  全局们_小写 = NULL;

  while (牌_短_小写->种类_小写 != 牌_文件终) {
    变量属性_短 attr = {};
    类型 *基本类型_短 = 声明的说明(&牌_短_小写, 牌_短_小写, &attr);

    // Typedef
    if (attr.是否_类型定义) {
      牌_短_小写 = 解析_类型定义(牌_短_小写, 基本类型_短);
      continue;
    }

    // Function
    if (是否_函数(牌_短_小写)) {
      牌_短_小写 = 函数_全_小写(牌_短_小写, 基本类型_短, &attr);
      continue;
    }

    // Global variable
    牌_短_小写 = 全局_变量_全(牌_短_小写, 基本类型_短, &attr);
  }

  for (对象_缩_大写 *变量_短 = 全局们_小写; 变量_短; 变量_短 = 变量_短->下一个_小写)
    if (变量_短->是否_根部)
      记号_存活(变量_短);

  // Remove redundant tentative definitions.
  扫描_全局们();
  return 全局们_小写;
}
