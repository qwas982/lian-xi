'use strict';

function 牌化(输入){
    let 当前字符索引 = 0; let 牌数组 = [];
    while(当前字符索引<输入.length){
        let 字符 = 输入[当前字符索引];
        if(字符==='('){
            牌数组.push({
                类型: '左括号',
                值:'('
            });
            当前字符索引++;
            continue;
        }
        if(字符===')'){
            牌数组.push({
                类型:'右括号',
                值:')'
            });
            当前字符索引++;
            continue;
        }
        let 空白字符 = /\s/;
        if(空白字符.test(字符)){
            当前字符索引++;
            continue;
        }
        let 数号 = /[0-9]/;
        if(数号.test(字符)){
            let 值 = '';
            while(数号.test(字符)){
                值 += 字符;
                字符 = 输入[++当前字符索引];
            }
            牌数组.push({
                类型:'数号',
                值
            });
            continue;
        }
        if(字符==='"'){
            let 值 = '';
            字符 = 输入[++当前字符索引];
            while(字符 !== '"'){
                值 += 字符;
                字符 = 输入[++当前字符索引];
            }
            字符 = 输入[++当前字符索引];
            牌数组.push({
                类型:'字符串',
                值
            });
            continue;
        }
        let 印刻字母 = /[a-z]/i;
        if(印刻字母.test(字符)){
            let 值 = '';
            while(印刻字母.test(字符)){
                值 += 字符;
                字符 = 输入[++当前字符索引];
            }
            牌数组.push({
                类型:'名字',
                值
            });
            continue;
        }
        throw new TypeError('我不懂此字符是什么: '+ 字符);
    }
    return 牌数组;
}

function 解析器(牌数组){
    let  当前牌索引 = 0;
    function 走路(){
        let 当前牌 = 牌数组[当前牌索引];
        if(当前牌.类型 === '数号'){
            当前牌索引++;
            return {
                键:'数号字面',
                值:当前牌.值,
            };
        }
        if(当前牌.类型 === '字符串'){
            当前牌索引++;
            return {
                键:'字符串字面',
                值:当前牌.值,
            };
        }
        if(当前牌.键==='左括号' && 当前牌.值==='('){
            当前牌 = 牌数组[++当前牌索引];
            let 节点 = {
                类型: '调用表达式',
                名字: 当前牌.值,
                形参: [],
            };
            当前牌 = 牌数组[++当前牌索引];
            while((当前牌.类型 !== '右括号') || (当前牌.类型==='右括号' && 当前牌.值 !== ')')){
                节点.形参.push(走路());
                当前牌 = 牌数组[当前牌索引];
            }
            当前牌索引++;
            return 节点;
        }
        throw new TypeError(当前牌.类型);
    }
    let 句法树 = {
        类型:'程序',
        体:[],
    };
    while(当前牌索引<牌数组.length){
        句法树.体.push(走路());
    }
    return 句法树;
}

function 遍历器(句法树,访问器){
    function 遍历数组(数组,父母){
        数组.forEach(孩子 => {
            遍历节点(孩子,父母);
        });
    }
    function 遍历节点(节点,父母){
        let 方法 = 访问器[节点.类型];
        if(方法&&方法.enter){
            方法.enter(节点,父母);
        }
        switch(节点.类型){
            case '程序': 
                遍历数组(节点.体,节点);
                break;
            case '调用表达式': 
                遍历数组(节点.形参,节点);
                break;
            case '数号字面':
            case '字符串字面':
                break;
            default:
                throw new TypeError(节点.类型);
        }
        if(方法 && 方法.exit){
            方法.exit(节点,父母);
        }
    }
    遍历节点(句法树, null);
}

function 转换形态(句法树){
    let 新句法树 = {
        类型: '程序',
        体:[],
    };
    句法树.上下文 = 新句法树.体;
    遍历器(句法树,{
        数号字面:{
            enter(节点,父母){
                父母.上下文.push({
                    类型:'数号字面',
                    值: 节点.值,
                });
            },
        },
        字符串字面:{
            enter(节点,父母){
                父母.上下文.push({
                    类型:'字符串字面',
                    值: 节点.值,
               });
            },
        },
        调用表达式:{
            enter(节点,父母){
                let 表达式={
                    类型: '调用表达式',
                    被调用:{
                        类型: '标识符',
                        名字: 节点.名字,
                    },
                    实参: [],
                };
                节点.上下文 = 表达式.实参;
                if(父母.类型 !== '调用表达式'){
                    表达式 = {
                        类型: '表达式语句',
                        表达式: 表达式,
                    };
                }
                父母.上下文.push(表达式);
            },
        }
    });
    return 新句法树;
}

function 代码生成器(节点){
    switch(节点.类型){
        case '程序':
            return 节点.体.map(代码生成器).join('\n');
        case '表达式语句':
            return (代码生成器(节点.表达式)+';');
        case '调用表达式':
            return (代码生成器(节点.被调用)+'('+
                    节点.实参.map(代码生成器)
                    .join(', ')+ ')');
        case '表达式':
            return 节点.名字;
        case '数号字面':
            return 节点.值;
        case '字符串字面':
            return '"'+节点.值+'"';
        default:
            throw new TypeError(节点.类型);
    }
}

function 编译器(输入){
    let 牌 = 牌化(输入);
    let 句法树 = 解析器(牌);
    let 新句法树 = 转换形态(句法树);
    let  输出 =  代码生成器(新句法树);

    return 输出;
}

module.exports = {
    牌化,
    解析器,
    遍历器,
    转换形态,
    代码生成器,
    编译器,
};