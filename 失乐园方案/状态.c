/*
 * The 失乐园方案系统
 
 */

#include <stdlib.h>

#include "失乐园.h"
#include "入出.h"
#include "虚拟机.h"
#include "状态.h"

#include "启动.h"
#include "初始.h"
#include "编译器.h"

int 失乐园_打开_库(失乐园_状态_类型* 大失);
int 失乐园_打开_标准(失乐园_状态_类型* 大失);

/* garbage collector callback */
struct 垃圾回收_数据 {
  失乐园_状态_类型 *大失;
  uint32_t 状态, 计数;
};

static struct 垃圾回收_数据 垃圾回收_数据;

static 失乐园_对象_类型* 垃圾回收_回调(void *小用户数据)
{
  struct 垃圾回收_数据 *垃圾回收_数据;

  垃圾回收_数据 = (struct 垃圾回收_数据*) 小用户数据;

  for(;;) {
    if(垃圾回收_数据->状态 == 0) {
      /* 栈 */
      if(垃圾回收_数据->计数 == 垃圾回收_数据->大失->栈指针) {
	垃圾回收_数据->状态++;
	垃圾回收_数据->计数 = 0;
	continue;
      } else {
	return &垃圾回收_数据->大失->栈[垃圾回收_数据->计数++];
      }
    } else if(垃圾回收_数据->状态 == 1) {
      /* 全局复 */
      if(垃圾回收_数据->计数 == 垃圾回收_数据->大失->全局_环境.大小) {
	垃圾回收_数据->状态++;
	垃圾回收_数据->计数 = 0;
	continue;
      } else {
	return &垃圾回收_数据->大失->全局_环境.变量复[垃圾回收_数据->计数++].值;
      }
    } else if(垃圾回收_数据->状态 == 2) {
      /* constants */
      if(垃圾回收_数据->计数 == 垃圾回收_数据->大失->数号_常量) {
	垃圾回收_数据->状态++;
	垃圾回收_数据->计数 = 0;
	continue;
      } else {
	return &垃圾回收_数据->大失->常量短[垃圾回收_数据->计数++];
      }
    } else if(垃圾回收_数据->状态 == 3) {
      /* registers */
      if(垃圾回收_数据->计数 == 0) {
	垃圾回收_数据->计数++;
	return &垃圾回收_数据->大失->累加短;
      } else if(垃圾回收_数据->计数 == 1) {
	垃圾回收_数据->计数++;
	return &垃圾回收_数据->大失->过程短;
      } else {
	垃圾回收_数据->状态++;
	垃圾回收_数据->计数 = 0;
	continue;
      }
    } else {
      垃圾回收_数据->状态 = 0;
      垃圾回收_数据->计数 = 0;
      return NULL;
    }
  }
}

static 失乐园_状态_类型* 失乐园_创建_状态(void)
{
  失乐园_状态_类型 *大失 = NULL;

  大失 = (失乐园_状态_类型*)malloc(sizeof(失乐园_状态_类型));
  if(!大失) {
    return NULL;
  }

  /*
   * 储存
   */

  垃圾回收_数据.大失 = 大失;
  垃圾回收_数据.状态 = 0;
  垃圾回收_数据.计数 = 0;
  if(失乐园_垃圾回收_初始(&大失->储存, 垃圾回收_回调, &垃圾回收_数据) == 0) {
    return NULL;
  }

  大失->程序计数器 = 0;
  大失->帧指针 = 0;

  /*
   * 代码
   */

  大失->代码_大小 = 1;
  大失->代码 = (uint32_t*)malloc(sizeof(uint32_t));
  if(大失->代码 == NULL) {
    free(大失);
    return NULL;
  }
  大失->代码[失乐园_停机_地址] = (uint32_t) 失乐园_操作_停机;

  /*
   * 栈
   */

  大失->栈指针 = 1;
  大失->栈 = (失乐园_对象_类型*)malloc(sizeof(失乐园_对象_类型) * 1024);
  if(大失->栈) {
    大失->栈_大小 = 1024;
  } else {
    free(大失->代码);
    free(大失);
    return NULL;
  }

  /* sentinel */
  大失->栈[0].类型 = 失乐园_类型_取消定义;

  /*
   * 符号 table
   */

  大失->符号_表 = NULL;

  /*
   * constants
   */

  大失->常量短 = NULL;
  大失->数号_常量 = 0;

  /*
   * 全局复
   */
  大失->全局_环境.大小 = 0;
  大失->全局_环境.变量复 = NULL;

  /*
   * registers
   */
  大失->过程短.类型 = 失乐园_类型_取消定义;
  大失->累加短.类型 = 失乐园_类型_取消定义;

  /*
   * virtual machine
   */
  失乐园_虚拟机_初始(大失);

  return 大失;
}

失乐园_状态_类型* 失乐园_打开(void)
{
  失乐园_状态_类型 *大失 = 失乐园_创建_状态();

  /* register C libs */
  失乐园_打开_库(大失);
  失乐园_打开_标准(大失);

  失乐园_载入_缓冲区(大失, 初始_缓冲);
  失乐园_载入_缓冲区(大失, 启动_缓冲);
  失乐园_载入_缓冲区(大失, 编译_缓冲);

  return 大失;
}

void 失乐园_关闭(失乐园_状态_类型* 大失)
{
  if(大失) {
    失乐园_垃圾回收_完成(&大失->储存);

    if(大失->代码) {
      free(大失->代码);
    }

    if(大失->栈) {
      free(大失->栈);
    }

    if(大失->符号_表) {
      失乐园_符号_类型 *符号短;
      for(符号短 = 大失->符号_表; 符号短 != NULL;) {
	失乐园_符号_类型 *临时短 = 符号短->下一个;
	free(符号短->串短);
	free(符号短);
	符号短 = 临时短;
      }
    }

    free(大失);
  }
}

void 失乐园_状态_扩大_全局(失乐园_状态_类型* 大失, uint32_t 更多)
{
  失乐园_环境_变量_类型 *变量复;

  更多 += 大失->全局_环境.大小;
  变量复 = (失乐园_环境_变量_类型*)realloc(大失->全局_环境.变量复,
				 更多 * sizeof(失乐园_环境_变量_类型));

  /* TODO: test return and throw 错误 */
  大失->全局_环境.变量复 = 变量复;
  大失->全局_环境.大小 = 更多;
}

int 失乐园_状态_取_全局_索引(失乐园_状态_类型* 大失, 失乐园_符号_类型 *全局)
{
  size_t 计数甲;

  for(计数甲 = 0; 计数甲 < 大失->全局_环境.大小; 计数甲++) {
    if(全局 == 大失->全局_环境.变量复[计数甲].符号) {
      return 计数甲;
    }
  }

  return -1;
}

