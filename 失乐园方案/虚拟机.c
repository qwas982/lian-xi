/*
 * The 失乐园方案编译器
 
 */

#include "失乐园.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "垃圾回收.h"
#include "入出.h"
#include "虚拟机.h"
#include "对象.h"
#include "状态.h"

/*
 * Sly bytecode is an array of 32-bit values for
 * efficiency (数据 alignment), but wasteful because
 * most instructions do not have operands. It is
 * therefore hostile for embedded systems but optimised
 * for 32-bit machines with large RAMs. It is gonna
 * be like this for now for simplicity, but the
 * situation may improve in the future.
 *
 * Further reading:
 * http://compilers.iecc.com/comparch/article/04-12-156
 *
 * There are two types of instructions:
 * 类型 甲: First byte is operand, the rest is for
 *         alignment only.
 * 类型 乙: First byte is operand, remaining 3 bytes
 *         are used for single operand.
 */

#define 是否_类型_乙(指令短) ((指令短) > 119)

#define 提取_操作(指令短)   ((uint8_t)((指令短) & 0x000000ff))
#define 提取_实参(指令短)  ((uint32_t)((指令短) >> 8))

struct  失乐园_操作码_ {
  uint8_t 小操作;
  const char *名称;
  失乐园_符号_类型 *符号短;
};

typedef struct 失乐园_操作码_ 失乐园_操作码_类型;

static 失乐园_操作码_类型 全局_操作码[] = {
  {失乐园_操作_载入_零,               "LOAD-NIL",           NULL},
  {失乐园_操作_载入_假,             "LOAD-FALSE",         NULL},
  {失乐园_操作_载入_真,              "LOAD-TRUE",          NULL},
  {失乐园_操作_载入_取消定义,             "LOAD-UNDEF",         NULL},
  {失乐园_操作_载入_零零,              "LOAD-ZERO",          NULL},
  {失乐园_操作_载入_一,               "LOAD-ONE",           NULL},
  {失乐园_操作_推,                   "PUSH",               NULL},
  {失乐园_操作_载入_0,                 "LOAD0",              NULL},
  {失乐园_操作_载入_1,                 "LOAD1",              NULL},
  {失乐园_操作_载入_2,                 "LOAD2",              NULL},
  {失乐园_操作_载入_3,                 "LOAD3",              NULL},
  {失乐园_操作_返回,                 "RETURN",             NULL},
  {失乐园_操作_保存_继续短,              "SAVE-CONT",          NULL},
  {失乐园_操作_重置_继续短,              "REST-CONT",          NULL},
  {失乐园_操作_盒子,                    "BOX",                NULL},
  {失乐园_操作_打开_盒子,               "OPEN-BOX",           NULL},
  {失乐园_操作_停机,                   "HALT",               NULL},
  {失乐园_操作_中止,                  "ABORT",              NULL},
  {失乐园_操作_空指针_问,                 "NULL?",              NULL},
  {失乐园_操作_布尔_问,                 "BOOL?",              NULL},
  {失乐园_操作_印刻_问,                 "CHAR?",              NULL},
  {失乐园_操作_固定整数_问,               "固定整数大?",            NULL},
  {失乐园_操作_点对_问,                 "PAIR?",              NULL},
  {失乐园_操作_符号_问,               "SYMBOL?",            NULL},
  {失乐园_操作_自增,                    "INC",                NULL},
  {失乐园_操作_自减,                    "DEC",                NULL},
  {失乐园_操作_固定整数_到_印刻,         "固定整数大->CHAR",       NULL},
  {失乐园_操作_印刻_到_固定整数,         "CHAR->固定整数大",       NULL},
  {失乐园_操作_零零_问,                 "ZERO?",              NULL},
  {失乐园_操作_非,                    "NOT",                NULL},
  {失乐园_操作_加号,                   "PLUS",               NULL},
  {失乐园_操作_减,                  "MINUS",              NULL},
  {失乐园_操作_乘,                   "MULT",               NULL},
  {失乐园_操作_构造,                   "CONS",               NULL},
  {失乐园_操作_切头,                    "切头大",                NULL},
  {失乐园_操作_切尾,                    "切尾大",                NULL},
  {失乐园_操作_数号_等于,                 "NUM-EQ",             NULL},
  {失乐园_操作_等于,                     "EQ?",                NULL},
  {失乐园_操作_相等,                    "EQV?",               NULL},
  {失乐园_操作_制作_串,            "MAKE-STRING",        NULL},
  {失乐园_操作_串_设置,             "STRING-SET",         NULL},
  {失乐园_操作_串_到_符号,       "STRING->SYMBOL",     NULL},
  {失乐园_操作_制作_向量,            "MAKE-VECTOR",        NULL},
  {失乐园_操作_向量_设置,             "VECTOR-SET",         NULL},
  {失乐园_操作_调试,                  "DEBUG",              NULL},
  {失乐园_操作_载入_固定整数,            "LOAD-固定整数大",        NULL},
  {失乐园_操作_载入_印刻,              "LOAD-CHAR",          NULL},
  {失乐园_操作_载入,                   "LOAD",               NULL},
  {失乐园_操作_制作_闭包,           "MAKE-CLOSURE",       NULL},
  {失乐园_操作_调用,                   "CALL",               NULL},
  {失乐园_操作_跳_若_非,             "JMP-IF-NOT",         NULL},
  {失乐园_操作_跳,                    "JMP",                NULL},
  {失乐园_操作_载入_自由,              "LOAD-FREE",          NULL},
  {失乐园_操作_赋值,                 "ASSIGN",             NULL},
  {失乐园_操作_赋值_自由,            "ASSIGN-FREE",        NULL},
  {失乐园_操作_帧,                  "FRAME",              NULL},
  {失乐园_操作_尾_调用,              "TAIL-CALL",          NULL},
  {失乐园_操作_载入_本地,             "LOAD-LOCAL",         NULL},
  {失乐园_操作_插入_盒子,             "INSERT-BOX",         NULL},
  {失乐园_操作_赋值_本地,           "ASSIGN-LOCAL",       NULL},
  {失乐园_操作_弹,                    "POP",                NULL},
  {失乐园_操作_全局_引用,             "GLOBAL-REF",         NULL},
  {失乐园_操作_已检查_全局_引用,     "CHECKED-GLOBAL-REF", NULL},
  {失乐园_操作_全局_设置,             "GLOBAL-SET",         NULL},
  {失乐园_操作_已检查_全局_设置,     "CHECKED-GLOBAL-SET", NULL},
  {失乐园_操作_常量,                  "CONST",              NULL},
  {失乐园_操作_常量_初始,             "CONST-INIT",         NULL},
  {失乐园_操作_元数_等于,               "ARITY=",             NULL},
  {失乐园_操作_大等,               "ARITY>=",            NULL},
  {失乐园_操作_列出,                "LISTIFY",            NULL},
  {0, NULL, NULL}
};

void 失乐园_虚拟机_初始(失乐园_状态_类型* 大失)
{
  失乐园_操作码_类型 *小操作码;
  失乐园_对象_类型 符号短;
  失乐园_垃圾回收对象_类型 *串短;

  /* creating symbols for instructions */
  for(小操作码 = 全局_操作码; 小操作码->名称 != NULL; 小操作码++) {
    串短 = 失乐园_创建_串_来自_美信交标码(大失, 小操作码->名称);
    符号短 = 失乐园_创建_符号(大失, 失乐园_串(串短));
    小操作码->符号短 = 符号短.值.符号;
  }
}

/*
 * debugging
 */

static void 转储_指令(失乐园_状态_类型 *大失, uint32_t 指令短, 失乐园_对象_类型 *端口)
{
  uint8_t 小操作;
  失乐园_操作码_类型* 小调试;
  char 缓冲短[64];

  小操作 = 提取_操作(指令短);
  for(小调试 = 全局_操作码; 小调试->名称 != NULL; 小调试++) {
    if(小调试->小操作 == 小操作) {
      snprintf(缓冲短, 64, "%u\t%s", (uint32_t)小操作, 小调试->名称);
      失乐园_入出_写_印名_串(大失, 缓冲短, 端口);
      if(是否_类型_乙(小操作)) {
	snprintf(缓冲短, 64, " %u", 提取_实参(指令短));
        失乐园_入出_写_印名_串(大失, 缓冲短, 端口);
      }
      break;
    }
  }
}

/*
static void 反汇编(失乐园_状态_类型* 大失)
{
  uint32_t 计数甲;

  printf("Code listing:\n");
  for(计数甲 = 0; 计数甲 < 大失->代码_大小; 计数甲++) {
    printf("\t%u\t", 计数甲);
    转储_指令(大失->代码[计数甲]);
    printf("\n");
  }
}
*/

void 失乐园_虚拟机_转储(失乐园_状态_类型* 大失)
{
  uint32_t 计数甲;
  char 缓冲短[64];
  失乐园_对象_类型 端口;

  端口.类型 = 失乐园_类型_输出_端口;
  端口.值.小垃圾回收 = 失乐园_入出_创建_标准错(大失);

  失乐园_入出_写_印名_串(大失, "Instruction: ", &端口);
  转储_指令(大失, 大失->代码[大失->程序计数器], &端口);
  失乐园_入出_新行(大失, &端口);

  失乐园_入出_写_印名_串(大失, "Registers:", &端口);
  失乐园_入出_新行(大失, &端口);
  失乐园_入出_写_印名_串(大失, "\taccum: ", &端口);
  失乐园_入出_写(大失, &大失->累加短, &端口);
  失乐园_入出_新行(大失, &端口);
  失乐园_入出_写_印名_串(大失, "\tclosure: ", &端口);
  失乐园_入出_写(大失, &大失->过程短, &端口);
  失乐园_入出_新行(大失, &端口);
  snprintf(缓冲短, 64, "\tPC: %d", 大失->程序计数器);
  失乐园_入出_写_印名_串(大失, 缓冲短, &端口);
  失乐园_入出_新行(大失, &端口);
  snprintf(缓冲短, 64, "\tFP: %d", 大失->帧指针);
  失乐园_入出_写_印名_串(大失, 缓冲短, &端口);
  失乐园_入出_新行(大失, &端口);

  失乐园_入出_写_印名_串(大失, "Stack:", &端口);
  for(计数甲 = 0; 计数甲 < 大失->栈指针; 计数甲++) {
    失乐园_入出_写_印名_串(大失, " ", &端口);
    失乐园_入出_写(大失, 大失->栈 + 计数甲, &端口);
  }

  失乐园_入出_新行(大失, &端口);
  失乐园_入出_新行(大失, &端口);

#if 0
  printf("Globals:\n");
  for(计数甲 = 0; 计数甲 < 大失->全局_环境.大小; 计数甲++) {
    失乐园_环境_变量_类型 var = 大失->全局_环境.变量复[计数甲];
    printf(" [ %d , ", 计数甲);
    fflush(NULL);
    if(var.符号) {
      失乐园_入出_写_符号(大失, var.符号, &端口);
    }
    printf(" , ");
    fflush(NULL);
    失乐园_入出_写(大失, &var.值, &端口);
    printf("]\n");
    fflush(NULL);
  }
  printf("\n\n");
  fflush(NULL);

  printf("Constants:");
  for(计数甲 = 0; 计数甲 < 大失->数号_常量; 计数甲++) {
    printf(" ");
    失乐园_入出_写(大失->常量短 + 计数甲);
  }
  printf("\n\n");
#endif
}

static void 检查_分配(失乐园_状态_类型 *大失, void* 指针短)
{
  大失 = 大失;

  if(指针短 == NULL) {
    fprintf(stderr, "失乐园: Out of memory!\n");
    abort();
  }
}

static void 返回_来自_调用(失乐园_状态_类型* 大失)
{
  /* remove arguments and locals */
  大失->栈指针 = 大失->帧指针;
    
  /* restoring previous frame pointer */
  大失->帧指针 = (大失->栈[--大失->栈指针]).值.固定整数;

  /* restoring previous procedure */
  大失->过程短 = 大失->栈[--大失->栈指针];

  /* jumping to return address */
  大失->程序计数器 = (大失->栈[--大失->栈指针]).值.固定整数;
}

static void 调用_c_闭包(失乐园_状态_类型* 大失, 失乐园_闭包_类型 *闭包短_)
{
  int 返回短;

  /* arguments are already in position, do the call */
  返回短 = (闭包短_->进入_点.c)(大失);

  /* result is on top of 栈 */
  if(返回短) {
    大失->累加短 = 大失->栈[大失->栈指针-1];
  }

  /* now must do a 'return' */
  返回_来自_调用(大失);
}

#define 失乐园_设置_布尔(条件短)		\
  do {					\
    if(条件短) {				\
      大失->累加短.类型 = 失乐园_类型_布尔;	\
      大失->累加短.值.bool = 1;		\
    } else {				\
      大失->累加短.类型 = 失乐园_类型_布尔;	\
      大失->累加短.值.bool = 0;		\
    }					\
  } while(0)

/*
 * When a call to a procedure is to be
 * performed, the 栈 must have this
 * configuration:
 *
 * SP ->
 *        +---------------------+
 *        | locals, returns etc.|
 *        +---------------------+
 *        |        arg N        |
 *        |          .          |
 *        |          .          |
 *        |          .          |
 *        |        arg 1        |
 *        +---------------------+
 * FP ->  | number of arguments |
 *        +---------------------+
 *        | saved frame pointer |
 *        +---------------------+
 *        |   saved procedure   !
 *        +---------------------+
 *        |    return address   |
 *        +=====================+
 *        |    previous frame   |
 */
static int 失乐园_虚拟机_跑(失乐园_状态_类型* 大失)
{
  int 继_续 = 1, 调试 = 0;

  /*反汇编(大失);*/

  while(继_续) {
    失乐园_对象_类型 临时短;
    register uint32_t 指令短;
    uint32_t 计数甲, 计数乙, 数据字1, 数据字2;

    if(调试) {
      失乐园_虚拟机_转储(大失);
      /*getchar();*/
    }
    assert(大失->程序计数器 < 大失->代码_大小);

    指令短 = 大失->代码[大失->程序计数器++];

    switch(提取_操作(指令短)) {

    case 失乐园_操作_载入_零:
      大失->累加短.类型 = 失乐园_类型_零;
      break;

    case 失乐园_操作_载入_假:
      大失->累加短.类型 = 失乐园_类型_布尔;
      大失->累加短.值.bool = 0;
      break;

    case 失乐园_操作_载入_真:
      大失->累加短.类型 = 失乐园_类型_布尔;
      大失->累加短.值.bool = 1;
      break;

    case 失乐园_操作_载入_零零:
      大失->累加短.类型 = 失乐园_类型_固定整数;
      大失->累加短.值.固定整数 = 0;
      break;

    case 失乐园_操作_载入_一:
      大失->累加短.类型 = 失乐园_类型_固定整数;
      大失->累加短.值.固定整数 = 1;
      break;

    case 失乐园_操作_载入_固定整数:
      大失->累加短.类型 = 失乐园_类型_固定整数;
      大失->累加短.值.固定整数 = 提取_实参(指令短);
      break;

    case 失乐园_操作_载入_印刻:
      大失->累加短.类型 = 失乐园_类型_印刻;
      大失->累加短.值.印刻短 = (失乐园_印刻_类型) 提取_实参(指令短);
      break;

    case 失乐园_操作_自增:
      大失->累加短.值.固定整数++;
      break;

    case 失乐园_操作_自减:
      大失->累加短.值.固定整数--;
      break;

    case 失乐园_操作_固定整数_到_印刻:
      大失->累加短.类型 = 失乐园_类型_印刻;
      大失->累加短.值.印刻短 = (失乐园_印刻_类型) 大失->累加短.值.固定整数;
      break;

    case 失乐园_操作_印刻_到_固定整数:
      大失->累加短.类型 = 失乐园_类型_固定整数;
      大失->累加短.值.固定整数 = (uint32_t) 大失->累加短.值.印刻短;
      break;

    case 失乐园_操作_空指针_问:
      失乐园_设置_布尔(大失->累加短.类型 == 失乐园_类型_零);
      break;

    case 失乐园_操作_零零_问:
      失乐园_设置_布尔(大失->累加短.值.固定整数 == 0);
      break;

    case 失乐园_操作_非:
      失乐园_设置_布尔(大失->累加短.类型 == 失乐园_类型_布尔 &&
		    大失->累加短.值.bool == 0);
      break;

    case 失乐园_操作_布尔_问:
      失乐园_设置_布尔(大失->累加短.类型 == 失乐园_类型_布尔);
      break;

    case 失乐园_操作_印刻_问:
      失乐园_设置_布尔(大失->累加短.类型 == 失乐园_类型_印刻);
      break;

    case 失乐园_操作_固定整数_问:
      失乐园_设置_布尔(大失->累加短.类型 == 失乐园_类型_固定整数);
      break;

    case 失乐园_操作_点对_问:
      失乐园_设置_布尔(大失->累加短.类型 == 失乐园_类型_点对);
      break;

    case 失乐园_操作_符号_问:
      失乐园_设置_布尔(大失->累加短.类型 == 失乐园_类型_符号);
      break;

    case 失乐园_操作_推:
      大失->栈[大失->栈指针++] = 大失->累加短;
      break;

    case 失乐园_操作_加号:
      大失->累加短.值.固定整数 =
	(大失->栈[--大失->栈指针]).值.固定整数 + 大失->累加短.值.固定整数;
      break;

    case 失乐园_操作_减:
      大失->累加短.值.固定整数 =
	(大失->栈[--大失->栈指针]).值.固定整数 - 大失->累加短.值.固定整数;
      break;

    case 失乐园_操作_乘:
      大失->累加短.值.固定整数 =
	(大失->栈[--大失->栈指针]).值.固定整数 * 大失->累加短.值.固定整数;
      break;

    case 失乐园_操作_载入_0:
      大失->累加短 = 大失->栈[大失->帧指针+1];
      break;

    case 失乐园_操作_载入_1:
      大失->累加短 = 大失->栈[大失->帧指针+2];
      break;

    case 失乐园_操作_载入_2:
      大失->累加短 = 大失->栈[大失->帧指针+3];
      break;

    case 失乐园_操作_载入_3:
      大失->累加短 = 大失->栈[大失->帧指针+4];
      break;

    case 失乐园_操作_载入:
      大失->累加短 = 大失->栈[大失->帧指针+提取_实参(指令短)+1];
      break;

    case 失乐园_操作_制作_闭包:
      /*
       * There is always a jump after this instruction, to jump over the
       * closure 代码. So the closure 进入 point is PC + 1
       */
      数据字1 = 大失->程序计数器 + 1;

      /* number of 自由 variables */
      数据字2 = 提取_实参(指令短);

      临时短.类型 = 失乐园_类型_闭包;
      临时短.值.小垃圾回收 = 失乐园_创建_失闭包(大失, 数据字1, 数据字2);
      检查_分配(大失, 临时短.值.小垃圾回收);
      大失->累加短 = 临时短;

      /* gathering 自由 variables */
      for(计数甲 = 0; 计数甲 < 数据字2; 计数甲++) {
	失乐园_闭包(大失->累加短.值.小垃圾回收)->自由_变量[计数甲] = 大失->栈[大失->栈指针-计数甲-1];
      }
      大失->栈指针 -= 数据字2;
      break;

    case 失乐园_操作_尾_调用:
      if(大失->累加短.类型 != 失乐园_类型_闭包) {
        失乐园_推_串(大失, "calling non-closure");
	失乐园_错误(大失, 1);
      }

      /*
       * the arguments to the callee must be shifted down
       * removing the arguments of the caller
       */

      /* number of arguments newly pushed */
      数据字1 = 提取_实参(指令短);

      /* where to copy the new values */
      计数甲 = 大失->帧指针 + 1;

      /* where the values will be copied from */
      计数乙 = 大失->栈指针 - 数据字1;

      memmove(大失->栈+计数甲, 大失->栈+计数乙, 数据字1 * sizeof(失乐园_对象_类型));

      大失->栈指针 = 大失->帧指针 + 数据字1 + 1;
      大失->栈[大失->帧指针].值.固定整数 = 数据字1;

      /* setting active procedure */
      大失->过程短 = 大失->累加短;

      if(失乐园_闭包(大失->过程短.值.小垃圾回收)->是否_小闭包) {
        调用_c_闭包(大失, 失乐园_闭包(大失->过程短.值.小垃圾回收));
      } else {
        /* just jump to closure 代码 */
        大失->程序计数器 = 失乐园_闭包(大失->过程短.值.小垃圾回收)->进入_点.scm;
      }
      break;

    case 失乐园_操作_调用:
      if(大失->累加短.类型 != 失乐园_类型_闭包) {
	失乐园_推_串(大失, "calling non-closure");
	失乐园_错误(大失, 1);
      }

      /* number of arguments newly pushed */
      数据字1 = 提取_实参(指令短);

      /* frame pointer */
      大失->帧指针 = 大失->栈指针 - 数据字1 - 1;
      大失->栈[大失->帧指针].值.固定整数 = 数据字1;

      /* setting active procedure */
      大失->过程短 = 大失->累加短;

      if(失乐园_闭包(大失->过程短.值.小垃圾回收)->是否_小闭包) {
        调用_c_闭包(大失, 失乐园_闭包(大失->过程短.值.小垃圾回收));
      } else {
        /* just jump to closure 代码 */
        大失->程序计数器 = 失乐园_闭包(大失->过程短.值.小垃圾回收)->进入_点.scm;
      }
      break;

    case 失乐园_操作_返回:
      返回_来自_调用(大失);
      break;

    case 失乐园_操作_跳_若_非:
      if(大失->累加短.类型 == 失乐园_类型_布尔 && 大失->累加短.值.bool == 0) {
	大失->程序计数器 += 提取_实参(指令短);
      }
      break;

    case 失乐园_操作_跳:
      大失->程序计数器 += 提取_实参(指令短);
      break;

    case 失乐园_操作_载入_自由:
      大失->累加短 = 失乐园_闭包(大失->过程短.值.小垃圾回收)->自由_变量[提取_实参(指令短)];
      break;

    case 失乐园_操作_保存_继续短:
      数据字1 = 大失->栈指针 * sizeof(失乐园_对象_类型);

      临时短.类型 = 失乐园_类型_继续短;
      临时短.值.小垃圾回收 = 失乐园_创建_继续短(大失, 大失->栈指针);
      检查_分配(大失, 临时短.值.小垃圾回收);
      大失->累加短 = 临时短;

      /* copying 栈 */
      memcpy(失乐园_继续短(大失->累加短.值.小垃圾回收)->栈, 大失->栈, 数据字1);
      break;

    case 失乐园_操作_重置_继续短:
      /* return 值 is on the 栈 */
      临时短 = 大失->栈[--大失->栈指针];

      /* restoring 栈 */
      大失->栈指针 = 失乐园_继续短(大失->累加短.值.小垃圾回收)->大小;
      大失->帧指针 = 大失->栈指针 - 1;
      memcpy(大失->栈, 失乐园_继续短(大失->累加短.值.小垃圾回收)->栈, 大失->栈指针 * sizeof(失乐园_对象_类型));

      大失->累加短 = 临时短;
      break;

    case 失乐园_操作_赋值:
      assert((大失->栈[大失->帧指针+提取_实参(指令短)+1]).类型 == 失乐园_类型_盒子);
      失乐园_盒子((大失->栈[大失->帧指针+提取_实参(指令短)+1]).值.小垃圾回收)->值 = 大失->累加短;
      break;

    case 失乐园_操作_赋值_自由:
      assert((失乐园_闭包(大失->过程短.值.小垃圾回收)->自由_变量[提取_实参(指令短)]).类型 == 失乐园_类型_盒子);
      失乐园_盒子((失乐园_闭包(大失->过程短.值.小垃圾回收)->自由_变量[提取_实参(指令短)]).值.小垃圾回收)->值 = 大失->累加短;
      break;

    case 失乐园_操作_盒子:
      临时短.类型 = 失乐园_类型_盒子;
      临时短.值.小垃圾回收 = 失乐园_创建_盒子(大失);
      检查_分配(大失, 临时短.值.小垃圾回收);
      失乐园_盒子(临时短.值.小垃圾回收)->值 = 大失->累加短;

      大失->累加短 = 临时短;
      break;

    case 失乐园_操作_打开_盒子:
      assert(大失->累加短.类型 == 失乐园_类型_盒子);
      大失->累加短 = 失乐园_盒子(大失->累加短.值.小垃圾回收)->值;
      break;

    case 失乐园_操作_帧:
      /* pushing return address */
      (大失->栈[大失->栈指针  ]).类型 = 失乐园_类型_固定整数;
      (大失->栈[大失->栈指针++]).值.固定整数 = 提取_实参(指令短);

      /* pushing current procedure */
      大失->栈[大失->栈指针++] = 大失->过程短;

      /* pushing frame pointer */
      (大失->栈[大失->栈指针  ]).类型 = 失乐园_类型_固定整数;
      (大失->栈[大失->栈指针++]).值.固定整数 = 大失->帧指针;

      /* push slot where number of arguments will be 设置 */
      (大失->栈[大失->栈指针  ]).类型 = 失乐园_类型_固定整数;
      (大失->栈[大失->栈指针++]).值.固定整数 = 0;      
      break;

    case 失乐园_操作_停机:
      继_续 = 0;
      break;

    case 失乐园_操作_载入_本地:
      大失->累加短 = 大失->栈[大失->帧指针+提取_实参(指令短)+1];
      break;

    case 失乐园_操作_插入_盒子:
      计数甲 = 大失->帧指针+提取_实参(指令短)+1;

      临时短.类型 = 失乐园_类型_盒子;
      临时短.值.小垃圾回收 = 失乐园_创建_盒子(大失);
      检查_分配(大失, 临时短.值.小垃圾回收);
      失乐园_盒子(临时短.值.小垃圾回收)->值 = 大失->栈[计数甲];

      大失->栈[计数甲] = 临时短;
      break;

    case 失乐园_操作_赋值_本地:
      assert((大失->栈[大失->帧指针+提取_实参(指令短)+1]).类型 == 失乐园_类型_盒子);
      失乐园_盒子((大失->栈[大失->帧指针+提取_实参(指令短)+1]).值.小垃圾回收)->值 = 大失->累加短;
      break;

    case 失乐园_操作_弹:
      大失->栈指针 -= 提取_实参(指令短);
      break;

    case 失乐园_操作_已检查_全局_引用:
      if(大失->全局_环境.变量复[提取_实参(指令短)].值.类型 == 失乐园_类型_取消定义) {
	失乐园_推_串(大失, "undefined 全局 referenced: ");
	大失->栈[大失->栈指针].类型 = 失乐园_类型_符号;
        大失->栈[大失->栈指针++].值.符号 = 大失->全局_环境.变量复[提取_实参(指令短)].符号;
	失乐园_错误(大失, 2);
      }
      /* fall through */

    case 失乐园_操作_全局_引用:
      大失->累加短 = 大失->全局_环境.变量复[提取_实参(指令短)].值;
      break;

    case 失乐园_操作_已检查_全局_设置:
      if(大失->全局_环境.变量复[提取_实参(指令短)].值.类型 == 失乐园_类型_取消定义) {
	失乐园_推_串(大失, "undefined 全局 assigned: ");
	大失->栈[大失->栈指针].类型 = 失乐园_类型_符号;
        大失->栈[大失->栈指针++].值.符号 = 大失->全局_环境.变量复[提取_实参(指令短)].符号;
	失乐园_错误(大失, 2);
      }
      /* fall through */

    case 失乐园_操作_全局_设置:
      大失->全局_环境.变量复[提取_实参(指令短)].值 = 大失->累加短;
      break;

    case 失乐园_操作_载入_取消定义:
      大失->累加短.类型 = 失乐园_类型_取消定义;
      break;

    case 失乐园_操作_常量:
      大失->累加短 = 大失->常量短[提取_实参(指令短)];
      break;

    case 失乐园_操作_常量_初始:
      大失->常量短[提取_实参(指令短)] = 大失->累加短;
      break;

    case 失乐园_操作_元数_等于:
      if(大失->栈[大失->帧指针].值.固定整数 != 提取_实参(指令短)) {
	失乐园_推_串(大失, "arity mismatch");
	失乐园_错误(大失, 1);
      }
      break;

    case 失乐园_操作_大等:
      if(大失->栈[大失->帧指针].值.固定整数 < 提取_实参(指令短)) {
	失乐园_推_串(大失, "variable arity mismatch");
	失乐园_错误(大失, 1);
      }
      break;

    case 失乐园_操作_列出:
      /* number of fixed arguments */
      数据字1 = 提取_实参(指令短);

      /* total number of arguments */
      数据字2 = 大失->栈[大失->帧指针].值.固定整数;

      /* consing */
      大失->累加短.类型 = 失乐园_类型_零;
      for(计数甲 = 大失->帧指针 + 数据字2; 计数甲 > 大失->帧指针 + 数据字1; 计数甲--) {
	临时短.类型 = 失乐园_类型_点对;
	临时短.值.小垃圾回收 = 失乐园_创建_点对(大失);
	检查_分配(大失, 临时短.值.小垃圾回收);
	失乐园_点对(临时短.值.小垃圾回收)->切头 = 大失->栈[计数甲];
	失乐园_点对(临时短.值.小垃圾回收)->切尾 = 大失->累加短;

	大失->累加短 = 临时短;
      }

      /* adjusting 栈 */
      大失->栈[大失->帧指针 + ++数据字1] = 大失->累加短;
      大失->栈[大失->帧指针].值.固定整数 = 数据字1;
      大失->栈指针 = 大失->帧指针 + 数据字1 + 1;
      break;

    case 失乐园_操作_中止:
      失乐园_错误(大失, 0);
      break;

    case 失乐园_操作_构造:
      临时短.类型 = 失乐园_类型_点对;
      临时短.值.小垃圾回收 = 失乐园_创建_点对(大失);
      检查_分配(大失, 临时短.值.小垃圾回收);
      失乐园_点对(临时短.值.小垃圾回收)->切头 = 大失->栈[--大失->栈指针];
      失乐园_点对(临时短.值.小垃圾回收)->切尾 = 大失->累加短;

      大失->累加短 = 临时短;
      break;

    case 失乐园_操作_切头:
      大失->累加短 = 失乐园_点对(大失->累加短.值.小垃圾回收)->切头;
      break;

    case 失乐园_操作_切尾:
      大失->累加短 = 失乐园_点对(大失->累加短.值.小垃圾回收)->切尾;
      break;

    case 失乐园_操作_数号_等于:
      /* TODO: throw 错误 if args are not numbers */
      失乐园_设置_布尔(大失->累加短.值.固定整数 == 大失->栈[--大失->栈指针].值.固定整数);
      break;

    case 失乐园_操作_等于:
      失乐园_设置_布尔(失乐园_对象_等号(大失->累加短, 大失->栈[大失->栈指针-1]));
      --大失->栈指针;
      break;

    case 失乐园_操作_相等:
      失乐园_设置_布尔(失乐园_对象_等号(大失->累加短, 大失->栈[大失->栈指针-1]));
      --大失->栈指针;
      break;

    case 失乐园_操作_制作_串:
      /* string 大小 */
      数据字1 = 大失->累加短.值.固定整数;

      临时短.类型 = 失乐园_类型_串;
      临时短.值.小垃圾回收 = 失乐园_创建_串(大失, NULL, 数据字1);
      检查_分配(大失, 临时短.值.小垃圾回收);

      大失->累加短 = 临时短;
      break;

    case 失乐园_操作_串_设置:
      数据字1 = 大失->累加短.值.印刻短;
      数据字2 = 大失->栈[--大失->栈指针].值.固定整数;
      大失->累加短 = 大失->栈[--大失->栈指针];
      失乐园_串(大失->累加短.值.小垃圾回收)->印刻复[数据字2] = 数据字1;
      break;

    case 失乐园_操作_串_到_符号:
      临时短 = 失乐园_创建_符号(大失, 失乐园_串(大失->累加短.值.小垃圾回收));
      大失->累加短 = 临时短;
      break;

    case 失乐园_操作_制作_向量:
      /* vector 大小 */
      数据字1 = 大失->累加短.值.固定整数;

      临时短.类型 = 失乐园_类型_向量;
      临时短.值.小垃圾回收 = 失乐园_创建_向量(大失, 数据字1);
      检查_分配(大失, 临时短.值.小垃圾回收);

      大失->累加短 = 临时短;
      break;

    case 失乐园_操作_向量_设置:
      临时短 = 大失->累加短;
      数据字1 = 大失->栈[--大失->栈指针].值.固定整数;
      大失->累加短 = 大失->栈[--大失->栈指针];
      失乐园_向量(大失->累加短.值.小垃圾回收)->数据[数据字1] = 临时短;    
      break;

    case 失乐园_操作_调试:
      if(大失->累加短.值.bool == 0) {
	调试 = 0;
      } else {
	调试 = 1;
      }
      break;

    default:
      abort();
    }
  }

  return 1;
}

void 失乐园_虚拟机_调用(失乐园_状态_类型* 大失, 失乐园_对象_类型 过程短, uint32_t 实参数号)
{
  int 索引短;

  /* must copy args "up" to create space for frame info */
  索引短 = 大失->栈指针 - 实参数号;
  大失->栈指针 += 4;
  memmove(&大失->栈[索引短+4], &大失->栈[索引短], 实参数号 * sizeof(失乐园_对象_类型));

  /* return address */
  (大失->栈[索引短  ]).类型 = 失乐园_类型_固定整数;
  (大失->栈[索引短++]).值.固定整数 = 失乐园_停机_地址;

  /* saved procedure */
  大失->栈[索引短++] = 大失->过程短;
  大失->过程短 = 过程短;

  /* saved frame pointer */
  (大失->栈[索引短  ]).类型 = 失乐园_类型_固定整数;
  (大失->栈[索引短++]).值.固定整数 = 大失->帧指针;

  /* number of arguments */
  大失->帧指针 = 索引短;
  (大失->栈[索引短]).类型 = 失乐园_类型_固定整数;
  (大失->栈[索引短]).值.固定整数 = 实参数号;

  if(失乐园_闭包(大失->过程短.值.小垃圾回收)->是否_小闭包) {
    调用_c_闭包(大失, 失乐园_闭包(大失->过程短.值.小垃圾回收));
  } else {
    /* reenter the virtual machine */
    大失->程序计数器 = 失乐园_闭包(大失->过程短.值.小垃圾回收)->进入_点.scm;
    失乐园_虚拟机_跑(大失);
  }
}

/*
 * loading
 */

static void 失乐园_摧毁_模块(失乐园_模块_类型 *M)
{
  uint32_t 计数甲;

  free(M->代码);

  for(计数甲 = 0; 计数甲 < M->数号_全局; 计数甲++) {
    free(M->全局复[计数甲]);
  }
  free(M->全局复);
}

static uint32_t 失乐园_链接_模块(失乐园_状态_类型* 大失, 失乐园_模块_类型 *模块短)
{
  失乐园_环境_类型 环境短;
  失乐园_对象_类型 对象短, *临时短;
  uint32_t *代码;
  int 索引短, 旧_大小;
  uint32_t 计数甲, 数据字, 常量_基础, 代码_基础, 生长;

  环境短.大小 = 模块短->数号_全局;
  环境短.变量复 = (失乐园_环境_变量_类型*)malloc(环境短.大小 * sizeof(失乐园_环境_变量_类型));
  /* TODO: test return and throw 错误 */

  /*
   * adding 全局 to environment
   * a little trick is used here, I use the 值
   * of the 全局 var to 储存 the index where the
   * 全局 will be mapped to when linking the 代码
   *
   */
  for(生长 = 0, 计数甲 = 0; 计数甲 < 环境短.大小; 计数甲++) {
    对象短 = 失乐园_创建_符号(大失, 模块短->全局复[计数甲]);
    环境短.变量复[计数甲].符号 = 对象短.值.符号;
    环境短.变量复[计数甲].值.类型 = 失乐园_类型_固定整数;

    索引短 = 失乐园_状态_取_全局_索引(大失, 环境短.变量复[计数甲].符号);
    if(索引短 < 0) {
      数据字 = 大失->全局_环境.大小 + 生长++;
    } else {
      数据字 = 索引短;
    }

    环境短.变量复[计数甲].值.值.固定整数 = 数据字;
  }

  /* enlarging 全局 environment */
  if(生长 > 0) {
    旧_大小 = 大失->全局_环境.大小;
    失乐园_状态_扩大_全局(大失, 生长);

    for(计数甲 = 0; 计数甲 < 环境短.大小; 计数甲++) {
      索引短 = 环境短.变量复[计数甲].值.值.固定整数;
      if(索引短 >= 旧_大小) {
	大失->全局_环境.变量复[索引短].符号 = 环境短.变量复[计数甲].符号;
	大失->全局_环境.变量复[索引短].值.类型 = 失乐园_类型_取消定义;
      }
    }
  }

  /* enlarging constants */
  常量_基础 = 大失->数号_常量;
  数据字 = 大失->数号_常量 + 模块短->数号_常量;
  临时短 = (失乐园_对象_类型*)realloc(大失->常量短, 数据字 * sizeof(失乐园_对象_类型));
  /* TODO: test return and throw 错误 */
  大失->常量短 = 临时短;
  for(计数甲 = 大失->数号_常量; 计数甲 < 数据字; 计数甲++) {
    大失->常量短[计数甲].类型 = 失乐园_类型_取消定义;
  }
  大失->数号_常量 = 数据字;

  /* enlarging 代码 */
  代码_基础 = 大失->代码_大小;
  数据字 = 大失->代码_大小 + 模块短->代码_大小;
  代码 = (uint32_t*)realloc(大失->代码, 数据字 * sizeof(uint32_t));
  /* TODO: test return and throw 错误 */
  大失->代码_大小 = 数据字;
  大失->代码 = 代码;

  for(计数甲 = 0; 计数甲 < 模块短->代码_大小; 计数甲++) {
    uint32_t 指令短, 小操作;

    指令短 = 模块短->代码[计数甲];
    小操作 = 提取_操作(指令短);

    switch(小操作) {

    case 失乐园_操作_帧:
      数据字 = 提取_实参(指令短);
      数据字 += 代码_基础;
      指令短 = ((uint32_t)小操作) | 数据字 << 8;
      break;

    case 失乐园_操作_常量:
    case 失乐园_操作_常量_初始:
      数据字 = 提取_实参(指令短);
      数据字 += 常量_基础;
      指令短 = ((uint32_t)小操作) | 数据字 << 8;
      break;

    case 失乐园_操作_全局_引用:
    case 失乐园_操作_已检查_全局_引用:
    case 失乐园_操作_全局_设置:
    case 失乐园_操作_已检查_全局_设置:
      数据字 = 提取_实参(指令短);
      数据字 = 环境短.变量复[数据字].值.值.固定整数;
      指令短 = ((uint32_t)小操作) | 数据字 << 8;
      break;
    }

    大失->代码[代码_基础+计数甲] = 指令短;
  }

  free(环境短.变量复);

  return 代码_基础;
}

int 失乐园_虚拟机_链接_跑_模块(失乐园_状态_类型* 大失, 失乐园_模块_类型 *模块短)
{
  大失->程序计数器 = 失乐园_链接_模块(大失, 模块短);
  失乐园_摧毁_模块(模块短);

  /* initial frame on 栈 with address of halt instruction */
  /* return address */
  (大失->栈[大失->栈指针  ]).类型 = 失乐园_类型_固定整数;
  (大失->栈[大失->栈指针++]).值.固定整数 = 失乐园_停机_地址;

  /* saved procedure */
  大失->栈[大失->栈指针++] = 大失->过程短;

  /* saved frame pointer */
  (大失->栈[大失->栈指针  ]).类型 = 失乐园_类型_固定整数;
  (大失->栈[大失->栈指针++]).值.固定整数 = 大失->帧指针;

  /* number of arguments */
  (大失->栈[大失->栈指针  ]).类型 = 失乐园_类型_固定整数;
  (大失->栈[大失->栈指针++]).值.固定整数 = 0;

  大失->帧指针 = 大失->栈指针 - 1;

  return 失乐园_虚拟机_跑(大失);
}

#define 切头大(l) (失乐园_点对((l).值.小垃圾回收)->切头)
#define 切尾大(l) (失乐园_点对((l).值.小垃圾回收)->切尾)
#define 向量_引用(v,计数甲) (失乐园_向量((v).值.小垃圾回收)->数据[计数甲])

static uint8_t 取_操作码(失乐园_对象_类型 符号短)
{
  失乐园_操作码_类型 *小操作码;

  for(小操作码 = 全局_操作码; 小操作码->名称 != NULL; 小操作码++) {
    if(符号短.值.符号 == 小操作码->符号短) {
      return 小操作码->小操作;
    }
  }

  return 255;
}

static uint32_t 列表_长度(失乐园_对象_类型 列表短)
{
  uint32_t 计数甲;

  if(列表短.类型 == 失乐园_类型_零) {
    return 0;
  }

  for(计数甲 = 1;; 计数甲++, 列表短 = 切尾大(列表短)) {
    if((切尾大(列表短)).类型 == 失乐园_类型_零) {
      return 计数甲;
    }
  }
}

void 失乐园_虚拟机_向量_到_模块(失乐园_对象_类型 向量短, 失乐园_模块_类型 *模块短)
{
  uint32_t sz;
  失乐园_对象_类型 p;

  assert(向量短.类型 == 失乐园_类型_向量);

  /* 全局复 */
  p = 向量_引用(向量短, 0);
  sz = 列表_长度(p);
  模块短->数号_全局 = sz;
  sz *= sizeof(失乐园_串_类型*);
  模块短->全局复 = (失乐园_串_类型**)malloc(sz);
  memset(模块短->全局复, 0x00, sz);
  for(sz = 0;; p = 切尾大(p), sz++) {
    uint32_t 大小;
    失乐园_串_类型 *串短;

    if(p.类型 == 失乐园_类型_零) {
      break;
    } else {
      大小 = 失乐园_大小_的_串((切头大(p)).值.符号->串短->大小);
      串短 = (失乐园_串_类型*)malloc(大小);
      memmove(串短, (切头大(p)).值.符号->串短, 大小);

      模块短->全局复[sz] = 串短;
    }
  }

  /* constants */
  模块短->数号_常量 = 列表_长度(向量_引用(向量短, 1));

  /* loading 代码 */
  sz = (向量_引用(向量短, 2)).值.固定整数;
  模块短->代码_大小 = sz;
  模块短->代码 = (uint32_t*)malloc(sz * sizeof(uint32_t));
  向量短 = 向量_引用(向量短, 3);

  for(sz = 0; sz < 模块短->代码_大小; sz++) {
    uint32_t 指令短, dat;
    失乐园_对象_类型 向量_指令;

    向量_指令 = 向量_引用(向量短, sz);
    指令短 = (uint32_t)取_操作码(向量_引用(向量_指令, 0));

    /* retrieve operands if any */
    if(是否_类型_乙(指令短)) {
      dat = (向量_引用(向量_指令, 1)).值.固定整数;
      指令短 |= (dat << 8);
    }

    模块短->代码[sz] = 指令短;
  }
}

int 失乐园_虚拟机_载入(失乐园_状态_类型* 大失, 失乐园_对象_类型 向量短)
{
  失乐园_模块_类型 模块短;

  assert(向量短.类型 == 失乐园_类型_向量);

  失乐园_虚拟机_向量_到_模块(向量短, &模块短);
  return 失乐园_虚拟机_链接_跑_模块(大失, &模块短);
}

#define 固定整数大(o, n) do {(o).类型 = 失乐园_类型_固定整数; (o).值.固定整数 = (n);} while(0)

static void 写_固定整数(失乐园_状态_类型 *大失, 失乐园_对象_类型 *固定短, 失乐园_对象_类型 *端口)
{
  uint8_t b;
  uint32_t 值短;
  失乐园_对象_类型 o;

  值短 = 固定短->值.固定整数;

  b = 值短 / (1 << 24);
  值短 %= 1 << 24;
  固定整数大(o, b);
  失乐园_入出_写(大失, &o, 端口);
  失乐园_入出_写_印名_串(大失, " ", 端口);

  b = 值短 / (1 << 16);
  值短 %= 1 << 16;
  固定整数大(o, b);
  失乐园_入出_写(大失, &o, 端口);
  失乐园_入出_写_印名_串(大失, " ", 端口);

  b = 值短 / (1 << 8);
  值短 %= 1 << 8;
  固定整数大(o, b);
  失乐园_入出_写(大失, &o, 端口);
  失乐园_入出_写_印名_串(大失, " ", 端口);

  固定整数大(o, 值短);
  失乐园_入出_写(大失, &o, 端口);
  失乐园_入出_写_印名_串(大失, " ", 端口);
}

void 失乐园_虚拟机_写_代码(失乐园_状态_类型 *大失, 失乐园_对象_类型 向量短, 失乐园_对象_类型 *端口)
{
  uint32_t 计数甲;
  失乐园_模块_类型 模块短;
  失乐园_对象_类型 o;

  失乐园_虚拟机_向量_到_模块(向量短, &模块短);

  失乐园_入出_写_印名_串(大失, "#( ", 端口);
  固定整数大(o, 模块短.数号_全局);
  写_固定整数(大失, &o, 端口);

  for(计数甲 = 0; 计数甲 < 模块短.数号_全局; 计数甲++) {
    uint32_t 计数乙;
    失乐园_串_类型 *串短;

    串短 = 模块短.全局复[计数甲];
    固定整数大(o, 串短->大小);
    写_固定整数(大失, &o, 端口);

    for(计数乙 = 0; 计数乙 < 串短->大小; 计数乙++) {
      固定整数大(o, 串短->印刻复[计数乙]);
      写_固定整数(大失, &o, 端口);
    }
  }

  固定整数大(o, 模块短.数号_常量);
  写_固定整数(大失, &o, 端口);

  固定整数大(o, 模块短.代码_大小);
  写_固定整数(大失, &o, 端口);

  for(计数甲 = 0; 计数甲 < 模块短.代码_大小; 计数甲++) {
    uint32_t 指令短;

    指令短 = 模块短.代码[计数甲];
    固定整数大(o, 提取_操作(指令短));
    失乐园_入出_写(大失, &o, 端口);
    失乐园_入出_写_印名_串(大失, " ", 端口);

    if(是否_类型_乙(指令短)) {
      固定整数大(o, 提取_实参(指令短));
      写_固定整数(大失, &o, 端口);
    }
  }

  失乐园_入出_写_印名_串(大失, ")", 端口);
  失乐园_入出_新行(大失, 端口);

  失乐园_摧毁_模块(&模块短);
}

static int 取_下一个(FILE* f, uint32_t *下一个)
{
  int 返回短;

  返回短 = fscanf(f, " %u", 下一个);
  if(返回短 == EOF || 返回短 == 0) {
    return 0;
  } else {
    return 1;
  }
}

static int 取_固定整数(FILE* f, uint32_t *数号短)
{
  int 返回短;
  uint32_t b1, b2, b3, b4;

  返回短 = 取_下一个(f, &b1);
  if(!返回短) {
    return 0;
  }
  返回短 = 取_下一个(f, &b2);
  if(!返回短) {
    return 0;
  }
  返回短 = 取_下一个(f, &b3);
  if(!返回短) {
    return 0;
  }
  返回短 = 取_下一个(f, &b4);
  if(!返回短) {
    return 0;
  }

  *数号短 = b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);

  return 1;
}

static int 取_串(FILE *f, 失乐园_串_类型 **串短)
{
  int 返回短;
  uint32_t 计数甲, 数据字1, 数据字2;

  /* string 大小 */
  返回短 = 取_固定整数(f, &数据字1);
  if(!返回短) {
    return 0;
  }

  *串短 = (失乐园_串_类型*)malloc(失乐园_大小_的_串(数据字1));
  /* TODO: test return and throw 错误 */
  (*串短)->大小  = 数据字1;
  失乐园_垃圾回收对象(*串短)->类型 = 失乐园_类型_串;

  for(计数甲 = 0; 计数甲 < 数据字1; 计数甲++) {
    返回短 = 取_固定整数(f, &数据字2);
    if(!返回短) {
      free(*串短);
      *串短 = NULL;
      return 0;
    }
    (*串短)->印刻复[计数甲] = 数据字2;
  }

  return 1;
}

static int 载入_代码_来自_文件(失乐园_模块_类型 *模块短, const char* 文件名)
{
  int 返回短;
  FILE *f;
  uint32_t 计数甲, 数据字1, 数据字2;

  /* opening input 文件 */
  f = fopen(文件名, "r");
  if(!f) {
    return 0;
  }

  /* bytecode beginning */
  返回短 = fscanf(f, " #(");
  if(返回短 == EOF) {
    fclose(f);
    return 0;
  }

  /* reading number of 全局复 */
  返回短 = 取_固定整数(f, &数据字1);
  if(!返回短) {
    fclose(f);
    return 0;
  }

  模块短->数号_全局 = 数据字1;
  数据字2 = 数据字1 * sizeof(失乐园_串_类型*);
  模块短->全局复 = (失乐园_串_类型**)malloc(数据字2);
  /* TODO: test return and throw 错误 */
  memset(模块短->全局复, 0x00, 数据字2);

  /* reading 全局复 */
  for(计数甲 = 0; 计数甲 < 模块短->数号_全局; 计数甲++) {

    返回短 = 取_串(f, &模块短->全局复[计数甲]);
    if(!返回短) {
      fclose(f);
      return 0;
    }
  }

  /* reading number of constants */
  返回短 = 取_固定整数(f, &数据字1);
  if(!返回短) {
    fclose(f);
    return -1;
  }

  模块短->数号_常量 = 数据字1;

  /* reading 代码 大小 */
  返回短 = 取_固定整数(f, &数据字1);
  if(!返回短) {
    fclose(f);
    return -1;
  }

  模块短->代码_大小 = 数据字1;
  模块短->代码 = (uint32_t*)malloc(数据字1 * sizeof(uint32_t));
  /* TODO: test return and throw 错误 */

  /* reading actual 代码 */
  for(计数甲 = 0; 计数甲 < 模块短->代码_大小; 计数甲++) {
    uint32_t 指令短;

    返回短 = 取_下一个(f, &指令短);
    if(!返回短) {
      /* unexpected end */
      失乐园_摧毁_模块(模块短);
      fclose(f);
      return 0;
    }

    /* retrieve operands if any */
    if(是否_类型_乙(指令短)) {
      返回短 = 取_固定整数(f, &数据字1);
      if(!返回短) {
	失乐园_摧毁_模块(模块短);
	fclose(f);
	return 0;
      }

      指令短 |= (数据字1 << 8);
    }

    模块短->代码[计数甲] = 指令短;
  }

  fclose(f);
  return 1;
}

static void 取_固定整数_乙(uint8_t **缓冲短, uint32_t *数号短)
{
  uint32_t b1, b2, b3, b4;

  b1 = (*缓冲短)[0];
  b2 = (*缓冲短)[1];
  b3 = (*缓冲短)[2];
  b4 = (*缓冲短)[3];

  *数号短 = b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);

  *缓冲短 += 4;
}

static int 取_串_乙(uint8_t **缓冲短, 失乐园_串_类型 **串短)
{
  uint32_t 计数甲, 数据字1, 数据字2;

  /* string 大小 */
  取_固定整数_乙(缓冲短, &数据字1);

  *串短 = (失乐园_串_类型*)malloc(失乐园_大小_的_串(数据字1));
  /* TODO: test return and throw 错误 */
  (*串短)->大小  = 数据字1;
  失乐园_垃圾回收对象(*串短)->类型 = 失乐园_类型_串;

  for(计数甲 = 0; 计数甲 < 数据字1; 计数甲++) {
    取_固定整数_乙(缓冲短, &数据字2);
    (*串短)->印刻复[计数甲] = 数据字2;
  }

  return 1;
}

static int 载入_代码_来自_缓冲区(失乐园_模块_类型 *模块短, const uint8_t *缓冲区)
{
  uint8_t *缓冲短;
  uint32_t 计数甲, 数据字1, 数据字2;

  缓冲短 = (uint8_t*)缓冲区;

  /* reading number of 全局复 */
  取_固定整数_乙(&缓冲短, &数据字1);

  模块短->数号_全局 = 数据字1;
  数据字2 = 数据字1 * sizeof(失乐园_串_类型*);
  模块短->全局复 = (失乐园_串_类型**)malloc(数据字2);
  /* TODO: test return and throw 错误 */
  memset(模块短->全局复, 0x00, 数据字2);

  /* reading 全局复 */
  for(计数甲 = 0; 计数甲 < 模块短->数号_全局; 计数甲++) {
    取_串_乙(&缓冲短, &模块短->全局复[计数甲]);
  }

  /* reading number of constants */
  取_固定整数_乙(&缓冲短, &数据字1);
  模块短->数号_常量 = 数据字1;

  /* reading 代码 大小 */
  取_固定整数_乙(&缓冲短, &数据字1);

  模块短->代码_大小 = 数据字1;
  模块短->代码 = (uint32_t*)malloc(数据字1 * sizeof(uint32_t));
  /* TODO: test return and throw 错误 */

  /* reading actual 代码 */
  for(计数甲 = 0; 计数甲 < 模块短->代码_大小; 计数甲++) {
    uint32_t 指令短;

    指令短 = (uint32_t)*(缓冲短++);

    /* retrieve operands if any */
    if(是否_类型_乙(指令短)) {
      取_固定整数_乙(&缓冲短, &数据字1);

      指令短 |= (数据字1 << 8);
    }

    模块短->代码[计数甲] = 指令短;
  }

  return 1;
}

int 失乐园_载入_缓冲区(失乐园_状态_类型* 大失, const uint8_t *缓冲区)
{
  失乐园_模块_类型 模块短;

  /* tries to 载入 代码 into module */
  if(!载入_代码_来自_缓冲区(&模块短, 缓冲区)) {
    return 0;
  }

  return 失乐园_虚拟机_链接_跑_模块(大失, &模块短);
}
