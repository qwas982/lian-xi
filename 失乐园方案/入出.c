/*
 * The 失乐园方案 输入/输出
 
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "失乐园.h"
#include "入出.h"
#include "对象.h"
#include "状态.h"

#define 失乐园_通用字符集_印刻_表            0x0009
#define 失乐园_通用字符集_行_喂养           0x000A
#define 失乐园_通用字符集_行_表            0x000B
#define 失乐园_通用字符集_来自_喂养           0x000C
#define 失乐园_通用字符集_切头_返回          0x000D
#define 失乐园_通用字符集_空格               0x0020
#define 失乐园_通用字符集_下一个_行           0x0085
#define 失乐园_通用字符集_行_自升式            0x2028
#define 失乐园_通用字符集_伞兵_自升式            0x0029
#define 失乐园_通用字符集_左_引号          0x201C
#define 失乐园_通用字符集_右_引号         0x201D
#define 失乐园_通用字符集_省略号            0x2026
#define 失乐园_通用字符集_分数_斜杠      0x2044

/* using the Unicode private range */
#define 失乐园_通用字符集_文件终                 0xF000
#define 失乐园_通用字符集_不_印刻             0xF001

/*
 * reader tokens
 */
#define 失乐园_牌_没有                1
#define 失乐园_牌_文件终                 2
#define 失乐园_牌_基准               3
#define 失乐园_牌_左_小括号          4
#define 失乐园_牌_右_小括号         5
#define 失乐园_牌_尖_小括号         6
#define 失乐园_牌_引号               7
#define 失乐园_牌_反引号           8
#define 失乐园_牌_逗号               9
#define 失乐园_牌_逗号_在           10
#define 失乐园_牌_句号                11


/*
 * character sets
 */
static const 失乐园_印刻_类型 分隔符_设置[]     = {'(', ')', '[', ']', '"', ';', '\0'};
static const 失乐园_印刻_类型 加减句_开始_设置[] = {'+', '-', '.', '\0'};
static const 失乐园_印刻_类型 符号_开始_设置[] = {'!', '$', '%', '&', '*', '/', ':', '<', '=',
                                           '>', '?', '^', '_', '~', '\0'};
static const 失乐园_印刻_类型 数号_设置[]       = {'e', 'E', 'i', 'I', 'b', 'B', 'o', 'O',
                                           'd', 'D', 'x', 'X', '\0'};

/*
 * some string constants
 */

static const 失乐园_印刻_类型 空格_串[]     = {'#', '\\', 's', 'p', 'a', 'c', 'e', '\0'};
static const 失乐园_印刻_类型 新行_串[]   = {'#', '\\', 'n', 'e', 'w', 'l', 'i', 'n', 'e', '\0'};
static const 失乐园_印刻_类型 省略号_串[]  = {'.', '.', '.', '\0'};

static int 是否_行_终(失乐园_印刻_类型 c)
{
  return c == 失乐园_通用字符集_行_喂养 || c == 失乐园_通用字符集_切头_返回 ||
         c == 失乐园_通用字符集_下一个_行 || c == 失乐园_通用字符集_行_自升式;
}

static int 是否_空格(失乐园_印刻_类型 c)
{
  return 是否_行_终(c) || c == 失乐园_通用字符集_空格 ||
         (c >= 失乐园_通用字符集_印刻_表 && c <= 失乐园_通用字符集_切头_返回) ||
         (c > 0x1FFF && c < 0x200B);
}

static int 是否_印刻_内_设置(失乐园_印刻_类型 c, const 失乐园_印刻_类型 *设置)
{
  const 失乐园_印刻_类型 *p;

  p = 设置;
  while(*p != 0) {
    if(c == *p++) {
      return 1;
    }
  }

  return 0;
}

static int 串_长度(const 失乐园_印刻_类型 *串短)
{
  int 计数甲;

  for(计数甲 = 0; 串短[计数甲] != 0; 计数甲++);

  return 计数甲;
}

/*
 * char encodings
 */

static int 印刻到万国码编码8(失乐园_印刻_类型 c, uint8_t *缓冲短, uint8_t *sz)
{
  int 返回短 = 1;

  if(c < 0x80) {
    *sz = 1;
    缓冲短[0] = (uint8_t)c;
  } else if(c < 0x800) {
    *sz = 2;
    缓冲短[0] = 0xC0 | (uint8_t)((c >>  6) & 0x1F);
    缓冲短[1] = 0x80 | (uint8_t)(c & 0x3F);
  } else if(c > 0xD7FF && c < 0xE000) {
    /* this range is for surrogates */
    返回短 = 0;
  } else if(c < 0x10000) {
    *sz = 3;
    缓冲短[0] = 0xE0 | (uint8_t)((c >> 12) & 0x0F);
    缓冲短[1] = 0x80 | (uint8_t)((c >>  6) & 0x3F);
    缓冲短[2] = 0x80 | (uint8_t)(c & 0x3F);
  } else if(c < 0x110000) {
    *sz = 4;
    缓冲短[0] = 0xF0 | (uint8_t)((c >> 18) & 0x07);
    缓冲短[1] = 0x80 | (uint8_t)((c >> 12) & 0x3F);
    缓冲短[2] = 0x80 | (uint8_t)((c >>  6) & 0x3F);
    缓冲短[3] = 0x80 | (uint8_t)(c & 0x3F);
  } else {
    返回短 = 0;
  }

  return 返回短;
}

static int 印刻到万国码编码16(失乐园_印刻_类型 c, uint8_t *缓冲短_, uint8_t *sz)
{
  int 返回短 = 1;
  uint16_t *缓冲短 = (uint16_t*)缓冲短_;

  if(c > 0xD7FF && c < 0xE000) {
    /* this range is for surrogates */
    返回短 = 0;
  } else if(c < 0xFFFF) {
    *sz = 2;
    缓冲短[0] = (uint16_t)c;
  } else if(c < 0x110000) {
    *sz = 4;
    c -= 0x10000;
    缓冲短[0] = 0xD800 | (uint16_t)((c >> 10) & 0x3FF);
    缓冲短[1] = 0xDC00 | (uint16_t)(c & 0x3FF);
  } else {
    返回短 = 0;
  }

  return 返回短;
}

static int 印刻到拉丁文1(失乐园_印刻_类型 c, uint8_t *缓冲短, uint8_t *sz)
{
  int 返回短 = 1;

  *sz = 1;
  if(c < 0x100) {
    缓冲短[0] = (uint8_t)c;
  } else if(c > 0x1FFF && c < 0x200B) {
    /* several compatibility spaces */
    缓冲短[0] = (uint8_t)' ';
  } else if(c == 失乐园_通用字符集_左_引号 ||
            c == 失乐园_通用字符集_右_引号) {
    缓冲短[0] = (uint8_t)'"';
  } else if(c == 失乐园_通用字符集_省略号) {
    *sz = 3;
    缓冲短[0] = 缓冲短[1] = 缓冲短[2] = '.';
  } else if(c == 失乐园_通用字符集_分数_斜杠) {
    缓冲短[0] = (uint8_t)'/';
  } else if(c > 0xD7FF && c < 0xE000) {
    /* this range is for surrogates */
    返回短 = 0;
  } else {
    缓冲短[0] = 191; /* inverted question mark */
  }

  return 返回短;
}

static uint8_t* 来自_串(失乐园_串_类型 *串短, uint8_t 印刻_编码)
{
  uint32_t 计数甲, 大小;
  uint8_t *返回短, sz, 缓冲短[4];
  int (*函数短)(失乐园_印刻_类型,uint8_t*,uint8_t*);

  switch(印刻_编码) {
  case 失乐园_印刻_编码_万国码编码8:
    函数短 = 印刻到万国码编码8;
    break;
  case 失乐园_印刻_编码_万国码编码16:
    函数短 = 印刻到万国码编码16;
    break;
  case 失乐园_印刻_编码_拉丁文1:
    函数短 = 印刻到拉丁文1;
    break;
  default:
    return NULL;
  }

  /* calculating 大小 of final string */
  for(大小 = 0, 计数甲 = 0; 计数甲 < 串短->大小; 计数甲++, 大小 += sz) {
    if(!函数短(串短->印刻复[计数甲], 缓冲短, &sz)) {
      return NULL;
    }
  }

  返回短 = (uint8_t*)malloc((大小+1) * sizeof(uint8_t));
  if(!返回短) {
    return NULL;
  }

  返回短[大小] = '\0';
  for(大小 = 0, 计数甲 = 0; 计数甲 < 串短->大小; 计数甲++, 大小 += sz) {
    函数短(串短->印刻复[计数甲], 缓冲短, &sz);
    memcpy(&返回短[大小], 缓冲短, sz * sizeof(uint8_t));
  }

  return 返回短;
}

/*
 * A string 缓冲区
 */

struct 失乐园_缓冲区_类型 {
  size_t 位置短;
  size_t 大小;
  失乐园_印刻_类型 *串短;
};

失乐园_缓冲区_类型* 失乐园_入出_创建_串缓冲区(void)
{
  失乐园_缓冲区_类型 *返回短;

  返回短 = (失乐园_缓冲区_类型*) malloc(sizeof(失乐园_缓冲区_类型));
  if(返回短 == NULL) {
    return NULL;
  }

  /* most identifiers are small */
  返回短->位置短 = 0;
  返回短->大小 = 32;
  返回短->串短 = (失乐园_印刻_类型*) malloc(返回短->大小 * sizeof(失乐园_印刻_类型));
  if(返回短->串短 == NULL) {
    free(返回短);
    return NULL;
  }
  返回短->串短[0] = '\0';

  return 返回短;
}

void 失乐园_入出_摧毁_串缓冲区(失乐园_缓冲区_类型* 缓冲区)
{
  if(缓冲区 != NULL) {
    if(缓冲区->串短 != NULL) {
      free(缓冲区->串短);
    }
    free(缓冲区);
  }
}

void 失乐园_缓冲区_赋值(失乐园_缓冲区_类型* 缓冲区, const char* 串短)
{
  size_t 计数甲, 长度短;

  长度短 = strlen(串短) + 1;
  if(长度短 > 缓冲区->大小) {
    失乐园_印刻_类型 *t;

    t = (失乐园_印刻_类型*) realloc(缓冲区->串短, 长度短 * sizeof(失乐园_印刻_类型));
    if(t == NULL) {
      return;
    }
    缓冲区->串短 = t;
    缓冲区->大小 = 长度短;
  }

  for(计数甲 = 0; 计数甲 < 长度短; 计数甲++) {
    缓冲区->串短[计数甲] = 串短[计数甲];
  }
  缓冲区->位置短 = 长度短 - 1;
  缓冲区->串短[长度短] = '\0';
}

void 失乐园_缓冲区_添加(失乐园_缓冲区_类型* 缓冲区, 失乐园_印刻_类型 c)
{
  if(缓冲区 == NULL) {
    return;
  }

  if(缓冲区->位置短 == 缓冲区->大小 - 1) {
    失乐园_印刻_类型 *t;
    size_t 大小;

    大小 = 缓冲区->大小 * 3 / 2;
    t = (失乐园_印刻_类型*) realloc(缓冲区->串短, 大小 * sizeof(失乐园_印刻_类型));
    if(t == NULL) {
      return;
    }
    缓冲区->串短 = t;
    缓冲区->大小 = 大小;
  }
  
  缓冲区->串短[缓冲区->位置短++] = c;
  缓冲区->串短[缓冲区->位置短] = '\0';
}

int 失乐园_缓冲区_谓词等于(失乐园_缓冲区_类型* 缓冲区, const 失乐园_印刻_类型* 串短)
{
  return 缓冲区->位置短 == (uint32_t)串_长度(串短) &&
         memcmp(缓冲区->串短, 串短, 缓冲区->位置短 * sizeof(失乐园_印刻_类型)) == 0;
}

/*
 * 文件 ports
 */

struct 文件端口_私有 {
  FILE *f;
  失乐园_印刻_类型 印刻短;
  uint8_t 可关闭;
};

static int 文件端口_完成(失乐园_端口_类型 *自己)
{
  int 返回短;
  struct 文件端口_私有 *私有短;

  私有短 = (struct 文件端口_私有*)失乐园_端口(自己)->private;

  if(私有短->可关闭) {
    返回短 = fclose(私有短->f) == 0;
  } else {
    返回短 = 1;
  }
  free(私有短);

  return 返回短;
}

static int 文件端口_读_印刻_万国码编码8(失乐园_入端口_类型 *自己, 失乐园_印刻_类型 *c)
{
  FILE* f;
  uint8_t b1, b2[3];

  f = ((struct 文件端口_私有*)失乐园_端口(自己)->private)->f;
  if(fread(&b1, sizeof(uint8_t), 1, f) < 1) {
    if(feof(f)) {
      *c = 失乐园_通用字符集_文件终;
      return 1;
    } else {
      return 0;
    }
  }

  if(b1 >= 0xC0) {
    if(b1 < 0xE0) {
      if(fread(b2, sizeof(uint8_t), 1, f) < 1) {
        if(feof(f)) {
          *c = 失乐园_通用字符集_文件终;
          return 1;
        } else {
          return 0;
        }
      }
      if((b2[0] & 0xC0) == 0x80) {
        *c = ((b1 & 0x1F) << 6) | (b2[0] & 0x3F);
      } else {
        return 0;
      }
    } else if(b1 < 0xF0) {
      if(fread(b2, sizeof(uint8_t), 2, f) < 2) {
        if(feof(f)) {
          *c = 失乐园_通用字符集_文件终;
          return 1;
        } else {
          return 0;
        }
      }
      if(((b2[0] & 0xC0) == 0x80) && ((b2[1] & 0xC0) == 0x80)) {
        *c = ((b1 & 0x0F) << 12) |
             ((b2[0] & 0x3F) << 6) |
              (b2[1] & 0x3F);
      } else {
        return 0;
      }
    } else if(b1 <= 0xF4) {
      if(fread(b2, sizeof(uint8_t), 3, f) < 3) {
        if(feof(f)) {
          *c = 失乐园_通用字符集_文件终;
          return 1;
        } else {
          return 0;
        }
      }
      if(((b1 == 0xF4 && ((b2[0] & 0xF0) == 0x80)) ||
          ((b2[0] & 0xC0) == 0x80)) &&
          ((b2[1] & 0xC0) == 0x80) &&
          ((b2[2] & 0xC0) == 0x80)) {
        *c = ((b1 & 0x7) << 18) |
             ((b2[0] & 0x3F) << 12) |
             ((b2[1] & 0x3F) << 6) |
              (b2[2] & 0x3F);
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  } else if(b1 & 0x80) {
    return 0;
  } else {
    *c = (失乐园_印刻_类型)b1;
  }

  return 1;
}

static int 文件端口_读_印刻_万国码编码16(失乐园_入端口_类型 *自己, 失乐园_印刻_类型 *c)
{
  FILE* f;
  uint8_t *b1, *b2;
  失乐园_代码点2_类型 c1, c2;

  b1 = (uint8_t*)&c1;
  b2 = (uint8_t*)&c2;

  f = ((struct 文件端口_私有*)失乐园_端口(自己)->private)->f;
  if(fread(b1, sizeof(uint8_t), 2, f) < 2) {
    if(feof(f)) {
      *c = 失乐园_通用字符集_文件终;
      return 1;
    } else {
      return 0;
    }
  }

  if((c1 & 0xFC00) != 0xD800) {
    /* non-surrogate */
    *c = (失乐园_印刻_类型)c1;
  } else {
    if(fread(b2, sizeof(uint8_t), 2, f) < 2) {
      if(feof(f)) {
        *c = 失乐园_通用字符集_文件终;
        return 1;
      } else {
        return 0;
      }
    }

    if((c2 & 0xFC00) != 0xDC00) {
      /* broken surrogate 点对 */
      return 0;
    }

    *c = (((c1 & 0x3FF) << 10) | (c2 & 0x3FF)) + 0x10000;
  }

  return 1;
}

static int 文件端口_读_印刻_拉丁文1(失乐园_入端口_类型 *自己, 失乐园_印刻_类型 *c)
{
  FILE* f;
  uint8_t b;

  f = ((struct 文件端口_私有*)失乐园_端口(自己)->private)->f;
  if(fread(&b, sizeof(uint8_t), 1, f) < 1) {
    if(feof(f)) {
      *c = 失乐园_通用字符集_文件终;
      return 1;
    } else {
      return 0;
    }
  }

  *c = (失乐园_印刻_类型)b;

  return 1;
}

static int 文件端口_读_一次(失乐园_入端口_类型 *自己, 失乐园_印刻_类型 *c)
{
  switch(失乐园_端口(自己)->印刻_编码) {
  case 失乐园_印刻_编码_万国码编码8:
    return 文件端口_读_印刻_万国码编码8(自己, c);

  case 失乐园_印刻_编码_万国码编码16:
    return 文件端口_读_印刻_万国码编码16(自己, c);

  case 失乐园_印刻_编码_拉丁文1:
    return 文件端口_读_印刻_拉丁文1(自己, c);

  default:
    return 0;
  }
}

static int 文件端口_读_印刻(失乐园_入端口_类型 *自己, 失乐园_印刻_类型 *c)
{
  struct 文件端口_私有 *p = (struct 文件端口_私有*)失乐园_端口(自己)->private;

  if(p->印刻短 == 失乐园_通用字符集_不_印刻) {
    if(!文件端口_读_一次(自己, &p->印刻短)) {
      return 0;
    }
  }

  *c = p->印刻短;
  if(!文件端口_读_一次(自己, &p->印刻短)) {
    return 0;
  }

  return 1;
}

static int 文件端口_窥_印刻(失乐园_入端口_类型 *自己, 失乐园_印刻_类型 *c)
{
  struct 文件端口_私有 *p = (struct 文件端口_私有*)失乐园_端口(自己)->private;

  if(p->印刻短 == 失乐园_通用字符集_不_印刻) {
    if(!文件端口_读_一次(自己, &p->印刻短)) {
      return 0;
    }
  }

  *c = p->印刻短;

  return 1;
}

static int 文件端口_刷新(失乐园_出端口_类型 *p)
{
  return fflush(((struct 文件端口_私有*)失乐园_端口(p)->private)->f) == 0;
}

static int 文件端口_写_印刻(失乐园_出端口_类型 *p, 失乐园_印刻_类型 c)
{
  int 返回短;
  FILE *f;
  uint8_t sz, 缓冲短[4];

  switch(失乐园_端口(p)->印刻_编码) {
  case 失乐园_印刻_编码_万国码编码8:
    返回短 = 印刻到万国码编码8(c, 缓冲短, &sz);
    break;
  case 失乐园_印刻_编码_万国码编码16:
    返回短 = 印刻到万国码编码16(c, 缓冲短, &sz);
    break;
  case 失乐园_印刻_编码_拉丁文1:
    返回短 = 印刻到拉丁文1(c, 缓冲短, &sz);
    break;
  default:
    返回短 = 0;
    break;
  }

  if(返回短) {
    f = ((struct 文件端口_私有*)失乐园_端口(p)->private)->f;
    if(fwrite(缓冲短, sizeof(uint8_t), sz, f) < sz) {
      return 0;
    }
  }

  return 返回短;
}

/*
 * generic 端口 interface
 */

static 失乐园_印刻_类型 窥_印刻(失乐园_状态_类型* 大失, 失乐园_入端口_类型 *p)
{
  失乐园_印刻_类型 结果短;

  if(p->窥_印刻(p, &结果短)) {
    return 结果短;
  } else {
    失乐园_推_串(大失, "cannot peek char");
    return (失乐园_印刻_类型)失乐园_错误(大失, 1);
  }
}

static 失乐园_印刻_类型 读_印刻(失乐园_状态_类型* 大失, 失乐园_入端口_类型 *p)
{
  失乐园_印刻_类型 结果短;

  if(p->读_印刻(p, &结果短)) {
    return 结果短;
  } else {
    失乐园_推_串(大失, "cannot read char");
    return (失乐园_印刻_类型)失乐园_错误(大失, 1);
  }
}

static void 刷新(失乐园_状态_类型* 大失, 失乐园_出端口_类型 *p)
{
  if(!p->刷新(p)) {
    失乐园_推_串(大失, "cannot 刷新 端口");
    失乐园_错误(大失, 1);
  }
}

static void 写_印刻(失乐园_状态_类型* 大失, 失乐园_出端口_类型 *p, 失乐园_印刻_类型 c)
{
  if(!p->写_印刻(p, c)) {
    失乐园_推_串(大失, "cannot 写 char");
    失乐园_错误(大失, 1);
  }
}

/*
 * reader
 */

#define 窥_印刻_大(大失, o) (窥_印刻((大失), 失乐园_入端口((o)->值.小垃圾回收)))
#define 读_印刻_大(大失, o) (读_印刻((大失), 失乐园_入端口((o)->值.小垃圾回收)))

static void 读_串(失乐园_状态_类型* 大失, 失乐园_对象_类型* in, 失乐园_缓冲区_类型* 缓冲短)
{
  失乐园_印刻_类型 c;

  /* remove left 引号 */
  读_印刻_大(大失, in);
  
  c = 读_印刻_大(大失, in);
  失乐园_缓冲区_赋值(缓冲短, "");

  while(c != '"') {

    if(c == 失乐园_通用字符集_文件终) {
      失乐园_推_串(大失, "unterminated string");
      失乐园_错误(大失, 1);
    }

    if(c == '\\') {
      c = 读_印刻_大(大失, in);

      if(c == 失乐园_通用字符集_文件终) {
        失乐园_推_串(大失, "unterminated string");
        失乐园_错误(大失, 1);
      }

      switch(c) {
      case 'a':
        c = '\a';
        break;

      case 'b':
        c = '\b';
        break;

      case 't':
        c = '\t';
        break;

      case 'n':
        c = '\n';
        break;

      case 'v':
        c = '\v';
        break;

      case 'f':
        c = '\f';
        break;

      case 'r':
        c = '\r';
        break;
      }
    }

    失乐园_缓冲区_添加(缓冲短, c);
    c = 读_印刻_大(大失, in);
  };
}

static void 读_直到_分隔符(失乐园_状态_类型* 大失, 失乐园_对象_类型* in, 失乐园_缓冲区_类型* 缓冲短)
{
  失乐园_印刻_类型 c;

  失乐园_缓冲区_赋值(缓冲短, "");

  c = 窥_印刻_大(大失, in);
  while(!是否_空格(c) && c != 失乐园_通用字符集_文件终 && !是否_印刻_内_设置(c, 分隔符_设置)) {
    失乐园_缓冲区_添加(缓冲短, c);
    读_印刻_大(大失, in);
    c = 窥_印刻_大(大失, in);
  };
}

static int 数字_值(失乐园_印刻_类型 c, int 基础, uint8_t *值)
{
  int 返回短;
  uint8_t 计数甲;
  static const 失乐园_印刻_类型 数字复[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

  返回短 = 0;
  for(计数甲 = 0; 计数甲 < 基础; 计数甲++) {
    if(c == 数字复[计数甲]) {
      返回短 = 1;
      if(值) {
        *值 = 计数甲;
      }
      break;
    }
  }

  return 返回短;
}

static int 解析_数号(失乐园_缓冲区_类型 *缓冲短, 失乐园_对象_类型 *结果短)
{
  uint8_t 值短;
  失乐园_印刻_类型 *串短;
  uint32_t 表达式短;
  失乐园_固定整数_类型 返回短;
  int 计数甲, 计数乙, 基础, 是否_确切, 征兆;

  计数甲 = 0;
  征兆 = 1;
  基础 = -1;
  是否_确切 = -1;
  串短 = 缓冲短->串短;

  /* are there prefixes? */
  while(串短[计数甲] == '#') {
    ++计数甲;
    if(串短[计数甲] == 'i' || 串短[计数甲] == 'I') {
      if(是否_确切 != -1) {
	return 0;
      }
      是否_确切 = 0;
    } else if(串短[计数甲] == 'e' || 串短[计数甲] == 'E') {
      if(是否_确切 != -1) {
	return 0;
      }
      是否_确切 = 1;
    } else if(串短[计数甲] == 'b' || 串短[计数甲] == 'B') {
      if(基础 != -1) {
	return 0;
      }
      基础 = 2;
    } else if(串短[计数甲] == 'd' || 串短[计数甲] == 'D') {
      if(基础 != -1) {
	return 0;
      }
      基础 = 10;
    } else if(串短[计数甲] == 'o' || 串短[计数甲] == 'O') {
      if(基础 != -1) {
	return 0;
      }
      基础 = 8;
    } else if(串短[计数甲] == 'x' || 串短[计数甲] == 'X') {
      if(基础 != -1) {
	return 0;
      }
      基础 = 16;
    } else {
      return 0;
    }
    ++计数甲;
  }

  基础 = 基础 == -1 ? 10 : 基础;
  是否_确切 = 是否_确切 == -1 ? 1 : 是否_确切;

  /* 征兆 */
  if(串短[计数甲] == '+') {
    ++计数甲;
  } else if(串短[计数甲] == '-') {
    ++计数甲;
    征兆 = -1;
  }

  /* for now, just fixnums */
  返回短 = 0;
  表达式短 = 1;
  for(计数乙 = 缓冲短->位置短 - 1; 计数乙 >= 计数甲; 计数乙--) {
    if(!数字_值(缓冲短->串短[计数乙], 基础, &值短)) {
      return 0;
    }

    返回短 += 值短 * 表达式短;
    表达式短 *= 基础;
  }
  结果短->类型 = 失乐园_类型_固定整数;
  结果短->值.固定整数 = 返回短 * 征兆;

  return 1;
}

static int 读_牌(失乐园_状态_类型* 大失, 失乐园_对象_类型* in, 失乐园_缓冲区_类型 *缓冲短, 失乐园_对象_类型* 结果短)
{
  失乐园_印刻_类型 c;
  失乐园_垃圾回收对象_类型 *对象短;

  c = 窥_印刻_大(大失, in);
  while(是否_空格(c) || c == ';') {
    /* eating up whitespace and comments */
    while(是否_空格(c)) {
      读_印刻_大(大失, in);
      c = 窥_印刻_大(大失, in);
    }

    if(c == ';') {
      while(!是否_行_终(c)) {
	c = 读_印刻_大(大失, in);
      }
      c = 窥_印刻_大(大失, in);
    }
  }

  if(c == 失乐园_通用字符集_文件终) {
    读_印刻_大(大失, in);
    结果短->类型 = 失乐园_类型_文件终;
    return 失乐园_牌_文件终;
  }

  if(c == '(') {
    读_印刻_大(大失, in);
    return 失乐园_牌_左_小括号;
  }

  if(c == ')') {
    读_印刻_大(大失, in);
    return 失乐园_牌_右_小括号;
  }

  if(c == '\'') {
    读_印刻_大(大失, in);
    return 失乐园_牌_引号;
  }

  if(c == '`') {
    读_印刻_大(大失, in);
    return 失乐园_牌_反引号;
  }

  if(c == ',') {
    读_印刻_大(大失, in);
    c = 窥_印刻_大(大失, in);
    if(c == '@') {
      读_印刻_大(大失, in);
      return 失乐园_牌_逗号_在;
    } else {
      return 失乐园_牌_逗号;
    }
  }

  /* strings */
  if(c == '"') {
    读_串(大失, in, 缓冲短);
    对象短 = 失乐园_创建_串(大失, 缓冲短->串短, 缓冲短->位置短);
    结果短->类型 = 失乐园_类型_串;
    结果短->值.小垃圾回收 = 对象短;
    return 失乐园_牌_基准;
  }

  if(c == '#') {
    读_直到_分隔符(大失, in, 缓冲短);
    if(缓冲短->位置短 == 1 && 窥_印刻_大(大失, in) == '(') {
      读_印刻_大(大失, in);
      return 失乐园_牌_尖_小括号;
    } else if(缓冲短->位置短 == 2 &&
       (缓冲短->串短[1] == 'f' || 缓冲短->串短[1] == 'F')) {
      /* boolean false */
      结果短->类型 = 失乐园_类型_布尔;
      结果短->值.bool = 0;
    } else if(缓冲短->位置短 == 2 &&
              (缓冲短->串短[1] == 't' || 缓冲短->串短[1] == 'T')) {
      /* boolean true */
      结果短->类型 = 失乐园_类型_布尔;
      结果短->值.bool = 1;
    } else if(缓冲短->串短[1] == '\\') {
      /* character */
      结果短->类型 = 失乐园_类型_印刻;
      c = 窥_印刻_大(大失, in);
      if(缓冲短->位置短 == 2 && (是否_印刻_内_设置(c, 分隔符_设置) || 是否_空格(c))) {
        /* the character itself is a delimiter, must read it */
        读_印刻_大(大失, in);
        读_直到_分隔符(大失, in, 缓冲短);
        if(缓冲短->位置短 != 0) {
          失乐园_推_串(大失, "invalid character syntax");
          失乐园_错误(大失, 1);
        }
        结果短->值.印刻短 = c;
        return 失乐园_牌_基准;
      }
      if(失乐园_缓冲区_谓词等于(缓冲短, 空格_串)) {
	结果短->值.印刻短 = 失乐园_通用字符集_空格;
      } else if(失乐园_缓冲区_谓词等于(缓冲短, 新行_串)) {
	结果短->值.印刻短 = 失乐园_通用字符集_行_喂养;
      } else if(缓冲短->位置短 == 3) {
	结果短->值.印刻短 = 缓冲短->串短[2];
      } else {
        失乐园_推_串(大失, "invalid character syntax");
        失乐园_错误(大失, 1);
      }
    } else if(缓冲短->串短[1] == '#') {
      /* private symbols */
      对象短 = 失乐园_创建_串(大失, 缓冲短->串短, 缓冲短->位置短);
      *结果短 = 失乐园_创建_符号(大失, 失乐园_串(对象短));
    } else if(是否_印刻_内_设置(缓冲短->串短[1], 数号_设置)) {
      /* number */
      if(!解析_数号(缓冲短, 结果短)) {
        失乐园_推_串(大失, "cannot parse number");
        失乐园_错误(大失, 1);
      }
    } else {
      失乐园_推_串(大失, "unknown read syntax");
      失乐园_错误(大失, 1);
    }
    return 失乐园_牌_基准;
  }

  /* symbols */
  if(是否_印刻_内_设置(c, 加减句_开始_设置)) {
    读_直到_分隔符(大失, in, 缓冲短);
    if(缓冲短->串短[0] == '+' || 缓冲短->串短[0] == '-') {
      if(缓冲短->位置短 == 1) {
	对象短 = 失乐园_创建_串(大失, 缓冲短->串短, 缓冲短->位置短);
	*结果短 = 失乐园_创建_符号(大失, 失乐园_串(对象短));
      } else {
	/* number */
        if(!解析_数号(缓冲短, 结果短)) {
          失乐园_推_串(大失, "cannot parse number");
          失乐园_错误(大失, 1);
        }
      }
    } else if(缓冲短->位置短 == 1 && 缓冲短->串短[0] == '.') {
      return 失乐园_牌_句号;
    } else if(失乐园_缓冲区_谓词等于(缓冲短, 省略号_串)) {
      对象短 = 失乐园_创建_串(大失, 缓冲短->串短, 缓冲短->位置短);
      *结果短 = 失乐园_创建_符号(大失, 失乐园_串(对象短));
    } else {
      失乐园_推_串(大失, "unknown read syntax");
      失乐园_错误(大失, 1);
    }
    return 失乐园_牌_基准;
  }

  if(是否_印刻_内_设置(c, 符号_开始_设置) || isalpha(c)) {
    读_直到_分隔符(大失, in, 缓冲短);
    对象短 = 失乐园_创建_串(大失, 缓冲短->串短, 缓冲短->位置短);
    *结果短 = 失乐园_创建_符号(大失, 失乐园_串(对象短));
    return 失乐园_牌_基准;
  }

  if(数字_值(c, 10, NULL)) {
    /* 基础 10 number */
    读_直到_分隔符(大失, in, 缓冲短);
    if(!解析_数号(缓冲短, 结果短)) {
      失乐园_推_串(大失, "cannot parse number");
      失乐园_错误(大失, 1);
    }
    return 失乐园_牌_基准;
  }

  return 失乐园_牌_没有;
}

void 失乐园_入出_读_牌(失乐园_状态_类型 *大失, 失乐园_对象_类型 *p, 失乐园_对象_类型 *返回短)
{
  int 牌短;
  失乐园_缓冲区_类型 *缓冲短;
  失乐园_对象_类型 临时1, 临时2;

  缓冲短 = 失乐园_入出_创建_串缓冲区();

  牌短 = 读_牌(大失, p, 缓冲短, 返回短);
  switch(牌短) {
  case 失乐园_牌_文件终:
    返回短->类型 = 失乐园_类型_文件终;
    break;

  case 失乐园_牌_基准:
    临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "datum");
    临时2 = 失乐园_创建_符号(大失, 失乐园_串(临时1.值.小垃圾回收));
    临时1.类型 = 失乐园_类型_点对;
    临时1.值.小垃圾回收 = 失乐园_创建_点对(大失);
    失乐园_点对(临时1.值.小垃圾回收)->切头 = 临时2;
    失乐园_点对(临时1.值.小垃圾回收)->切尾 = *返回短;
    *返回短 = 临时1;
    break;

  case 失乐园_牌_句号:
    临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "dot");
    *返回短 = 失乐园_创建_符号(大失, 失乐园_串(临时1.值.小垃圾回收));
    break;

  case 失乐园_牌_左_小括号:
    临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "left-paren");
    *返回短 = 失乐园_创建_符号(大失, 失乐园_串(临时1.值.小垃圾回收));
    break;

  case 失乐园_牌_右_小括号:
    临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "right-paren");
    *返回短 = 失乐园_创建_符号(大失, 失乐园_串(临时1.值.小垃圾回收));
    break;

  case 失乐园_牌_尖_小括号:
    临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "sharp-paren");
    *返回短 = 失乐园_创建_符号(大失, 失乐园_串(临时1.值.小垃圾回收));
    break;

  case 失乐园_牌_引号:
  case 失乐园_牌_反引号:
  case 失乐园_牌_逗号:
  case 失乐园_牌_逗号_在:
    临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "macro");
    临时2 = 失乐园_创建_符号(大失, 失乐园_串(临时1.值.小垃圾回收));
    返回短->值.小垃圾回收 = 失乐园_创建_点对(大失);
    返回短->类型 = 失乐园_类型_点对;
    失乐园_点对(返回短->值.小垃圾回收)->切头 = 临时2;
    失乐园_点对(返回短->值.小垃圾回收)->切尾.类型 = 失乐园_类型_零;

    switch(牌短) {
    case 失乐园_牌_引号:
      临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "引号");
      break;

    case 失乐园_牌_反引号:
      临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "quasiquote");
      break;

    case 失乐园_牌_逗号:
      临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "unquote");
      break;

    case 失乐园_牌_逗号_在:
      临时1.值.小垃圾回收 = 失乐园_创建_串_来自_美信交标码(大失, "unquote-splicing");
    }

    临时2 = 失乐园_创建_符号(大失, 失乐园_串(临时1.值.小垃圾回收));
    失乐园_点对(返回短->值.小垃圾回收)->切尾 = 临时2;
    break;
  }

  失乐园_入出_摧毁_串缓冲区(缓冲短);
}

/*
 * writer
 */

#define 刷新大(大失,o) (刷新((大失), 失乐园_出端口((o)->值.小垃圾回收)))
#define 写_印刻_大(大失,o,c) (写_印刻((大失), 失乐园_出端口((o)->值.小垃圾回收), (c)))

static void 写_串(失乐园_状态_类型 *大失, 失乐园_串_类型* s, 失乐园_对象_类型 *端口, int 引号)
{
  uint32_t 计数甲;

  if(引号) {
    写_印刻_大(大失, 端口, '"');
  }

  for(计数甲 = 0; 计数甲 < s->大小; 计数甲++) {
    写_印刻_大(大失, 端口, s->印刻复[计数甲]);
  }

  if(引号) {
    写_印刻_大(大失, 端口, '"');
  }
}

static void 失乐园_入出_写_入(失乐园_状态_类型 *大失, 失乐园_对象_类型* 对象短, 失乐园_对象_类型 *端口, int 引号)
{
  uint32_t 计数甲;
  char 缓冲短[64];

  switch(对象短->类型) {

  case 失乐园_类型_文件终:
    失乐园_入出_写_印名_串(大失, "<#eof>", 端口);
    break;

  case 失乐园_类型_空:
    失乐园_入出_写_印名_串(大失, "<#void>", 端口);
    break;

  case 失乐园_类型_取消定义:
    失乐园_入出_写_印名_串(大失, "<#undef>", 端口);
    break;

  case 失乐园_类型_零:
    失乐园_入出_写_印名_串(大失, "()", 端口);
    break;

  case 失乐园_类型_布尔:
    写_印刻_大(大失, 端口, (失乐园_印刻_类型)'#');
    if(对象短->值.bool) {
      写_印刻_大(大失, 端口, (失乐园_印刻_类型)'t');
    } else {
      写_印刻_大(大失, 端口, (失乐园_印刻_类型)'f');
    }
    break;

  case 失乐园_类型_固定整数:
    snprintf(缓冲短, 64, "%ld", 对象短->值.固定整数);
    失乐园_入出_写_印名_串(大失, 缓冲短, 端口);
    break;

  case 失乐园_类型_印刻:
    if(引号) {
      写_印刻_大(大失, 端口, (失乐园_印刻_类型)'#');
      写_印刻_大(大失, 端口, (失乐园_印刻_类型)'\\');
    }

    写_印刻_大(大失, 端口, 对象短->值.印刻短);
    break;

  case 失乐园_类型_符号:
    写_串(大失, 对象短->值.符号->串短, 端口, 0);
    break;

  case 失乐园_类型_闭包:
    失乐园_入出_写_印名_串(大失, "<#closure>", 端口);
    break;

  case 失乐园_类型_点对: {
    失乐园_对象_类型 切尾;
    失乐园_垃圾回收对象_类型 *p = 对象短->值.小垃圾回收;

    写_印刻_大(大失, 端口, (失乐园_印刻_类型)'(');
    for(;;) {
    
      失乐园_入出_写(大失, &(失乐园_点对(p)->切头), 端口);

      切尾 = 失乐园_点对(p)->切尾;
      if(切尾.类型 == 失乐园_类型_零) {
        break;
      } else if(切尾.类型 != 失乐园_类型_点对) {
        失乐园_入出_写_印名_串(大失, " . ", 端口);
        失乐园_入出_写(大失, &切尾, 端口);
        break;
      } else {
        写_印刻_大(大失, 端口, (失乐园_印刻_类型)' ');
        p = 切尾.值.小垃圾回收;
      }
    }
    写_印刻_大(大失, 端口, (失乐园_印刻_类型)')');
  }
    break;

  case 失乐园_类型_继续短:
    snprintf(缓冲短, 64, "<#continuation %lu>", 失乐园_继续短(对象短->值.小垃圾回收)->大小);
    失乐园_入出_写_印名_串(大失, 缓冲短, 端口);
    break;

  case 失乐园_类型_盒子:
    失乐园_入出_写_印名_串(大失, "#&", 端口);
    失乐园_入出_写(大失, &(失乐园_盒子(对象短->值.小垃圾回收)->值), 端口);
    break;

  case 失乐园_类型_串:
    写_串(大失, 失乐园_串(对象短->值.小垃圾回收), 端口, 引号);
    break;

  case 失乐园_类型_向量:
    失乐园_入出_写_印名_串(大失, "#(", 端口);
    for(计数甲 = 0; 计数甲 < 失乐园_向量(对象短->值.小垃圾回收)->大小; 计数甲++) {
      if(计数甲 != 0) {
        写_印刻_大(大失, 端口, (失乐园_印刻_类型)' ');
      }
      失乐园_入出_写(大失, 失乐园_向量(对象短->值.小垃圾回收)->数据 + 计数甲, 端口);
    }
    失乐园_入出_写_印名_串(大失, ")", 端口);
    break;

  case 失乐园_类型_句法闭包:
    失乐园_入出_写_印名_串(大失, "<#syntactic closure>", 端口);
    break;

  case 失乐园_类型_输入_端口:
    失乐园_入出_写_印名_串(大失, "<#input 端口>", 端口);
    break;

  case 失乐园_类型_输出_端口:
    失乐园_入出_写_印名_串(大失, "<#output 端口>", 端口);
    break;

  default:
    失乐园_入出_写_印名_串(大失, "Unknown 类型!", 端口);
  }
}

uint8_t *失乐园_入出_到_拉丁文1(失乐园_状态_类型 *大失, 失乐园_串_类型 *串短)
{
  uint8_t *返回短;

  返回短 = 来自_串(串短, 失乐园_印刻_编码_拉丁文1);
  if(!返回短) {
    失乐园_推_串(大失, "错误 converting string to latin-1");
    失乐园_错误(大失, 1);
  }

  return 返回短;
}

失乐园_代码点1_类型 *失乐园_入出_到_万国码编码8(失乐园_状态_类型 *大失, 失乐园_串_类型 *串短)
{
  失乐园_代码点1_类型 *返回短;

  返回短 = 来自_串(串短, 失乐园_印刻_编码_万国码编码8);
  if(!返回短) {
    失乐园_推_串(大失, "错误 converting string to UTF-8");
    失乐园_错误(大失, 1);
  }

  return 返回短;
}

失乐园_代码点2_类型 *失乐园_入出_万国码编码16(失乐园_状态_类型 *大失, 失乐园_串_类型 *串短)
{
  失乐园_代码点2_类型 *返回短;

  返回短 = (失乐园_代码点2_类型*)来自_串(串短, 失乐园_印刻_编码_万国码编码16);
  if(!返回短) {
    失乐园_推_串(大失, "错误 converting string to UTF-16");
    失乐园_错误(大失, 1);
  }

  return 返回短;
}

失乐园_垃圾回收对象_类型 *失乐园_入出_创建_入文件端口(失乐园_状态_类型 *大失, FILE* 文件)
{
  失乐园_垃圾回收对象_类型 *端口;
  struct 文件端口_私有 *私有短;

  端口 = 失乐园_创建_入端口(大失);
  私有短 = (struct 文件端口_私有*)malloc(sizeof(struct 文件端口_私有));

  私有短->f = 文件;
  私有短->可关闭 = 1;
  私有短->印刻短 = 失乐园_通用字符集_不_印刻;
  失乐园_端口(端口)->private = 私有短;
  失乐园_端口(端口)->完成 = 文件端口_完成;
  失乐园_端口(端口)->类型 = 失乐园_类型_端口_文件;

  失乐园_入端口(端口)->窥_印刻 = 文件端口_窥_印刻;
  失乐园_入端口(端口)->读_印刻 = 文件端口_读_印刻;

  return 端口;
}

失乐园_垃圾回收对象_类型 *失乐园_入出_创建_出文件端口(失乐园_状态_类型 *大失, FILE* 文件)
{
  失乐园_垃圾回收对象_类型 *端口;
  struct 文件端口_私有 *私有短;

  端口 = 失乐园_创建_出端口(大失);
  私有短 = (struct 文件端口_私有*)malloc(sizeof(struct 文件端口_私有));

  私有短->f = 文件;
  私有短->可关闭 = 1;
  私有短->印刻短 = 失乐园_通用字符集_不_印刻;
  失乐园_端口(端口)->private = 私有短;
  失乐园_端口(端口)->完成 = 文件端口_完成;
  失乐园_端口(端口)->类型 = 失乐园_类型_端口_文件;

  失乐园_出端口(端口)->刷新 = 文件端口_刷新;
  失乐园_出端口(端口)->写_印刻 = 文件端口_写_印刻;

  return 端口;
}

失乐园_垃圾回收对象_类型 *失乐园_入出_创建_标准入(失乐园_状态_类型 *大失)
{
  失乐园_垃圾回收对象_类型 *端口;

  端口 = 失乐园_入出_创建_入文件端口(大失, stdin);
  ((struct 文件端口_私有*)失乐园_端口(端口)->private)->可关闭 = 0;

  return 端口;
}

失乐园_垃圾回收对象_类型 *失乐园_入出_创建_标准出(失乐园_状态_类型 *大失)
{
  失乐园_垃圾回收对象_类型 *端口;

  端口 = 失乐园_入出_创建_出文件端口(大失, stdout);
  ((struct 文件端口_私有*)失乐园_端口(端口)->private)->可关闭 = 0;

  return 端口;
}

失乐园_垃圾回收对象_类型 *失乐园_入出_创建_标准错(失乐园_状态_类型 *大失)
{
  失乐园_垃圾回收对象_类型 *端口;

  端口 = 失乐园_入出_创建_出文件端口(大失, stderr);
  ((struct 文件端口_私有*)失乐园_端口(端口)->private)->可关闭 = 0;

  return 端口;
}

失乐园_垃圾回收对象_类型 *失乐园_入出_打开_入文件(失乐园_状态_类型 *大失, 失乐园_对象_类型 *串短, uint8_t 印刻_编码)
{
  char *文件名;
  FILE *文件;

  文件名 = (char*)来自_串(失乐园_串(串短->值.小垃圾回收), 印刻_编码);
  if(!文件名) {
    失乐园_推_串(大失, "cannot convert 文件 名称");
    失乐园_错误(大失, 1);
  }

  文件 = fopen(文件名, "rb");
  if(!文件) {
    失乐园_推_串(大失, "cannot open input 文件: ");
    失乐园_推_串(大失, 文件名);
    free(文件名);
    失乐园_错误(大失, 2);
  }
  free(文件名);

  return 失乐园_入出_创建_入文件端口(大失, 文件);
}

失乐园_垃圾回收对象_类型 *失乐园_入出_打开_出文件(失乐园_状态_类型 *大失, 失乐园_对象_类型 *串短, uint8_t 印刻_编码)
{
  char *文件名;
  FILE *文件;

  文件名 = (char*)来自_串(失乐园_串(串短->值.小垃圾回收), 印刻_编码);
  if(!文件名) {
    失乐园_推_串(大失, "cannot convert 文件 名称");
    失乐园_错误(大失, 1);
  }

  文件 = fopen(文件名, "wb");
  if(!文件) {
    失乐园_推_串(大失, "cannot open output 文件: ");
    失乐园_推_串(大失, 文件名);
    free(文件名);
    失乐园_错误(大失, 2);
  }
  free(文件名);

  return 失乐园_入出_创建_出文件端口(大失, 文件);
}

void 失乐园_入出_关闭_入端口(失乐园_状态_类型 *大失, 失乐园_对象_类型 *端口)
{
  大失 = 大失;

  if(失乐园_端口(端口)->类型 == 失乐园_类型_端口_文件) {
    fclose(((struct 文件端口_私有*)失乐园_端口(端口)->private)->f);
  }
}

void 失乐园_入出_关闭_出端口(失乐园_状态_类型 *大失, 失乐园_对象_类型 *端口)
{
  大失 = 大失;

  if(失乐园_端口(端口)->类型 == 失乐园_类型_端口_文件) {
    fclose(((struct 文件端口_私有*)失乐园_端口(端口)->private)->f);
  }
}

void 失乐园_入出_写_印名_串(失乐园_状态_类型 *大失, const char* s, 失乐园_对象_类型 *端口)
{
  const char *p;

  for(p = s; *p; p++) {
    写_印刻_大(大失, 端口, (失乐园_印刻_类型)*p);
  }
  刷新大(大失, 端口);
}

void 失乐园_入出_写_符号(失乐园_状态_类型 *大失, 失乐园_符号_类型 *符号短, 失乐园_对象_类型 *端口)
{
  写_串(大失, 符号短->串短, 端口, 0);
  刷新大(大失, 端口);
}

/* TODO: create 'eol' parameter */
void 失乐园_入出_新行(失乐园_状态_类型 *大失, 失乐园_对象_类型 *端口)
{
#ifdef _WIN32
  写_印刻_大(大失, 端口, (失乐园_印刻_类型)'\r');
#endif
  写_印刻_大(大失, 端口, (失乐园_印刻_类型)'\n');

  刷新大(大失, 端口);
}

void 失乐园_入出_写(失乐园_状态_类型 *大失, 失乐园_对象_类型 *对象短, 失乐园_对象_类型 *端口)
{
  失乐园_入出_写_入(大失, 对象短, 端口, 1);
  刷新大(大失, 端口);
}

void 失乐园_入出_显示(失乐园_状态_类型 *大失, 失乐园_对象_类型 *对象短, 失乐园_对象_类型 *端口)
{
  失乐园_入出_写_入(大失, 对象短, 端口, 0);
  刷新大(大失, 端口);
}

