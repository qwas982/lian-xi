/*
 * The 失乐园方案 应用程序接口
 
 */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#ifdef 失乐园_调试_应程接
#include <assert.h>
#endif

#include "失乐园.h"

#include "入出.h"
#include "虚拟机.h"
#include "状态.h"

static int 谓词数号(失乐园_状态_类型* 大失, uint32_t 索引短)
{
  return 大失->栈[索引短].类型 == 失乐园_类型_固定整数;
}

static uint32_t 计算器_索引(失乐园_状态_类型* 大失, int 索引短)
{
  /*
   * TODO: better checking of index interval
   * permitted
   */

  if(索引短 < 0) {
    /* counting from the top */
    索引短 = 大失->栈指针 + 索引短;
  } else {
    /* 计数 from the frame pointer */
    索引短 += 大失->帧指针 + 1;
  }

#ifdef 失乐园_调试_应程接
  assert(索引短 > (int)大失->帧指针 && 索引短 < (int)大失->栈指针);
#endif

  return 索引短;
}

int 失乐园_错误(失乐园_状态_类型* 大失, uint32_t 数号短)
{
  int 计数甲;

#ifdef 失乐园_调试_应程接
  assert(数号短 < 大失->栈指针 - 大失->帧指针);
#endif

  失乐园_推_当前_错误_端口(大失);

  /* 错误 objects are on top of 栈 */
  失乐园_推_串(大失, "Error: ");
  失乐园_显示(大失, -1, -2);
  大失->栈指针--;
  for(计数甲 = -数号短-1; 计数甲 < -1; ++计数甲) {
    失乐园_显示(大失, 计数甲, -1);
  }
  失乐园_新行(大失, -1);
  大失->栈指针--;

  大失->栈指针 -= 数号短;
  失乐园_虚拟机_转储(大失);

  失乐园_关闭(大失);
  abort();

  /* execution never gets here */
  return 0;
}

int 失乐园_取_顶部(失乐园_状态_类型* 大失)
{
  /*
   * the current 栈 height only goes as down
   * as the 最后 frame pushed
   */
  return 大失->栈指针 - 大失->帧指针 - 1;
}

void 失乐园_弹(失乐园_状态_类型* 大失, uint32_t 数号短)
{
#ifdef 失乐园_调试_应程接
  assert(数号短 < 大失->栈指针 - 大失->帧指针);
#endif

  大失->栈指针 -= 数号短;
}

static int 检查_类型(失乐园_状态_类型* 大失, int 索引短, int 类型)
{
  索引短 = 计算器_索引(大失, 索引短);

  return 大失->栈[索引短].类型 == 类型;
}

int 失乐园_谓词盒子(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_盒子);
}

int 失乐园_谓词印刻(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_印刻);
}

int 失乐园_谓词整数(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_固定整数);
}

int 失乐园_谓词号码(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_固定整数);
}

int 失乐园_谓词点对(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_点对);
}

int 失乐园_谓词列表(失乐园_状态_类型* 大失, int 索引短)
{
  失乐园_垃圾回收对象_类型 *p;

  索引短 = 计算器_索引(大失, 索引短);

  if(大失->栈[索引短].类型 == 失乐园_类型_零) {
    return 1;
  }

  if(大失->栈[索引短].类型 != 失乐园_类型_点对) {
    return 0;
  }

  p = 大失->栈[索引短].值.小垃圾回收;
  for(;;) {
    失乐园_对象_类型 切尾;

    切尾 = 失乐园_点对(p)->切尾;
    if(切尾.类型 == 失乐园_类型_零) {
      return 1;
    } else if(切尾.类型 != 失乐园_类型_点对) {
      return 0;
    } else {
      p = 切尾.值.小垃圾回收;
    }
  }
}

int 失乐园_谓词串(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_串);
}

int 失乐园_谓词向量(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_向量);
}

int 失乐园_谓词过程(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_闭包);
}

int 失乐园_谓词文件终_对象(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_文件终);
}

int 失乐园_谓词输入_端口(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_输入_端口);
}

int 失乐园_谓词输出_端口(失乐园_状态_类型* 大失, int 索引短)
{
  return 检查_类型(大失, 索引短, 失乐园_类型_输出_端口);
}

void 失乐园_推_值(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

  大失->栈[大失->栈指针++] = 大失->栈[索引短];
}

void 失乐园_推_布尔(失乐园_状态_类型* 大失, int bool)
{
  大失->栈[大失->栈指针].类型 = 失乐园_类型_布尔;
  大失->栈[大失->栈指针++].值.bool = bool ? 1 : 0;
}

void 失乐园_推_印刻(失乐园_状态_类型* 大失, 失乐园_印刻_类型 c)
{
  大失->栈[大失->栈指针].类型 = 失乐园_类型_印刻;
  大失->栈[大失->栈指针++].值.印刻短 = c;
}

void 失乐园_推_整数(失乐园_状态_类型* 大失, 失乐园_固定整数_类型 数号短)
{
  大失->栈[大失->栈指针].类型 = 失乐园_类型_固定整数;
  大失->栈[大失->栈指针++].值.固定整数 = 数号短;
}

void 失乐园_推_c闭包(失乐园_状态_类型* 大失, 失乐园_c函数_类型 函数短, uint32_t 数号_变量)
{
  uint32_t 计数甲;
  失乐园_垃圾回收对象_类型 *cl;

  cl = 失乐园_创建_c闭包(大失, 函数短, 数号_变量);

  for(计数甲 = 0; 计数甲 < 数号_变量; 计数甲++) {
    失乐园_闭包(cl)->自由_变量[计数甲] = 大失->栈[大失->栈指针-计数甲-1];
  }
  大失->栈指针 -= 数号_变量;

  大失->栈[大失->栈指针].类型 = 失乐园_类型_闭包;
  大失->栈[大失->栈指针++].值.小垃圾回收 = cl;
}

void 失乐园_推_串(失乐园_状态_类型* 大失, const char* 串短)
{
  uint32_t 计数甲, 长度短;
  失乐园_垃圾回收对象_类型 *对象短;

  长度短 = strlen(串短);

  对象短 = 失乐园_创建_串(大失, NULL, 长度短);
  for(计数甲 = 0; 计数甲 < 长度短; 计数甲++) {
    失乐园_串(对象短)->印刻复[计数甲] = (失乐园_印刻_类型)串短[计数甲];
  }

  大失->栈[大失->栈指针].类型 = 失乐园_类型_串;
  大失->栈[大失->栈指针++].值.小垃圾回收 = 对象短;
}

void 失乐园_推_向量(失乐园_状态_类型* 大失, uint32_t 大小)
{
  失乐园_对象_类型 对象短;

  对象短.类型 = 失乐园_类型_向量;
  对象短.值.小垃圾回收 = 失乐园_创建_向量(大失, 大小);

  大失->栈[大失->栈指针++] = 对象短;
}

void 失乐园_取_全局(失乐园_状态_类型* 大失, const char *名称)
{
  int glob;
  失乐园_对象_类型 对象短;

  对象短 = 失乐园_创建_符号_来自_美信交标码(大失, 名称);

  glob = 失乐园_状态_取_全局_索引(大失, 对象短.值.符号);
  if(glob < 0) {
    栈短(大失->栈指针++).类型 = 失乐园_类型_零;
  } else {
    栈短(大失->栈指针++) = 大失->全局_环境.变量复[glob].值;
  }
}

失乐园_固定整数_类型 失乐园_到_整数(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(谓词数号(大失, 索引短));
#endif

  return 大失->栈[索引短].值.固定整数;
}

失乐园_印刻_类型* 失乐园_到_串(失乐园_状态_类型* 大失, int 索引短)
{
  uint32_t 大小;
  失乐园_印刻_类型 *返回短;
  失乐园_串_类型 *串短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif

  串短 = (失乐园_串_类型*)大失->栈[索引短].值.小垃圾回收;
  大小 = 串短->大小;
  返回短 = (失乐园_印刻_类型*)malloc((大小+1) * sizeof(失乐园_印刻_类型));
  if(!返回短) {
    失乐园_推_串(大失, "could not allocate memory");
    失乐园_错误(大失, 1);
  }

  返回短[大小] = '\0';
  memcpy(返回短, 串短->印刻复, 大小 * sizeof(失乐园_印刻_类型));

  return 返回短;
}

uint8_t* 失乐园_到_串_拉丁文1(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif
  
  return 失乐园_入出_到_拉丁文1(大失, 失乐园_串(大失->栈[索引短].值.小垃圾回收));
}

uint8_t* 失乐园_到_串_万国码编码8(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif

  return 失乐园_入出_到_万国码编码8(大失, 失乐园_串(大失->栈[索引短].值.小垃圾回收));
}

失乐园_代码点2_类型* 失乐园_到_串_万国码编码16(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif

  return 失乐园_入出_万国码编码16(大失, 失乐园_串(大失->栈[索引短].值.小垃圾回收));
}

int 失乐园_小于_(失乐园_状态_类型* 大失, int 索引1, int 索引2)
{
  索引1 = 计算器_索引(大失, 索引1);
  索引2 = 计算器_索引(大失, 索引2);

  return 大失->栈[索引1].值.固定整数 < 大失->栈[索引2].值.固定整数;
}

int 失乐园_大于_(失乐园_状态_类型* 大失, int 索引1, int 索引2)
{
  索引1 = 计算器_索引(大失, 索引1);
  索引2 = 计算器_索引(大失, 索引2);

  return 大失->栈[索引1].值.固定整数 > 大失->栈[索引2].值.固定整数;
}

void 失乐园_符号_到_串(失乐园_状态_类型* 大失, int 索引短)
{
  uint32_t 大小;
  失乐园_符号_类型 *符号短;
  失乐园_垃圾回收对象_类型 *串短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_符号);
#endif

  符号短 = 大失->栈[索引短].值.符号;
  大小 = 符号短->串短->大小;
  串短 = 失乐园_创建_串(大失, NULL, 大小);
  memcpy(失乐园_串(串短)->印刻复, 符号短->串短->印刻复, 大小 * sizeof(失乐园_印刻_类型));

  大失->栈[大失->栈指针].类型 = 失乐园_类型_串;
  大失->栈[大失->栈指针++].值.小垃圾回收 = 串短;
}

void 失乐园_串_到_符号(失乐园_状态_类型* 大失, int 索引短)
{
  失乐园_对象_类型 符号短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif

  符号短 = 失乐园_创建_符号(大失, 失乐园_串((大失->栈[索引短]).值.小垃圾回收));
  大失->栈[大失->栈指针++] = 符号短;
}

void 失乐园_颠倒(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(谓词数号(大失, 索引短));
#endif

  失乐园_推_整数(大失, 1);
}

void 失乐园_一元_减号(失乐园_状态_类型* 大失, int 索引短)
{
  失乐园_固定整数_类型 结果短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(谓词数号(大失, 索引短));
#endif

  结果短 = - 大失->栈[索引短].值.固定整数;
  失乐园_推_整数(大失, 结果短);
}

void 失乐园_加法(失乐园_状态_类型* 大失, uint32_t 数号_号码)
{
#ifdef 失乐园_调试_应程接
  assert(数号_号码 < 大失->栈指针 - 大失->帧指针);
#endif

  if(数号_号码 == 0) {
    失乐园_推_整数(大失, 0);
  } else if(数号_号码 == 1) {

#ifdef 失乐园_调试_应程接
    assert(谓词数号(大失, 大失->栈指针-1));
#endif

  } else {
    失乐园_固定整数_类型 结果短;
    uint32_t 计数甲, 第一, 最后;

    第一 = 计算器_索引(大失, -数号_号码);
    最后 = 计算器_索引(大失, -1);

    for(结果短 = 0, 计数甲 = 第一; 计数甲 <= 最后; 计数甲++) {

#ifdef 失乐园_调试_应程接
      assert(谓词数号(大失, 计数甲));
#endif

      结果短 += 大失->栈[计数甲].值.固定整数;
    }

    大失->栈指针 -= 数号_号码;
    大失->栈[大失->栈指针].类型 = 失乐园_类型_固定整数;
    大失->栈[大失->栈指针++].值.固定整数 = 结果短;
  }
}

void 失乐园_减法(失乐园_状态_类型* 大失, uint32_t 数号_号码)
{
#ifdef 失乐园_调试_应程接
  assert(数号_号码 < 大失->栈指针 - 大失->帧指针);
#endif

  if(数号_号码 == 1) {

#ifdef 失乐园_调试_应程接
    assert(谓词数号(大失, 大失->栈指针-1));
#endif

    大失->栈[大失->栈指针-1].值.固定整数 = -大失->栈[大失->栈指针-1].值.固定整数;
  } else {
    失乐园_固定整数_类型 结果短;
    uint32_t 计数甲, 第一, 最后;

    第一 = 计算器_索引(大失, -数号_号码);
    最后 = 计算器_索引(大失, -1);

#ifdef 失乐园_调试_应程接
    assert(谓词数号(大失, 第一));
#endif

    结果短 = 大失->栈[第一].值.固定整数;

    for(计数甲 = 第一 + 1; 计数甲 <= 最后; 计数甲++) {

#ifdef 失乐园_调试_应程接
      assert(谓词数号(大失, 计数甲));
#endif

      结果短 -= 大失->栈[计数甲].值.固定整数;
    }

    大失->栈指针 -= 数号_号码;
    大失->栈[大失->栈指针].类型 = 失乐园_类型_固定整数;
    大失->栈[大失->栈指针++].值.固定整数 = 结果短;
  }
}

void 失乐园_分号(失乐园_状态_类型* 大失, uint32_t 数号_号码)
{
#ifdef 失乐园_调试_应程接
  assert(数号_号码 < 大失->栈指针 - 大失->帧指针);
#endif

  if(数号_号码 == 1) {

#ifdef 失乐园_调试_应程接
    assert(谓词数号(大失, 大失->栈指针-1));
#endif

    大失->栈[大失->栈指针-1].值.固定整数 = 1;
  } else {
    失乐园_固定整数_类型 结果短;
    uint32_t 计数甲, 第一, 最后;

    第一 = 计算器_索引(大失, -数号_号码);
    最后 = 计算器_索引(大失, -1);

#ifdef 失乐园_调试_应程接
    assert(谓词数号(大失, 第一));
#endif

    结果短 = 大失->栈[第一].值.固定整数;

    for(计数甲 = 第一 + 1; 计数甲 <= 最后; 计数甲++) {

#ifdef 失乐园_调试_应程接
      assert(谓词数号(大失, 计数甲));
#endif

      结果短 /= 大失->栈[计数甲].值.固定整数;
    }

    大失->栈指针 -= 数号_号码;
    大失->栈[大失->栈指针].类型 = 失乐园_类型_固定整数;
    大失->栈[大失->栈指针++].值.固定整数 = 结果短;
  }
}

void 失乐园_环绕(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
    assert(谓词数号(大失, 索引短));
#endif

    大失->栈[大失->栈指针].类型 = 失乐园_类型_固定整数;
    大失->栈[大失->栈指针++].值.固定整数 = 大失->栈[索引短].值.固定整数;
}

void 失乐园_余数(失乐园_状态_类型* 大失, int 索引1, int 索引2)
{
  索引1 = 计算器_索引(大失, 索引1);
  索引2 = 计算器_索引(大失, 索引2);

#ifdef 失乐园_调试_应程接
  assert(谓词数号(大失, 索引1));
  assert(谓词数号(大失, 索引2));
#endif

  大失->栈[大失->栈指针].类型 = 失乐园_类型_固定整数;
  大失->栈[大失->栈指针++].值.固定整数 =
    大失->栈[索引1].值.固定整数 % 大失->栈[索引2].值.固定整数;
}

void 失乐园_数号_到_串(失乐园_状态_类型* 大失, int 索引短)
{
  char 临时短[64];
  uint32_t 计数甲, 长度短;
  失乐园_垃圾回收对象_类型 *串短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_固定整数);
#endif

  snprintf(临时短, 64, "%ld", 大失->栈[索引短].值.固定整数);
  长度短 = strlen(临时短);

  串短 = 失乐园_创建_串(大失, NULL, 长度短);
  for(计数甲 = 0; 计数甲 < 长度短; 计数甲++) {
    失乐园_串(串短)->印刻复[计数甲] = (失乐园_印刻_类型)临时短[计数甲];
  }

  大失->栈[大失->栈指针].类型 = 失乐园_类型_串;
  大失->栈[大失->栈指针++].值.小垃圾回收 = 串短;
}

void 失乐园_盒子_(失乐园_状态_类型* 大失)
{
  失乐园_垃圾回收对象_类型 *盒子;

  盒子 = 失乐园_创建_盒子(大失);
  失乐园_盒子(盒子)->值 = 栈短(大失->栈指针-1);

  /* replace top of 栈 with 盒子 */
  栈短(大失->栈指针-1).类型 = 失乐园_类型_盒子;
  垃圾回收栈(大失->栈指针-1) = 盒子;
}

void 失乐园_拆盒(失乐园_状态_类型* 大失)
{
  失乐园_对象_类型 对象短;

#ifdef 失乐园_调试_应程接
  assert(栈短(大失->栈指针-1).类型 == 失乐园_类型_盒子);
#endif

  对象短 = 失乐园_盒子(垃圾回收栈(大失->栈指针-1))->值;

  /* replace top of 栈 with 盒子 contents */
  栈短(大失->栈指针-1) = 对象短;
}

void 失乐园_设置_盒子(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(栈短(索引短).类型 == 失乐园_类型_盒子);
#endif

  失乐园_盒子(垃圾回收栈(索引短))->值 = 栈短(大失->栈指针-1);
  --大失->栈指针;
}

void 失乐园_构造(失乐园_状态_类型* 大失, int 索引1, int 索引2)
{
  失乐园_垃圾回收对象_类型 *点对;

  索引1 = 计算器_索引(大失, 索引1);
  索引1 = 计算器_索引(大失, 索引1);

  点对 = 失乐园_创建_点对(大失);
  失乐园_点对(点对)->切头 = 大失->栈[索引1];
  失乐园_点对(点对)->切尾 = 大失->栈[索引2];

  大失->栈[大失->栈指针].类型 = 失乐园_类型_点对;
  大失->栈[大失->栈指针++].值.小垃圾回收 = 点对;
}

void 失乐园_切头(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_点对);
#endif

  大失->栈[大失->栈指针++] = 失乐园_点对(大失->栈[索引短].值.小垃圾回收)->切头;
}

void 失乐园_切尾(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_点对);
#endif

  大失->栈[大失->栈指针++] = 失乐园_点对(大失->栈[索引短].值.小垃圾回收)->切尾;
}

uint32_t 失乐园_串_长度(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif

  return 失乐园_串(大失->栈[索引短].值.小垃圾回收)->大小;
}

失乐园_印刻_类型 失乐园_串_引用(失乐园_状态_类型* 大失, uint32_t 位置短, int 索引短)
{
  失乐园_垃圾回收对象_类型 *串短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif

  串短 = 大失->栈[索引短].值.小垃圾回收;

#ifdef 失乐园_调试_应程接
  assert(位置短 < 失乐园_串(串短)->大小);
#endif

  return 失乐园_串(串短)->印刻复[位置短];
}

void 失乐园_连接(失乐园_状态_类型* 大失, uint32_t 数号_串)
{
#ifdef 失乐园_调试_应程接
  assert(数号_串 < 大失->栈指针 - 大失->帧指针);
#endif

  if(数号_串 == 0) {
    失乐园_推_串(大失, "");
  } else {
    失乐园_垃圾回收对象_类型 *串短, *临时短;
    uint32_t 计数甲, 计数乙, 计数丙, 第一, 最后, 总共_大小 = 0;

    第一 = 计算器_索引(大失, -数号_串);
    最后 = 计算器_索引(大失, -1);

    for(计数甲 = 第一; 计数甲 <= 最后; 计数甲++) {

#ifdef 失乐园_调试_应程接
      assert(大失->栈[计数甲].类型 == 失乐园_类型_串);
#endif

      总共_大小 += 失乐园_串(大失->栈[计数甲].值.小垃圾回收)->大小;
    }

    串短 = 失乐园_创建_串(大失, NULL, 总共_大小);
    for(计数丙 = 0, 计数甲 = 第一; 计数甲 <= 最后; 计数甲++) {
      临时短 = 大失->栈[计数甲].值.小垃圾回收;
      for(计数乙 = 0; 计数乙 < 失乐园_串(临时短)->大小; 计数乙++) {
        失乐园_串(串短)->印刻复[计数丙++] = 失乐园_串(临时短)->印刻复[计数乙];
      }
    }

    大失->栈指针 -= 数号_串;
    大失->栈[大失->栈指针].类型 = 失乐园_类型_串;
    大失->栈[大失->栈指针++].值.小垃圾回收 = 串短;
  }
}

uint32_t 失乐园_向量_长度(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_向量);
#endif

  return 失乐园_向量(大失->栈[索引短].值.小垃圾回收)->大小;
}

void 失乐园_向量_引用(失乐园_状态_类型* 大失, uint32_t 位置短, int 索引短)
{
  失乐园_垃圾回收对象_类型 *向量短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_向量);
#endif

  向量短 = 大失->栈[索引短].值.小垃圾回收;

#ifdef 失乐园_调试_应程接
  assert(位置短 < 失乐园_向量(向量短)->大小);
#endif

  大失->栈[大失->栈指针++] = 失乐园_向量(向量短)->数据[位置短];
}

void 失乐园_向量_设置(失乐园_状态_类型* 大失, uint32_t 位置短, int 索引短)
{
  失乐园_垃圾回收对象_类型 *向量短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_向量);
#endif

  向量短 = 大失->栈[索引短].值.小垃圾回收;

#ifdef 失乐园_调试_应程接
  assert(位置短 < 失乐园_向量(向量短)->大小);
#endif

  失乐园_向量(向量短)->数据[位置短] = 大失->栈[--大失->栈指针];
}

void 失乐园_应用(失乐园_状态_类型* 大失, int 索引短, uint32_t 数号_实参)
{
  uint32_t 过程短;
  失乐园_对象_类型 p;

  过程短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(数号_实参 > 0);
  assert(数号_实参 < 大失->栈指针 - 大失->帧指针);
  assert(大失->栈[过程短].类型 == 失乐园_类型_闭包);
  assert(失乐园_谓词列表(大失, -1));
#endif

  /* add arguments from list */
  --数号_实参;
  for(p = 大失->栈[大失->栈指针-1], 大失->栈指针--; p.类型 == 失乐园_类型_点对; 数号_实参++) {
    大失->栈[大失->栈指针++] = 失乐园_点对(p.值.小垃圾回收)->切头;
    p = 失乐园_点对(p.值.小垃圾回收)->切尾;
  }

  失乐园_虚拟机_调用(大失, 大失->栈[过程短], 数号_实参);
  大失->栈[大失->栈指针++] = 大失->累加短;
}

void 失乐园_求值(失乐园_状态_类型 *大失, int 索引短)
{
  int 过程短;
  失乐园_垃圾回收对象_类型 *点对;

  索引短 = 计算器_索引(大失, 索引短);

  失乐园_取_全局(大失, "compile-toplevel");
  过程短 = 大失->栈指针 - 1;

  /* pushing argument */
  点对 = 失乐园_创建_点对(大失);
  失乐园_点对(点对)->切头 = 大失->栈[索引短];
  失乐园_点对(点对)->切尾.类型 = 失乐园_类型_零;

  大失->栈[大失->栈指针].类型 = 失乐园_类型_点对;
  大失->栈[大失->栈指针++].值.小垃圾回收 = 点对;

  /* the compiler is in Scheme land */
  失乐园_虚拟机_调用(大失, 栈短(过程短), 1);
  失乐园_虚拟机_载入(大失, 大失->累加短);

  /* put result over procedure */
  大失->栈[大失->栈指针-1] = 大失->累加短;
}

void 失乐园_调用(失乐园_状态_类型 *大失, uint32_t n_args)
{
  int 过程短;

  过程短 = 计算器_索引(大失, -n_args-1);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[过程短].类型 = 失乐园_类型_闭包);
#endif

  失乐园_虚拟机_调用(大失, 大失->栈[过程短], n_args);
  大失->栈[大失->栈指针++] = 大失->累加短;
}

void 失乐园_载入_文件(失乐园_状态_类型* 大失, int 索引短)
{
  int 索引2;
  失乐园_模块_类型 模块短;

  索引短 = 计算器_索引(大失, 索引短);
  索引2 = 计算器_索引(大失, -1);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 = 失乐园_类型_串);
#endif
 
  失乐园_取_全局(大失, "compile-from-端口");
  大失->栈[大失->栈指针++] = 大失->栈[索引短];
  失乐园_打开_输入_文件(大失);
  失乐园_调用(大失, 1);

  失乐园_虚拟机_向量_到_模块(大失->栈[大失->栈指针-1], &模块短);

  失乐园_虚拟机_链接_跑_模块(大失, &模块短);
  大失->栈指针 = ++索引2 + 1;
  大失->栈[索引2] = 大失->累加短;
}

void 失乐园_推_当前_输入_端口(失乐园_状态_类型 *大失)
{
  失乐园_取_全局(大失, "current-input-端口");
  失乐园_虚拟机_调用(大失, 栈短(大失->栈指针-1), 0);
  栈短(大失->栈指针-1) = 大失->累加短;
}

void 失乐园_推_当前_输出_端口(失乐园_状态_类型 *大失)
{
  失乐园_取_全局(大失, "current-output-端口");
  失乐园_虚拟机_调用(大失, 栈短(大失->栈指针-1), 0);
  栈短(大失->栈指针-1) = 大失->累加短;
}

void 失乐园_推_当前_错误_端口(失乐园_状态_类型 *大失)
{
  失乐园_取_全局(大失, "current-错误-端口");
  失乐园_虚拟机_调用(大失, 栈短(大失->栈指针-1), 0);
  栈短(大失->栈指针-1) = 大失->累加短;
}

void 失乐园_新行(失乐园_状态_类型* 大失, int 索引短)
{
  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_输出_端口);
#endif

  失乐园_入出_新行(大失, &大失->栈[索引短]);
  大失->累加短.类型 = 失乐园_类型_空;
}

void 失乐园_读(失乐园_状态_类型 *大失, int 索引短)
{
  int 过程短;

  索引短 = 计算器_索引(大失, 索引短);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_输入_端口);
#endif

  失乐园_取_全局(大失, "read");
  过程短 = 大失->栈指针 - 1;
  
  /* pushing 端口 */
  大失->栈[大失->栈指针++] = 大失->栈[索引短];

  /* the reader is in Scheme land */
  失乐园_虚拟机_调用(大失, 栈短(过程短), 1);

  /* put result over procedure */
  大失->栈[大失->栈指针-1] = 大失->累加短;
}

void 失乐园_写(失乐园_状态_类型* 大失, int 索引1, int 索引2)
{
  索引1 = 计算器_索引(大失, 索引1);
  索引2 = 计算器_索引(大失, 索引2);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引2].类型 == 失乐园_类型_输出_端口);
#endif

  失乐园_入出_写(大失, &大失->栈[索引1], &大失->栈[索引2]);
}

void 失乐园_显示(失乐园_状态_类型* 大失, int 索引1, int 索引2)
{
  索引1 = 计算器_索引(大失, 索引1);
  索引2 = 计算器_索引(大失, 索引2);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引2].类型 == 失乐园_类型_输出_端口);
#endif

  失乐园_入出_显示(大失, &大失->栈[索引1], &大失->栈[索引2]);
  大失->累加短.类型 = 失乐园_类型_空;
}

void 失乐园_打开_输入_文件(失乐园_状态_类型* 大失)
{
  int 索引短;
  失乐园_垃圾回收对象_类型 *端口;

  索引短 = 计算器_索引(大失, -1);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif

  端口 = 失乐园_入出_打开_入文件(大失, &大失->栈[索引短], 失乐园_印刻_编码_拉丁文1);

  大失->栈[索引短].类型 = 失乐园_类型_输入_端口;
  大失->栈[索引短].值.小垃圾回收 = 端口;
}

void 失乐园_打开_输出_文件(失乐园_状态_类型* 大失)
{
  int 索引短;
  失乐园_垃圾回收对象_类型 *端口;

  索引短 = 计算器_索引(大失, -1);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_串);
#endif

  端口 = 失乐园_入出_打开_出文件(大失, &大失->栈[索引短], 失乐园_印刻_编码_拉丁文1);

  大失->栈[索引短].类型 = 失乐园_类型_输出_端口;
  大失->栈[索引短].值.小垃圾回收 = 端口;
}

void 失乐园_关闭_输入_端口(失乐园_状态_类型* 大失)
{
  int 索引短 = 计算器_索引(大失, -1);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_输入_端口);
#endif

  失乐园_入出_关闭_入端口(大失, &大失->栈[索引短]);
  大失->栈指针--;
}

void 失乐园_关闭_输出_端口(失乐园_状态_类型* 大失)
{
  int 索引短 = 计算器_索引(大失, -1);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引短].类型 == 失乐园_类型_输出_端口);
#endif

  失乐园_入出_关闭_出端口(大失, &大失->栈[索引短]);
  大失->栈指针--;
}

void 失乐园_设置_全局(失乐园_状态_类型* 大失, const char* 名称)
{
  int 索引短;
  失乐园_对象_类型 符号短;

  符号短 = 失乐园_创建_符号_来自_美信交标码(大失, 名称);

  /* is the 全局 already there? */
  索引短 = 失乐园_状态_取_全局_索引(大失, 符号短.值.符号);
  if(索引短 > 0) {
    大失->全局_环境.变量复[索引短].值 = 大失->栈[--大失->栈指针];
  } else {
    索引短 = 大失->全局_环境.大小;
    失乐园_状态_扩大_全局(大失, 1);
    大失->全局_环境.变量复[索引短].符号 = 符号短.值.符号;
    大失->全局_环境.变量复[索引短].值 = 大失->栈[--大失->栈指针];
  }
}

void 失乐园_寄存器(失乐园_状态_类型* 大失, 失乐园_寄存_类型* 寄存复)
{
  int 计数甲;

  for(计数甲 = 0; 寄存复[计数甲].名称 != NULL; 计数甲++) {
    失乐园_推_c闭包(大失, 寄存复[计数甲].函数短, 0);
    失乐园_设置_全局(大失, 寄存复[计数甲].名称);
  }
}

void 失乐园_读求值印环(失乐园_状态_类型 *大失)
{
  int 索引1, 索引2;
  失乐园_对象_类型 *出;

  索引1 = 计算器_索引(大失, -2);
  索引2 = 计算器_索引(大失, -1);

#ifdef 失乐园_调试_应程接
  assert(大失->栈[索引1].类型 == 失乐园_类型_输入_端口);
  assert(大失->栈[索引2].类型 == 失乐园_类型_输出_端口);
#endif

  出 = &大失->栈[索引2];

  while(1) {
    失乐园_入出_写_印名_串(大失, "#;> ", 出);
    失乐园_读(大失, -2);

    if(失乐园_谓词文件终_对象(大失, -1)) {
      大失->栈指针--;
      break;
    }

    失乐园_求值(大失, -1);
    if(大失->栈[大失->栈指针-1].类型 != 失乐园_类型_空) {
      失乐园_写(大失, -1, -3);
      失乐园_新行(大失, -3);
    }
    大失->栈指针 -= 2;
  }

  /* removing ports */
  大失->栈指针 -= 2;
}
