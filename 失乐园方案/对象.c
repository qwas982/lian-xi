/*
 * The 失乐园方案系统
 
 */

#include <stdlib.h>
#include <string.h>

#include "失乐园.h"
#include "对象.h"
#include "状态.h"

static int 串_等于_问(失乐园_串_类型 *s1, 失乐园_串_类型 *s2)
{
  if(s1->大小 != s2->大小) {
    return 0;
  }

  return memcmp(s1->印刻复, s2->印刻复, s1->大小 * sizeof(失乐园_印刻_类型)) == 0;
}

static 失乐园_串_类型* 串_复制_外部(失乐园_串_类型* s)
{
  uint32_t 大小;
  失乐园_串_类型 *返回短;

  大小 = 失乐园_大小_的_串(s->大小);

  返回短 = (失乐园_串_类型*)malloc(大小);
  /* TODO: test and throw 错误 */
  memcpy(返回短, s, 大小);

  return 返回短;
}

失乐园_垃圾回收对象_类型 *失乐园_创建_盒子(失乐园_状态_类型 *大失)
{
  失乐园_盒子_类型 *返回短;

  返回短 = (失乐园_盒子_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_盒子);
  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_盒子;
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_失闭包(失乐园_状态_类型 *大失, uint32_t 进入, uint32_t 数号_变量)
{
  失乐园_闭包_类型 *返回短;

  返回短 = (失乐园_闭包_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_闭包(数号_变量));
  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_闭包;
    返回短->是否_小闭包 = 0;
    返回短->数号_自由 = 数号_变量;
    返回短->进入_点.scm = 进入;
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_c闭包(失乐园_状态_类型 *大失, 失乐园_c函数_类型 函数短, uint32_t 数号_变量)
{
  失乐园_闭包_类型 *返回短;

  返回短 = (失乐园_闭包_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_闭包(数号_变量));
  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_闭包;
    返回短->是否_小闭包 = 1;
    返回短->数号_自由 = 数号_变量;
    返回短->进入_点.c = 函数短;
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_点对(失乐园_状态_类型 *大失)
{
  失乐园_点对_类型 *返回短;

  返回短 = (失乐园_点对_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_点对);
  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_点对;
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_继续短(失乐园_状态_类型 *大失, uint32_t 栈_大小)
{
  失乐园_继续短_类型 *返回短;

  返回短 = (失乐园_继续短_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_继续短(栈_大小));
  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_继续短;
    返回短->大小 = 栈_大小;
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_串(失乐园_状态_类型 *大失, const 失乐园_印刻_类型* 串短, uint32_t 大小)
{
  失乐园_串_类型 *返回短;

  返回短 = (失乐园_串_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_串(大小));

  if(返回短) {
    uint32_t 计数甲;

    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_串;
    返回短->大小 = 大小;

    if(串短) {
      for(计数甲 = 0; 计数甲 < 大小; 计数甲++) {
	返回短->印刻复[计数甲] = 串短[计数甲];
      }
    } else {
      for(计数甲 = 0; 计数甲 < 大小; 计数甲++) {
	返回短->印刻复[计数甲] = (失乐园_印刻_类型)' ';
      }
    }
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_串_来自_美信交标码(失乐园_状态_类型 *大失, const char* 串短)
{
  int 长度短;
  失乐园_串_类型 *返回短;

  长度短 = strlen(串短);
  返回短 = (失乐园_串_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_串(长度短));

  if(返回短) {
    int 计数甲;

    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_串;
    返回短->大小 = 长度短;

    for(计数甲 = 0; 计数甲 < 长度短; 计数甲++) {
      返回短->印刻复[计数甲] = (失乐园_印刻_类型)串短[计数甲];
    }
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_向量(失乐园_状态_类型 *大失, uint32_t 大小)
{
  失乐园_向量_类型* 返回短;

  返回短 = (失乐园_向量_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_向量(大小));

  if(返回短) {
    uint32_t 计数甲;

    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_向量;
    返回短->大小 = 大小;

    for(计数甲 = 0; 计数甲 < 大小; 计数甲++) {
      返回短->数据[计数甲].类型 = 失乐园_类型_取消定义;
    }
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_动态_绑定(失乐园_状态_类型 *大失)
{
  失乐园_动态_绑定_类型 *返回短;

  返回短 = (失乐园_动态_绑定_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_动态_绑定);
  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_动态_绑定;
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_句法_闭包(失乐园_状态_类型 *大失)
{
  失乐园_句法_闭包_类型 *返回短;

  返回短 = (失乐园_句法_闭包_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_句法闭包);
  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_句法闭包;
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_入端口(失乐园_状态_类型 *大失)
{
  失乐园_入端口_类型* 返回短;

  返回短 = (失乐园_入端口_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_入端口);

  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_输入_端口;
    失乐园_端口(返回短)->印刻_编码 = 失乐园_印刻_编码_拉丁文1;
    失乐园_端口(返回短)->完成 = NULL;
    失乐园_端口(返回短)->private = NULL;

    /* register 端口 to be finalised when collected */
    失乐园_垃圾回收_添加_端口(&大失->储存, 失乐园_端口(返回短));
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_垃圾回收对象_类型 *失乐园_创建_出端口(失乐园_状态_类型 *大失)
{
  失乐园_出端口_类型* 返回短;

  返回短 = (失乐园_出端口_类型*)失乐园_垃圾回收_分配(&大失->储存, 失乐园_大小_的_出端口);

  if(返回短) {
    失乐园_垃圾回收对象(返回短)->类型 = 失乐园_类型_输出_端口;
    失乐园_端口(返回短)->印刻_编码 = 失乐园_印刻_编码_拉丁文1;
    失乐园_端口(返回短)->完成 = NULL;
    失乐园_端口(返回短)->private = NULL;

    /* register 端口 to be finalised when collected */
    失乐园_垃圾回收_添加_端口(&大失->储存, 失乐园_端口(返回短));
  }

  return 失乐园_垃圾回收对象(返回短);
}

失乐园_对象_类型 失乐园_创建_符号(失乐园_状态_类型* 大失, 失乐园_串_类型 *串短)
{
  失乐园_对象_类型 对象短;
  失乐园_符号_类型 *临时短;

  /* is the 符号 already there? */
  for(临时短 = 大失->符号_表; 临时短 != NULL; 临时短 = 临时短->下一个) {
    if(串_等于_问(临时短->串短, 串短)) {
      break;
    }
  }

  if(临时短 == NULL) {
    /* adding new 符号 */
    临时短 = (失乐园_符号_类型*)malloc(sizeof(失乐园_符号_类型));
    临时短->串短 = 串_复制_外部(串短);
    临时短->下一个 = 大失->符号_表;
    大失->符号_表 = 临时短;
  }

  对象短.类型 = 失乐园_类型_符号;
  对象短.值.符号 = 临时短;

  return 对象短;
}

失乐园_对象_类型 失乐园_创建_符号_来自_美信交标码(失乐园_状态_类型* 大失, const char* 名称)
{
  失乐园_垃圾回收对象_类型 *串短;

  串短 = 失乐园_创建_串_来自_美信交标码(大失, 名称);
  return 失乐园_创建_符号(大失, 失乐园_串(串短));
}
