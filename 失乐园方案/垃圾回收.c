/*
 * The 失乐园方案 垃圾回收
 
 */

#include "失乐园.h"

#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "垃圾回收.h"
#include "对象.h"

#ifdef 失乐园_动态跟踪
#include "失乐园_提供者.h"
#endif

/*
 * the 储存, i.e., memory
 */

#if defined(__LP64__) || defined(__LLP64__)
#define 字大小     8
#else
#define 字大小     4
#endif

#define 失乐园_初始_空间_大小     ((size_t)(1 << 7))
#define 失乐园_立即_问号(o)         ((o)->类型 < 失乐园_类型_闭包)
#define 失乐园_向前_标签            199

/* forward reference to object in to-space */
typedef struct 失乐园_向前_类型 失乐园_向前_类型;

struct 失乐园_向前_类型 {
  失乐园_垃圾回收对象_类型 基础;
  失乐园_垃圾回收对象_类型 *引用短;
};

static size_t 求大小_垃圾回收对象(失乐园_垃圾回收对象_类型* 对象短)
{
  size_t 大小;

  switch(对象短->类型) {
  case 失乐园_类型_闭包:
    大小 = 失乐园_大小_的_闭包(失乐园_闭包(对象短)->数号_自由);
    break;

  case 失乐园_类型_点对:
    大小 = 失乐园_大小_的_点对;
    break;

  case 失乐园_类型_继续短:
    大小 = 失乐园_大小_的_继续短(失乐园_继续短(对象短)->大小);
    break;

  case 失乐园_类型_盒子:
    大小 = 失乐园_大小_的_盒子;
    break;

  case 失乐园_类型_串:
    大小 = 失乐园_大小_的_串(失乐园_串(对象短)->大小);
    break;

  case 失乐园_类型_向量:
    大小 = 失乐园_大小_的_向量(失乐园_向量(对象短)->大小);
    break;

  case 失乐园_类型_动态_绑定:
    大小 = 失乐园_大小_的_动态_绑定;
    break;

  case 失乐园_类型_句法闭包:
    大小 = 失乐园_大小_的_句法闭包;
    break;

  case 失乐园_类型_输入_端口:
    大小 = 失乐园_大小_的_入端口;
    break;

  case 失乐园_类型_输出_端口:
    大小 = 失乐园_大小_的_出端口;
    break;

  default:
    abort();
  }

  return 大小;
}

static void 复制_对象(失乐园_储存_类型* 大失, 失乐园_对象_类型* 对象短)
{
  void *to;
  size_t 大小;

  if(失乐园_立即_问号(对象短)) {
    /* if not heap-allocated, bail */
    return;
  }

  if(对象短->值.小垃圾回收->类型 == 失乐园_向前_标签) {
    /* already copied, just update pointer */
    对象短->值.小垃圾回收 = ((失乐园_向前_类型*)对象短->值.小垃圾回收)->引用短;
    return;
  }

  /* actual copy */
  to = 大失->到_空间 + 大失->大小;
  大小 = 求大小_垃圾回收对象(对象短->值.小垃圾回收);
  memcpy(to, 对象短->值.小垃圾回收, 大小);
  大失->大小 += 大小;

  assert(大小 >= sizeof(失乐园_向前_类型));

  /* leave a forwarding pointer and update */
  对象短->值.小垃圾回收->类型 = 失乐园_向前_标签;
  ((失乐园_向前_类型*)对象短->值.小垃圾回收)->引用短 = to;
  对象短->值.小垃圾回收 = to;
}

static void 回收_向前对象(失乐园_储存_类型 *大失)
{
  失乐园_最终对象_类型 *向前对象, *上一个;

  for(上一个 = NULL, 向前对象 = 大失->最终对象复; 向前对象;) {
    if(向前对象->对象短->类型 == 失乐园_向前_标签) {
      向前对象->对象短 = ((失乐园_向前_类型*)向前对象->对象短)->引用短;
      上一个 = 向前对象;
      向前对象 = 向前对象->下一个;
    } else {
      失乐园_最终对象_类型 *临时短 = 向前对象->下一个;

      /* if object was not copied then it's dead */
      if(上一个) {
        上一个->下一个 = 临时短;
      } else {
        大失->最终对象复 = 临时短;
      }
      if(向前对象->对象短->类型 == 失乐园_类型_输入_端口 ||
         向前对象->对象短->类型 == 失乐园_类型_输出_端口) {
        失乐园_端口_类型 *端口;

        端口 = 失乐园_端口(向前对象->对象短);
        端口->完成(端口);
      }
      free(向前对象);
      向前对象 = 临时短;
    }
  }
}

static void 回收_垃圾(失乐园_储存_类型* 大失)
{
  /*
   * classic, simple 2-space copy collector
   * using Cheney's algorithm
   */
  void *扫描;
  失乐园_对象_类型 *对象短;

#ifdef 失乐园_动态跟踪
  size_t 旧_大小 = 大失->大小;
  失乐园_垃圾回收_开始();
#endif

  if(!大失->根_回调) {
    return;
  }

  大失->大小 = 0;

  /* copying roots */
  while((对象短 = 大失->根_回调(大失->根_回调_数据))) {
    复制_对象(大失, 对象短);
  }

  /* now 扫描 to-space */
  扫描 = 大失->到_空间;
  while(扫描 < 大失->到_空间 + 大失->大小) {
    uint32_t 计数甲;
    size_t 大小;
    失乐园_垃圾回收对象_类型 *垃圾回收对象;

    垃圾回收对象 = 失乐园_垃圾回收对象(扫描);
    大小 = 求大小_垃圾回收对象(垃圾回收对象);

    switch(垃圾回收对象->类型) {
    case 失乐园_类型_闭包:
      for(计数甲 = 0; 计数甲 < 失乐园_闭包(垃圾回收对象)->数号_自由; 计数甲++) {
	复制_对象(大失, &(失乐园_闭包(垃圾回收对象)->自由_变量[计数甲]));
      }
      break;

    case 失乐园_类型_点对:
      复制_对象(大失, &(失乐园_点对(垃圾回收对象)->切头));
      复制_对象(大失, &(失乐园_点对(垃圾回收对象)->切尾));
      break;

    case 失乐园_类型_继续短:
      for(计数甲 = 0; 计数甲 < 失乐园_继续短(垃圾回收对象)->大小; 计数甲++) {
	复制_对象(大失, &(失乐园_继续短(垃圾回收对象)->栈[计数甲]));
      }
      break;

    case 失乐园_类型_盒子:
      复制_对象(大失, &(失乐园_盒子(垃圾回收对象)->值));
      break;

    case 失乐园_类型_向量:
      for(计数甲 = 0; 计数甲 < 失乐园_向量(垃圾回收对象)->大小; 计数甲++) {
	复制_对象(大失, &(失乐园_向量(垃圾回收对象)->数据[计数甲]));
      }
      break;

    case 失乐园_类型_动态_绑定:
      复制_对象(大失, &(失乐园_动态_绑定(垃圾回收对象)->标签));
      复制_对象(大失, &(失乐园_动态_绑定(垃圾回收对象)->值));
      break;

    case 失乐园_类型_句法闭包:
      复制_对象(大失, &(失乐园_句法闭包(垃圾回收对象)->环境短));
      复制_对象(大失, &(失乐园_句法闭包(垃圾回收对象)->自由_));
      复制_对象(大失, &(失乐园_句法闭包(垃圾回收对象)->表达式短));
      break;
    }

    扫描 += 大小;
  }

  /* swap spaces */
  扫描 = 大失->来自_空间;
  大失->来自_空间 = 大失->到_空间;
  大失->到_空间 = 扫描;

  /* process objects that need finalisation */
  回收_向前对象(大失);

#ifdef 失乐园_动态跟踪
  if(失乐园_垃圾回收_终_启用()) {
    失乐园_垃圾回收_终(旧_大小, 大失->大小);
  }
#endif
}

static int 扩展_储存(失乐园_储存_类型* 大失)
{
  void *临时短;
  size_t 旧_大小, 大小;

  旧_大小 = 大失->容量;

  /* new 大小 is 30% larger, word aligned */
  大小 = 旧_大小 * 4 / 3;
  大小 -= 大小 % 字大小;

#ifdef 失乐园_动态跟踪
  if(失乐园_垃圾回收_重设大小_启用()) {
    失乐园_垃圾回收_重设大小(旧_大小, 大小);
  }
#endif

  临时短 = malloc(大小 * 2);
  if(临时短 == NULL) {
    return 0;
  } else {
    大失->容量 = 大小;

    /* copy objects to new memory */
    大失->到_空间 = 临时短;
    回收_垃圾(大失);

    /* fix pointers */
    大失->到_空间 = 临时短 + 大小;
    free(大失->操系_地址);
    大失->操系_地址 = 临时短;
    return 1;
  }
}

int 失乐园_垃圾回收_初始(失乐园_储存_类型 *大失, 失乐园_根_回调_类型 小回调, void* 小用户数据)
{
  /* alloc heap */
  大失->来自_空间 = malloc(失乐园_初始_空间_大小 * 2);
  if(大失->来自_空间 == NULL) {
    return 0;
  }

  大失->大小 = 0;
  大失->操系_地址 = 大失->来自_空间;
  大失->容量 = 失乐园_初始_空间_大小;
  大失->到_空间 = 大失->来自_空间 + (失乐园_初始_空间_大小);

  大失->最终对象复 = NULL;

  大失->根_回调 = 小回调;
  大失->根_回调_数据 = 小用户数据;

  return 1;
}

void 失乐园_垃圾回收_完成(失乐园_储存_类型 *大失)
{
  失乐园_最终对象_类型 *向前对象;

  for(向前对象 = 大失->最终对象复; 向前对象;) {
    失乐园_最终对象_类型 *t;

    t = 向前对象->下一个;
    if(向前对象->对象短->类型 == 失乐园_类型_输入_端口 ||
       向前对象->对象短->类型 == 失乐园_类型_输出_端口) {
      失乐园_端口_类型 *端口;

      端口 = 失乐园_端口(向前对象->对象短);
      端口->完成(端口);
    }
    free(向前对象);
    向前对象 = t;
  }

  free(大失->操系_地址);
  大失->大小 = 大失->容量 = 0;
  大失->来自_空间 = 大失->到_空间 = NULL;
  大失->根_回调 = 大失->根_回调_数据 = NULL;
}

void* 失乐园_垃圾回收_分配(失乐园_储存_类型 *大失, size_t 大小)
{
  void *返回短;

  /* allocating only word-multiple sized blocks */
  assert(大小 % 字大小 == 0);

#ifdef 失乐园_动态跟踪
  if(失乐园_垃圾回收_分配_启用()) {
    失乐园_垃圾回收_分配(大小);
  }
#endif

  if(大失->容量 - 大失->大小 < 大小) {
    /* not enough space, try to find some */
    回收_垃圾(大失);

    while(大失->容量 - 大失->大小 < 大小) {
      /* expand 储存 until it fits */
      if(扩展_储存(大失) == 0) {
	return NULL;
      }
    }
  }

  /* allocs from the from space */
  返回短 = 大失->来自_空间 + 大失->大小;
  大失->大小 += 大小;

  /* returned address must be word aligned */
  assert((uintptr_t)返回短 % 字大小 == 0);

  return 返回短;
}

void 失乐园_垃圾回收_添加_端口(失乐园_储存_类型 *大失, 失乐园_端口_类型 *端口)
{
  失乐园_最终对象_类型 *链接;

  if(!端口) {
    return;
  }

  链接 = (失乐园_最终对象_类型*)malloc(sizeof(失乐园_最终对象_类型));
  if(!链接) {
    return;
  }

  链接->下一个 = 大失->最终对象复;
  链接->对象短 = 失乐园_垃圾回收对象(端口);

  大失->最终对象复 = 链接;
}
