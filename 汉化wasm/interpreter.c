#include "interpreter.h"
#include "module.h"
#include "操作代码.h"
#include "utils.h"
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

// 控制块（包含函数）被调用前，将关联的栈帧压入到调用栈顶，成为当前栈帧，
// 同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
void 推_块(网汇模块 *m, 控制块 *框对应块, int 栈指针) {
    /* 1. 压入调用栈顶 */

    // 因新的栈帧要压入调用栈顶成为当前栈帧，所以调用栈指针（保存处在调用栈顶的栈帧索引）要加 1
    m->调用栈指针 += 1;

    /* 2. 关联控制块 */

    // 将 参数 框对应块 设置为 当前栈帧关联的控制块
    m->调用栈[m->调用栈指针].框对应块 = 框对应块;

    /* 3. 保存 栈指针 */

    // 将该栈帧被压入操作数栈顶前的【操作数栈顶指针】保存到 frame->栈指针 中，
    // 以便后续当前栈帧关联的控制块执行完成，当前栈帧弹出后，恢复压栈前的【操作数栈顶指针】
    m->调用栈[m->调用栈指针].栈指针 = 栈指针;

    /* 4. 保存 框指针 */

    // 将该栈帧被压入操作数栈顶前的【当前栈帧的操作数栈底指针】保存到 frame>框指针 中，
    // 以便后续该栈帧关联的控制块执行完成，该栈帧弹出后，恢复压栈前的【当前栈帧的操作数栈底指针】
    m->调用栈[m->调用栈指针].框指针 = m->框指针;

    /* 5. 保存 返回地址 */

    // 将该栈帧被压入操作数栈顶前的【下一条即将执行的指令的地址】保存到 frame>返回地址 中，
    // 以便后续该栈帧关联的函数执行完后，返回到调用该函数的地方继续执行后面的指令
    m->调用栈[m->调用栈指针].返回地址 = m->程序计数器;
}

// 当前控制块（包含函数）执行结束后，将关联的当前栈帧从调用栈顶中弹出，
// 同时恢复该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
控制块 *弹_块(网汇模块 *m) {
    /* 1. 弹出调用栈顶 */

    // 从调用栈顶中弹出当前栈帧，同时调用栈指针减 1
    栈里的框 *frame = &m->调用栈[m->调用栈指针--];

    /* 2. 校验控制块的返回值类型 */

    // 获取控制帧对应控制块（包含函数）的签名（即控制块的返回值的数量和类型）
    签名类型 *t = frame->框对应块->类型;
    // 背景知识：目前多返回值提案还没有进入 Wasm 标准，根据当前版本的 Wasm 标准，控制块不能有参数，且最多只能有一个返回值
    // 如果控制块的返回值数量为 1，也就是有一个返回值时，需要对返回值类型进行校验
    if (t->结果_计数 == 1) {
        // 获取当前栈帧的操作数栈顶值，也就是控制块（包含函数）的返回值，
        // 判断其类型和【控制块签名中的返回值类型】是否一致，如果不一致则记录异常信息
        if (m->栈[m->栈指针].值_类型 != t->结果们[0]) {
            sprintf(异常, "call 类型 mismatch");
            return NULL;
        }
    }

    /* 3. 恢复 栈指针 */

    // 因为该栈帧弹出，所以需要恢复该栈帧被压入调用栈前的【操作数栈顶指针】
    // 注：frame->栈指针 保存的是该栈帧被压入调用栈前的【操作数栈顶指针】
    if (t->结果_计数 == 1) {
        // 背景知识：目前多返回值提案还没有进入 Wasm 标准，根据当前版本的 Wasm 标准，控制块不能有参数，且最多只能有一个返回值
        // 如果控制块有一个返回值，则这个返回值需要压入到恢复后的操作数栈顶，即恢复后的操作数栈长度需要加 1
        // 所以恢复的【操作数栈顶指针值】是 该栈帧被压入调用栈前的【操作数栈顶指针】再加 1
        if (frame->栈指针 < m->栈指针) {
            m->栈[frame->栈指针 + 1] = m->栈[m->栈指针];
            m->栈指针 = frame->栈指针 + 1;
        }
    } else {
        // 如果控制块没有返回值，则直接恢复该栈帧被压入调用栈前的【操作数栈顶指针】即可
        if (frame->栈指针 < m->栈指针) {
            m->栈指针 = frame->栈指针;
        }
    }

    /* 4. 恢复 框指针 */

    // 因为该栈帧弹出，所以需要恢复该栈帧被压入调用栈前的【当前栈帧的操作数栈底指针】
    // 注：frame->框指针 保存的是该栈帧被压入调用栈前的【当前栈帧的操作数栈底指针】
    m->框指针 = frame->框指针;

    /* 5. 恢复 返回地址 */

    // 当控制块类型为函数时，在函数执行完成该栈帧弹出时，需要返回到该函数调用指令的下一条指令继续执行
    if (frame->框对应块->块_类型 == 0x00) {
        // 将函数返回地址赋给程序计数器 程序计数器（记录下一条即将执行的指令的地址）
        m->程序计数器 = frame->返回地址;
    }

    return frame->框对应块;
}

// 调用函数前的设置，主要设置内容如下：
// 1. 将当前函数关联的栈帧压入到调用栈顶成为当前栈帧，同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
// 2. 将当前函数的局部变量压入到操作数栈顶（默认初始值为 0）
// 3. 将函数的字节码部分的【起始地址】设置为 程序计数器（即下一条待执行指令的地址），即开始执行函数字节码中的指令流
void 设置_调用(网汇模块 *m, uint32_t 函索引) {
    // 根据索引 函索引 从 m->函数们 中获取当前函数
    控制块 *func = &m->函数们[函索引];

    // 获取函数签名
    签名类型 *类型 = func->类型;
    // 将当前函数关联的栈帧压入到调用栈顶，成为当前栈帧，同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
    // 注：第三个参数操作数栈顶指针减去函数参数个数的原因如下：
    // 调用该函数的父函数的栈帧的操作数栈，和该函数的栈帧的操作数栈，是相邻的，且有一部分数据是重叠的，
    // 这部分数据就是子函数的参数，这样就起到了父函数将参数传递给子函数的作用，所以目前操作数栈顶会有 类型->形参_计数 个参数
    // 真实的操作数栈顶位置应该去除掉子函数参数个数，因为当子函数执行完成后，操作数栈上的参数应该要被消耗掉，
    // 所以真实的操作数栈顶指针应该是 m->栈指针 - (int)类型->形参_计数
    // 推_块 函数的第三个参数的 栈指针 本意就是栈帧压入调用栈时的真实操作数栈顶，待后面函数执行完栈帧弹出时，恢复 推_块 中缓存的真实操作数栈顶
    推_块(m, func, m->栈指针 - (int) 类型->形参_计数);

    // 设置当前栈帧的操作数栈底指针 框指针，减去函数参数个数的原因同上，也是为了从父函数传递参数给子函数
    m->框指针 = m->栈指针 - (int) 类型->形参_计数 + 1;

    // 将当前函数的局部变量压入到操作数栈顶（默认初始值为 0）
    for (uint32_t lidx = 0; lidx < func->本地_计数; lidx++) {
        m->栈指针 += 1;
        m->栈[m->栈指针].值_类型 = func->本地们[lidx];
        m->栈[m->栈指针].值.无符整64位 = 0;
    }

    // 将函数的字节码部分的【起始地址】设置为 m->程序计数器（即下一条待执行指令的地址）
    m->程序计数器 = func->起始_地址;
}

// 虚拟机执行字节码中的指令流
bool 解释(网汇模块 *m) {
    const uint8_t *字节们 = m->字节们;// Wasm 二进制内容
    栈值 *栈 = m->栈;   // 操作数栈
    uint8_t 操作代码;                 // 操作码
    uint32_t 当前_程序计数器;                // 当前的程序计数器（即下一条即将执行的指令的地址）
    控制块 *框对应块;                   // 控制块
    uint8_t 值_类型;             // 控制块返回值的类型（根据当前版本的 Wasm 标准，控制块不能有参数，且最多只能有一个返回值）
    uint32_t 条件;                  // 保存在操作数栈顶的判断条件的值
    uint32_t 深度;                 // 跳转指令的目标标签索引
    uint32_t 函索引;                  // 函数索引
    uint32_t 索引乎;                   // 变量索引
    uint8_t *maddr;                 // 实际内存地址指针
    uint32_t 地址;                  // 用于计算相对内存地址
    uint32_t 偏移;                // 内存偏移量
    uint32_t a, b, c;               // 用于 整32 数值计算
    uint64_t d, e, f;               // 用于 整64 数值计算
    float g, h, i;                  // 用于 浮32 数值计算
    double j, k, l;                 // 用于 浮64 数值计算

    while (m->程序计数器 < m->字节_计数) {
        操作代码 = 字节们[m->程序计数器];// 读取指令中的操作码
        当前_程序计数器 = m->程序计数器;       // 保存程序计数器的值（即下一条即将执行的指令的地址）
        m->程序计数器 += 1;           // 程序计数器加 1，即指向下一条指令

        switch (操作代码) {
            /*
             * 控制指令--其他指令（2 条）
             * */
            case 不可达:
                // 指令作用：引发运行时错误
                // 当执行 不可达 操作码时，则记录异常信息并返回 false 退出虚拟机执行
                sprintf(异常, "%s", "unreachable");
                return false;
            case 无操作:
                // 指令作用：什么都不做
                // 注：无操作 即 No Operation 缩写
                continue;

            /*
             * 控制指令--结构化控制指令（3 条）
             * */
            case 块指令:
            case 环:
                // 指令作用：将当前控制块（框对应块 或 loop 类型）关联的栈帧压入到调用栈顶，成为当前栈帧

                // 该指令的立即数为控制块的返回值类型（占 1 个字节）
                // TODO: 暂时不需要控制块的返回值类型，故暂时忽略
                值_类型 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);
                (void) 值_类型;

                // 如果调用栈溢出，则记录异常信息并返回 false 退出虚拟机执行
                if (m->调用栈指针 >= 调用栈_大小) {
                    sprintf(异常, "call 栈 exhausted");
                    return false;
                }

                // 在 块_查找 中根据 环/块指令 操作码的地址查找对应的控制块
                // 注：块_查找 索引就是控制块的起始地址，而控制块就是以 块指令/环/若 操作码为开头
                框对应块 = m->块_查找[当前_程序计数器];

                // 控制块（包含函数）被调用前，将【待调用的控制块（包含函数）关联的栈帧】压入到调用栈顶，成为当前栈帧，
                // 同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
                推_块(m, 框对应块, m->栈指针);
                continue;
            case 若:
                // 指令作用：将当前控制块（if 类型）关联的栈帧压入到调用栈顶，成为当前栈帧

                // 该指令的立即数为控制块的返回值类型（占 1 个字节）
                // TODO: 暂时不需要控制块的返回值类型，故暂时忽略
                值_类型 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);
                (void) 值_类型;

                // 如果调用栈溢出，则记录异常信息并返回 false 退出虚拟机执行
                if (m->调用栈指针 >= 调用栈_大小) {
                    sprintf(异常, "call 栈 exhausted");
                    return false;
                }

                // 在 块_查找 中根据 若 操作码的地址查找对应的控制块
                // 注：块_查找 索引就是控制块的起始地址，而控制块就是以 块指令/环/若 操作码为开头
                框对应块 = m->块_查找[当前_程序计数器];

                // 控制块（包含函数）被调用前，将【待调用的控制块（包含函数）关联的栈帧】压入到调用栈顶，成为当前栈帧，
                // 同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
                推_块(m, 框对应块, m->栈指针);

                // 从操作数栈顶获取判断条件的值
                // 注：在调用 若 指令时，操作数栈顶保存的就是判断条件的值
                条件 = 栈[m->栈指针--].值.无符整32位;
                // 如果判断条件为 false，则将程序计数器 程序计数器 设置为 else 控制块首地址或 if 控制块结尾地址，
                // 即跳过 if 分支的代码对应的指令，执行后面的指令
                if (条件 == 0) {
                    if (框对应块->否则_地址 == 0) {
                        // 如果不存在 else 分支，则跳转到 if 控制块结尾的下一条指令继续执行
                        m->程序计数器 = 框对应块->分支_地址 + 1;
                        // 在上面的 推_块 函数中 if 控制块对应的栈帧已经被压入到调用栈且调用栈顶索引 调用栈指针 加 1，
                        // 此时不需要执行 if 控制块的指令，所以调用栈顶索引需要减 1
                        m->调用栈指针 -= 1;
                    } else {
                        // 如果存在 else 分支，则执行 else 分支代码对应的字节码的起始指令，也是 否则指令 指令的下一条指令
                        m->程序计数器 = 框对应块->否则_地址;
                    }
                }
                continue;

            /*
             * 控制指令--伪指令（2 条）
             * 注：否则指令 和 End 指令只起分隔作用，故称为伪指令
             * */
            case 否则指令:
                // 指令作用：跳转到控制块的结尾指令继续执行

                // 获取当前栈帧对应的控制块
                框对应块 = m->调用栈[m->调用栈指针].框对应块;
                // 跳转到控制块的结尾指令继续执行
                // 注：当上一个分支对应的指令流执行完成后，会执行到 否则指令 指令，则需要跳过 否则指令 指令后面的 else 分支对应的指令流，
                // 直接执行控制块的结尾指令，可以看出 否则指令 指令起到了分隔多个分支对应的指令流的作用
                m->程序计数器 = 框对应块->分支_地址;
                continue;
            case 终指令:
                // 指令作用：控制块执行结束后，将关联的当前栈帧从调用栈顶中弹出，并根据具体情况决定是否退出虚拟机的执行

                // 当前控制块（包含函数）执行结束后，将关联的当前栈帧从调用栈顶中弹出，
                // 同时恢复该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
                框对应块 = 弹_块(m);

                // 如果 弹_块 函数返回 NULL，则说明有异常（具体逻辑可查看 弹_块 函数），
                // 则直接返回 false 退出虚拟机执行
                if (框对应块 == NULL) {
                    return false;
                }

                if (框对应块->块_类型 == 0x00) {
                    // 1. 当控制块类型为函数时，且调用栈为空（即 调用栈指针 为 -1），说明已经执行完顶层的控制块，
                    // 则直接返回 true 退出虚拟机执行，否则继续执行下一条指令
                    if (m->调用栈指针 == -1) {
                        return true;
                    }
                } else if (框对应块->块_类型 == 0x01) {
                    // 2. 当控制块类型为初始化表达式时，说明只有一层控制块调用，则直接返回 true 退出虚拟机执行即可
                    return true;
                }
                // 3. 当控制块的块类型为 框对应块/loop/if，则继续执行下一条指令
                continue;

            /*
             * 控制指令--跳转指令（4 条）
             * */
            case 分支:
                // 指令作用：跳转到目标控制块的跳转地址继续执行后面的指令

                // 该指令的立即数表示跳转的目标标签索引（占 4 个字节）
                // 另外该目标标签索引是相对的，例如为 0 表示该指令所在的控制块定义的跳转标签，
                // 为 1 表示往外一层控制块定义的跳转标签，
                // 为 2 表示再往外一层控制块定义的跳转标签，以此类推
                深度 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);
                // 将目标控制块关联的栈帧设置为当前栈帧
                m->调用栈指针 -= (int) 深度;
                // 跳转到目标控制块的跳转地址继续执行后面的指令
                m->程序计数器 = m->调用栈[m->调用栈指针].框对应块->分支_地址;
                continue;
            case 若分支:
                // 指令作用：根据判断条件决定是否跳转到目标控制块的跳转地址继续执行后面的指令

                // 该指令的立即数表示跳转的目标标签索引（占 4 个字节）
                // 另外该目标标签索引是相对的，例如为 0 表示该指令所在的控制块定义的跳转标签，
                // 为 1 表示往外一层控制块定义的跳转标签，
                // 为 2 表示再往外一层控制块定义的跳转标签，以此类推
                深度 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);
                // 将操作数栈顶值弹出，作为判断条件
                条件 = 栈[m->栈指针--].值.无符整32位;
                // 如果为真则跳转，否则不跳转
                if (条件) {
                    // 将目标控制块关联的栈帧设置为当前栈帧
                    m->调用栈指针 -= (int) 深度;
                    // 跳转到目标控制块的跳转地址继续执行后面的指令
                    m->程序计数器 = m->调用栈[m->调用栈指针].框对应块->分支_地址;
                }
                continue;
            case 分支表: {
                // 指令作用：根据运行时具体情况决定跳转到哪个目标控制块的跳转地址继续执行后面的指令

                // 该指令的立即数给定了 n+1 个跳转目标标签索引
                // 其中前 n 个目标标签索引构成一个索引表，后一个标签索引为默认索引
                // 最终跳转到哪一个目标标签索引，需要在运行期间才能决定

                // 该指令执行时，先从操作数栈顶弹出一个 整数32 类型的值 m，
                // 如果 m 小于 n，则跳转到索引表第 m 个索引指向的目标标签处，
                // 否则跳转到默认索引指定的标签处

                // 读取目标标签索引的数量，也就是索引表的大小
                uint32_t 计数 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 如果索引表超出了规定的最大值，则记录异常信息并直接返回 false 退出虚拟机执行
                if (计数 > 分支_表_大小) {
                    sprintf(异常, "分支_表 大小 %d exceeds max %d\n", 计数, 分支_表_大小);
                    return false;
                }

                // 构造索引表
                for (uint32_t n = 0; n < 计数; n++) {
                    m->分支_表[n] = 读_基于小端_无符号(字节们, &m->程序计数器, 32);
                }

                // 读取默认索引
                深度 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 从操作数栈顶弹出一个 整数32 类型的值 m
                int32_t didx = 栈[m->栈指针--].值.整型32位;
                // 如果 m 小于索引表大小 n，则跳转到索引表第 m 个索引指向的目标标签处，
                // 否则跳转到默认索引指定的标签处
                if (didx >= 0 && didx < (int32_t) 计数) {
                    深度 = m->分支_表[didx];
                }

                // 将目标控制块关联的栈帧设置为当前栈帧
                m->调用栈指针 -= (int) 深度;
                // 跳转到目标控制块的跳转地址继续执行后面的指令
                m->程序计数器 = m->调用栈[m->调用栈指针].框对应块->分支_地址;
                continue;
            }
            case 返回:
                // 指令作用：直接跳出最外层控制块，最终效果是函数返回

                // 循环向外层控制块跳转，直到跳转到当前函数对应的控制块（也就是循环条件中判断是否是函数类型的代码块）
                while (m->调用栈指针 >= 0 && m->调用栈[m->调用栈指针].框对应块->块_类型 != 0x00) {
                    m->调用栈指针--;
                }
                // 直接跳到当前函数对应的控制块结尾处，即 终指令 指令处并执行该指令
                // 对应的当前栈帧弹出调用栈和退出虚拟机执行 是在 终指令 指令执行逻辑中
                m->程序计数器 = m->调用栈[m->调用栈指针].框对应块->终_地址;
                continue;

            /*
             * 控制指令----函数调用指令（2 条）
             * */
            case 调用:
                // 指令作用：调用指定函数
                // 注：调用 指令要调用的函数是在编译期确定的，也就是说被调用函数的索引硬编码在 call 指令的立即数中

                // 读取该指令的立即数，也就是被调用函数的索引（占 4 个字节）
                函索引 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 如果函数索引值小于 m->导入_函_计数，则说明该函数为外部函数
                // 原因：在解析 Wasm 二进制文件内容时，首先解析导入段中的函数到 m->函数们，然后再解析函数段中的函数到 m->函数们
                if (函索引 < m->导入_函_计数) {
                    // TODO: 暂时忽略调用外部引入函数情况
                } else {
                    // 如果调用栈溢出，则记录异常信息并返回 false 退出虚拟机执行
                    if (m->调用栈指针 >= 调用栈_大小) {
                        sprintf(异常, "call 栈 exhausted");
                        return false;
                    }

                    // 调用函数前的设置，主要设置内容如下：
                    // 1. 将当前函数关联的栈帧压入到调用栈顶成为当前栈帧，同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
                    // 2. 将当前函数的局部变量压入到操作数栈顶（默认初始值为 0）
                    // 3. 将函数的字节码部分的【起始地址】设置为 程序计数器（即下一条待执行指令的地址），即开始执行函数字节码中的指令流
                    设置_调用(m, 函索引);
                }
                continue;
            case 直接调用: {
                // 指令作用：根据运行期间操作数栈顶的值调用指定函数
                // 注：在编译期只能确定被调用函数的类型（call_indirect 指令的立即数里存放的是被调用函数的类型索引），
                // 具体调用哪个函数只有在运行期间根据操作数栈顶的值才能确定

                // 第一个立即数表示被调用函数的类型索引（占 4 个字节）
                uint32_t tidx = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 第二个立即数为保留立即数（占 1 个比特位）
                读_基于小端_无符号(字节们, &m->程序计数器, 1);

                // 操作数栈顶保存的值是【函数索引值】在表 表 中的索引
                uint32_t 值也 = 栈[m->栈指针--].值.无符整32位;
                // 如果该值大于或等于表 表 的最大值，则记录异常信息并返回 false 退出虚拟机执行
                if (值也 >= m->表.最大_大小) {
                    sprintf(异常, "undefined element 0x%x (max: 0x%x) in 表", 值也, m->表.最大_大小);
                    return false;
                }

                // 从表 表 中读取【函数索引值】
                函索引 = m->表.条目们[值也];

                // 如果函数索引值小于 m->导入_函_计数，则说明该函数为外部函数
                // 原因：在解析 Wasm 二进制文件内容到内存时，是先解析导入段中的函数到 m->函数们，然后再解析函数段中的函数到 m->函数们
                if (函索引 < m->导入_函_计数) {
                    // TODO: 暂时忽略调用外部引入函数情况
                } else {
                    // 通过函数索引获取到函数
                    控制块 *func = &m->函数们[函索引];
                    // 获取函数签名
                    签名类型 *ftype = func->类型;

                    // 如果调用栈溢出，则记录异常信息并返回 false 退出虚拟机执行
                    if (m->调用栈指针 >= 调用栈_大小) {
                        sprintf(异常, "call 栈 exhausted");
                        return false;
                    }

                    // 如果【实际函数类型】和【指令立即数中对应的函数类型】不相同，
                    // 则记录异常信息并返回 false 退出虚拟机执行
                    if (ftype->面罩 != m->类型们[tidx].面罩) {
                        sprintf(异常, "indirect call 类型 mismatch (call 类型 and 函数之 类型 differ)");
                        return false;
                    }

                    // 调用函数前的设置，主要设置内容如下：
                    // 1. 将当前函数关联的栈帧压入到调用栈顶成为当前栈帧，同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
                    // 2. 将当前函数的局部变量压入到操作数栈顶（默认初始值为 0）
                    // 3. 将函数的字节码部分的【起始地址】设置为 程序计数器（即下一条待执行指令的地址），即开始执行函数字节码中的指令流
                    设置_调用(m, 函索引);

                    // 由于 设置_调用 函数中会将函数参数和局部变量压入操作数栈，
                    // 所以可以校验【函数签名中声明的参数数量 + 函数局部变量数量】和【压入操作数栈的函数参数和局部变量总数】是否相等，
                    // 如果不相等则记录异常信息并返回 false 退出虚拟机执行
                    if (ftype->形参_计数 + func->本地_计数 != m->栈指针 - m->框指针 + 1) {
                        sprintf(异常, "indirect call 类型 mismatch (param counts differ)");
                        return false;
                    }

                    // 由于 设置_调用 函数中会将函数参数和局部变量压入操作数栈，
                    // 所以可以遍历【压入操作数栈的函数参数】的值，校验其类型和【函数签名中声明的参数类型】是否相等，
                    // 如果不相等则记录异常信息并返回 false 退出虚拟机执行
                    for (uint32_t n = 0; n < ftype->形参_计数; n++) {
                        if (ftype->形参们[n] != m->栈[m->框指针 + n].值_类型) {
                            sprintf(异常, "indirect call 类型 mismatch (param 类型们 differ)");
                            return false;
                        }
                    }
                }
                continue;
            }

            /*
             * 参数指令（2 条）
             * */
            case 落下:
                // 指令作用：丢弃操作数栈顶值
                m->栈指针--;
                continue;
            case 选择:
                // 指令作用：从栈顶弹出 3 个操作数，根据最先弹出的操作数从其他两个操作数中选择一个压栈
                // 如果为 true，则则将最后弹出的操作数压栈；如果为 false，则将中间弹出的操作数压栈。
                // 注：最先弹出的操作数必须是 整数32 类型，其他 2 个操作数数相同类型就可以

                // 最先弹出的操作数必须是 整数32 类型，否则报错
                断言(栈[m->栈指针].值_类型 == 整32, "The 类型 of operand 栈 顶部 值 need to be 整数32 when call select instruction \n")
                // 先从操作数栈弹出一个值作为判断条件
                条件 = 栈[m->栈指针--].值.无符整32位;

                // 先将次栈顶设置为栈顶，
                // 如果判断条件为 true，则将最后弹出的操作数压栈，
                // 最后弹出的操作数也就是当前的次栈顶的值，已经将其设置为栈顶值，所以后面无需再做任何操作
                m->栈指针--;

                // 如果判断条件为 false，则将中间弹出的操作数压栈，
                // 中间弹出的操作数压栈也就是 m->栈指针-- 之前的栈顶值，
                // 所以用 m->栈指针-- 之前的栈顶值覆盖掉  m->栈指针-- 之后的栈顶值即可
                if (!条件) {
                    栈[m->栈指针] = 栈[m->栈指针 + 1];
                }
                continue;

            /*
             * 变量指令--局部变量指令（3 条）
             * 指令作用：读写函数的参数和局部变量
             *
             * 注：每个函数关联的栈帧拥有一段操作数栈（多个函数栈帧共享同一个大的操作数栈），
             * 该函数栈帧的操作数栈的开头就存储局部变量，
             * 所以可以通过【函数栈帧的操作数栈底】加上【局部变量索引】来定位到该局部变量，即 m->框指针 + 索引乎
             * */
            case 本地获取:
                // 指令作用：将指定局部变量压入到操作数栈顶

                // 该指令的立即数为局部变量的索引
                索引乎 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 将指定局部变量的值压入到操作数栈顶
                栈[++m->栈指针] = 栈[m->框指针 + 索引乎];
                continue;
            case LocalSet:
                // 指令作用：将操作数栈顶的值弹出并保存到指定局部变量中

                // 该指令的立即数为局部变量的索引
                索引乎 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 弹出操作数栈顶的值，将其保存到指定局部变量中
                栈[m->框指针 + 索引乎] = 栈[m->栈指针--];
                continue;
            case LocalTee:
                // 指令作用：将操作数栈顶值保存到指定局部变量中，但不弹出栈顶值

                // 该指令的立即数为局部变量的索引
                索引乎 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 弹出操作数栈顶的值，将其保存到指定局部变量中（注意：不弹出栈顶值）
                栈[m->框指针 + 索引乎] = 栈[m->栈指针];
                continue;

            /*
             * 变量指令--全局变量指令（2 条）
             * 指令作用：读写全局变量
             * */
            case 全局获取:
                // 指令作用：将指定全局变量压入到操作数栈顶

                // 该指令的立即数为全局变量的索引
                索引乎 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 将指定局部变量的值压入到操作数栈顶
                栈[++m->栈指针] = m->全局们[索引乎];
                continue;
            case GlobalSet:
                // 指令作用：操作数栈顶的值弹出并保存到指定全局变量中

                // 该指令的立即数为全局变量的索引
                索引乎 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 弹出操作数栈顶的值，将其保存到指定全局变量中
                m->全局们[索引乎] = 栈[m->栈指针--];
                continue;

            /*
             * 内存指令--内存加载指令（14 条）
             * 指令作用：从内存中加载数据，转换为适当类型的值，再压入操作数栈顶
             * */
            case I32Load ... I64Load32U:
                // 内存加载和存储指令都带有两个立即数：1.对齐方式 2.内存偏移量

                // 第一个立即数表示对齐方式
                // 保存的是以 2 为底，对齐字节数的对数，占 4 个字节
                // 例如 0 表示一字节（2^0）对齐，1 表示两字节（2^1）对齐，2 表示四字节（2^2）对齐
                // 对齐方式只起提示作用，目的是帮助 JIT/AOT 编译器生成更优化的机器代码，对实际执行结果没有任何影响，暂时忽略
                读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 第二个立即数表示内存偏移量
                // 从操作数栈顶弹出一个 整数32 类型的数，和内存偏移量 偏移 相加，就可以得到实际内存相对地址
                // 注：操作数栈顶弹出的数和内存偏移量都是 32 位无符号整数，所以 Wasm 实际拥有 33 比特的地址空间
                偏移 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);
                // 从操作数栈顶弹出一个 整数32 类型的数（用于获取实际内存地址）
                地址 = 栈[m->栈指针--].值.无符整32位;

                // 获取实际内存地址
                maddr = m->记忆.字节们 + 偏移 + 地址;

                // TODO: 忽略校验 偏移/地址/maddr 值的合法性

                // 将 0 作为初始值压入操作数栈顶
                栈[++m->栈指针].值.无符整64位 = 0;

                // 根据具体指令将实际内存地址里保存的数值拷贝到操作数栈顶
                switch (操作代码) {
                    case I32Load:
                        // 从内存拷贝 4 个字节数到操作数栈顶（栈顶类型为 32 位整数）
                        memcpy(&栈[m->栈指针].值, maddr, 4);
                        栈[m->栈指针].值_类型 = 整32;
                        break;

                    case I64Load:
                        // 从内存拷贝 8 个字节数到操作数栈顶（栈顶类型为 64 位整数）
                        memcpy(&栈[m->栈指针].值, maddr, 8);
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case F32Load:
                        // 从内存拷贝 4 个字节数到操作数栈顶（栈顶类型为 32 位浮点数）
                        memcpy(&栈[m->栈指针].值, maddr, 4);
                        栈[m->栈指针].值_类型 = 浮32;
                        break;
                    case F64Load:
                        // 从内存拷贝 8 个字节数到操作数栈顶（栈顶类型为 64 位浮点数）
                        memcpy(&栈[m->栈指针].值, maddr, 8);
                        栈[m->栈指针].值_类型 = 浮64;
                        break;
                    case I32Load8S:
                        // 从内存拷贝 1 个字节有符号数到操作数栈顶（栈顶类型为 32 位整数）
                        memcpy(&栈[m->栈指针].值, maddr, 1);
                        符号扩展_8_32(&栈[m->栈指针].值.无符整32位);
                        栈[m->栈指针].值_类型 = 整32;
                        break;
                    case I32Load8U:
                        // 从内存拷贝 1 个字节无符号数到操作数栈顶（栈顶类型为 32 位整数）
                        // 因为是无符号数，在转换为更大的数据类型时，只需简单地在开头添加 0 占位，无需特殊转换
                        memcpy(&栈[m->栈指针].值, maddr, 1);
                        栈[m->栈指针].值_类型 = 整32;
                        break;
                    case I32Load16S:
                        // 从内存拷贝 2 个字节有符号数到操作数栈顶（栈顶类型为 32 位整数）
                        memcpy(&栈[m->栈指针].值, maddr, 2);
                        符号扩展_16_32(&栈[m->栈指针].值.无符整32位);
                        栈[m->栈指针].值_类型 = 整32;
                        break;
                    case I32Load16U:
                        // 从内存拷贝 2 个字节无符号数到操作数栈顶（栈顶类型为 32 位整数）
                        // 因为是无符号数，在转换为更大的数据类型时，只需简单地在开头添加 0 占位，无需特殊转换
                        memcpy(&栈[m->栈指针].值, maddr, 2);
                        栈[m->栈指针].值_类型 = 整32;
                        break;
                    case I64Load8S:
                        // 从内存拷贝 1 个字节有符号数到操作数栈顶（栈顶类型为 64 位整数）
                        memcpy(&栈[m->栈指针].值, maddr, 1);
                        符号扩展_8_64(&栈[m->栈指针].值.无符整64位);
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case I64Load8U:
                        // 从内存拷贝 1 个字节无符号数到操作数栈顶（栈顶类型为 64 位整数）
                        // 因为是无符号数，在转换为更大的数据类型时，只需简单地在开头添加 0 占位，无需特殊转换
                        memcpy(&栈[m->栈指针].值, maddr, 1);
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case I64Load16S:
                        // 从内存拷贝 2 个字节有符号数到操作数栈顶（栈顶类型为 64 位整数）
                        memcpy(&栈[m->栈指针].值, maddr, 2);
                        符号扩展_16_64(&栈[m->栈指针].值.无符整64位);
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case I64Load16U:
                        // 从内存拷贝 2 个字节无符号数到操作数栈顶（栈顶类型为 64 位整数）
                        // 因为是无符号数，在转换为更大的数据类型时，只需简单地在开头添加 0 占位，无需特殊转换
                        memcpy(&栈[m->栈指针].值, maddr, 2);
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case I64Load32S:
                        // 从内存拷贝 4 个字节有符号数到操作数栈顶（栈顶类型为 64 位整数）
                        memcpy(&栈[m->栈指针].值, maddr, 4);
                        符号扩展_32_64(&栈[m->栈指针].值.无符整64位);
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case I64Load32U:
                        // 从内存拷贝 4 个字节无符号数到操作数栈顶（栈顶类型为 64 位整数）
                        // 因为是无符号数，在转换为更大的数据类型时，只需简单地在开头添加 0 占位，无需特殊转换
                        memcpy(&栈[m->栈指针].值, maddr, 4);
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    default:
                        break;
                }
                continue;

            /*
             * 内存指令--内存存储指令（9 条）
             * 指令作用：将操作数栈顶值弹出并存储到内存中
             * */
            case I32Store ... I64Store32:
                // 内存加载和存储指令都带有两个立即数：1.对齐方式 2.内存偏移量

                // 第一个立即数表示对齐方式
                // 保存的是以 2 为底，对齐字节数的对数，占 4 个字节
                // 例如 0 表示一字节（2^0）对齐，1 表示两字节（2^1）对齐，2 表示四字节（2^2）对齐
                // 对齐方式只起提示作用，目的是帮助 JIT/AOT 编译器生成更优化的机器代码，对实际执行结果没有任何影响，暂时忽略
                读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 第二个立即数表示内存偏移量
                // 从操作数栈顶弹出一个 整数32 类型的数，和内存偏移量 偏移 相加，就可以得到实际内存相对地址
                // 注：操作数栈顶弹出的数和内存偏移量都是 32 位无符号整数，所以 Wasm 实际拥有 33 比特的地址空间
                偏移 = 读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 获取操作数栈顶地址，并将栈顶弹出
                栈值 *sval = &栈[m->栈指针--];

                // 再从操作数栈顶弹出一个 整数32 类型的数（用于获取实际内存地址）
                地址 = 栈[m->栈指针--].值.无符整32位;
                // 获取实际内存地址
                maddr = m->记忆.字节们 + 偏移 + 地址;

                // TODO: 忽略校验 偏移/地址/maddr 值的合法性

                // 根据具体指令将数操作数栈顶值拷贝到实际内存地址
                switch (操作代码) {
                    case I32Store:
                        // 将操作数栈顶值（栈顶值类型为 32 位整数）的前 4 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.无符整32位, 4);
                        break;
                    case I64Store:
                        // 将操作数栈顶值（栈顶值类型为 64 位整数）的前 8 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.无符整64位, 8);
                        break;
                    case F32Store:
                        // 将操作数栈顶值（栈顶值类型为 32 位浮点数）的前 4 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.浮点32位, 4);
                        break;
                    case F64Store:
                        // 将操作数栈顶值（栈顶值类型为 64 位浮点数）的前 8 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.浮点64位, 8);
                        break;
                    case I32Store8:
                        // 将操作数栈顶值（栈顶值类型为 32 位整数）的前 1 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.无符整32位, 1);
                        break;
                    case I32Store16:
                        // 将操作数栈顶值（栈顶值类型为 32 位整数）的前 2 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.无符整32位, 2);
                        break;
                    case I64Store8:
                        // 将操作数栈顶值（栈顶值类型为 64 位整数）的前 1 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.无符整64位, 1);
                        break;
                    case I64Store16:
                        // 将操作数栈顶值（栈顶值类型为 64 位整数）的前 2 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.无符整64位, 2);
                        break;
                    case I64Store32:
                        // 将操作数栈顶值（栈顶值类型为 64 位整数）的前 4 个字节拷贝到实际内存地址
                        memcpy(maddr, &sval->值.无符整64位, 4);
                        break;
                    default:
                        break;
                }
                continue;

            /*
             * 内存指令--大小 指令
             * */
            case 内存大小:
                // 指令作用：将当前的内存页数以 整数32 类型压入操作数栈顶

                // 该指令的立即数表示当前操作的是第几块内存（占 1 个内存）
                // 但由于当前 Wasm 规范规定最多只能导入或定义一块内存，所以目前必须为 0
                读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 将当前的内存页数以 整数32 类型压入操作数栈顶
                栈[++m->栈指针].值_类型 = 整32;
                栈[m->栈指针].值.无符整32位 = m->记忆.当前_大小;
                continue;

            /*
             * 内存指令--grow 指令
             * */
            case 内存增长:
                // 指令作用：将内存增长若干页，并从操作数栈顶获取增长前的内存页数

                // 该指令的立即数表示当前操作的是第几块内存（占 1 个内存）
                // 但由于当前 Wasm 规范规定最多只能导入或定义一块内存，所以目前必须为 0
                读_基于小端_无符号(字节们, &m->程序计数器, 32);

                // 先保存当前内存页数
                uint32_t prev_pages = m->记忆.当前_大小;

                // 将操作数栈顶值作为内存要增长的页数
                uint32_t delta = 栈[m->栈指针].值.无符整32位;

                // 用刚刚保存的当前内存页数覆盖当前操作数栈顶值
                栈[m->栈指针].值.无符整32位 = prev_pages;

                // 校验内存增长页数是否合法
                if (delta == 0 || delta + prev_pages > m->记忆.最大_大小) {
                    // 如果内存增长页数为 0，
                    // 或者内存增长页数加上当前内存页数后，超过了内存最大页数，
                    // 则什么都不做，执行下一条指令
                    continue;
                }

                // 如果内存增长页数合法，则增加 delta 页内存
                m->记忆.当前_大小 += delta;
                m->记忆.字节们 = 重新分配内存配给(m->记忆.字节们, prev_pages * 页_大小, m->记忆.当前_大小 * 页_大小, sizeof(uint8_t), "网汇模块->记忆.字节们");
                continue;

            /*
             * 数值指令--常量指令（4 条）
             * 
             * 注：数值指令中除了常量指令之外，其余的数值指令都没有立即数
             * */
            case I32Const:
                // 指令作用：将指令的立即数以 整数32 类型压入操作数栈顶

                栈[++m->栈指针].值_类型 = 整32;
                栈[m->栈指针].值.无符整32位 = 读_基于小端_有符号(字节们, &m->程序计数器, 32);
                continue;
            case I64Const:
                // 指令作用：将指令的立即数以 整数64 类型压入操作数栈顶

                栈[++m->栈指针].值_类型 = 整64;
                栈[m->栈指针].值.整型64位 = (int64_t) 读_基于小端_有符号(字节们, &m->程序计数器, 64);
                continue;
            case F32Const:
                // 指令作用：将指令的立即数以 浮点32位 类型压入操作数栈顶

                栈[++m->栈指针].值_类型 = 浮32;
                // LEB128 编码仅针对整数，而该指令的立即数为浮点数，并没有被编码，而是直接写入到 Wasm 二进制文件中的
                memcpy(&栈[m->栈指针].值.无符整32位, 字节们 + m->程序计数器, 4);
                // 由于是直接将 4 个字节长度的立即数的值拷贝到栈顶，
                // 没有调用 读_基于小端_有符号（该函数会实时更新 程序计数器 保存的值），所以程序计数器需要手动加 4
                m->程序计数器 += 4;
                continue;
            case F64Const:
                // 指令作用：将指令的立即数以 浮点64位 类型压入操作数栈顶

                栈[++m->栈指针].值_类型 = 浮64;
                // LEB128 编码仅针对整数，而该指令的立即数为浮点数，并没有被编码，而是直接写入到 Wasm 二进制文件中的
                memcpy(&栈[m->栈指针].值.无符整64位, 字节们 + m->程序计数器, 8);
                // 由于是直接将 8 个字节长度的立即数的值拷贝到栈顶，
                // 没有调用 读_基于小端_有符号（该函数会实时更新 程序计数器 保存的值），所以程序计数器需要手动加 8
                m->程序计数器 += 8;
                continue;

            /*
             * 数值指令--测试指令（2 条）
             *
             * 注：测试指令是冗余的，完全可用常量指令和比较指令代替，
             * 但是考虑到判断一个数是否为 0 是一种相当常见的操作，使用测试指令可以节约一条常量指令
             * */
            case I32Eqz:
                // 指令作用：判断操作数栈顶值（32 位整数）是否为 0

                // 获取栈顶操作数栈顶值（32 位整数），判断是否为 0，
                // 然后用判断结果（整数32 类型的布尔值）覆盖当前操作数栈顶值
                栈[m->栈指针].值_类型 = 整32;
                栈[m->栈指针].值.无符整32位 = 栈[m->栈指针].值.无符整32位 == 0;
                continue;
            case I64Eqz:
                // 指令作用：判断操作数栈顶值（64 位整数）是否为 0

                // 获取栈顶操作数值（64 位整数），判断是否为 0，
                // 然后用判断结果（整数32 类型的布尔值）覆盖当前操作数栈顶值
                栈[m->栈指针].值_类型 = 整32;
                栈[m->栈指针].值.无符整32位 = 栈[m->栈指针].值.无符整64位 == 0;
                continue;

            /*
             * 数值指令--比较指令（32 条）
             * */
            case I32Eq ... I32GeU:
                // 指令作用：获取操作数栈的栈顶和次栈顶的值（32 位整数），根据具体指令对两个值进行比较，并用比较结果覆盖当前操作数栈顶值

                a = 栈[m->栈指针 - 1].值.无符整32位;
                b = 栈[m->栈指针].值.无符整32位;
                m->栈指针 -= 1;
                switch (操作代码) {
                    case I32Eq:
                        c = a == b;
                        break;
                    case I32Ne:
                        c = a != b;
                        break;
                    case I32LtS:
                        c = (uint32_t) a < (uint32_t) b;
                        break;
                    case I32LtU:
                        c = a < b;
                        break;
                    case I32GtS:
                        c = (uint32_t) a > (uint32_t) b;
                        break;
                    case I32GtU:
                        c = a > b;
                        break;
                    case I32LeS:
                        c = (uint32_t) a <= (uint32_t) b;
                        break;
                    case I32LeU:
                        c = a <= b;
                        break;
                    case I32GeS:
                        c = (uint32_t) a >= (uint32_t) b;
                        break;
                    case I32GeU:
                        c = a >= b;
                        break;
                    default:
                        break;
                }
                // 注：比较的结果为布尔值，用 32 位整数表示
                栈[m->栈指针].值_类型 = 整32;
                栈[m->栈指针].值.无符整32位 = c;
                continue;
            case I64Eq ... I64GeU:
                // 指令作用：获取操作数栈的栈顶和次栈顶的值（64 位整数），根据具体指令对两个值进行比较，并用比较结果覆盖当前操作数栈顶值

                d = 栈[m->栈指针 - 1].值.无符整64位;
                e = 栈[m->栈指针].值.无符整64位;
                m->栈指针 -= 1;
                switch (操作代码) {
                    case I64Eq:
                        c = d == e;
                        break;
                    case I64Ne:
                        c = d != e;
                        break;
                    case I64LtS:
                        c = (uint64_t) d < (uint64_t) e;
                        break;
                    case I64LtU:
                        c = d < e;
                        break;
                    case I64GtS:
                        c = (uint64_t) d > (uint64_t) e;
                        break;
                    case I64GtU:
                        c = d > e;
                        break;
                    case I64LeS:
                        c = (uint64_t) d <= (uint64_t) e;
                        break;
                    case I64LeU:
                        c = d <= e;
                        break;
                    case I64GeS:
                        c = (uint64_t) d >= (uint64_t) e;
                        break;
                    case I64GeU:
                        c = d >= e;
                        break;
                    default:
                        break;
                }
                // 注：比较的结果为布尔值，用 32 位整数表示
                栈[m->栈指针].值_类型 = 整32;
                栈[m->栈指针].值.无符整32位 = c;
                continue;
            case F32Eq ... F32Ge:
                // 指令作用：获取操作数栈的栈顶和次栈顶的值（32 位浮点数），根据具体指令对两个值进行比较，并用比较结果覆盖当前操作数栈顶值

                g = 栈[m->栈指针 - 1].值.浮点32位;
                h = 栈[m->栈指针].值.浮点32位;
                m->栈指针 -= 1;
                switch (操作代码) {
                    case F32Eq:
                        c = g == h;
                        break;
                    case F32Ne:
                        c = g != h;
                        break;
                    case F32Lt:
                        c = g < h;
                        break;
                    case F32Gt:
                        c = g > h;
                        break;
                    case F32Le:
                        c = g <= h;
                        break;
                    case F32Ge:
                        c = g >= h;
                        break;
                    default:
                        break;
                }
                // 注：比较的结果为布尔值，用 32 位整数表示
                栈[m->栈指针].值_类型 = 整32;
                栈[m->栈指针].值.无符整32位 = c;
                continue;
            case F64Eq ... F64Ge:
                // 指令作用：获取操作数栈的栈顶和次栈顶的值（64 位浮点数），根据具体指令对两个值进行比较，并用比较结果覆盖当前操作数栈顶值

                j = 栈[m->栈指针 - 1].值.浮点64位;
                k = 栈[m->栈指针].值.浮点64位;
                m->栈指针 -= 1;
                switch (操作代码) {
                    case F64Eq:
                        c = j == k;
                        break;
                    case F64Ne:
                        c = j != k;
                        break;
                    case F64Lt:
                        c = j < k;
                        break;
                    case F64Gt:
                        c = j > k;
                        break;
                    case F64Le:
                        c = j <= k;
                        break;
                    case F64Ge:
                        c = j >= k;
                        break;
                    default:
                        break;
                }
                // 注：比较的结果为布尔值，用 32 位整数表示
                栈[m->栈指针].值_类型 = 整32;
                栈[m->栈指针].值.无符整32位 = c;
                continue;

            /*
             * 数值指令--算术指令（64 条）
             * */
            case I32Clz ... I32PopCnt:
                // 指令作用：获取操作数栈顶值（32 位整数），根据指令对其进行相应计算，并用计算结果覆盖当前操作数栈顶值

                a = 栈[m->栈指针].值.无符整32位;
                switch (操作代码) {
                    case I32Clz:
                        // 数值的二进制表示的位数
                        c = a == 0 ? 32 : __builtin_clz(a);
                        break;
                    case I32Ctz:
                        // 数值的二进制表示的末尾后面 0 的个数
                        c = a == 0 ? 32 : __builtin_ctz(a);
                        break;
                    case I32PopCnt:
                        // 数值的二进制表示中的 1 的个数
                        c = __builtin_popcount(a);
                        break;
                    default:
                        break;
                }

                栈[m->栈指针].值.无符整32位 = c;
                continue;
            case I32Add ... I32Rotr:
                // 指令作用：获取操作数栈的栈顶和次栈顶的值（32 位整数），根据具体指令对两个值进行计算，并用计算结果覆盖当前操作数栈顶值

                a = 栈[m->栈指针 - 1].值.无符整32位;
                b = 栈[m->栈指针].值.无符整32位;
                m->栈指针 -= 1;

                // 执行 I32DivS 和 I32RemU 之间的指令时，栈顶值 b 不能为 0，
                // 如果为 0 则记录异常信息并返回 false 退出虚拟机执行
                if (操作代码 >= I32DivS && 操作代码 <= I32RemU && b == 0) {
                    sprintf(异常, "integer divide by zero");
                    return false;
                }

                switch (操作代码) {
                    case I32Add:
                        // 加法
                        c = a + b;
                        break;
                    case I32Sub:
                        // 减法
                        c = a - b;
                        break;
                    case I32Mul:
                        // 乘法
                        c = a * b;
                        break;
                    case I32DivS:
                        // 除法（有符号）
                        if (a == 0x80000000 && b == -1) {
                            sprintf(异常, "integer overflow");
                            return false;
                        }
                        c = (int32_t) a / (int32_t) b;
                        break;
                    case I32DivU:
                        // 除法（无符号）
                        c = a / b;
                        break;
                    case I32RemS:
                        // 取余（有符号）
                        if (a == 0x80000000 && b == -1) {
                            c = 0;
                        } else {
                            c = (int32_t) a % (int32_t) b;
                        }
                        break;
                    case I32RemU:
                        // 取余（无符号）
                        c = a % b;
                        break;
                    case I32And:
                        // 与
                        c = a & b;
                        break;
                    case I32Or:
                        // 或
                        c = a | b;
                        break;
                    case I32Xor:
                        // 异或
                        c = a ^ b;
                        break;
                    case I32Shl:
                        // 左移
                        c = a << b;
                        break;
                    case I32ShrS:
                        // 右移
                        c = ((int32_t) a) >> b;
                        break;
                    case I32ShrU:
                        // 右移
                        c = a >> b;
                        break;
                    case I32Rotl:
                        // 循环左移
                        c = 左旋转32位(a, b);
                        break;
                    case I32Rotr:
                        // 循环右移
                        c = 右旋转32位(a, b);
                        break;
                    default:
                        break;
                }

                栈[m->栈指针].值.无符整32位 = c;
                continue;
            case I64Clz ... I64PopCnt:
                // 指令作用：获取操作数栈顶值（64 位整数），根据指令对其进行相应计算，并用计算结果覆盖当前操作数栈顶值

                d = 栈[m->栈指针].值.无符整64位;

                switch (操作代码) {
                    case I64Clz:
                        // 数值的二进制表示的位数
                        f = d == 0 ? 64 : __builtin_clzll(d);
                        break;
                    case I64Ctz:
                        // 数值的二进制表示的末尾后面 0 的个数
                        f = d == 0 ? 64 : __builtin_ctzll(d);
                        break;
                    case I64PopCnt:
                        // 数值的二进制表示中的 1 的个数
                        f = __builtin_popcountll(d);
                        break;
                    default:
                        break;
                }

                栈[m->栈指针].值.无符整64位 = f;
                continue;
            case I64Add ... I64Rotr:
                // 指令作用：获取操作数栈的栈顶和次栈顶的值（64 位整数），根据具体指令对两个值进行计算，并用计算结果覆盖当前操作数栈顶值

                d = 栈[m->栈指针 - 1].值.无符整64位;
                e = 栈[m->栈指针].值.无符整64位;
                m->栈指针 -= 1;

                // 执行 I64DivS 和 I64RemU 之间的指令时，栈顶值 e 不能为 0，
                // 如果为 0 则记录异常信息并返回 false 退出虚拟机执行
                if (操作代码 >= I64DivS && 操作代码 <= I64RemU && e == 0) {
                    sprintf(异常, "integer divide by zero");
                    return false;
                }

                switch (操作代码) {
                    case I64Add:
                        // 加法
                        f = d + e;
                        break;
                    case I64Sub:
                        // 减法
                        f = d - e;
                        break;
                    case I64Mul:
                        // 乘法
                        f = d * e;
                        break;
                    case I64DivS:
                        // 除法（有符号）
                        if (d == 0x80000000 && e == -1) {
                            sprintf(异常, "integer overflow");
                            return false;
                        }
                        f = (int64_t) d / (int64_t) e;
                        break;
                    case I64DivU:
                        // 除法（无符号）
                        f = d / e;
                        break;
                    case I64RemS:
                        // 取余（有符号）
                        if (d == 0x80000000 && e == -1) {
                            f = 0;
                        } else {
                            f = (int64_t) d % (int64_t) e;
                        }
                        break;
                    case I64RemU:
                        // 取余（无符号）
                        f = d % e;
                        break;
                    case I64And:
                        // 与
                        f = d & e;
                        break;
                    case I64Or:
                        // 或
                        f = d | e;
                        break;
                    case I64Xor:
                        // 异或
                        f = d ^ e;
                        break;
                    case I64Shl:
                        // 左移
                        f = d << e;
                        break;
                    case I64ShrS:
                        // 右移
                        f = ((int64_t) d) >> e;
                        break;
                    case I64ShrU:
                        // 右移
                        f = d >> e;
                        break;
                    case I64Rotl:
                        // 循环左移
                        f = 左旋转64位(d, e);
                        break;
                    case I64Rotr:
                        // 循环右移
                        f = 右旋转64位(d, e);
                        break;
                    default:
                        break;
                }

                栈[m->栈指针].值.无符整64位 = f;
                continue;
            case F32Abs:
                // 取绝对值（32 位浮点型）
                栈[m->栈指针].值.浮点32位 = fabsf(栈[m->栈指针].值.浮点32位);
                continue;
            case F32Neg:
                // 取反（32 位浮点型）
                栈[m->栈指针].值.浮点32位 = -栈[m->栈指针].值.浮点32位;
                continue;
            case F32Ceil:
                // 获取大于或等于操作数栈顶值的最小的整数值（32 位浮点型）
                栈[m->栈指针].值.浮点32位 = ceilf(栈[m->栈指针].值.浮点32位);
                continue;
            case F32Floor:
                // 获取小于或等于操作数栈顶值的最小的整数值（32 位浮点型）
                栈[m->栈指针].值.浮点32位 = floorf(栈[m->栈指针].值.浮点32位);
                continue;
            case F32Trunc:
                // 将小数部分截去，保留整数（32 位浮点型）
                栈[m->栈指针].值.浮点32位 = truncf(栈[m->栈指针].值.浮点32位);
                continue;
            case F32Nearest:
                // 获取最接近操作数栈顶值的整数，如果有 2 个数同样接近，则取偶数的整数（32 位浮点型）
                栈[m->栈指针].值.浮点32位 = rintf(栈[m->栈指针].值.浮点32位);
                continue;
            case F32Sqrt:
                // 取平方根（32 位浮点型）
                栈[m->栈指针].值.浮点32位 = sqrtf(栈[m->栈指针].值.浮点32位);
                continue;
            case F32Add ... F32CopySign:
                // 指令作用：获取操作数栈的栈顶和次栈顶的值（32 位浮点数），根据具体指令对两个值进行计算，并用计算结果覆盖当前操作数栈顶值

                g = 栈[m->栈指针 - 1].值.浮点32位;
                h = 栈[m->栈指针].值.浮点32位;
                m->栈指针 -= 1;

                switch (操作代码) {
                    case F32Add:
                        // 加法
                        i = g + h;
                        break;
                    case F32Sub:
                        // 减法
                        i = g - h;
                        break;
                    case F32Mul:
                        // 乘法
                        i = g * h;
                        break;
                    case F32Div:
                        // 除法
                        if (h == 0) {
                            sprintf(异常, "integer divide by zero");
                            return false;
                        }
                        i = g / h;
                        break;
                    case F32Min:
                        // 取两者之间的最小值
                        i = 网汇_32位浮点最小(g, h);
                        break;
                    case F32Max:
                        // 取两者之间的最大值
                        i = 网汇_32位浮点最大(g, h);
                        break;
                    case F32CopySign:
                        // 获取带有第二个浮点数符号的第一个浮点数
                        // 注：signbit 函数用于判断参数的符号位的正负，为负的时候返回 true，否则返回 false
                        i = signbit(h) ? -fabsf(g) : fabsf(g);
                        break;
                    default:
                        break;
                }

                栈[m->栈指针].值.浮点32位 = i;
                continue;
            case F64Abs:
                // 取绝对值（64 位浮点型）
                栈[m->栈指针].值.浮点32位 = (float) fabs(栈[m->栈指针].值.浮点64位);
                continue;
            case F64Neg:
                // 取反（64 位浮点型）
                栈[m->栈指针].值.浮点64位 = -栈[m->栈指针].值.浮点64位;
                continue;
            case F64Ceil:
                // 获取大于或等于操作数栈顶值的最小的整数值（64 位浮点型）
                栈[m->栈指针].值.浮点64位 = ceil(栈[m->栈指针].值.浮点64位);
                continue;
            case F64Floor:
                // 获取小于或等于操作数栈顶值的最小的整数值（64 位浮点型）
                栈[m->栈指针].值.浮点64位 = floor(栈[m->栈指针].值.浮点64位);
                continue;
            case F64Trunc:
                // 将小数部分截去，保留整数（64 位浮点型）
                栈[m->栈指针].值.浮点64位 = trunc(栈[m->栈指针].值.浮点64位);
                continue;
            case F64Nearest:
                // 获取最接近操作数栈顶值的整数，如果有 2 个数同样接近，则取偶数的整数（64 位浮点型）
                栈[m->栈指针].值.浮点64位 = rint(栈[m->栈指针].值.浮点64位);
                continue;
            case F64Sqrt:
                // 取平方根（64 位浮点型）
                栈[m->栈指针].值.浮点64位 = sqrt(栈[m->栈指针].值.浮点64位);
                continue;
            case F64Add ... F64CopySign:
                // 指令作用：获取操作数栈的栈顶和次栈顶的值（64 位浮点数），根据具体指令对两个值进行计算，并用计算结果覆盖当前操作数栈顶值

                j = 栈[m->栈指针 - 1].值.浮点64位;
                k = 栈[m->栈指针].值.浮点64位;
                m->栈指针 -= 1;

                switch (操作代码) {
                    case F64Add:
                        // 加法
                        l = j + k;
                        break;
                    case F64Sub:
                        // 减法
                        l = j - k;
                        break;
                    case F64Mul:
                        // 乘法
                        l = j * k;
                        break;
                    case F64Div:
                        // 除法
                        if (k == 0) {
                            sprintf(异常, "integer divide by zero");
                            return false;
                        }
                        l = j / k;
                        break;
                    case F64Min:
                        // 取两者之间的最小值
                        l = 网汇_64位浮点最小(j, k);
                        break;
                    case F64Max:
                        // 取两者之间的最大值
                        l = 网汇_64位浮点最大(j, k);
                        break;
                    case F64CopySign:
                        // 获取带有第二个浮点数符号的第一个浮点数
                        // 注：signbit 函数用于判断参数的符号位的正负，为负的时候返回 true，否则返回 false
                        l = signbit(k) ? -fabs(j) : fabs(j);
                        break;
                    default:
                        break;
                }

                栈[m->栈指针].值.浮点64位 = l;
                continue;

            /*
             * 数值指令--类型转换指令（31 条）
             *
             * 注：类型转换指令的助记符是 t'.conv_t，
             * 其中操作数在类型转换之前的类型是 t，之后的类型是 t'，转换操作是 conv
             * */
            case I32WrapI64:
                // 指令作用：将 64 位整数截断为 32 位整数
                栈[m->栈指针].值.无符整64位 &= 0x00000000ffffffff;
                栈[m->栈指针].值_类型 = 整32;
                continue;
            case I32TruncF32S:
                // 指令作用：将 32 位浮点数截断为 32 有符号位整数（截掉小数部分）
                OP_I32_TRUNC_F32(栈[m->栈指针].值.整型32位, 栈[m->栈指针].值.浮点32位)
                栈[m->栈指针].值_类型 = 整32;
                continue;
            case I32TruncF32U:
                // 指令作用：将 32 位浮点数截断为 32 位无符号整数（截掉小数部分）
                OP_U32_TRUNC_F32(栈[m->栈指针].值.无符整32位, 栈[m->栈指针].值.浮点32位)
                栈[m->栈指针].值_类型 = 整32;
                continue;
            case I32TruncF64S:
                // 指令作用：将 64 位浮点数截断为 32 位有符号整数（截掉小数部分）
                OP_I32_TRUNC_F64(栈[m->栈指针].值.整型32位, 栈[m->栈指针].值.浮点64位)
                栈[m->栈指针].值_类型 = 整32;
                continue;
            case I32TruncF64U:
                // 指令作用：将 64 位浮点数截断为 32 位无符号整数（截掉小数部分）
                OP_U32_TRUNC_F64(栈[m->栈指针].值.无符整32位, 栈[m->栈指针].值.浮点64位)
                栈[m->栈指针].值_类型 = 整32;
                continue;
            case I64ExtendI32S:
                // 指令作用：将 32 位有符号整数位数拉升为 64 位整数
                栈[m->栈指针].值.无符整64位 = 栈[m->栈指针].值.无符整32位;
                符号扩展_32_64(&栈[m->栈指针].值.无符整64位);
                栈[m->栈指针].值_类型 = 整64;
                continue;
            case I64ExtendI32U:
                // 指令作用：将 32 位无符号整数位数拉升为 64 位整数
                栈[m->栈指针].值.无符整64位 = 栈[m->栈指针].值.无符整32位;
                栈[m->栈指针].值_类型 = 整64;
                continue;
            case I64TruncF32S:
                // 指令作用：将 32 位浮点数截断为 64 位有符号整数（截掉小数部分）
                OP_I64_TRUNC_F32(栈[m->栈指针].值.整型64位, 栈[m->栈指针].值.浮点32位)
                栈[m->栈指针].值_类型 = 整64;
                continue;
            case I64TruncF32U:
                // 指令作用：将 32 位浮点数截断为 64 位无符号整数（截掉小数部分）
                OP_U64_TRUNC_F32(栈[m->栈指针].值.无符整64位, 栈[m->栈指针].值.浮点32位)
                栈[m->栈指针].值_类型 = 整64;
                continue;
            case I64TruncF64S:
                // 指令作用：将 64 位浮点数截断为 64 位有符号整数（截掉小数部分）
                OP_I64_TRUNC_F64(栈[m->栈指针].值.整型64位, 栈[m->栈指针].值.浮点64位)
                栈[m->栈指针].值_类型 = 整64;
                continue;
            case I64TruncF64U:
                // 指令作用：将 64 位无符号浮点数截断为 64 位无符号整数（截掉小数部分）
                OP_U64_TRUNC_F64(栈[m->栈指针].值.无符整64位, 栈[m->栈指针].值.浮点64位)
                栈[m->栈指针].值_类型 = 整64;
                continue;
            case F32ConvertI32S:
                // 指令作用：将 32 位有符号整数转化为 32 位浮点数
                栈[m->栈指针].值.浮点32位 = (float) 栈[m->栈指针].值.整型32位;
                栈[m->栈指针].值_类型 = 浮32;
                continue;
            case F32ConvertI32U:
                // 指令作用：将 32 位无符号整数转化为 32 位浮点数
                栈[m->栈指针].值.浮点32位 = (float) 栈[m->栈指针].值.无符整32位;
                栈[m->栈指针].值_类型 = 浮32;
                continue;
            case F32ConvertI64S:
                // 指令作用：将 64 位有符号整数转化为 32 位浮点数
                栈[m->栈指针].值.浮点32位 = (float) 栈[m->栈指针].值.整型64位;
                栈[m->栈指针].值_类型 = 浮32;
                continue;
            case F32ConvertI64U:
                // 指令作用：将 64 位无符号整数转化为 32 位浮点数
                栈[m->栈指针].值.浮点32位 = (float) 栈[m->栈指针].值.无符整64位;
                栈[m->栈指针].值_类型 = 浮32;
                continue;
            case F32DemoteF64:
                // 指令作用：将 64 位浮点数精度降低到 32 位
                栈[m->栈指针].值.浮点32位 = (float) 栈[m->栈指针].值.浮点64位;
                栈[m->栈指针].值_类型 = 浮32;
                continue;
            case F64ConvertI32S:
                // 指令作用：将 32 位有符号整数转化为 64 位浮点数
                栈[m->栈指针].值.浮点64位 = 栈[m->栈指针].值.整型32位;
                栈[m->栈指针].值_类型 = 浮64;
                continue;
            case F64ConvertI32U:
                // 指令作用：将 32 位无符号整数转化为 64 位浮点数
                栈[m->栈指针].值.浮点64位 = 栈[m->栈指针].值.无符整32位;
                栈[m->栈指针].值_类型 = 浮64;
                continue;
            case F64ConvertI64S:
                // 指令作用：将 64 位有符号整数转化为 64 位浮点数
                栈[m->栈指针].值.浮点64位 = (double) 栈[m->栈指针].值.整型64位;
                栈[m->栈指针].值_类型 = 浮64;
                continue;
            case F64ConvertI64U:
                // 指令作用：将 64 位无符号整数转化为 64 位浮点数
                栈[m->栈指针].值.浮点64位 = (double) 栈[m->栈指针].值.无符整64位;
                栈[m->栈指针].值_类型 = 浮64;
                continue;
            case F64PromoteF32:
                // 指令作用：将 32 位浮点数精度提升到 64 位
                栈[m->栈指针].值.浮点64位 = 栈[m->栈指针].值.浮点32位;
                栈[m->栈指针].值_类型 = 浮64;
                continue;
            case I32ReinterpretF32:
                // 指令作用：将 64 位浮点数重新解释为 32 位整数类型，但不改变比特位
                栈[m->栈指针].值_类型 = 整32;
                continue;
            case I64ReinterpretF64:
                // 指令作用：将 64 位浮点数重新解释为 64 位整数类型，但不改变比特位
                栈[m->栈指针].值_类型 = 整64;
                continue;
            case F32ReinterpretI32:
                // 指令作用：将 32 位整数重新解释为 32 位浮点数类型，但不改变比特位
                栈[m->栈指针].值_类型 = 浮32;
                continue;
            case F64ReinterpretI64:
                // 指令作用：将 64 位整数重新解释为 64 位浮点数类型，但不改变比特位
                栈[m->栈指针].值_类型 = 浮64;
                continue;
            case I32Extend8S:
                // 指令作用：将 8 位有符号整数位数拉升为 32 位整数
                栈[m->栈指针].值.整型32位 = ((int32_t) (int8_t) 栈[m->栈指针].值.整型32位);
                continue;
            case I32Extend16S:
                // 指令作用：将 16 位有符号整数位数拉升为 32 位整数
                栈[m->栈指针].值.整型32位 = ((int32_t) (int16_t) 栈[m->栈指针].值.整型32位);
                continue;
            case I64Extend8S:
                // 指令作用：将 8 位有符号整数位数拉升为 64 位整数
                栈[m->栈指针].值.整型64位 = ((int64_t) (int8_t) 栈[m->栈指针].值.整型64位);
                continue;
            case I64Extend16S:
                // 指令作用：将 16 位有符号整数位数拉升为 64 位整数
                栈[m->栈指针].值.整型64位 = ((int64_t) (int16_t) 栈[m->栈指针].值.整型64位);
                continue;
            case I64Extend32S:
                // 指令作用：将 32 位有符号整数位数拉升为 64 位整数
                栈[m->栈指针].值.整型64位 = ((int64_t) (int32_t) 栈[m->栈指针].值.整型64位);
                continue;
            case 饱和截断: {
                // 饱和截断指令
                // Wasm 支持的 4 种基本类型都是固定长度：整数32 和 浮点32位 类型占 4 字节，整数64 和 浮点64位 类型占 8 字节
                // 定长的数据类型只能表达有限的数值，因此对 2 个某种类型的数进行计算，其结果可能会超出该类型的表达范围，也就是溢出：包括上溢和下溢
                // 针对溢出有 3 种处理方式：
                // 1. 环绕（Wrapping），整数运算通常采用这种方式。以 无整32 类型为例，0xfffffffd 和 0x04 相加导致溢出，结果为 0x01
                // 2. 饱和（Saturation），浮点数运算通常采用这种方式，超出范围的值会被表示为正或负“无穷”（+Inf / -Inf）
                // 3. 异常，例如整数除 0 通常会产生异常
                // 截断指令需要将浮点数截断为整数，所以可能会产生溢出，或者无法转换（比如 NaN）情况

                // 新增的 8 条饱和截断指令和上面的 8 条非饱和截断指令是一一对应的，只是对于异常情况做了特殊处理，
                // 比如将 NaN 转换为 0。再比如如果超出了类型能表达的范围，让该变量等于一个最大值或者最小值。
                // 这 8 条指令是通过一条特殊的操作码前缀 0xFC 引入的，操作码前缀 0xFC 未来可能会用来增加其他指令。
                // 为了保持统一，我们仍将 0xFC 作为一个普通操作码，将跟在它后面的字节当作它的立即数，这样就可以认为只有一条饱和截断指令

                // 在读取一个字节，用来区分不同类型的浮点数和整数之间的转换
                uint8_t 类型 = 读_基于小端_无符号(字节们, &m->程序计数器, 8);
                switch (类型) {
                    case 0x00:
                        // 指令作用：将 32 位浮点数饱和截断为 32 有符号位整数（截掉小数部分）
                        OP_I32_TRUNC_SAT_F32(栈[m->栈指针].值.整型32位, 栈[m->栈指针].值.浮点32位)
                        栈[m->栈指针].值_类型 = 整32;
                        break;
                    case 0x01:
                        // 指令作用：将 32 位浮点数截断为 32 位无符号整数（截掉小数部分）
                        OP_U32_TRUNC_SAT_F32(栈[m->栈指针].值.无符整32位, 栈[m->栈指针].值.浮点32位)
                        栈[m->栈指针].值_类型 = 整32;
                        break;
                    case 0x02:
                        // 指令作用：将 64 位浮点数截断为 32 位有符号整数（截掉小数部分）
                        OP_I32_TRUNC_SAT_F64(栈[m->栈指针].值.整型32位, 栈[m->栈指针].值.浮点64位)
                        栈[m->栈指针].值_类型 = 整32;
                        break;
                    case 0x03:
                        // 指令作用：将 64 位浮点数截断为 32 位无符号整数（截掉小数部分）
                        OP_U32_TRUNC_SAT_F64(栈[m->栈指针].值.无符整32位, 栈[m->栈指针].值.浮点64位)
                        栈[m->栈指针].值_类型 = 整32;
                        break;
                    case 0x04:
                        // 指令作用：将 32 位浮点数截断为 64 位有符号整数（截掉小数部分）
                        OP_I64_TRUNC_SAT_F32(栈[m->栈指针].值.整型64位, 栈[m->栈指针].值.浮点32位)
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case 0x05:
                        // 指令作用：将 32 位浮点数截断为 64 位无符号整数（截掉小数部分）
                        OP_U64_TRUNC_SAT_F32(栈[m->栈指针].值.无符整64位, 栈[m->栈指针].值.浮点32位)
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case 0x06:
                        // 指令作用：将 64 位浮点数截断为 64 位有符号整数（截掉小数部分）
                        OP_I64_TRUNC_SAT_F64(栈[m->栈指针].值.整型64位, 栈[m->栈指针].值.浮点64位)
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    case 0x07:
                        // 指令作用：将 64 位无符号浮点数截断为 64 位无符号整数（截掉小数部分）
                        OP_U64_TRUNC_SAT_F64(栈[m->栈指针].值.无符整64位, 栈[m->栈指针].值.浮点64位)
                        栈[m->栈指针].值_类型 = 整64;
                        break;
                    default:
                        break;
                }
                continue;
            }
            default:
                // 无法识别的非法操作码（不在 Wasm 规定的字节码）
                return false;
        }
    }

    // 正常情况不会执行到这里
    return false;
}

// 调用索引为 函索引 的函数
bool 援引(网汇模块 *m, uint32_t 函索引) {
    bool result;

    // 调用函数前的设置，主要设置内容如下：
    // 1. 将当前函数关联的栈帧压入到调用栈顶成为当前栈帧，同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
    // 2. 将当前函数的局部变量压入到操作数栈顶（默认初始值为 0）
    // 3. 将函数的字节码部分的【起始地址】设置为 程序计数器（即下一条待执行指令的地址），即开始执行函数字节码中的指令流
    设置_调用(m, 函索引);

    // 虚拟机执行起始函数的字节码中的指令流
    result = 解释(m);

    // 返回虚拟机的执行指令的结果
    // 如果结果为 false，表示执行过程中出现异常。如果结果为 true，表示成功执行完指令流。
    return result;
}

// 计算初始化表达式
// 参数 类型 为初始化表达式的返回值类型
// 参数 *程序计数器 为初始化表达式的字节码部分的【起始地址】
void 跑_初始_表达(网汇模块 *m, uint8_t 类型, uint32_t *程序计数器) {
    m->程序计数器 = *程序计数器;// 将控制块中字节码部分的【起始地址】赋值给程序计数器 m->程序计数器（程序计数器，记录下一条即将执行的指令的地址）

    控制块 框对应块 = {
            .块_类型 = 0x01,          // 控制块类型为初始化表达式
            .类型 = 获取_块_类型(类型),// 控制块签名（返回值数量和类型）由参数 类型 决定
            .起始_地址 = *程序计数器            // 控制块中字节码部分的【起始地址】
    };
    // 初始化表达式的字节码中的指令流被执行前，将【待调用的初始化表达式控制块关联的栈帧】压入到调用栈顶，成为当前栈帧，
    // 同时保存该栈帧被压入调用栈顶前的运行时状态，例如 栈指针 框指针 返回地址 等
    推_块(m, &框对应块, m->栈指针);

    // 虚拟机执行初始化表达式的字节码中的指令流
    解释(m);

    // 当初始化表达式的字节码中的指令流被执行完成后，需要将在 Wasm 二进制字节码中的当前位置的地址赋给参数 *程序计数器，以便继续解析后面的 Wasm 二进制字节码
    // 注：跑_初始_表达 函数是在解析 Wasm 二进制字节码的 载入_模块 函数中调用，
    // 在调用 跑_初始_表达 函数计算初始化表达式结果后，仍需要继续解析后面的二进制字节码内容
    *程序计数器 = m->程序计数器;

    // 初始化表达式的字节码中的指令流执行完成后，操作数栈顶保存的就是指令流的执行结果，也就是初始化表达式计算的返回值
    // 由于初始化表达式计算一定会有返回值，且目前版本的 Wasm 规范规定控制块最多只能有一个返回值，所以初始化表达式计算必定会有一个返回值
    // 所以可以通过比对保存在操作数栈顶的值类型和参数 类型 是否相同，来判断计算得到的返回值的类型是否正确
    断言(m->栈[m->栈指针].值_类型 == 类型, "Init_expr 类型 mismatch 0x%x != 0x%x\n", m->栈[m->栈指针].值_类型, 类型)
}
