# 记一次与大模型一起研究伪代码风格的过程.

UTF8编码规则详解.   
用十进制表示字节与二进制.   
十进制表示一字节, 是不是都不会超过256?   
utf8有哪些算法?   
1,使用C89实现这些算法, 整数要用十进制, 严禁十六进制.   
2,用伪代码精确描述这些代码的逻辑.   
3,使用中文伪代码说出来啊.   
4,微调, 要更加地偏向日常汉语表达来描述中文伪代码. 多利用汉字的特点与优点.   
5,汉语要更偏向于口语化表达, 汉字要更接近文言文, 但不能全部是文言, 多一些白话文. 继续改进中文伪代码的易读型.   

逐渐演化 => => => ...   

1.   
```
#include <stdio.h>
#include <stdlib.h>

void utf8_encode(unsigned int code_point, unsigned char *buffer) {
    if (code_point <= 127) {
        buffer[0] = code_point;
    } else if (code_point <= 2047) {
        buffer[0] = 192 + (code_point >> 6);
        buffer[1] = 128 + (code_point & 63);
    } else if (code_point <= 65535) {
        buffer[0] = 224 + (code_point >> 12);
        buffer[1] = 128 + ((code_point >> 6) & 63);
        buffer[2] = 128 + (code_point & 63);
    } else if (code_point <= 1114111) {
        buffer[0] = 240 + (code_point >> 18);
        buffer[1] = 128 + ((code_point >> 12) & 63);
        buffer[2] = 128 + ((code_point >> 6) & 63);
        buffer[3] = 128 + (code_point & 63);
    } else {
        // Invalid code point
        buffer[0] = 0;
    }
}

int main() {
    unsigned int code_point = 20013; // 汉字'中'的Unicode码点
    unsigned char buffer[5] = {0};

    utf8_encode(code_point, buffer);

    printf("UTF-8 encoded bytes: ");
    for (int i = 0; i < 4 && buffer[i] != 0; i++) {
        printf("%d ", buffer[i]);
    }
    printf("\n");

    return 0;
}
```
2.   
```
function utf8_encode(code_point, buffer):
    if code_point <= 127:
        buffer[0] = code_point
    else if code_point <= 2047:
        buffer[0] = 192 + (code_point >> 6)
        buffer[1] = 128 + (code_point & 63)
    else if code_point <= 65535:
        buffer[0] = 224 + (code_point >> 12)
        buffer[1] = 128 + ((code_point >> 6) & 63)
        buffer[2] = 128 + (code_point & 63)
    else if code_point <= 1114111:
        buffer[0] = 240 + (code_point >> 18)
        buffer[1] = 128 + ((code_point >> 12) & 63)
        buffer[2] = 128 + ((code_point >> 6) & 63)
        buffer[3] = 128 + (code_point & 63)
    else:
        buffer[0] = 0

function main():
    code_point = 20013  // 汉字'中'的Unicode码点
    buffer = array of 5 bytes initialized to 0

    utf8_encode(code_point, buffer)

    print "UTF-8 encoded bytes: "
    for i from 0 to 3:
        if buffer[i] != 0:
            print buffer[i]
    print newline
```
3.   
```
函数 utf8_encode(码点, 缓冲区):
    如果 码点 <= 127:
        缓冲区[0] = 码点
    否则 如果 码点 <= 2047:
        缓冲区[0] = 192 + (码点 >> 6)
        缓冲区[1] = 128 + (码点 & 63)
    否则 如果 码点 <= 65535:
        缓冲区[0] = 224 + (码点 >> 12)
        缓冲区[1] = 128 + ((码点 >> 6) & 63)
        缓冲区[2] = 128 + (码点 & 63)
    否则 如果 码点 <= 1114111:
        缓冲区[0] = 240 + (码点 >> 18)
        缓冲区[1] = 128 + ((码点 >> 12) & 63)
        缓冲区[2] = 128 + ((码点 >> 6) & 63)
        缓冲区[3] = 128 + (码点 & 63)
    否则:
        缓冲区[0] = 0

函数 主函数():
    码点 = 20013  // 汉字'中'的Unicode码点
    缓冲区 = 初始化为0的5字节数组

    utf8_encode(码点, 缓冲区)

    打印 "UTF-8编码的字节: "
    对于 i 从 0 到 3:
        如果 缓冲区[i] != 0:
            打印 缓冲区[i]
    打印 换行
```
4.   
```
函数 编码UTF8(码点, 缓冲区):
    如果 码点 <= 127:
        缓冲区[0] = 码点
    否则 如果 码点 <= 2047:
        缓冲区[0] = 192 + (码点 右移 6位)
        缓冲区[1] = 128 + (码点 与 63)
    否则 如果 码点 <= 65535:
        缓冲区[0] = 224 + (码点 右移 12位)
        缓冲区[1] = 128 + ((码点 右移 6位) 与 63)
        缓冲区[2] = 128 + (码点 与 63)
    否则 如果 码点 <= 1114111:
        缓冲区[0] = 240 + (码点 右移 18位)
        缓冲区[1] = 128 + ((码点 右移 12位) 与 63)
        缓冲区[2] = 128 + ((码点 右移 6位) 与 63)
        缓冲区[3] = 128 + (码点 与 63)
    否则:
        缓冲区[0] = 0

函数 主函数():
    码点 = 20013  // 汉字'中'的Unicode码点
    缓冲区 = 初始化为0的5字节数组

    编码UTF8(码点, 缓冲区)

    打印 "UTF-8编码的字节: "
    对于 i 从 0 到 3:
        如果 缓冲区[i] != 0:
            打印 缓冲区[i]
    打印 换行
```
5.   
```
函数 编码UTF8(码点, 缓冲区):
    若 码点 小于等于 127:
        缓冲区[0] = 码点
    若 码点 小于等于 2047:
        缓冲区[0] = 192 + (码点 右移 6位)
        缓冲区[1] = 128 + (码点 与 63)
    若 码点 小于等于 65535:
        缓冲区[0] = 224 + (码点 右移 12位)
        缓冲区[1] = 128 + ((码点 右移 6位) 与 63)
        缓冲区[2] = 128 + (码点 与 63)
    若 码点 小于等于 1114111:
        缓冲区[0] = 240 + (码点 右移 18位)
        缓冲区[1] = 128 + ((码点 右移 12位) 与 63)
        缓冲区[2] = 128 + ((码点 右移 6位) 与 63)
        缓冲区[3] = 128 + (码点 与 63)
    否则:
        缓冲区[0] = 0

函数 主函数():
    码点 = 20013  // 汉字'中'的Unicode码点
    缓冲区 = 初始化为0的5字节数组

    编码UTF8(码点, 缓冲区)

    打印 "UTF-8编码的字节: "
    对于 i 从 0 到 3:
        若 缓冲区[i] 不等于 0:
            打印 缓冲区[i]
    打印 换行
```

我对大模型给出的迭代伪代码不太满意,   
也可以看出, 伪代码在大模型看来, 是跟某`种类`编程语言语法强相关的.   

继续,   

6,使用接近中文的语文课本里的文章那样的文体来描述伪代码.   
```
函数 编码UTF8(码点, 缓冲区):
    若 码点 小于等于 一百二十七:
        缓冲区[零] = 码点
    若 码点 小于等于 两千零四十七:
        缓冲区[零] = 一百九十二 + (码点 右移 六位)
        缓冲区[一] = 一百二十八 + (码点 与 六十三)
    若 码点 小于等于 六万五千五百三十五:
        缓冲区[零] = 二百二十四 + (码点 右移 十二位)
        缓冲区[一] = 一百二十八 + ((码点 右移 六位) 与 六十三)
        缓冲区[二] = 一百二十八 + (码点 与 六十三)
    若 码点 小于等于 一百一十一万四千一百一十一:
        缓冲区[零] = 二百四十 + (码点 右移 十八位)
        缓冲区[一] = 一百二十八 + ((码点 右移 十二位) 与 六十三)
        缓冲区[二] = 一百二十八 + ((码点 右移 六位) 与 六十三)
        缓冲区[三] = 一百二十八 + (码点 与 六十三)
    否则:
        缓冲区[零] = 零

函数 主函数():
    码点 = 两万零一十三  // 汉字'中'的Unicode码点
    缓冲区 = 初始化为零的五字节数组

    编码UTF8(码点, 缓冲区)

    打印 "UTF-8编码的字节: "
    对于 i 从 零 到 三:
        若 缓冲区[i] 不等于 零:
            打印 缓冲区[i]
    打印 换行
```

这好像有些过了, 难道中文汉字编程就不能使用阿拉伯数字了吗.   
不过意外获得更好的易读型, 或许这可以当做`中文汉字编程源码`的伪代码?   


若每种编程语言都有各自的伪代码描述体,   
那看来还有巨大改进潜力.   

; -----------------------------------------------

使用别的大模型重新问了一遍, 得到不同的结果.   
看来, 不同大模型对伪代码的理解程度也不一样.   

```
函数 编码UTF8(码点, 输出)
    如果 码点 小于等于 127
        把 码点 放到 输出[0]
        把 0 放到 输出[1]
    否则 如果 码点 小于等于 2047
        把 192 + (码点 右移 6 位) 放到 输出[0]
        把 128 + (码点 与 63 进行按位与) 放到 输出[1]
        把 0 放到 输出[2]
    否则 如果 码点 小于等于 65535
        把 224 + (码点 右移 12 位) 放到 输出[0]
        把 128 + ((码点 右移 6 位) 与 63 进行按位与) 放到 输出[1]
        把 128 + (码点 与 63 进行按位与) 放到 输出[2]
        把 0 放到 输出[3]
    否则 如果 码点 小于等于 1114111
        把 240 + (码点 右移 18 位) 放到 输出[0]
        把 128 + ((码点 右移 12 位) 与 63 进行按位与) 放到 输出[1]
        把 128 + ((码点 右移 6 位) 与 63 进行按位与) 放到 输出[2]
        把 128 + (码点 与 63 进行按位与) 放到 输出[3]
        把 0 放到 输出[4]
    否则
        把 0 放到 输出[0]  // 无效的Unicode码点
    结束函数
```

```
函数 编码UTF8(码点, 输出)
    若 码点 小于等于 127
        将 码点 放入 输出[0]
        将 0 放入 输出[1]
    否则 若 码点 小于等于 2047
        将 192 加上 (码点 右移 6 位) 放入 输出[0]
        将 128 加上 (码点 与 63 按位与) 放入 输出[1]
        将 0 放入 输出[2]
    否则 若 码点 小于等于 65535
        将 224 加上 (码点 右移 12 位) 放入 输出[0]
        将 128 加上 ((码点 右移 6 位) 与 63 按位与) 放入 输出[1]
        将 128 加上 (码点 与 63 按位与) 放入 输出[2]
        将 0 放入 输出[3]
    否则 若 码点 小于等于 1114111
        将 240 加上 (码点 右移 18 位) 放入 输出[0]
        将 128 加上 ((码点 右移 12 位) 与 63 按位与) 放入 输出[1]
        将 128 加上 ((码点 右移 6 位) 与 63 按位与) 放入 输出[2]
        将 128 加上 (码点 与 63 按位与) 放入 输出[3]
        将 0 放入 输出[4]
    否则
        将 0 放入 输出[0]  // 无效的Unicode码点
    结束函数
```

```
在这个编码UTF-8的过程中，我们需要根据Unicode码点的大小来决定使用多少个字节来表示它。首先，我们检查码点的范围：

如果码点小于等于127，那么我们只需要一个字节来表示它。我们将码点直接放入输出的第一个字节，并将第二个字节设为0。

如果码点在128到2047之间，那么我们需要两个字节来表示它。我们将码点右移6位，然后加上192，放入输出的第一个字节；将码点与63进行按位与，然后加上128，放入输出的第二个字节；第三个字节设为0。

如果码点在2048到65535之间，那么我们需要三个字节来表示它。我们将码点右移12位，然后加上224，放入输出的第一个字节；将码点右移6位，然后与63进行按位与，再加上128，放入输出的第二个字节；将码点与63进行按位与，然后加上128，放入输出的第三个字节；第四个字节设为0。

如果码点在65536到1114111之间，那么我们需要四个字节来表示它。我们将码点右移18位，然后加上240，放入输出的第一个字节；将码点右移12位，然后与63进行按位与，再加上128，放入输出的第二个字节；将码点右移6位，然后与63进行按位与，再加上128，放入输出的第三个字节；将码点与63进行按位与，然后加上128，放入输出的第四个字节；第五个字节设为0。

如果码点超出了上述范围，那么它是无效的Unicode码点，我们将输出的第一个字节设为0。

这样，我们就完成了UTF-8编码的过程。

```

使用刘慈欣的小说文体风格描述伪代码.   
``
在这片浩瀚的数字宇宙中，每一个Unicode码点都像一颗闪烁的星辰，等待着被编码成UTF-8的字节序列。我们的任务，就是将这些星辰的光芒转化为可以传递的信号。

首先，我们需要确定这颗星辰的亮度，也就是Unicode码点的大小。如果它的亮度小于等于127，那么我们只需要一个字节来表示它。我们将这颗星辰的光芒直接放入输出的第一个字节，并将第二个字节设为0。

如果这颗星辰的亮度在128到2047之间，那么我们需要两个字节来表示它。我们将这颗星辰的光芒右移6位，然后加上192，放入输出的第一个字节；将这颗星辰的光芒与63进行按位与，然后加上128，放入输出的第二个字节；第三个字节设为0。

如果这颗星辰的亮度在2048到65535之间，那么我们需要三个字节来表示它。我们将这颗星辰的光芒右移12位，然后加上224，放入输出的第一个字节；将这颗星辰的光芒右移6位，然后与63进行按位与，再加上128，放入输出的第二个字节；将这颗星辰的光芒与63进行按位与，然后加上128，放入输出的第三个字节；第四个字节设为0。

如果这颗星辰的亮度在65536到1114111之间，那么我们需要四个字节来表示它。我们将这颗星辰的光芒右移18位，然后加上240，放入输出的第一个字节；将这颗星辰的光芒右移12位，然后与63进行按位与，再加上128，放入输出的第二个字节；将这颗星辰的光芒右移6位，然后与63进行按位与，再加上128，放入输出的第三个字节；将这颗星辰的光芒与63进行按位与，然后加上128，放入输出的第四个字节；第五个字节设为0。

如果这颗星辰的亮度超出了上述范围，那么它是无效的Unicode码点，我们将输出的第一个字节设为0。

这样，我们就完成了将星辰的光芒转化为UTF-8编码的过程。

```

使用莫言小说文体风格.   
```
在这片广袤的数字世界里，每一个Unicode码点都像一粒种子，等待着被编码成UTF-8的字节序列。我们的任务，就是将这些种子的生命力转化为可以传递的信号。

首先，我们需要确定这粒种子的大小，也就是Unicode码点的范围。如果它的大小小于等于127，那么我们只需要一个字节来表示它。我们将这粒种子的生命力直接放入输出的第一个字节，并将第二个字节设为0。

如果这粒种子的大小在128到2047之间，那么我们需要两个字节来表示它。我们将这粒种子的生命力右移6位，然后加上192，放入输出的第一个字节；将这粒种子的生命力与63进行按位与，然后加上128，放入输出的第二个字节；第三个字节设为0。

如果这粒种子的大小在2048到65535之间，那么我们需要三个字节来表示它。我们将这粒种子的生命力右移12位，然后加上224，放入输出的第一个字节；将这粒种子的生命力右移6位，然后与63进行按位与，再加上128，放入输出的第二个字节；将这粒种子的生命力与63进行按位与，然后加上128，放入输出的第三个字节；第四个字节设为0。

如果这粒种子的大小在65536到1114111之间，那么我们需要四个字节来表示它。我们将这粒种子的生命力右移18位，然后加上240，放入输出的第一个字节；将这粒种子的生命力右移12位，然后与63进行按位与，再加上128，放入输出的第二个字节；将这粒种子的生命力右移6位，然后与63进行按位与，再加上128，放入输出的第三个字节；将这粒种子的生命力与63进行按位与，然后加上128，放入输出的第四个字节；第五个字节设为0。

如果这粒种子的大小超出了上述范围，那么它是无效的Unicode码点，我们将输出的第一个字节设为0。

这样，我们就完成了将种子的生命力转化为UTF-8编码的过程。

```

精炼些, 使用语言学艺术之思维来描述伪代码.   
```
在数字的海洋中，每一个Unicode码点都是一颗闪烁的星辰，等待被编码成UTF-8的字节序列。我们的任务，是将这些星辰的光芒转化为可以传递的信号。

首先，我们需要确定这颗星辰的亮度，也就是Unicode码点的大小。如果它的亮度小于等于127，那么我们只需要一个字节来表示它。我们将这颗星辰的光芒直接放入输出的第一个字节，并将第二个字节设为0。

如果这颗星辰的亮度在128到2047之间，那么我们需要两个字节来表示它。我们将这颗星辰的光芒右移6位，然后加上192，放入输出的第一个字节；将这颗星辰的光芒与63进行按位与，然后加上128，放入输出的第二个字节；第三个字节设为0。

如果这颗星辰的亮度在2048到65535之间，那么我们需要三个字节来表示它。我们将这颗星辰的光芒右移12位，然后加上224，放入输出的第一个字节；将这颗星辰的光芒右移6位，然后与63进行按位与，再加上128，放入输出的第二个字节；将这颗星辰的光芒与63进行按位与，然后加上128，放入输出的第三个字节；第四个字节设为0。

如果这颗星辰的亮度在65536到1114111之间，那么我们需要四个字节来表示它。我们将这颗星辰的光芒右移18位，然后加上240，放入输出的第一个字节；将这颗星辰的光芒右移12位，然后与63进行按位与，再加上128，放入输出的第二个字节；将这颗星辰的光芒右移6位，然后与63进行按位与，再加上128，放入输出的第三个字节；将这颗星辰的光芒与63进行按位与，然后加上128，放入输出的第四个字节；第五个字节设为0。

如果这颗星辰的亮度超出了上述范围，那么它是无效的Unicode码点，我们将输出的第一个字节设为0。

这样，我们就完成了将星辰的光芒转化为UTF-8编码的过程。

```

用莎士比亚文集的风格描述伪代码.   
```
在这片数字的王国中，每一个Unicode码点都是一颗闪耀的星辰，等待着被编码成UTF-8的字节序列。我们的使命，是将这些星辰的光辉转化为可以传递的信号。

首先，我们需要确定这颗星辰的光辉，也就是Unicode码点的大小。如果它的光辉小于等于127，那么我们只需要一个字节来表示它。我们将这颗星辰的光辉直接放入输出的第一个字节，并将第二个字节设为0。

如果这颗星辰的光辉在128到2047之间，那么我们需要两个字节来表示它。我们将这颗星辰的光辉右移6位，然后加上192，放入输出的第一个字节；将这颗星辰的光辉与63进行按位与，然后加上128，放入输出的第二个字节；第三个字节设为0。

如果这颗星辰的光辉在2048到65535之间，那么我们需要三个字节来表示它。我们将这颗星辰的光辉右移12位，然后加上224，放入输出的第一个字节；将这颗星辰的光辉右移6位，然后与63进行按位与，再加上128，放入输出的第二个字节；将这颗星辰的光辉与63进行按位与，然后加上128，放入输出的第三个字节；第四个字节设为0。

如果这颗星辰的光辉在65536到1114111之间，那么我们需要四个字节来表示它。我们将这颗星辰的光辉右移18位，然后加上240，放入输出的第一个字节；将这颗星辰的光辉右移12位，然后与63进行按位与，再加上128，放入输出的第二个字节；将这颗星辰的光辉右移6位，然后与63进行按位与，再加上128，放入输出的第三个字节；将这颗星辰的光辉与63进行按位与，然后加上128，放入输出的第四个字节；第五个字节设为0。

如果这颗星辰的光辉超出了上述范围，那么它是无效的Unicode码点，我们将输出的第一个字节设为0。

这样，我们就完成了将星辰的光辉转化为UTF-8编码的过程。

```


看来变化已不大, 已经是重复套用一个模板、一套话术的方式, 没啥创新了.   
可能大模型的对中文的文科理解与表达水平就停在这一层次了.   
大模型的改进方向, 像`o1`一样的强逻辑推理, 应该是正确的.   
下轮大模型的训练与推理, 应该侧重跨学科、跨领域的强逻辑推理, 以此实现创新.   
