# 简单栈机示例.py 当简单教程用

# 基于栈的虚拟机实现
import sys

# 虚拟机的二进制指令集
class 指令集:
    终止 = 0
    输入 = 1
    输出 = 2
    加法 = 3
    减法 = 4
    乘法 = 5
    除法 = 6
    存内存 = 7
    取内存 = 8
    复制 = 9
    加载 = 10
    存储 = 11
    加载常量 = 12
    小于跳转 = 13
    小于等于跳转 = 14
    大于跳转 = 15
    大于等于跳转 = 16
    等于跳转 = 17
    不等于跳转 = 18
    无条件跳转 = 19
    无效 = 20

# 指令结构体
class 指令:
    def __init__(self, 指令码, 操作数):
        self.指令码 = 指令码
        self.操作数 = 操作数

# 栈
栈 = []

# 指令内存
指令内存 = []

# 数据内存
数据内存 = [0] * 101

# 状态码
class 状态码:
    终止 = 0
    正常 = 1
    除零错误 = 2
    数据内存错误 = 3
    指令内存错误 = 4
    堆栈溢出错误 = 5
    堆栈空错误 = 6
    弹出错误 = 7
    未知指令码错误 = 8

# 输出错误信息
def 错误(错误信息):
    print(错误信息, file=sys.stderr)

# 根据指令码返回指令码需要的操作数个数
def 获取操作数个数(指令码):
    if 指令码 in [指令集.存内存, 指令集.取内存, 指令集.加载常量, 指令集.小于跳转, 指令集.小于等于跳转, 指令集.大于跳转, 指令集.大于等于跳转, 指令集.等于跳转, 指令集.不等于跳转, 指令集.无条件跳转]:
        return 1
    else:
        return 0

# 读取指令
# 从字符串中读取指令码和操作数
# 这里读取的是文本，而非二进制
# 所以指令码占2位，操作数占4位
def 读取指令(字符串代码):
    索引 = 0
    while 索引 < len(字符串代码):
        字符串指令码 = 字符串代码[索引:索引+2]
        索引 += 2
        print(字符串指令码, end='')
        指令码 = int(字符串指令码)
        操作数个数 = 获取操作数个数(指令码)
        if 操作数个数 > 0:
            字符串操作数 = 字符串代码[索引:索引+4]
            索引 += 4
            操作数 = int(字符串操作数)
            print(f'\t{字符串操作数}', end='')
        else:
            操作数 = 0
        print()
        指令内存.append(指令(指令码, 操作数))

# 执行指令
def 执行指令():
    索引 = 0
    while 索引 < len(指令内存) and 指令内存[索引].指令码 != 指令集.终止:
        索引变化 = False
        跳转索引 = 0
        当前指令 = 指令内存[索引]
        if 当前指令.指令码 == 指令集.终止:  # 终止
            break
        elif 当前指令.指令码 == 指令集.输入:  # 输入
            临时变量 = int(input("输入："))
            栈.append(临时变量)
        elif 当前指令.指令码 == 指令集.输出:  # 输出
            临时变量 = 栈.pop()
            print(临时变量)
        elif 当前指令.指令码 == 指令集.加法:  # 加法
            a = 栈.pop()
            b = 栈.pop()
            c = b + a
            栈.append(c)
        elif 当前指令.指令码 == 指令集.减法:  # 减法
            a = 栈.pop()
            b = 栈.pop()
            c = b - a
            栈.append(c)
        elif 当前指令.指令码 == 指令集.乘法:  # 乘法
            a = 栈.pop()
            b = 栈.pop()
            c = b * a
            栈.append(c)
        elif 当前指令.指令码 == 指令集.除法:  # 除法
            a = 栈.pop()
            b = 栈.pop()
            if a == 0:
                错误("除数为0")
            else:
                c = b // a
                栈.append(c)
        elif 当前指令.指令码 == 指令集.存内存:
            地址 = 当前指令.操作数
            if 地址 < 0 or 地址 >= len(数据内存):
                错误("数据地址错误")
            else:
                数据内存[地址] = 栈.pop()
        elif 当前指令.指令码 == 指令集.取内存:
            地址 = 当前指令.操作数
            if 地址 < 0 or 地址 >= len(数据内存):
                错误("数据地址错误")
            else:
                栈.append(数据内存[地址])
        elif 当前指令.指令码 == 指令集.复制:  # 将栈顶元素的值重复压栈
            栈.append(栈[-1])
        elif 当前指令.指令码 == 指令集.加载:  # 弹出栈顶元素值，以值为地址，将该地址上的值压栈
            地址 = 栈.pop()
            if 地址 < 0 or 地址 >= len(数据内存):
                错误("地址错误")
            else:
                栈.append(数据内存[地址])
        elif 当前指令.指令码 == 指令集.存储:  # 弹出值，再弹出地址，将值赋予该地址
            值 = 栈.pop()
            地址 = 栈.pop()
            if 地址 < 0 or 地址 >= len(数据内存):
                错误("地址错误")
            else:
                数据内存[地址] = 值
        elif 当前指令.指令码 == 指令集.加载常量:  # 该指令有参数，将该参数压入栈中
            栈.append(当前指令.操作数)
        elif 当前指令.指令码 == 指令集.小于跳转:  # 该指令有参数，如果从栈中弹出的值小于0，则指令指针寄存器跳转到操作数
            临时变量 = 栈.pop()
            if 临时变量 < 0:
                索引变化 = True
                跳转索引 = 当前指令.操作数
        elif 当前指令.指令码 == 指令集.小于等于跳转:  # <=
            临时变量 = 栈.pop()
            if 临时变量 <= 0:
                索引变化 = True
                跳转索引 = 当前指令.操作数
        elif 当前指令.指令码 == 指令集.大于跳转:  # >
            临时变量 = 栈.pop()
            if 临时变量 > 0:
                索引变化 = True
                跳转索引 = 当前指令.操作数
        elif 当前指令.指令码 == 指令集.大于等于跳转:  # >=
            临时变量 = 栈.pop()
            if 临时变量 >= 0:
                索引变化 = True
                跳转索引 = 当前指令.操作数
        elif 当前指令.指令码 == 指令集.等于跳转:  # ==
            临时变量 = 栈.pop()
            if 临时变量 == 0:
                索引变化 = True
                跳转索引 = 当前指令.操作数
        elif 当前指令.指令码 == 指令集.不等于跳转:  # !=
            临时变量 = 栈.pop()
            if 临时变量 != 0:
                索引变化 = True
                跳转索引 = 当前指令.操作数
        elif 当前指令.指令码 == 指令集.无条件跳转:  # 无条件
            索引变化 = True
            跳转索引 = 当前指令.操作数
        else:
            错误("未知指令码")

        if 索引变化:
            索引 = 跳转索引
        else:
            索引 += 1

# 复位虚拟机
def 复位():
    global 指令内存, 数据内存, 栈
    指令内存 = []
    数据内存 = [0] * 101
    栈 = []

# 主函数
def 主函数():
    while True:
        字符串代码 = input()
        读取指令(字符串代码)
        执行指令()
        复位()

if __name__ == "__main__":
    主函数()