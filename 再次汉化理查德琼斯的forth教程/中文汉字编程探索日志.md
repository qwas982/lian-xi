中文汉字编程探索日志;    

连日来的一些研究, 让我获得了一些创新的灵感.    

把栈语言当做中间码用, 或虚拟机的汇编.    
把跑栈语言的线程码当做虚拟机用.    

因树语言的语法几乎等价于抽象句法树,    
所以语法分析可以翻译成树语言AST来用.    

源码使用什么文法呢?    
使用文言 + 白话, 混合一些日常口语化, 的这么一种伪代码风格.    
APL+forth+uiua?    
继续探索.    

//
完善设计想法;    

源码我设定/假设为; 一种基于中文汉字的伪代码.    

`词法分析/字词剖开`打算用`元轮求值`这种解释型算法进行实现, 就不用文法 + 状态机了, 虽然元轮求值已经包括了个简单版本.    

`语法分析/句法(句段)剖开`打算用符号表达式的结构实现. 同样用元轮求值算法实现.    

中间码打算用forth程序风格实现, 它也是图灵完备的, 也就是说即便是前端来的源码再复杂, 也可以执行.    

虚拟CPU使用仿真技术, 加上LEB128编码为二进制, 使用forth的线程码执行, 以此获得仅次于跑二进制的最高效率.    
当然, 也是看重仿真技术的跨平台可移植特点.    

//2024年12月12日更新
通过与大模型交流与做各种测试,
我找到一种适合用伪代码实现中文编程的语法(句法).

从py里学习缩进的使用,    
从lisp里学习波兰表达式的使用,    
加上分割表达式的 `.`句号的使用, BTW 也可以用中文汉字的句号 `。`     

提示语: 使用 `.`句号, 与 `    ` 缩进, 与 `PN`波兰表达式设计一种可以替代lisp的 `()`括号的语法.     
思考下, 测试用 `. 符号 .`  替代 `( 符号 )` 是否可行.    
得到演示如下;    
```
+
    *
        2
        3.
    4.
```

```
if
    >
        x
        0.
    print
        "Positive".
    print
        "Negative.".
```
还有很多提示语, 就不一一列出了,    

尝试过多种形式, 似乎这样更适合常人表达习惯.    
波兰表达式默认实现前缀法,    
用缩进替代括号表示分支与程序树的深度,    
用句号分开每句表达式或语句,    
其它的功能可以学习lisp的宏去实现, 比如数组、结构等等.    
当然, 这种形式也直接继承了lisp的那些优点.    

若把此类形式视为中文汉字伪代码编程的源码, 那么我们可以写一个求值器读取这样的源码,    
解释这样的源码为lisp的符号表达式, 因为 `S expr`几乎等同于AST,    

随后, 使用后序遍历的方式遍历AST, 得到一种序列, 类似于forth句法的逆波兰表达式,    
这里有个疑惑, 待会儿再延伸推理,    

疑惑是, 先模仿SICP第五章编译符号表达式, 还是先遍历符号表达式,    
直接遍历的话, 生成的逆波兰表达式会过于复杂, 这样的话, 后面阶段的forth编译器需要做更多工作,    
先编译符号表达式再遍历的话, 就会得到常规复杂度的指令, 或中间码,    
再翻译这个中间码为forth程序, forth编译器就可以做得很简单.    
这样一来, 复杂的工作就转移到把符号表达式编译为指令的编译工作上来了.    
但这有现成的样例可供参考, 似乎容易很多.    
不过这样却失去了挑战创新的0到1步骤.    


接着, 使用forth编译器, 把逆波兰表达式编译为forth程序,    
使用forth的直接线程码与间接线程码, 加它的两个栈, 与字典等组件, 组成forth虚拟机,    
或增强forth虚拟机变成一个虚拟CPU,使其应用范围变广泛,    
最后使用这个虚拟机读取已编译的forth字, 再执行forth程序完成计算.    

总结:    
源码为 -> 使用 `.`句号, 与 `    ` 缩进, 与 `PN`波兰表达式, 组成的字符串.    
中间形式为 -> 符号表达式.    
后端为 -> forth程序 + 线程码虚拟机.    

需要写三个编译器;    
源码编译器, lisp编译器, forth编译器.    
幸运的是, 全都有可供参考的样例.    

当然也可以直接编译为某架构的机器码, forth也曾有自己的专用CPU,    
但为了便携可移植, 还是要在虚拟机阶段, 编码为 `LEB128`,    
在forth编译器后面, 增加一步, 把forth字编码为LEB128二进制序列,    

源码程序使用栈与帧(框)管理, 还是使用环境管理, 还有待论证.    
后端内存模型也需要细化, 是否可以借鉴WASM的方式.    

//
问了大模型, 发现仅使用句号与缩进与波兰表达式, 无法实现宏与元编程,    
还得有专门的解析规则来解析代码块与关键字, 这就与初衷背道而驰了,    
还得是括号啊, 经过时间检验的.    


//
按照以下步骤处理我给你的文件;    
我需要你 `用思维链`思考{ `把所给文件内源码逻辑翻译为等价的伪代码.`     
`用中文伪代码精确描述这些代码的逻辑.`    
`中文伪代码必须完全用中文描述, 包括所有标识符, 要更加地偏向日常汉语表达来描述中文伪代码, 多利用汉字的特点与优点.`
`汉语要更偏向于社交网络化表达, 汉字的使用要更接近文言文, 但不能全部是文言, 多一些白话文.`    
`步骤不用显示出来, 仅给出最终结果.` }    
1.思考后直接给出伪代码演示, 需要包含给定文件内的全部逻辑.    


我搞明白了, 产品经理的功能, 就是 `用自然语言描述项目的算法之集合`.    
原来如此.    
因为 `一个项目`里有很多 `模块`, 模块里有很多 `文件`, 文件内有很多 `函数与结构与数据`, `流程`, 还有 `离散的组织方式`.    
这不就是树形结构或图结构的 `复合形式算法`吗?    
`主算法 -> 子算法 -> 子算法 ...`    
除了这些, 产品经理还要组织 `人|事|物`, 我们可不可以把这个 `行为过程`也看作是算法?    
递归使用上述描述来组织人|事|物? 原来如此.    
所以说白了, 就是 `用自然语言描述算法`.    

```
算法 = { 算法 => 步骤 => 指令 => 操作 => 变量 }
变量 = 状态
状态 = { 变量 , 顺序 , 跳转 }
```

而训练了 `自然语言通用理解能力与数学理解能力的大模型`, 岂不是很擅长这点?    
`即-自然语言 => 算法的转化`.    
再用训练了 `编程的大模型`, 将算法代码化, 之后再用黑盒测试.    
训练一个专门 `审查review与测试`的大模型, 进行黑盒测试, 有问题再 `跳转`到编程大模型进行修改.    
三个大模型互相配合, 是否足以应付起码1万行起步的程序项目-软件工程?    

使用者-人-用户, 只需要用自然语言描述自己软件需求, 只要芯片的计算速度够快, 这是要秒秒钟出软件成果的节奏啊.    
不可思议.    

把它们打包成一个应用app;    
是否需要第四个大模型来协调前三个大模型的配合?    
或许只需要写个简单的状态机就够了? 所谓的代理agent似乎有些多此一举的样子.    

哦, 不对, 确实需要 `第四个`大模型, 充当记忆的角色. `图灵机 = 无限状态机`.    
要记住有限个状态, 组织 `前三个`大模型, 使其正交, 理解来自于 `使用者-人-用户`的任务需求, 协调与配合前三个大模型.    
确实需要第四个大模型来做到这点.    
这 `#4`大模型需要翻译一遍人的需求给 `#1`大模型, 因为人的需求描述是模糊的,    
也就是充当自然语言到自然语言的翻译. 相当于是人的助手或副官.    

有很多人可能已经想到了, 可以把它们四个大模型合在一起训练, 但这是闭源大模型搞的事.    
开源大模型就灵活多了, 咱们可以专门训练4个垂直的小模型, 使用时组合到一起就是了.    
微积分的思想啊这是, lambda演算... (´･_･`)    

; ------------------------------------------------------------------------------

为了实现lambda纯函数式编程,    
在一个具有{ `应用 , 求值 , 环境 , 内存管理与垃圾回收` }的基本条件基础上,    
初始环境必须具备{ `quote, atom, eq, define, lambda , load , print` }.    
这些元素是构建函数式编程环境所必需的基本操作和功能.    
使得程序能够定义和操作函数,处理表达式,并进行基本的对比和定义.    

在具备了上述这些基本条件后,    
可以通过lambda演算定义{ `car, cdr, cons, if, Y组合子` }.    
这些定义展示了如何在纯函数式编程环境中,    
利用lambda表达式和基本操作来构建更复杂的操作和实现递归.    

`锚 = Y组合子`    
`入 = lambda`    

若要实现宏,    
还需要在以上基础上定义{ `cond, and, or, not, pair?, else` }.    
之后才有足够条件实现宏操作.    


; -----------------------------------------------------------------

用py写一个lisp解释器,    
支持 `原子,列表,数字,符号,字符串`, `函数`(过程), `表达式`.    
必须具备以下元素;    

有哈希表, 基于哈希表的环境(支持词法作用域),    
重视Unicode的支持,善用 `.encode()`方法与 `.decode()`方法.     
基于状态机的词法分析器(灵活用 `chr`与 `ord`完整支持Unicode),    
基于递归下降的语法分析器(灵活用chr与ord完整支持Unicode),    
一个元循环求值器(遍历AST求值与应用),     
必须实现以下特殊形式 `quote, atom, eq, define, lambda` , `load`(灵活用chr与ord完整支持Unicode) , `print`(灵活用chr与ord完整支持Unicode).    
一个`repl`(灵活用chr与ord完整支持Unicode).    
环境内初始原语支持多参数的算术逻辑运算.    

尽量使用py的先进功能, 例如oop, 工厂模式, 元类, 闭包, 推导式, 迭代器, 类型提示, 函数式编程, 数据类等功能!    
