/*
使用https://chat.mistral.ai/chat 大模型翻译汇编.

把这段gas汇编代码翻译为等价的NASM汇编代码. 
并且,涉及到特殊的复杂指令,要替换为更简单的指令组合来实现. 
要确保翻译后,执行结果完全相同. 
不要用lodsb, movzx等等的这些复杂指令与变体指令, 要用最简单的指令实现.
*/

%include "th.inc"

/*	一个有时最小的FORTH编译器和Linux/i386系统的教程。 -*- 汇编 -*-
	作者：Richard W.M. Jones <rich@annexia.org> http://annexia.org/forth
	这是公共领域（见下面的公共领域发布声明）。
	$Id: jonesforth.S,v 1.47 2009-09-11 08:33:13 rich Exp $

	gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
*/
琼斯_版本 等同 47
/*
	引言 ----------------------------------------------------------------------

	FORTH 是那些大多数工作程序员认为与 Haskell、LISP 等类似的异类语言之一。它们是如此奇怪，以至于他们宁愿不去想它，以便能够继续编写这份有报酬的代码。但这是错误的，如果你对编程有任何关心，那么你应该至少理解所有这些语言，即使你永远不会使用它们。

	LISP 是终极的高级语言，LISP 的特性每十年都会被添加到更常见的语言中。但在某些方面，FORTH 是低级编程的终极体现。开箱即用，它缺乏动态内存管理甚至字符串等功能。事实上，在其原始级别上，它甚至缺乏 IF-语句和循环等基本概念。

	那么，你为什么要学习 FORTH 呢？有几个非常好的理由。首先，最重要的是，FORTH 是极简的。你真的可以用大约 2000 行代码编写一个完整的 FORTH。我不仅仅是指一个 FORTH 程序，我指的是一个完整的 FORTH 操作系统、环境和语言。你可以在一个裸露的 PC 上启动这样的 FORTH，它会出现一个提示符，你可以在那里开始做有用的工作。这里的 FORTH 不是极简的，并且使用 Linux 进程作为其“基础 PC”（为了使其成为一个好的教程）。完全理解这个系统是可能的。谁能说他们完全理解 Linux 或 gcc 的工作原理？

	其次，FORTH 具有一种特殊的自举特性。我的意思是，在编写了一点汇编代码与硬件对话并实现一些原语之后，语言和编译器的所有其余部分都是用 FORTH 本身编写的。还记得我之前说过 FORTH 缺乏 IF-语句和循环吗？当然，它实际上并不缺乏，因为这样的语言是无用的，但我的意思是 IF-语句和循环是用 FORTH 本身编写的。

	当然，这在其他语言中也很常见，在那些语言中我们称之为“库”。例如，在 C 中，'printf' 是一个用 C 编写的库函数。但在 FORTH 中，这远远超出了单纯的库。你能想象用 C 编写 C 的 'if' 吗？这引出了我的第三个理由：如果你能在 FORTH 中编写 'if'，那么为什么要限制自己使用通常的 if/while/for/switch 结构呢？你想要一个遍历数字列表中每隔一个元素的结构吗？你可以将其添加到语言中。或者，如何添加一个直接从配置文件中提取变量并使其作为 FORTH 变量可用的操作符？或者，如何向语言添加类似 Makefile 的依赖关系？在 FORTH 中没有问题。如何修改 FORTH 编译器以允许复杂的内联策略——简单。这个概念在编程语言中并不常见，但它有两个名字：“宏”（我的意思是 LISP 风格的宏，而不是 C 预处理器）和“领域特定语言”（DSLs）。

	本教程不是关于学习 FORTH 语言的。如果你不熟悉使用 FORTH，我会向你推荐一些你应该阅读的参考资料。本教程是关于如何编写 FORTH 的。事实上，直到你理解了 FORTH 是如何编写的，你才会对如何使用它有一个非常肤浅的理解。

	所以，如果你不熟悉 FORTH 或想刷新你的记忆，这里有一些在线参考资料可以阅读：

	http://en.wikipedia.org/wiki/Forth_%28programming_language%29

	http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm

	http://wiki.laptop.org/go/Forth_Lessons

	http://www.albany.net/~hello/simple.htm

	这里还有另一篇“为什么选择 FORTH？”的文章：http://www.jwdt.com/~paysan/why-forth.html

	关于这个 FORTH 的讨论和批评在这里：http://lambda-the-ultimate.org/node/2452
*/

/*
	致谢 ----------------------------------------------------------------------

	此代码大量借鉴了 Albert van der Horst 的 LINA FORTH（http://home.hccnet.nl/a.w.m.van.der.horst/lina.html）的设计。代码中的任何相似之处可能并非偶然。

	此 FORTH 的某些部分也基于 1992 年的这个 IOCCC 条目：
	http://ftp.funet.fi/pub/doc/IOCCC/1992/buzzard.2.design。当 Sean Barrett，这个 IOCCC 条目的原作者，在 LtU 线程中评论这个 FORTH 时，我感到非常自豪。
	http://lambda-the-ultimate.org/node/2452#comment-36818

	最后，我要感谢（可能已被遗忘的？）ARTIC FORTH 的作者，因为他们最初的程序，我仍然保留在原始的盒式磁带上，多年来一直困扰着我。
	http://en.wikipedia.org/wiki/Artic_Software
*/

/*
	公共领域 ----------------------------------------------------------------------

	我，此作品的版权持有者，特此将其发布到公共领域。这适用于全球范围。

	如果这在法律上不可行，我授予任何实体使用此作品的任何目的的权利，没有任何条件，除非法律要求此类条件。
*/


/*
	设置 ----------------------------------------------------------------------

	让我们先处理一些家务事。首先，因为我需要画很多 ASCII 艺术图来解释概念，最好的查看方式是使用一个固定宽度字体且至少这么宽的窗口：

 <------------------------------------------------------------------------------------------------------------------------>

	其次，确保 TAB 设置为 8 个字符。以下应该是一条垂直线。如果不是，请整理你的 TAB。

		|
	        |
	    	|

	第三，我假设你的屏幕至少有 50 行高。
*/

/*
	汇编 ----------------------------------------------------------------------

	如果你想实际运行这个 FORTH，而不是仅仅阅读它，你需要在 i386 上运行 Linux。Linux 是因为我没有直接在裸机 PC 上编程，而是选择了一个更简单的教程，假设“硬件”是一个具有一些基本系统调用（read、write 和 exit，差不多就这些）的 Linux 进程。i386 是必需的，因为我必须为处理器编写汇编代码，而 i386 是目前最常见的。（当然，当我说“i386”时，任何 32 位或 64 位的 x86 处理器都可以。我是在 64 位 AMD Opteron 上编译这个的）。

	再次，要汇编这个，你需要 gcc 和 gas（GNU 汇编器）。汇编和运行代码的命令（将此文件保存为 'jonesforth.S'）是：

	gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
	cat jonesforth.f - | ./jonesforth

	如果你想运行你自己的 FORTH 程序，你可以这样做：

	cat jonesforth.f myprog.f | ./jonesforth

	如果你想加载你自己的 FORTH 代码然后继续读取用户命令，你可以这样做：

	cat jonesforth.f myfunctions.f - | ./jonesforth
*/

/*
	汇编器 ----------------------------------------------------------------------

	（你可以直接跳到下一部分——你不需要能够读懂汇编器来跟随这个教程）。

	然而，如果你确实想阅读这里的汇编代码，这里有关于 gas（GNU 汇编器）的一些注释：

	(1) 寄存器名称前缀为 '%'，所以 %eax 是 32 位 i386 累加器。i386 上可用的寄存器有：%eax, %ebx, %ecx, %edx, %esi, %edi, %ebp 和 %esp，其中大多数有特殊用途。

	(2) 加法、移动等操作的参数形式为 SRC,DEST。所以 mov %eax,%ecx 将 %eax 移动到 %ecx。

	(3) 常量前缀为 '$'，你一定不要忘记它！如果你忘记了，它会导致从内存中读取，所以：
	    mov $2,%eax		将数字 2 移动到 %eax
	    mov 2,%eax		从地址 2 读取 32 位字到 %eax（即很可能是一个错误）

	(4) gas 有一个用于局部标签的时髦语法，其中 '1f'（等等）表示标签 '1:' "向前"，而 '1b'（等等）表示标签 '1:' "向后"。注意这些标签可能会被误认为是十六进制数字（例如，你可能会将 1b 与 $0x1b 混淆）。

	(5) 'ja' 是 "如果大于则跳转"，'jb' 是 "如果小于则跳转"，'je' 是 "如果相等则跳转" 等等。

	(6) gas 有一个相当不错的 .macro 语法，我大量使用它们来使代码更短且不那么重复。

	有关阅读汇编器的更多帮助，请在 Linux 提示符下执行 "info gas"。

	现在教程正式开始。
*/

/*
	字典 ----------------------------------------------------------------------

	在 FORTH 中，正如你所知，函数被称为“字”，就像在其他语言中一样，它们有一个名称和一个定义。这里有两个 FORTH 字：

	: DOUBLE 副本 + ;		\ 名称是 "DOUBLE"，定义是 "副本 +"
	: QUADRUPLE DOUBLE DOUBLE ;	\ 名称是 "QUADRUPLE"，定义是 "DOUBLE DOUBLE"

	字，无论是内建的还是程序员后来定义的，都存储在一个字典中，这个字典只是一个字典条目的链表。

	<--- 字典条目（头部） ----------------------->
	+------------------------+--------+---------- - - - - +----------- - - - -
	| 链接指针               | 长度/ | 名称	      | 定义
	|			 | 旗   |     	      |
	+--- (4 字节) ----------+- 字节 -+- n 字节  - - - - +----------- - - - -

	我稍后会谈到字的定义。现在只看头部。前 4 个字节是链接指针。
	它指向字典中前一个字，或者对于字典中的第一个字，它只是一个 NULL 指针。
	然后是一个长度/旗字节。字的长度可以达到 31 个字符（使用 5 位），前 3 位用于各种旗，我稍后会谈到。
	接下来是名称本身，在这个实现中，名称通过用零字节填充来四舍五入到 4 字节的倍数。
	这只是为了确保定义从 32 位边界开始。

	一个名为 最后 的 FORTH 变量包含一个指向最近定义的字的指针，换句话说，是这个链表的头。

	DOUBLE 和 QUADRUPLE 可能看起来像这样：

	  pointer to previous word
	   ^
	   |
	+--|------+---+---+---+---+---+---+---+---+------------- - - - -
	| LINK    | 6 | D | O | U | B | L | E | 0 | (definition ...)
	+---------+---+---+---+---+---+---+---+---+------------- - - - -
           ^       len                         padding
	   |
	+--|------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
	| LINK    | 9 | Q | U | A | D | R | U | P | L | E | 0 | 0 | (definition ...)
	+---------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
           ^       len                                     padding
           |
           |
	  最后

	你应该能够从这里看到如何在字典中查找字（只需从 最后 开始沿着字典条目匹配名称，
	直到找到匹配或到达字典末尾的 NULL 指针）；以及如何在字典中添加字（创建一个新的定义，
	将其 LINK 设置为 LATEST，并将 最后 指向新字）。我们稍后会在汇编代码中看到这些函数的精确实现。

	使用链表的一个有趣后果是你可以重新定义字，并且一个字的新定义会覆盖旧定义。
	这是 FORTH 中的一个重要概念，因为它意味着任何字（甚至是“内建”或“标准”字）都可以用新定义覆盖，
	无论是为了增强它、使其更快，甚至是为了禁用它。
	然而，由于 FORTH 字的编译方式（你将在下面理解），使用旧定义定义的字继续使用旧定义。
	只有在新的定义之后定义的字才使用新的定义。
*/

/*
	直接线程代码 ----------------------------------------------------------------------

	现在我们将进入理解 FORTH 的真正关键部分，所以去拿一杯茶或咖啡，坐下来。
	可以说，如果你不理解这一部分，那么你就不会“明白”FORTH 是如何工作的，那将是我没有解释清楚的失败。
	所以，如果你在阅读这一部分几次后仍然不理解，请给我发邮件（rich@annexia.org）。

	首先让我们谈谈“线程代码”的含义。
	想象一个特殊的 C 版本，你只能调用没有参数的函数。（现在不用担心这种语言会完全无用！）所以在我们的特殊 C 中，
	代码看起来像这样：

	f ()
	{
	  a ();
	  b ();
	  c ();
	}

	等等。一个函数，比如上面的 'f'，会被标准的 C 编译器编译成什么样的汇编代码呢？可能是这样的。
	在右边我写了实际的 i386 机器码。

	f:
	  CALL a			E8 08 00 00 00
	  CALL b			E8 1C 00 00 00
	  CALL c			E8 2C 00 00 00
	  ; 暂时忽略函数的返回

	“E8”是 x86 机器码，用于“调用”一个函数。
	在计算的前 20 年，内存非常昂贵，我们可能会担心重复的“E8”字节浪费的空间。
	我们可以通过推缩成以下内容来节省 20% 的代码大小（因此，在昂贵的内存中）：

	08 00 00 00		只是函数地址，没有 CALL 前缀。
	1C 00 00 00
	2C 00 00 00

	在像最初运行 FORTH 的 16 位机器上，节省的空间更大 - 33%。

	[历史注释：如果 FORTH 使用的执行模型从下面的段落看起来很奇怪，那么它完全是由在早期计算机上节省内存的需求所驱动的。
	这种代码压缩在现在我们的机器的 L1 缓存中的内存比那些早期计算机总共拥有的内存还要多的情况下并不那么重要，但这种执行模型仍然有一些有用的特性]。

	当然，这种代码不能再直接在 CPU 上运行了。
	相反，我们需要编写一个解释器，它接受每一组字节并调用它。

	在 i386 机器上，我们实际上可以很容易地编写这个解释器，只需两个汇编指令，总共只有 3 字节的机器码。
	让我们将指向下一个要执行的字的指针存储在 %esi 寄存器中：

		08 00 00 00	<- 我们现在正在执行这个。%esi 是下一个要执行的。
	%esi -> 1C 00 00 00
		2C 00 00 00

	重要的 i386 指令称为 LODSL（或在 Intel 手册中称为 LODSW）。
	它做两件事。首先，它将 %esi 处的内存读入累加器（%eax）。
	其次，它将 %esi 增加 4 字节。所以在 LODSL 之后，情况现在看起来像这样：

		08 00 00 00	<- 我们仍然在执行这个
		1C 00 00 00	<- %eax 现在包含这个地址（0x0000001C）
	%esi -> 2C 00 00 00

	现在我们只需要跳转到 %eax 中的地址。这又只是一个 x86 指令，写成 JMP *(%eax)。在跳转之后，情况看起来像：

		08 00 00 00
		1C 00 00 00	<- 现在我们正在执行这个子程序。
	%esi -> 2C 00 00 00

	为了使这工作，每个子程序后面都跟着两个指令 'LODSL; JMP *(%eax)'，它们实际上跳转到下一个子程序。

	这就引出了我们的第一段实际代码！嗯，这是一个宏。
*/

/* 下一个 macro. */
%macro 下一个 0
    移 甲, [金]
    加 金, 4
    跳 甲
%endmacro


/*	这个宏被称为 NEXT。这是一个 FORTH 术语。它扩展为这两个指令。

	我们编写的每个 FORTH 原语都必须以 下一个 结束。可以把它想象成某种返回。

	上面描述的是所谓的直接线程代码。

	总结一下：我们将函数调用压缩为地址列表，并使用一个有点神奇的宏作为“跳转到列表中的下一个函数”。我们还使用一个寄存器（%esi）作为某种指令指针，指向列表中的下一个函数。

	我只想说，一个 FORTH 定义，比如：

	: QUADRUPLE DOUBLE DOUBLE ;

	实际上编译（几乎，但不完全，但我们会看到为什么）为 DOUBLE、DOUBLE 和名为 出口 的特殊函数的地址列表。

	在这一点上，真正目光敏锐的汇编专家会说“JONES，你犯了一个错误！”。

	我关于 JMP *(%eax) 的说法是错误的。
*/

/*
	间接线程代码 ----------------------------------------------------------------------

	事实证明，直接线程代码很有趣，但只有当你只想执行用汇编语言编写的一系列函数时才有用。
	所以 QUADRUPLE 只有在 DOUBLE 是一个汇编语言函数时才会工作。
	在直接线程代码中，QUADRUPLE 看起来像：

		+------------------+
		| addr of DOUBLE  --------------------> (assembly code to do the double)
		+------------------+                    下一个
	%esi ->	| addr of DOUBLE   |
		+------------------+

	我们可以增加一个间接层，
	以允许我们运行用汇编语言编写的字（为速度编写的原语）和用 FORTH 本身编写的字作为地址列表。

	额外的间接层是 JMP *(%eax) 中括号的原因。

	让我们看看 QUADRUPLE 和 DOUBLE 在 FORTH 中真正的样子：

	        : QUADRUPLE DOUBLE DOUBLE ;

		+------------------+
		| codeword         |		   : DOUBLE 副本 + ;
		+------------------+
		| addr of DOUBLE  ---------------> +------------------+
		+------------------+               | codeword         |
		| addr of DOUBLE   |		   +------------------+
		+------------------+	   	   | addr of 副本   --------------> +------------------+
		| addr of 出口	   |		   +------------------+            | codeword      -------+
		+------------------+	   	   | addr of +     --------+	   +------------------+   |
						   +------------------+	   |	   | assembly to    <-----+
						   | addr of 出口     |    |       | implement 副本    |
						   +------------------+	   |	   |	..	      |
									   |	   |    ..            |
									   |	   | 下一个             |
									   |	   +------------------+
									   |
									   +-----> +------------------+
										   | codeword      -------+
										   +------------------+   |
										   | assembly to   <------+
										   | implement +      |
										   | 	..            |
										   | 	..            |
										   | 下一个      	      |
										   +------------------+

	这是你可能需要额外一杯茶/咖啡/你喜欢的含咖啡因饮料的部分。
	变化的是我在定义的开头添加了一个额外的指针。在 FORTH 中，这有时被称为“代码字”。
	代码字是一个指向解释器来运行函数的指针。
	对于用汇编语言编写的原语，“解释器”只是指向实际的汇编代码本身。它们不需要解释，它们只是运行。

	在用 FORTH 编写的字（如 QUADRUPLE 和 DOUBLE）中，代码字指向一个解释器函数。

	我很快就会向你展示解释器函数，但让我们回顾一下我们的间接 JMP *(%eax) 和“额外”的括号。
	以我们正在执行 DOUBLE 的情况为例，并且已经调用了 DUP。注意 %esi 指向 `+` 的地址。

	副本 的汇编代码最终会执行 NEXT。那：

	(1) 将 + 的地址读入 %eax		%eax 指向 + 的代码字
	(2) 将 %esi 增加 4
	(3) 跳转到间接 %eax			跳转到 + 的代码字中的地址，
							即实现 + 的汇编代码

		+------------------+
		| codeword         |
		+------------------+
		| addr of DOUBLE  ---------------> +------------------+
		+------------------+               | codeword         |
		| addr of DOUBLE   |		   +------------------+
		+------------------+	   	   | addr of 副本   --------------> +------------------+
		| addr of 出口	   |		   +------------------+            | codeword      -------+
		+------------------+	   	   | addr of +     --------+	   +------------------+   |
						   +------------------+	   |	   | assembly to    <-----+
					   %esi -> | addr of 出口     |    |       | implement 副本    |
						   +------------------+	   |	   |	..	      |
									   |	   |    ..            |
									   |	   | 下一个             |
									   |	   +------------------+
									   |
									   +-----> +------------------+
										   | codeword      -------+
										   +------------------+   |
									now we're  | assembly to    <-----+
									executing  | implement +      |
									this	   | 	..            |
									function   | 	..            |
										   | 下一个      	      |
										   +------------------+

	所以，我希望我已经说服了你，NEXT 大致做了你期望的事情。这是间接线程代码。

	我忽略了四件事。
	我想知道你是否能在继续阅读之前猜到它们是什么？

	.
	.
	.

	我的四件事清单是：
	(1) “EXIT” 是做什么的？
	(2) 与 (1) 相关的是你如何调用一个函数，即 %esi 如何开始指向 QUADRUPLE 的一部分，然后指向 DOUBLE 的一部分。
	(3) 在用 FORTH 编写的字的代码字中放什么？
	(4) 如何编译一个除了调用其他函数之外还做其他事情的函数，例如包含一个数字的函数：: DOUBLE 2 * ; ？
*/

/*
	解释器和返回栈 ------------------------------------------------------------

	让我们不按特定顺序讨论问题 (3) 和 (2)，解释器和返回栈。

	在 FORTH 中定义的字需要一个代码字，它指向一小段代码，为它们的生活提供“帮助”。
	它们不需要太多，但它们确实需要所谓的“解释器”，尽管它并不真正以与 Java 字节码曾经被解释（即缓慢）相同的方式“解释”。
	这个解释器只是设置一些机器寄存器，以便字可以使用上面的间接线程模型以全速执行。

	当 QUADRUPLE 调用 DOUBLE 时，需要发生的一件事是我们保存旧的 %esi（“指令指针”）并创建一个新的指向 DOUBLE 中的第一个字。
	因为我们需要在 DOUBLE 结束时恢复旧的 %esi（毕竟，这就像一个函数调用），我们将需要一个栈来存储这些“返回地址”（旧的 %esi 值）。

	正如你在背景文档中看到的，FORTH 有两个栈，一个普通的参数栈，和一个更神秘的返回栈。
	但我们的返回栈只是我在上一段中谈到的栈，用于在从 FORTH 字调用另一个 FORTH 字时保存 %esi。

	在这个 FORTH 中，我们使用普通的栈指针（%esp）作为参数栈。
	我们将使用 i386 的“另一个”栈指针（%ebp，通常称为“帧指针”）作为我们的返回栈。

	我有两个宏，它们只是包装了使用 %ebp 作为返回栈的细节。
	你可以像使用“PUSHRSP %eax”（将 %eax 推入返回栈）或“POPRSP %ebx”（将返回栈顶弹出到 %ebx）一样使用它们。
*/

/* Macros to deal with the return stack. */
%macro 推返回栈 1
    减 基指针, 4          ; push reg onto return stack
    移 [基指针], %1
%endmacro

%macro 弹返回栈 1
    移 %1, [基指针]       ; pop top of return stack to reg
    加 基指针, 4
%endmacro


/*
	有了这些，我们现在可以谈谈解释器了。

	在 FORTH 中，解释器函数通常称为 DOCOL（我认为它的意思是“DO COLON”，因为所有 FORTH 定义都以冒号开头，
	如 : DOUBLE 副本 + ;

	“解释器”（它并不真正“解释”）只需要将旧的 %esi 推入栈并设置 %esi 指向定义中的第一个字。
	记住我们使用 JMP *(%eax) 跳转到函数吗？
	好吧，一个后果是方便地 %eax 包含了这个代码字的地址，所以只需将其加 4，我们就可以得到第一个数据字的地址。
	最后，在设置 %esi 之后，它只需执行 NEXT，这将导致第一个字运行。
*/

/* 做冒号 - the interpreter! */
节 .text
对齐 4
做冒号:
    推返回栈 金         ; push %esi onto the return stack
    加 甲, 4          ; %eax points to codeword, so make
    移 金, 甲        ; %esi point to first data word
    下一个                ; 执行 the 下一个 instruction


/*
	只是为了确保这一点绝对清楚，让我们看看从 QUADRUPLE 跳转到 DOUBLE 时 做冒号 是如何工作的：

		QUADRUPLE:
		+------------------+
		| codeword         |
		+------------------+		   DOUBLE:
		| addr of DOUBLE  ---------------> +------------------+
		+------------------+       %eax -> | addr of 做冒号    |
	%esi ->	| addr of DOUBLE   |		   +------------------+
		+------------------+	   	   | addr of 副本      |
		| addr of 出口	   |		   +------------------+
		+------------------+               | etc.             |

	首先，对 DOUBLE 的调用会调用 DOCOL（DOUBLE 的代码字）。
	做冒号 这样做：它将旧的 %esi 推入返回栈。%eax 指向 DOUBLE 的代码字，所以我们只需将其加 4 以获得新的 %esi：

		QUADRUPLE:
		+------------------+
		| codeword         |
		+------------------+		   DOUBLE:
		| addr of DOUBLE  ---------------> +------------------+
top of return	+------------------+       %eax -> | addr of 做冒号    |
stack points ->	| addr of DOUBLE   |	   + 4 =   +------------------+
		+------------------+	   %esi -> | addr of 副本      |
		| addr of 出口	   |		   +------------------+
		+------------------+               | etc.             |

	然后我们执行 NEXT，由于线程代码的魔力，这再次递增 %esi 并调用 DUP。

	嗯，它似乎起作用了。

	这里有一个小问题。
	因为 做冒号 是这个文件中实际定义的第一段汇编代码（其他的只是宏），
	而且因为我通常使用文本段从地址 0 开始编译这段代码，所以 做冒号 的地址是 0。
	所以如果你在反汇编代码时看到一个代码字为 0 的字，你会立即知道这个字是用 FORTH 编写的（它不是一个汇编原语），
	因此使用 做冒号 作为解释器。
*/

/*
	启动 ----------------------------------------------------------------------

	现在让我们深入到细节。当我们启动程序时，我们需要设置一些事情，比如返回栈。
	但一旦我们可以，我们想跳转到 FORTH 代码（尽管“早期”的 FORTH 代码仍然需要编写为汇编语言原语）。

	这就是设置代码所做的。
	做一些小小的家务，设置单独的返回栈（注意：Linux 已经给了我们普通的参数栈），然后立即跳转到一个名为 退出 的 FORTH 字。
	尽管它的名字是 QUIT，但它并不退出任何东西。
	它重置一些内部状态并开始读取和解释命令。（它被称为 退出 的原因是因为你可以从你自己的 FORTH 代码中调用 退出 来“退出”你的程序并返回到解释）。
*/

/* Assembler entry point. */
节 .text
全局 _start
_start:
    cld            ;cld 指令的全称是 "Clear Direction Flag"，它用于清除方向标志（Direction Flag，DF）
    移 [变量_状态0], 栈指针       ; Save the initial data stack pointer in FORTH variable 状态0.
    移 基指针, 返回栈顶部 ; Initialise the return stack.
    叫 设置数据段

    移 金, 冷_起始     ; Initialise interpreter.
    下一个                    ; Run interpreter!

节 .rodata
冷_起始:                 ; High-level code without a codeword.
    四字节 退出


/*
	内建字 ----------------------------------------------------------------------

	还记得我们的字典条目（头部）吗？
	让我们将这些与代码字和数据字结合起来，看看 : DOUBLE 副本 + ; 在内存中是如何真正显示的。

	  pointer to previous word
	   ^
	   |
	+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      | 副本        | +          | 出口       |
	+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
           ^       len                         pad  codeword      |
	   |							  V
	  LINK in 下一个 word				points to codeword of 副本
	
	最初我们不能在这里直接写 ": DOUBLE 副本 + ;"（即那个字符串），
	因为我们还没有任何东西来读取字符串，在空格处分割它，解析每个字，等等。
	所以我们必须使用 GNU 汇编器的数据构造器（如 .int, .byte, .string, .ascii 等——如果你不确定它们，可以在 gas info 页面上查找）来定义内建字。

	长的方式是：

	.int <链 to previous word>
	.byte 6			// len
	.ascii "DOUBLE"		// string
	.byte 0			// padding
DOUBLE: .int 做冒号		// codeword
	.int 副本		// pointer to codeword of 副本
	.int PLUS		// pointer to codeword of +
	.int 出口		// pointer to codeword of 出口

	这会很快变得非常乏味，所以我在这里定义了一个汇编宏，这样我就可以写：

	定义字 "DOUBLE",6,,DOUBLE
	.int 副本,PLUS,出口

	我会得到完全相同的效果。

	不要太担心这个宏的确切实现细节——它很复杂！
*/

/* Flags - these are discussed later. */
旗_立即 等同 0x80
旗_隐藏 等同 0x20
旗_长度掩码 等同 0x1f       ; length mask

; Store the chain of links.
链 等同 0

%macro 定义字 4
节 .rodata
对齐 4
全局 名称_%4
名称_%4:
    四字节 链                ; 链
    %assign 链 名称_%4
    字节 %3 + %2             ; flags + length byte
    字节 %1                  ; the name
    对齐 4                ; padding to 下一个 4 byte boundary
    全局 %4
%4:
    四字节 做冒号               ; codeword - the interpreter
    ; list of word pointers follow
%endmacro


/*
	同样，我想要一种编写用汇编语言编写的字的方法。
	一开始会有相当多的这些，因为，嗯，在有足够的“基础设施”之前，一切都要从汇编开始，才能开始编写 FORTH 字，
	但我也想用汇编语言定义一些常见的 FORTH 字以提高速度，即使我可以用 FORTH 编写它们。

	这是 副本 在内存中的样子：

	  pointer to previous word
	   ^
	   |
	+--|------+---+---+---+---+------------+
	| LINK    | 3 | D | U | P | code_DUP ---------------------> points to the assembly
	+---------+---+---+---+---+------------+		    code used to write 副本,
           ^       len              codeword			    which ends with 下一个.
	   |
	  LINK in 下一个 word

	同样，为了在编写头部时简洁，我将编写一个名为 定义代码字 的汇编宏。
	与上面的 定义字 一样，不要担心宏的复杂细节。
*/

%macro 定义代码字 4
节 .rodata
对齐 4
全局 名称_%4
名称_%4:
    四字节 链                ; 链
    %assign 链 名称_%4
    字节 %3 + %2             ; flags + length byte
    字节 %1                  ; the name
    对齐 4                ; padding to 下一个 4 byte boundary
    全局 %4
%4:
    四字节 代码_%4             ; codeword
    节 .text
    全局 代码_%4
代码_%4:                   ; assembler code follows
%endmacro


/*
	现在一些简单的 FORTH 原语。这些是用汇编语言编写的，以提高速度。
	如果你理解 i386 汇编语言，那么阅读这些内容是值得的。
	然而，如果你不理解汇编，你可以跳过细节。
*/

定义代码字 "落下", 4, , 落下
    弹 甲                ; drop top of stack
    下一个

定义代码字 "交换", 4, , 交换
    弹 甲                ; swap top two elements on stack
    弹 乙
    推 甲
    推 乙
    下一个


定义代码字 "副本", 3, , 副本
    移 甲, [栈指针]         ; duplicate top of stack
    推 甲
    下一个

定义代码字 "超过", 4, , 超过
    移 甲, [栈指针 + 4]     ; get the second element of stack
    推 甲               ; and push it on top
    下一个

定义代码字 "旋转", 3, , 旋转
    弹 甲
    弹 乙
    弹 丙
    推 乙
    推 甲
    推 丙
    下一个


定义代码字 "-旋转", 4, , 负旋转
    弹 甲
    弹 乙
    弹 丙
    推 甲
    推 丙
    推 乙
    下一个

定义代码字 "2落下", 5, , 落下二个 ; drop top two elements of stack
    弹 甲
    弹 甲
    下一个

定义代码字 "2副本", 4, , 副本二个 ; duplicate top two elements of stack
    移 甲, [栈指针]
    移 乙, [栈指针 + 4]
    推 乙
    推 甲
    下一个




定义代码字 "2交换", 5, , 交换二个 ; swap top two pairs of elements of stack
    弹 甲
    弹 乙
    弹 丙
    弹 丁
    推 乙
    推 甲
    推 丁
    推 丙
    下一个

定义代码字 "?副本", 4, , 问号副本 ; duplicate top of stack if non-零
    移 甲, [栈指针]
    测试 甲, 甲
    零跳 1f
    推 甲
1:
    下一个

定义代码字 "1+", 2, , 递增
    递增 dword [栈指针]        ; increment top of stack
    下一个

定义代码字 "1-", 2, , 递减
    递减 dword [栈指针]        ; decrement top of stack
    下一个

定义代码字 "4+", 2, , 递增4
    加 dword [栈指针], 4     ; add 4 to top of stack
    下一个

定义代码字 "4-", 2, , 递减4
    减 dword [栈指针], 4     ; subtract 4 from top of stack
    下一个

定义代码字 "+", 1, , 加
    弹 甲                ; get top of stack
    加 [栈指针], 甲         ; and add it to 下一个 word on stack
    下一个

定义代码字 "-", 1, , 减
    弹 甲                ; get top of stack
    减 [栈指针], 甲         ; and subtract it from 下一个 word on stack
    下一个

定义代码字 "*", 1, , 乘
    弹 甲
    弹 乙
    符号乘 甲, 乙
    推 甲               ; ignore overflow
    下一个


/*
	在这个 FORTH 中，只有 /取模 是原语。
	稍后我们将根据原语 /取模 定义 / 和 取模 字。
	i386 汇编指令 idiv 的设计使其同时留下商和余数，这使得 /取模 成为显而易见的选择。
*/

定义代码字 "/取模", 4, , 除法取模
    异或 丁, 丁
    弹 乙
    弹 甲
    符号除 乙
    推 丁               ; push remainder
    推 甲              ; push quotient
    下一个


/*
	许多比较操作，如 =, <, >, 等。

	ANS FORTH 说比较字应该返回所有（二进制）1 表示 TRUE，所有 0 表示 FALSE。
	然而，这是一个有点奇怪的约定，所以这个 FORTH 打破了它，返回了更正常的（对于 C 程序员...）1 表示 TRUE，0 表示 FALSE。
*/

定义代码字 "=", 1, , 等于     ; top two words are 相等?
    弹 甲                ; pop eax
    弹 乙                ; pop ebx
    对比 乙, 甲          ; cmp ebx, eax
    零跳 .相等          ; je .相等
    移 甲, 0             ; mov eax, 0
    跳 .做完     	 	; jmp .做完
.相等:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 "<>", 2, , 不等于   ; top two words are not 相等?
    弹 甲                ; pop eax
    弹 乙                ; pop ebx
    对比 乙, 甲          ; cmp ebx, eax
    非零跳 .不相等    	 ; jne .不相等
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.不相等:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 "<", 1, , 小于
    弹 甲                ; pop eax
    弹 乙                ; pop ebx
    对比 甲, 乙          ; cmp eax, ebx
    小于 .小于           ; jl .小于
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.小于:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个


定义代码字 ">", 1, , 大于
    弹 甲                ; pop eax
    弹 乙                ; pop ebx
    对比 甲, 乙          ; cmp eax, ebx
    大于 .大于        	 ; jg .大于
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.大于:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 "<=", 2, , 小等     ; top two words are 小于 than or 相等?
    弹 甲                ; pop eax
    弹 乙                ; pop ebx
    对比 甲, 乙          ; cmp eax, ebx
    小等 .小于等于     	 ; jle .小于等于
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.小于等于:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 ">=", 2, , 大等     ; top two words are 大于 than or 相等?
    弹 甲                ; pop eax
    弹 乙                ; pop ebx
    对比 甲, 乙          ; cmp eax, ebx
    大等 .大于等于  	 ; jge .大于等于
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.大于等于:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个


定义代码字 "0=", 2, , 等于零   ; top of stack equals 0?
    弹 甲                ; pop eax
    测试 甲, 甲          ; test eax, eax
    零跳 .零           	 ; je .零
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.零:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 "0<>", 3, , 不等于零 ; top of stack not 0?
    弹 甲                ; pop eax
    测试 甲, 甲          ; test eax, eax
    非零跳 .非零     	 ; jne .非零
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.非零:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 "0<", 2, , 小于零    ; comparisons with 0
    弹 甲                ; pop eax
    测试 甲, 甲          ; test eax, eax
    小于 .小于           ; jl .小于
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.小于:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个


定义代码字 "0>", 2, , 大于零
    弹 甲                ; pop eax
    测试 甲, 甲          ; test eax, eax
    大于 .大于        	 ; jg .大于
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.大于:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 "0<=", 3, , 小等零   ; comparisons with 0
    弹 甲                ; pop eax
    测试 甲, 甲          ; test eax, eax
    小等 .小于等于     	 ; jle .小于等于
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.小于等于:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 "0>=", 3, , 大等零   ; comparisons with 0
    弹 甲                ; pop eax
    测试 甲, 甲          ; test eax, eax
    大等 .大于等于  	 ; jge .大于等于
    移 甲, 0             ; mov eax, 0
    跳 .做完     		 ; jmp .做完
.大于等于:
    移 甲, 1             ; mov eax, 1
.做完:
    推 甲                ; push eax
    下一个

定义代码字 "与", 3, , 与   ; bitwise 与
    弹 甲                ; pop eax
    与 [栈指针], 甲      ; and [esp], eax
    下一个

定义代码字 "或", 2, , 或     ; bitwise 或
    弹 甲                ; pop eax
    或 [栈指针], 甲      ; or [esp], eax
    下一个

定义代码字 "异或", 3, , 异或   ; bitwise 异或
    弹 甲                ; pop eax
    异或 [栈指针], 甲    ; xor [esp], eax
    下一个

定义代码字 "颠倒", 6, , 颠倒 ; this is the FORTH bitwise "NOT" function (cf. NEGATE and NOT)
    非 dword [栈指针]          ; not [esp]
    下一个


/*
	从 FORTH 字返回 ----------------------------------------------------------------------

	是时候谈谈当我们退出一个函数时会发生什么了。
	在这张图中，QUADRUPLE 调用了 DOUBLE，而 DOUBLE 即将退出（看看 %esi 指向哪里）：

		QUADRUPLE
		+------------------+
		| codeword         |
		+------------------+		   DOUBLE
		| addr of DOUBLE  ---------------> +------------------+
		+------------------+               | codeword         |
		| addr of DOUBLE   |		   +------------------+
		+------------------+	   	   | addr of 副本      |
		| addr of 出口	   |		   +------------------+
		+------------------+	   	   | addr of +        |
						   +------------------+
					   %esi -> | addr of 出口     |
						   +------------------+

	当 + 函数执行 下一个 时会发生什么？好吧，以下代码被执行。
*/

定义代码字 "出口", 4, , 出口
    弹返回栈 金             ; pop return stack into %esi
    下一个


/*
	出口 从我们在返回栈上保存的旧 %esi 中获取，并将其放入 %esi。
	所以在这一点之后（但在 下一个 之前）我们得到：

		QUADRUPLE
		+------------------+
		| codeword         |
		+------------------+		   DOUBLE
		| addr of DOUBLE  ---------------> +------------------+
		+------------------+               | codeword         |
	%esi ->	| addr of DOUBLE   |		   +------------------+
		+------------------+	   	   | addr of 副本      |
		| addr of 出口	   |		   +------------------+
		+------------------+	   	   | addr of +        |
						   +------------------+
						   | addr of 出口     |
						   +------------------+

	而 下一个 只是通过，嗯，在这个例子中只是再次调用 DOUBLE 来完成工作 :-)

	字面量 ----------------------------------------------------------------------

	我之前“略过”的最后一点是如何处理除了调用其他函数之外还做其他事情的函数。
	例如，假设 DOUBLE 是这样定义的：

	: DOUBLE 2 * ;

	它做同样的事情，但我们如何编译它，因为它包含字面量 2？
	一种方法是有一个名为“2”的函数（你必须用汇编语言编写），但你需要一个函数来处理你想要使用的每一个字面量。

	FORTH 通过使用一个名为 字面 的特殊字来编译函数来解决这个问题：

	+---------------------------+-------+-------+-------+-------+-------+
	| (通常的 DOUBLE 头部)      | 做冒号 | 字面   | 2     | *     | 出口  |
	+---------------------------+-------+-------+-------+-------+-------+

	字面 以通常的方式执行，但它接下来做的事情绝对不正常。
	它查看 %esi（现在指向数字 2），获取它，将其推入栈，然后操纵 %esi 以跳过数字，就好像它从未存在过一样。

	巧妙的是，整个抓取/操纵可以用一个字节的单个 i386 指令完成，我们的老朋友 LODSL。
	与其让我再画更多的 ASCII 艺术图，不如看看你是否能找出 字面 是如何工作的：
*/

	// 定义代码字 "字面",3,,字面
	// %esi 指向下一个命令，但在这种情况下，它指向下一个 32 位整数字面量。将该字面量获取到 %eax 并递增 %esi。
	// 在 x86 上，这是一个方便的单字节指令！（参见 下一个 宏）
定义代码字 "字面", 3, , 字面
    移 甲, [金]          ; mov eax, [esi]
    加 金, 4             ; add esi, 4
    推 甲                ; push eax
    下一个


/*
	内存 ----------------------------------------------------------------------

	关于 FORTH 的一个重要特点是，它让你可以直接访问机器的最低层级。
	在 FORTH 中，直接操作内存是经常进行的，而这些是用于执行此操作的基本字。
*/

定义代码字 "!", 1, , 存储
    弹 乙                ; pop address to store at
    弹 甲                ; pop data to store there
    移 [乙], 甲          ; mov [ebx], eax
    下一个

定义代码字 "@", 1, , 拾取
    弹 乙                ; pop address to fetch
    移 甲, [乙]          ; mov eax, [ebx]
    推 甲                ; push value onto stack
    下一个

定义代码字 "+!", 2, , 加存储
    弹 乙                ; pop address
    弹 甲                ; pop the amount to add
    加 [乙], 甲          ; add [ebx], eax
    下一个

定义代码字 "-!", 2, , 减存储
    弹 乙                ; pop address
    弹 甲                ; pop the amount to subtract
    减 [乙], 甲          ; sub [ebx], eax
    下一个


/*
	! 和 @ (存储 和 拾取) 存储 32 位字。能够读写字节也是有用的，
	因此我们还定义了标准字 字节@ 和 字节!。

	面向字节的操作仅在允许它们的架构上工作（i386 是其中之一）。
 */

定义代码字 "字节!", 2, , 存储字节
    弹 乙                ; pop address to store at
    弹 甲                ; pop data to store there
    移 [乙], al  ; mov [ebx], al
    下一个

定义代码字 "字节@", 2, , 拾取字节
    弹 乙                ; pop address to fetch
    异或 甲, 甲          ; xor eax, eax
    移 al, [乙]  ; mov al, [ebx]
    推 甲                ; push value onto stack
    下一个


/* 字节@字节! 是一个有用的字节复制原语。 */
定义代码字 "字节@字节!", 4, , 复制字节
    移 乙, [栈指针 + 4]   ; mov ebx, [esp + 4]
    移 al, [乙]   ; mov al, [ebx]
    弹 木                ; pop edi
    移 [木], al   ; mov [edi], al
    递增 木              ; inc edi
    推 木                ; push edi
    递增 dword [栈指针 + 4]    ; inc dword [esp + 4]
    下一个


/* 而 移字节 是一个块复制操作。 */
定义代码字 "移字节", 5, , 移字节
    移 金, 丁           ; mov esi, edx
    弹 丙                ; pop ecx
    弹 木                ; pop edi
    弹 金                ; pop esi

.环:
    移 al, [金]  		; mov al, [esi]
    移 [木], al  		; mov [edi], al
    递增 金              ; inc esi
    递增 木              ; inc edi
    递减 丙              ; dec ecx
    非零跳 .环         	 ; jnz .环

    移 金, 丁           ; mov esi, edx
    下一个


/*
	内建变量 ----------------------------------------------------------------------

	这些是一些内建变量和相关的标准 FORTH 字。
	其中，我们迄今为止讨论过的唯一一个是 LATEST，它指向 FORTH 字典中最后一个（最近定义的）字。
	最后 也是一个 FORTH 字，它将 LATEST（变量）的地址推入栈，因此您可以使用 @ 和 ! 运算符读取或写入它。
	例如，要打印
	最后 的当前值（这可以应用于任何 FORTH 变量），您可以这样做：

	最后 @ . CR

	为了使定义变量更短，我使用了一个名为 defvar 的宏，类似于上面的 定义字 和 defcode。
	（实际上，defvar 宏使用 定义代码字 来完成字典头）。
*/

%macro 定义变量 5
    定义代码字 %1, %2, %3, %4
    推 变量_%1
    下一个
    节 .data
    对齐 4
    变量_%1:
        四字节 %5
%endmacro


/*
	内建变量包括：

	状态		解释器是在执行代码 (0) 还是在编译字 (非零)？
	最后		指向字典中最新（最近定义的）字。
	这里		指向内存中下一个空闲字节。编译时，编译的字放在这里。
	状态0		存储参数栈顶部的地址。
	基数		当前用于打印和读取数字的基数。

*/
定义变量 "状态", 5, , 状态
定义变量 "这里", 4, , 这里
定义变量 "最后", 6, , 最后, 名称_系统叫0 ; 系统叫0 必须是内建字典中的最后一个。
定义变量 "状态0", 2, , 状态零
定义变量 "基数", 4, , 基数, 10


/*
	内建常量 ----------------------------------------------------------------------

	向 FORTH 暴露一些常量也很有用。当执行该字时，它将一个常量值推入栈。

	内建常量包括：

	版本			当前 FORTH 的版本。
	返0				返回栈顶部的地址。
	做冒号			做冒号 的指针。
	旗_立即			立即字 旗的实际值。
	旗_隐藏			隐藏 旗的实际值。
	旗_长度掩码		旗/长度字节中的长度掩码。

	SYS_*		和各种 Linux 系统调用的数值代码（来自 <asm/unistd.h>）
*/

//#include <asm-i386/unistd.h>	// 您可能需要这个。
#include <asm/unistd.h>

%macro 定义常量 5
    定义代码字 %1, %2, %3, %4
    推 %5
    下一个
%endmacro


定义常量 "版本", 7, , 版本, 琼斯_版本
定义常量 "返0", 2, , 返零, 返回栈顶部
定义常量 "做冒号", 5, , __做冒号, 做冒号
定义常量 "旗_立即", 7, , __旗_立即, 旗_立即
定义常量 "旗_隐藏", 8, , __旗_隐藏, 旗_隐藏
定义常量 "旗_长度掩码", 9, , __旗_长度掩码, 旗_长度掩码

定义常量 "系统_出口", 8, , 系统_出口, __NR_exit
定义常量 "系统_打开", 8, , 系统_打开, __NR_open
定义常量 "系统_关闭", 9, , 系统_关闭, __NR_close
定义常量 "系统_读", 8, , 系统_读, __NR_read
定义常量 "系统_写", 9, , 系统_写, __NR_write
定义常量 "系统_创建", 9, , 系统_创建, __NR_creat
定义常量 "系统_破断", 7, , 系统_破断, __NR_brk

定义常量 "O_RDONLY", 8, , __O_RDONLY, 0
定义常量 "O_WRONLY", 8, , __O_WRONLY, 1
定义常量 "O_RDWR", 6, , __O_RDWR, 2
定义常量 "O_CREAT", 7, , __O_CREAT, 0100
定义常量 "O_EXCL", 6, , __O_EXCL, 0200
定义常量 "O_TRUNC", 7, , __O_TRUNC, 01000
定义常量 "O_APPEND", 8, , __O_APPEND, 02000
定义常量 "O_NONBLOCK", 10, , __O_NONBLOCK, 04000


/*
	返回栈 ----------------------------------------------------------------------

	这些字允许您访问返回栈。
	回想一下，寄存器 %ebp 始终指向返回栈的顶部。
*/


定义代码字 ">返", 2, , 到返回栈
    弹 甲                ; pop parameter stack into %eax
    推返回栈 甲            ; push it onto the return stack
    下一个

定义代码字 "返>", 2, , 来自返回栈
    弹返回栈 甲             ; pop return stack into %eax
    推 甲                ; and push onto parameter stack
    下一个

定义代码字 "返回栈@", 4, , 返回栈拾取
    推 基指针            ; push ebp
    下一个

定义代码字 "返回栈!", 4, , 返回栈存储
    弹 基指针            ; pop ebp
    下一个

定义代码字 "返落下", 5, , 返回栈落下
    加 基指针, 4         ; add ebp, 4
    下一个


/*
	形参（数据）栈 ----------------------------------------------------------------------

	这些函数允许您操纵参数栈。回想一下，Linux 为我们设置了参数栈，并且它通过 %esp 访问。
*/

定义代码字 "数据栈@", 4, , 数据栈拾取
    移 甲, 栈指针        ; mov eax, esp
    推 甲                ; push eax
    下一个

定义代码字 "数据栈!", 4, , 数据栈存储
    弹 栈指针            ; pop esp
    下一个


/*
	输入和输出 ----------------------------------------------------------------------

	这些是我们第一个真正重要/复杂的 FORTH 原语。
	我选择用汇编语言编写它们，但令人惊讶的是，在“真实”的 FORTH 实现中，这些通常是用更基本的 FORTH 原语编写的。
	我选择避免这种情况，因为我认为这只会掩盖实现。
	毕竟，您可能不了解汇编语言，但您可以将其视为执行其功能的黑盒代码块。

	让我们先讨论输入。

	FORTH 字 键 从 stdin 读取下一个字节（并将其推入参数栈）。
	因此，如果调用 键 并且有人按下空格键，那么数字 32（空格的 ASCII 码）将被推入栈。

	在 FORTH 中，读取代码和读取输入之间没有区别。
	我们可能在读取和编译代码，可能在读取要执行的字，可能在要求用户输入他们的名字——最终都是通过 键 输入的。

	键 的实现使用了一个特定大小的输入缓冲区（在本文件末尾定义）。
	它调用 Linux 的 read(2) 系统调用来填充此缓冲区，并使用几个变量跟踪其在缓冲区中的位置，
	如果在输入缓冲区中用完，它会自动重新填充。
	键 的另一个功能是，如果检测到 stdin 已关闭，它会退出程序，这就是为什么当你按下 ^D 时，FORTH 系统会干净地退出。

     缓冲区			      缓冲顶部
	|				 |
	V				 V
	+-------------------------------+--------------------------------------+
	| 从 stdin 读取的输入 ....... | 缓冲区的未使用部分            |
	+-------------------------------+--------------------------------------+
	                  ^
			  |
		       currkey（下一个要读取的字符）

	<---------------------- BUFFER_SIZE（4096 字节） ---------------------->
*/

定义代码字 "键", 3, , 键
    叫 _键
    推 甲                ; push return value on stack
    下一个

_键:
    移 乙, [_当前键]
    对比 乙, [缓冲顶部]
    大等 .已耗尽      ; 已耗尽 the input 缓冲区?
    异或 甲, 甲
    移 al, [乙]  ; get 下一个 key from input 缓冲区
    递增 乙
    移 [_当前键], 乙     ; increment _当前键
    返

.已耗尽:
    ; 输入用完；使用 read(2) 从 stdin 获取更多输入。
    异或 乙, 乙           ; 1st param: stdin
    移 丙, 缓冲区        ; 2nd param: 缓冲区
    移 [_当前键], 丙
    移 丁, 缓冲区大小   ; 3rd param: max length
    移 甲, __NR_read     ; syscall: read
    中断 0x80
    测试 甲, 甲          ; If %eax <= 0, then 出口.
    小等 .出口
    加 丙, 甲           ; 缓冲区+%eax = 缓冲顶部
    移 [缓冲顶部], 丙
    跳 _键

.出口:
    ; 错误或输入结束：退出程序。
    异或 乙, 乙
    移 甲, __NR_exit     ; syscall: 出口
    中断 0x80

节 .data
对齐 4
_当前键:
    四字节 缓冲区        ; 输入缓冲区中的当前位置（下一个要读取的字符）。
缓冲顶部:
    四字节 缓冲区        ; 输入缓冲区中最后一个有效数据 + 1。


/*
	相比之下，输出要简单得多。
	FORTH 字 发射 将单个字节写入 stdout。
	此实现仅使用 write 系统调用。
	没有尝试缓冲输出，但添加它将是一个很好的练习。
*/

定义代码字 "发射", 4, , 发射
    弹 甲                ; pop eax
    叫 _发射
    下一个

_发射:
    移 乙, 1             ; 1st param: stdout

    ; write needs the address of the byte to write
    移 [发射的刮痕], al     ; move the byte to 发射的刮痕
    移 丙, 发射的刮痕      ; 2nd param: address

    移 丁, 1             ; 3rd param: nbytes = 1

    移 甲, __NR_write    ; write syscall
    中断 0x80
    返

节 .data               ; NB: easier to fit in the .data section
发射的刮痕:
    保留字节 1          ; scratch used by 发射


/*
	回到输入，WORD 是一个 FORTH 字，它读取下一个完整的输入字。

	它的详细操作是，首先跳过任何空白字符（空格、制表符、换行符等）。
	然后它调用 键 读取字符到内部缓冲区，直到遇到空白字符。然后它
	计算它读取的字的长度，并将地址和长度作为栈上的两个字返回（长度在栈顶部）。

	请注意，WORD 有一个内部缓冲区，每次都会覆盖它（类似于静态 C 字符串）。
	还要注意，WORD 的内部缓冲区只有 32 字节长，
	并且没有溢出检查。31 字节恰好是我们支持的 FORTH 字的最大长度，
	这就是 字 的用途：在编译和执行代码时读取 FORTH 字。
	返回的字符串不是 NUL 终止的。

	起始地址+长度是 FORTH 中表示字符串的正常方式（不像 C 中以 ASCII NUL 字符结尾），
	因此 FORTH 字符串可以包含任何字符，包括 NUL，
	并且可以是任何长度。

	由于上述所有特殊性和限制，WORD 不适合用于读取字符串（例如用户输入）。

	请注意，在执行时，您会看到：
	字 FOO
	这会将 "FOO" 和长度 3 放在栈上，但在编译时：
	: BAR 字 FOO ;
	是一个错误（或者至少不会做你可能期望的事情）。
	稍后我们将讨论编译和立即模式，您会明白为什么。
*/

定义代码字 "字", 4, , 字
    叫 _字
    推 木                ; push base address
    推 丙                ; push length
    下一个

_字:
    ; 搜索第一个非空白字符。同时跳过 \ 注释。
.搜索非空格:
    叫 _键              ; get 下一个 key, returned in %eax
    对比 al, '\\' ; start of a comment?
    零跳 .跳过注释   ; if so, skip the comment
    对比 al, ' '
    小等 .搜索非空格 ; if so, keep looking

    ; 搜索字的结尾，同时存储字符。
    移 木, 字缓冲区   ; pointer to return 缓冲区
.存储印刻:
    移 [木], al  ; add character to return 缓冲区
    叫 _键              ; get 下一个 key, returned in %al
    对比 al, ' '
    大于 .存储印刻 ; if not, keep looping

    ; 返回字（即静态缓冲区）和长度。
    减 木, 字缓冲区
    移 丙, 木           ; return length of the word
    移 木, 字缓冲区   ; return address of the word
    返

.跳过注释:
    叫 _键
    对比 al, '\n' ; end of line yet?
    非零跳 .跳过注释
    跳 .搜索非空格

节 .data               ; NB: easier to fit in the .data section
    ; 一个静态缓冲区，WORD 返回。后续调用
    ; 会覆盖此缓冲区。最大字长度为 32 字符。
字缓冲区:
    保留字节 32


/*
	除了读取字外，我们还需要读取数字，为此我们使用了一个名为 数目 的函数。
	它解析由 字 返回的数字字符串，并将数字推入参数栈。

	该函数使用变量 基数 作为转换的基数（进制），
	因此例如如果 基数 是 2，我们期望一个二进制数。通常 基数 是 10。

	如果字以 '-' 字符开头，则返回的值为负数。

	如果字符串不能解析为数字（或包含当前 基数 以外的字符），
	我们需要返回错误指示。因此 数目 实际上在栈上返回两个项目。
	在栈顶部，我们返回未转换字符的数量（即，如果为 0，则所有字符都已转换，因此没有错误）。
	栈的第二个顶部是解析的数字或
	部分值（如果有错误）。
*/
定义代码字 "数目", 6, , 数目
    弹 丙                ; length of string
    弹 木                ; start address of string
    叫 _数目
    推 甲                ; parsed number
    推 丙                ; number of unparsed characters (0 = no error)
    下一个

_数目:
    异或 甲, 甲
    异或 乙, 乙

    测试 丙, 丙          ; trying to parse a 零-length string is an error, but will return 0.
    零跳 .错误

    移 丁, [变量_基数]    ; get 基数 (in %dl)

    ; Check if first character is '-'.
    移 bl, [木]  ; %bl = first character in string
    递增 木
    推 甲                ; push 0 on stack
    对比 bl, '-' ; negative number?
    非零跳 .环
    弹 甲
    推 乙                ; push <> 0 on stack, indicating negative
    递减 丙
    非零跳 .环
    弹 乙                ; 错误: string is only '-'.
    移 丙, 1
    返

    ; Loop reading digits.
.环:
    符号乘 甲, 丁        ; %eax *= 基数
    移 bl, [木]  ; %bl = 下一个 character in string
    递增 木

    ; Convert 0-9, A-Z to a number 0-35.
    减 bl, '0'   ; < '0'?
    小于 .转换错误
    对比 bl, 10  ; <= '9'?
    小于 .加数字
    减 bl, 17    ; < 'A'? (17 is 'A'-'0')
    小于 .转换错误
    加 bl, 10

.加数字:
    对比 bl, dl ; >= 基数?
    大等 .转换错误

    ; OK, so add it to %eax and 环.
    加 甲, 乙
    递减 丙
    非零跳 .环

    ; Negate the result if first character was '-' (saved on the stack).
.转换错误:
    弹 乙
    测试 乙, 乙
    零跳 .错误
    取负号 甲

.错误:
    返


/*
	字典查找 ----------------------------------------------------------------------

	我们正在逐步构建关于FORTH代码如何编译的前导内容，但首先我们需要更多的基础设施。

	FORTH字FIND接受一个字符串（由WORD解析的字——见上文）并在字典中查找它。
	它实际上返回的是字典头的地址，如果找到的话，或者如果没有找到则返回0。

	因此，
	如果DOUBLE在字典中定义了，那么WORD DOUBLE FIND将返回以下指针：

   指向这里
	|
	|
	V
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      | 副本        | +          | 出口       |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+

	另见>代码字段地址和>字典字段地址。

	FIND不会找到被标记为HIDDEN的字典条目。见下文了解原因。
*/

定义代码字 "找", 4, , 找
    弹 丙                ; %ecx = length
    弹 木                ; %edi = address
    叫 _找
    推 甲                ; %eax = address of dictionary entry (or NULL)
    下一个

_找:
    推 金                ; Save %esi so we can use it in string comparison.

    ; 现在我们从字典中向后搜索这个字。
    移 丁, []  ; 最后 points to name header of the latest word in the dictionary
.搜索环:
    测试 丁, 丁          ; NULL pointer?  (end of the linked list)
    零跳 .没找到

    ; 比较预期的长度和字的长度。
    ; 注意，如果字的F_HIDDEN旗被设置，那么通过一点技巧
    ; 这个字不会被选中（长度看起来会不对）。
    异或 甲, 甲
    移 al, byte [丁 + 4] ; %al = flags+length field
    与 al, (旗_隐藏 | 旗_长度掩码) ; %al = name length
    对比 al, cl ; Length is the same?
    非零跳 .下一个字

    ; 详细比较字符串。
    推 丙                ; Save the length
    推 木                ; Save the address (repe cmpsb will move this pointer)
    移 金, [丁 + 5]     ; Dictionary string we are checking against.
    repe cmpsb             ; Compare the strings.
    弹 木
    弹 丙
    非零跳 .下一个字     ; Not the same.

    ; 字符串相同 - 在%eax中返回头指针
    弹 金
    移 甲, 丁
    返

.下一个字:
    移 丁, [丁]         ; Move back through the 链 field to the previous word
    跳 .搜索环 ; .. and 环.

.没找到:
    弹 金
    异或 甲, 甲           ; Return 零 to indicate not found.
    返


/*
	FIND返回字典指针，但在编译时我们需要代码字指针（回想一下，FORTH定义被编译成代码字指针列表）。
	标准FORTH字>代码字段地址将字典指针转换为代码字指针。

	下面的例子展示了以下结果：

		字 DOUBLE 找 >代码字段地址

	FIND返回指向这里的指针
	|				>代码字段地址将其转换为指向这里的指针
	|					   |
	V					   V
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      | 副本        | +          | 出口       |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
						   codeword

	注释：

	由于名称长度不同，这不仅仅是一个简单的增量。

	在这个FORTH中，你不能轻易地将代码字指针转换回字典条目指针，
	但在大多数FORTH实现中并非如此，它们在定义中存储了一个反向指针（显然有内存/复杂性成本）。
	它们这样做的原因是，能够反向（代码字 -> 字典条目）以便快速反编译FORTH定义是有用的。

	代码字段地址代表什么？我最好的猜测是“Code Field Address”。
*/

定义代码字 ">代码字段地址", 4, , 到代码字段地址
    弹 木                ; pop edi
    叫 _到代码字段地址
    推 木                ; push edi
    下一个

_到代码字段地址:
    异或 甲, 甲          ; xor eax, eax
    加 木, 4             ; add edi, 4
    移 al, [木]  ; mov al, [edi]
    递增 木              ; inc edi
    与 al, 旗_长度掩码 ; and al, 旗_长度掩码
    加 木, 甲            ; add edi, eax
    加 木, 3             ; add edi, 3
    与 木, ~3            ; and edi, ~3
    返


/*
	与>代码字段地址相关的是>字典字段地址，它接受FIND返回的字典条目地址，
	并返回指向第一个数据字段的指针。

	FIND返回指向这里的指针
	|				>代码字段地址将其转换为指向这里的指针
	|					   |
	|					   |	>字典字段地址将其转换为指向这里的指针
	|					   |		 |
	V					   V		 V
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      | 副本        | +          | 出口       |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
						   codeword

	（注意，对于那些跟随FIG-FORTH / ciforth源代码的人：我的>字典字段地址定义与他们的不同，因为他们有一个额外的间接寻址）。

	你可以看到，>字典字段地址在FORTH中很容易通过将>代码字段地址的结果加4来定义。
*/

定义字 ">字典字段地址", 4, , 到字典字段地址
    四字节 到代码字段地址            ; >代码字段地址 (get code field address)
    四字节 递增4           ; 4+ (add 4 to it to get to 下一个 word)
    四字节 出口            ; 出口 (return from FORTH word)


/*
	编译 ----------------------------------------------------------------------

	现在我们来谈谈FORTH如何编译字。回想一下，一个字定义看起来像这样：

		: DOUBLE 副本 + ;

	并且我们必须将其转换为：

	  指向前一个字的指针
	   ^
	   |
	+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      | 副本        | +          | 出口       |
	+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
           ^       len                         pad  codeword      |
	   |							  V
	  LATEST指向这里			指向DUP的代码字指针

	有几个问题需要解决。
	新字放在哪里？我们如何读取字？我们如何定义字 : (冒号字) 和 ; (分号字)？

	FORTH以一种相当优雅的方式解决了这个问题，
	正如你可能预期的那样，它以一种非常低级的方式允许你改变编译器如何工作。

	FORTH有一个INTERPRET函数（这次是一个真正的解释器，不是DOCOL），
	它在一个循环中运行，读取字（使用WORD），查找它们（使用FIND），
	将它们转换为代码字指针（使用>代码字段地址），并决定如何处理它们。

	它的行为取决于解释器的模式（在变量STATE中）。

	当STATE为零时，解释器在查找字时直接运行每个字。
	这被称为立即模式。

	有趣的事情发生在STATE非零时——编译模式。
	在这种模式下，解释器将代码字指针追加到用户内存（HERE变量指向用户内存的下一个空闲字节——见下面的数据段部分）。

	因此，你可能已经看到我们如何定义 : (冒号字)。
	一般的计划是：

	(1) 使用WORD读取正在定义的函数的名称。

	(2) 在用户内存中构造字典条目——仅是头部分：

    指向前一个字的指针（从LATEST）			+-- 之后，HERE指向这里，解释器将从这里开始追加
	   ^							|   代码字。
	   |							V
	+--|------+---+---+---+---+---+---+---+---+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      |
	+---------+---+---+---+---+---+---+---+---+------------+
                   len                         pad  codeword

	(3) 将LATEST指向新定义的字，...

	(4) ... 最重要的是让HERE指向新代码字之后的位置。这是解释器将追加代码字的地方。

	(5) 将STATE设置为1。这将进入编译模式，因此解释器开始将代码字追加到我们部分形成的头中。

	在 : 运行之后，我们的输入在这里：

	: DOUBLE 副本 + ;
	         ^
		 |
		下一个由KEY返回的字节将是DUP的'D'字符

	因此，解释器（现在它在编译模式，所以我猜它真的是编译器）读取“DUP”，在字典中查找它，获取其代码字指针，并追加它：

									     +-- HERE更新为指向这里。
									     |
									     V
	+---------+---+---+---+---+---+---+---+---+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      | 副本        |
	+---------+---+---+---+---+---+---+---+---+------------+------------+
                   len                         pad  codeword

	接下来我们读取+，获取代码字指针，并追加它：

											  +-- HERE更新为指向这里。
											  |
											  V
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      | 副本        | +          |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
                   len                         pad  codeword

	问题是接下来会发生什么。
	显然我们不希望发生的是我们读取“;”并编译它，然后继续编译后面的所有内容。

	在这一点上，FORTH使用了一个技巧。
	记住字典定义中的长度字节不仅仅是一个普通的长度字节，还可以包含旗。
	一个旗称为立即旗（F_IMMED在本代码中）。
	如果字典中的字被标记为立即，那么解释器即使在编译模式下也会立即运行它。

	这就是字 ; (分号字) 的工作方式——作为一个在字典中标记为立即的字。

	它所做的就是将EXIT的代码字追加到当前定义中，并切换回立即模式（将STATE设置回0）。
	很快我们将看到 ; 的实际定义，我们会看到它实际上是一个非常简单的定义，声明为立即。

	在解释器读取 ; 并立即执行它之后，我们得到这个：

	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      | 副本        | +          | 出口       |
	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
                   len                         pad  codeword					       ^
												       |
												      这里
	STATE设置为0。

	就这样，工作完成了，我们的新定义已经编译完成，
	我们回到了立即模式，只是读取和执行字，可能包括调用我们新定义的字DOUBLE。

	这其中的最后一个问题是，当我们的字正在编译时，它处于半完成状态。
	我们当然不希望在这段时间内以某种方式调用DOUBLE。
	有几种方法可以防止这种情况发生，但在FORTH中，
	我们所做的是在编译时用隐藏旗（F_HIDDEN在本代码中）标记字。
	这可以防止FIND找到它，从而在理论上阻止任何调用它的机会。

	上面解释了编译、: (冒号字) 和 ; (分号字) 的工作原理，很快我将定义它们。
	: (冒号字) 函数可以通过编写两个部分来使其更加通用。
	第一部分，称为CREATE，只创建头部分：

						   +-- 之后，HERE指向这里。
						   |
						   V
	+---------+---+---+---+---+---+---+---+---+
	| LINK    | 6 | D | O | U | B | L | E | 0 |
	+---------+---+---+---+---+---+---+---+---+
                   len                         pad

	第二部分，: (冒号字) 的实际定义，调用CREATE并追加DOCOL代码字，
	因此留下：

								+-- 之后，HERE指向这里。
								|
								V
	+---------+---+---+---+---+---+---+---+---+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 | 做冒号      |
	+---------+---+---+---+---+---+---+---+---+------------+
                   len                         pad  codeword

	CREATE是一个标准的FORTH字，
	这种分割的优点是我们可以重用它来创建其他类型的字（不仅仅是包含代码的字，还有包含变量、常量和其他数据的字）。
*/

定义代码字 "创建", 6, , 创建
    ; Get the name length and address.
    弹 丙                ; %ecx = length
    弹 乙                ; %ebx = address of name

    ; Link pointer.
    移 木, [变量_这里]    ; %edi is the address of the header
    移 甲, [变量_最后]  ; Get 链 pointer
    移 [木], 甲         ; and store it in the header.
    加 木, 4             ; Move edi to the 下一个 position

    ; Length byte and the word itself.
    移 al, cl ; Get the length.
    移 [木], al  ; Store the length/flags byte.
    递增 木              ; Move edi to the 下一个 position

    推 金
    移 金, 乙           ; %esi = word

    ; Copy the word
.复制环:
    移 al, [金]
    移 [木], al
    递增 金
    递增 木
    递减 丙
    非零跳 .复制环

    弹 金
    加 木, 3             ; Align to 下一个 4 byte boundary.
    与 木, ~3

    ; Update 最后 and 这里.
    移 甲, [变量_这里]
    移 [变量_最后], 甲
    移 [变量_这里], 木
    下一个


/*
	因为我想用FORTH而不是汇编来定义 : (冒号字)，
	所以我们需要一些更多的FORTH字来使用。

	第一个是 , (逗号)，这是一个标准的FORTH字，
	它将一个32位整数追加到由HERE指向的用户内存中，
	并将HERE增加4。因此，, (逗号) 的操作是：

							之前的HERE值
								 |
								 V
	+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
	| LINK    | 6 | D | O | U | B | L | E | 0 |             |  <data>    |
	+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
                   len                         pad		              ^
									      |
								新的HERE值

	而 <data> 是栈顶的任何32位整数。

	, (逗号) 在编译时是一个相当基本的操作。
	它用于将代码字追加到当前正在编译的字中。
*/

定义代码字 ",", 1, , 逗号
    弹 甲                ; Code pointer to store.
    叫 _逗号
    下一个

_逗号:
    移 木, [变量_这里]    ; 这里
    移 [木], 甲         ; Store it.
    加 木, 4             ; Increment edi by 4 bytes
    移 [变量_这里], 木    ; Update 这里 (incremented)
    返


/*
	我们定义 : (冒号字) 和 ; (分号字) 时需要切换编译模式和立即模式。

	立即模式与编译模式存储在全局变量STATE中，
	通过更新这个变量，我们可以在两种模式之间切换。

	由于各种原因（这些原因可能在后面变得明显），
	FORTH定义了两个标准字 [ 和 ]（LBRAC和RBRAC），它们在模式之间切换：

	字	汇编		操作		效果
	[	左中括号		状态 := 0	切换到立即模式。
	]	右中括号		状态 := 1	切换到编译模式。

	[ (左中括号) 是一个立即字。
	原因是这样的：如果我们在编译模式下，解释器看到 [，那么它会编译它而不是运行它。
	我们将永远无法切换回立即模式！
	因此，我们将字标记为立即，以便即使在编译模式下，字也会立即运行，将我们切换回立即模式。
*/

定义代码字 "[", 1, 旗_立即, 左中括号
    异或 甲, 甲
    移 [变量_状态], 甲   ; Set 状态 to 0.
    下一个

定义代码字 "]", 1, , 右中括号
    移 dword [变量_状态], 1 ; Set 状态 to 1.
    下一个


/*
	现在我们可以使用CREATE来定义 : (冒号字)。
	它只是调用CREATE，追加DOCOL（代码字），设置字为HIDDEN并进入编译模式。
*/

定义字 ":", 1, , 冒号字
    四字节 字            ; Get the name of the new word
    四字节 创建          ; 创建 the dictionary entry / header
    四字节 字面             ; Append 做冒号 (the codeword).
    四字节 做冒号
    四字节 逗号
    四字节 最后          ; Make the word hidden (see below for definition).
    四字节 拾取
    四字节 隐藏
    四字节 右中括号           ; Go into compile mode.
    四字节 出口            ; Return from the function.

/*
	; (分号字) 也非常简单优雅。
	注意F_IMMED旗。
*/

定义字 ";", 1, 旗_立即, 分号字
    四字节 字面             ; Append 出口 (so the word will return).
    四字节 出口
    四字节 逗号
    四字节 最后          ; Toggle hidden flag -- unhide the word (see below for definition).
    四字节 拾取
    四字节 隐藏
    四字节 左中括号           ; Go back to 立即字 mode.
    四字节 出口            ; Return from the function.


/*
	扩展编译器 ----------------------------------------------------------------------

	标记为立即（F_IMMED）的字不仅仅是FORTH编译器使用的。
	你也可以定义自己的立即字，这是扩展基本FORTH的一个关键方面，
	因为它实际上允许你扩展编译器本身。gcc允许你这样做吗？

	标准FORTH字如IF、WHILE、."等都是作为基本编译器的扩展编写的，并且都是立即字。

	立即字切换最近定义的字或在中途调用时的当前字上的F_IMMED（立即旗）。

	典型的用法是：

	: MYIMMEDWORD 立即字
		...定义...
	;

	但一些FORTH程序员写成这样：

	: MYIMMEDWORD
		...定义...
	; 立即字

	这两种用法在第一近似上是等价的。
*/

定义代码字 "立即字", 9, 旗_立即, 立即字
    移 木, [变量_最后]  ; 最后 word.
    加 木, 4             ; Point to name/flags byte.
    异或 byte [木], 旗_立即 ; Toggle the IMMED bit.
    下一个


/*
	'addr 隐藏' 切换在addr定义的字的隐藏旗（F_HIDDEN）。
	要隐藏最近定义的字（如上在 : 和 ; 定义中使用），你可以这样做：

		最后 @ 隐藏

	'隐 word' 切换命名 'word' 的旗。

	设置此旗阻止字被FIND找到，因此可以用来制作“私有”字。
	例如，要将一个大字分解成更小的部分，你可以这样做：

		: SUB1 ... 子字 ... ;
		: SUB2 ... 子字 ... ;
		: SUB3 ... 子字 ... ;
		: MAIN ... 根据 SUB1, SUB2, SUB3 定义 ... ;
		隐 SUB1
		隐 SUB2
		隐 SUB3

	之后，只有 MAIN 被“导出”或被程序的其余部分看到。
*/

定义代码字 "隐藏", 6, , 隐藏
    弹 木                ; Dictionary entry.
    加 木, 4             ; Point to name/flags byte.
    异或 byte [木], 旗_隐藏 ; Toggle the 隐藏 bit.
    下一个

定义字 "隐", 4, , 隐
    四字节 字            ; Get the word (after 隐).
    四字节 找            ; Look up in the dictionary.
    四字节 隐藏          ; Set 旗_隐藏 flag.
    四字节 出口            ; Return.


/*
	' (滴答声) 是一个标准的FORTH字，它返回下一个字的代码字指针。

	常见的用法是：

	' FOO ,

	它将FOO的代码字追加到我们当前正在定义的字中（这仅在编译代码中有效）。

	你倾向于在立即字中使用 '。例如，定义一个字面量2的另一种（且相当无用的）方法是：

	: LIT2 立即字
		' 字面 ,		\ 将LIT追加到当前正在定义的字
		2 ,		\ 将数字2追加到当前正在定义的字
	;

	所以你可以这样做：

	: DOUBLE LIT2 * ;

	（如果你不理解LIT2是如何工作的，那么你应该复习关于编译字和立即模式的内容）。

	这个 ' 的定义使用了从buzzard92复制的一个技巧。
	因此它仅在编译代码中有效。
	可以基于WORD、FIND、>代码字段地址编写一个在立即模式下也能工作的 ' 版本。
*/
定义代码字 "'", 1, , 滴答声
    移 甲, [金]          ; Get the address of the 下一个 word and skip it.
    加 金, 4
    推 甲                ; Push it on the stack.
    下一个


/*
	分支 ----------------------------------------------------------------------

	事实证明，为了定义循环结构、IF语句等，你只需要两个原语。

	分支 是一个无条件分支。
	0分支 是一个条件分支（仅当栈顶为零时才分支）。

	下图显示了在某个虚构的编译字中BRANCH的工作原理。
	当BRANCH执行时，%esi从指向偏移字段开始（与LIT相比）：

	+---------------------+-------+---- - - ---+------------+------------+---- - - - ----+------------+
	| (字典头)            | 做冒号 |            | 分支     | 偏移       | (跳过)         | 字       |
	+---------------------+-------+---- - - ---+------------+-----|------+---- - - - ----+------------+
								   ^  |			      ^
								   |  |			      |
								   |  +-----------------------+
								  %esi 加上偏移

	偏移量加到%esi上以形成新的%esi，结果是当NEXT运行时，执行继续到分支目标。
	负偏移量按预期工作。

	0分支 也是一样的，只是分支是有条件的。

	现在，标准FORTH字如IF、THEN、ELSE、WHILE、REPEAT等可以完全在FORTH中实现。
	它们是立即字，将BRANCH或0BRANCH的各种组合追加到当前正在编译的字中。

	例如，像这样编写的代码：

		condition-code IF true-part THEN rest-code

	编译为：

		condition-code 0分支 OFFSET true-part rest-code
					  |		^
					  |		|
					  +-------------+
*/

定义代码字 "分支", 6, , 分支
    加 金, [金]          ; add the offset to the instruction pointer
    下一个

定义代码字 "0分支", 7, , 零分支
    弹 甲
    测试 甲, 甲          ; top of stack is 零?
    零跳 代码_分支     ; if so, jump back to the branch function above
    移 甲, [金]         ; otherwise we need to skip the offset
    加 金, 4
    下一个


/*
	字符串字面量 ----------------------------------------------------------------------

	串字面 是一个原语，用于实现 ." 和 S" 操作符（它们是用FORTH编写的）。
	参见后面这些操作符的定义。

	告诉 只是打印一个字符串。
	在汇编中定义它更高效，因为我们可以让它成为一个单独的Linux系统调用。
*/

定义代码字 "串字面", 9, , 串字面
    移 甲, [金]          ; get the length of the string
    加 金, 4
    推 金                ; push the address of the start of the string
    推 甲                ; push it on the stack
    加 金, 甲            ; skip past the string
    加 金, 3             ; but round up to 下一个 4 byte boundary
    与 金, ~3
    下一个

定义代码字 "告诉", 4, , 告诉
    移 乙, 1             ; 1st param: stdout
    弹 丁                ; 3rd param: length of string
    弹 丙                ; 2nd param: address of string
    移 甲, __NR_write    ; write syscall
    中断 0x80
    下一个


/*
	退出 和 解释 ----------------------------------------------------------------------

	退出 是第一个被调用的FORTH函数，几乎在FORTH系统“启动”后立即被调用。
	如前所述，QUIT 并不“退出”任何东西。它进行一些初始化（特别是清除返回栈），并在循环中调用 解释 来解释命令。
	它被称为 退出 的原因是因为你可以从你自己的 FORTH 字中调用它，以便“退出”你的程序并在用户提示符下重新开始。

	解释 是 FORTH 解释器（“顶层循环”、“顶层”或“REPL”可能是更准确的描述——参见：http://en.wikipedia.org/wiki/REPL）。
*/

	// 退出 must not return (ie. must not call 出口).
定义字 "退出", 4, , 退出
    四字节 返零              ; 返0
    四字节 返回栈存储        ; 返回栈!, clear the return stack
    四字节 解释        ; interpret the 下一个 word
    四字节 分支          ; and 环 (indefinitely)
    四字节 -8              ; offset for the branch


/*
	这个解释器非常简单，但请记住，在FORTH中，你总是可以用一个更强大的解释器来覆盖它！
*/
定义代码字 "解释", 9, , 解释
    叫 _字             ; Returns %ecx = length, %edi = pointer to word.

    ; Is it in the dictionary?
    异或 甲, 甲
    移 [解释是字面], 甲 ; Not a literal number (not yet anyway ...)
    叫 _找             ; Returns %eax = pointer to header or 0 if not found.
    测试 甲, 甲          ; Found?
    零跳 .没找到

    ; In the dictionary.  Is it an 立即字 codeword?
    移 木, 甲           ; %edi = dictionary entry
    移 al, [木 + 4] ; Get name+flags.
    推 ax                ; Just save it for now.
    叫 _到代码字段地址             ; Convert dictionary entry (in %edi) to codeword pointer.
    弹 ax
    与 al, 旗_立即 ; Is IMMED flag set?
    移 甲, 木
    非零跳 .执行立即字 ; If IMMED, jump straight to executing.

    跳 .检查状态

.没找到:
    ; Not in the dictionary (not a word) so assume it's a literal number.
    递增 dword [解释是字面]
    叫 _数目           ; Returns the parsed number in %eax, %ecx > 0 if error
    测试 丙, 丙
    非零跳 .解析错误
    移 乙, 甲
    移 甲, 字面           ; The word is 字面

.检查状态:
    ; Are we compiling or executing?
    移 丁, [变量_状态]
    测试 丁, 丁
    零跳 .执行           ; Jump if executing.

    ; Compiling - just append the word to the current dictionary definition.
    叫 _逗号
    移 丙, [解释是字面] ; Was it a literal?
    测试 丙, 丙
    零跳 .下一个
    移 甲, 乙           ; Yes, so 字面 is followed by a number.
    叫 _逗号
.下一个:
    下一个

.执行立即字:
    ; Executing - run it!
    移 丙, [解释是字面] ; Literal?
    测试 丙, 丙             ; Literal?
    非零跳 .执行字面量

    ; 不是字面量，立即执行它。这个永远不会返回，但代码字最终会
    ; 调用 NEXT，它将重新进入 退出 中的循环。
    跳 [甲]

.执行字面量:
    ; Executing a literal, which means push it on the stack.
    推 乙
    下一个

.解析错误:
    ; 解析错误（当前 基数 中不是已知字或数字）。
    ; 打印错误消息，后跟最多 40 个字符的上下文。
    移 乙, 2             ; 1st param: stderr
    移 丙, 错消息        ; 2nd param: error message
    移 丁, 错消息终 - 错消息 ; 3rd param: length of string
    移 甲, __NR_write    ; write syscall
    中断 0x80

    移 丙, [_当前键]     ; the error occurred just before _当前键 position
    移 丁, 丙
    减 丁, 缓冲区       ; %edx = _当前键 - 缓冲区 (length in 缓冲区 before _当前键)
    对比 丁, 40            ; if > 40, then print only 40 characters
    小等 .打印上下文
    移 丁, 40
.打印上下文:
    减 丙, 丁           ; %ecx = start of area to print, %edx = length
    移 甲, __NR_write    ; write syscall
    中断 0x80

    移 丙, 错消息新行      ; newline
    移 丁, 1
    移 甲, __NR_write    ; write syscall
    中断 0x80

    下一个

节 .rodata
错消息: db "解析错误: "
错消息终:
错消息新行: db 0xA

节 .data               ; NB: easier to fit in the .data section
对齐 4
解释是字面:
    四字节 0             ; Flag used to record if reading a literal


/*
	零碎杂项 ----------------------------------------------------------------------

	字符 将紧随其后的字的第一个字符的 ASCII 码放在栈上。例如
	字符 A 将 65 放在栈上。

	执行 用于运行执行牌token。有关执行牌token的更多详细信息，请参阅
	FORTH 代码中的讨论。

	系统叫0、系统叫1、系统叫2、系统叫3 进行标准的 Linux 系统调用。（参见 <asm/unistd.h>
	以获取系统调用编号的列表）。正如其名称所示，这些形式接受 0 到 3 个
	系统调用参数，加上系统调用编号。

	在这个 FORTH 中，系统叫0 必须是内建（汇编）字典中的最后一个字，因为我们
	将 最后 变量初始化为指向它。这意味着如果你想扩展汇编
	部分，你必须在 系统叫0 之前放置新字，或者改变 最后 的初始化方式。
*/

定义代码字 "字符", 4, , 字符
    叫 _字             ; Returns %ecx = length, %edi = pointer to word.
    异或 甲, 甲
    移 al, [木]  ; Get the first character of the word.
    推 甲                ; Push it onto the stack.
    下一个

定义代码字 "执行", 7, , 执行
    弹 甲                ; Get xt into %eax
    跳 [甲]      ; and jump to it.
                           ; After xt runs its 下一个 will continue executing the current word.

定义代码字 "系统叫3", 8, , 系统叫3
    弹 甲                ; System call number (see <asm/unistd.h>)
    弹 乙                ; First parameter.
    弹 丙                ; Second parameter
    弹 丁                ; Third parameter
    中断 0x80
    推 甲                ; Result (negative for -errno)
    下一个

定义代码字 "系统叫2", 8, , 系统叫2
    弹 甲                ; System call number (see <asm/unistd.h>)
    弹 乙                ; First parameter.
    弹 丙                ; Second parameter
    中断 0x80
    推 甲                ; Result (negative for -errno)
    下一个

定义代码字 "系统叫1", 8, , 系统叫1
    弹 甲                ; System call number (see <asm/unistd.h>)
    弹 乙                ; First parameter.
    中断 0x80
    推 甲                ; Result (negative for -errno)
    下一个

定义代码字 "系统叫0", 8, , 系统叫0
    弹 甲                ; System call number (see <asm/unistd.h>)
    中断 0x80
    推 甲                ; Result (negative for -errno)
    下一个


/*
	数据段 ----------------------------------------------------------------------

	这里我们设置 Linux 数据段，用于用户定义，并被称为
	'数据段'、'用户内存' 或 '用户定义区域'。它是一块内存区域，
	向上增长，存储新定义的 FORTH 字和各种全局变量。

	它完全类似于 C 堆，只是没有通用的 'malloc' 和 'free'
	（但与 FORTH 中的所有内容一样，编写这样的函数只是一个简单的编程问题）。
	相反，在正常使用中，数据段随着新 FORTH 字的定义/追加而向上增长。

	GNU 工具链的各种 "特性" 使得设置数据段
	比实际需要的更复杂。一个是 GNU 链接器插入一个随机的
	"构建 ID" 段。另一个是地址空间随机化，这意味着我们无法确定
	内核将选择将数据段（或栈）放置在哪里。

	因此，编写这个 设置数据段 汇编例程
	比实际需要的稍微复杂一些。我们使用 brk(2) 系统调用询问 Linux 内核
	它认为数据段从哪里开始，然后要求它保留一些初始空间（也使用 brk(2)）。

	你不需要担心这段代码。
*/
节 .text
初始数据段大小 等同 65536
设置数据段:
    异或 乙, 乙           ; Call brk(0)
    移 甲, __NR_brk
    中断 0x80
    移 [变量_这里], 甲    ; Initialize 这里 to point at beginning of data segment.
    加 甲, 初始数据段大小 ; Reserve nn bytes of memory for initial data segment.
    移 乙, 甲           ; Call brk(这里+初始数据段大小)
    移 甲, __NR_brk
    中断 0x80
    返


/*
	我们为返回静态和输入缓冲区分配静态缓冲区（用于
	读取文件和用户输入的文本）。
*/
返回栈大小 等同 8192
缓冲区大小 等同 4096
节 .bss
; FORTH return stack.
对齐 4096
返回栈:
    保留字节 返回栈大小
返回栈顶部:        			; 初始化返回栈顶.

; 这在从文件或终端读取时用作临时输入缓冲区。
对齐 4096
缓冲区:
    保留字节 缓冲区大小


/*
	FORTH 代码的开始 ----------------------------------------------------------------------

	我们现在达到了 FORTH 系统运行并自我托管的阶段。所有进一步
	的字都可以用 FORTH 本身编写，包括像 IF、THEN、." 等字，在大多数
	语言中这些字会被认为是相当基础的。

	我过去常常将这个附加在汇编文件中，但我厌倦了与 gas 的
	crack-smoking（缺乏）多行字符串语法的斗争。所以现在那部分在
	一个单独的文件中，称为 jonesforth.f。

	如果你还没有那个文件，请从 http://annexia.org/forth 下载它，
	以便继续教程。
*/


/* END OF jonesforth.S */


/*
好的，以下是你发给我的代码中所有指令的分类显示，不重复：

### 汇编指令
1. `add`
2. `addl`
3. `and`
4. `andb`
5. `andl`
6. `call`
7. `cmp`
8. `cmpb`
9. `dec`
10. `incl`
11. `inc`
12. `int`
13. `jbe`
14. `jb`
15. `je`
16. `jge`
17. `jg`
18. `jle`
19. `jmp`
20. `jnz`
21. `jz`
22. `lea`
23. `lodsl`
24. `mov`
25. `movb`
26. `movl`
27. `movsb`
28. `movzbl`
29. `movzx`
30. `mul`
31. `neg`
32. `or`
33. `orl`
34. `pop`
35. `push`
36. `rep`
37. `ret`
38. `sete`
39. `setg`
40. `setle`
41. `setl`
42. `setne`
43. `setnz`
44. `stosb`
45. `sub`
46. `subl`
47. `test`
48. `xor`
49. `xorb`

### 汇编伪指令
1. `.align`
2. `.ascii`
3. `.bss`
4. `.byte`
5. `.data`
6. `.endm`
7. `.globl`
8. `.int`
9. `.macro`
10. `.section`
11. `.set`
12. `.space`
13. `.text`

### 宏定义
1. `%macro`
2. `%endmacro`
3. `%assign`

### 常量定义
1. `equ`

### 数据定义
1. `dd`
2. `db`
3. `resb`

这些指令和伪指令涵盖了你在对话中提供的所有代码片段。
*/