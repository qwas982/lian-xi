自省理解误区,
混淆了内存磁盘与VHD虚硬盘, vhd只是磁盘里的一个文件,

第二, 归纳总结,
我想在全内存下操作一切,

一个是, 我需要制作vhd, 并在vhd内安装win. 这个vhd文件存放在ssd某盘符下.
二个是, 我需要从裸机下引导机器进入内存磁盘, 并从ssd某盘下读取vhd文件到内存磁盘, 接着启动vhd内部的win.

ssd读取速度在1GB/s, vhd内的win需要尽可能小, 保守5GB.

所以, 
1, 我需要哪些工具, 2, Ventoy的原理是否有值得借鉴,

因为必须要把vhd做成一个成熟可用的系统,
仅仅是创建一个vhd文件是不够的, 即使是在vhd内部署好了一个win, 也是不够的.
我还得把vhd文件内的这个win调试好, 例如装驱动, 系统设置调教, 常用软件等等.

而这一切, 我都必须在当前系统下操作,
并且是, 尽量少读写硬盘, 而完全在内存里操作(已安装了一个Primo Ramdisk可用).

这些过程里, 还得考虑有哪些步骤可以用到py脚本实现半自动化.

看起来都是跟"磁盘, 分区, 文件", 强相关的.

/
我发现一个关键问题; 如果用grub2当启动器, 那么在把d盘的vhd文件读取到内存磁盘后, grub2怎么识别vhd内的一系列启动过程与相应启动文件?

其次, 既然当前系统内驱动运行正常, 那我能否导出全部驱动, 打包, 在制作vhd内win的时候, 直接导入驱动到新win行不行?

在安装系统的时候, 我平时都是通过pe进行图形化操作的, 
所以, 应该利用当前系统内的虚拟机, 在其内复用这部分熟练的技术, 虚拟机操作的是vhd, 所以最终一切改动都在虚拟机内的硬盘, 即vhd文件上.

也就是说, 现在我需要清楚VMware 是否支持vhd, 若不, 什么支持, 或怎么支持?
其次就是引导问题, 似乎只有这两个问题; 制作, 引导.
grub2必须安装到当前系统吗?
裸机上电后, 去哪里找启动文件? 若是通过grub2, 完整启动流程是啥样的?
似乎现在硬件与系统, 都仅支持efi+GPT了.

/
经过一天的探索与研究,
我似乎摸到了一点门道.
基于块设备, 还是目录树/文件系统, 需要根据系统种类选择.
系统之前与系统之后的虚拟化, 不一样.
裸机下的虚拟化与系统下的虚拟化, 不一样.

主要分成三阶段;
制作系统镜像(包括安装与微调系统).
从裸机引导的管理.
虚设备的衔接(重要).

因为虚拟化是看不见摸不着的, 是一个抽象的存在.
所以很多人失败在不理解其原理.
这套技术的精髓, 在于把虚拟化当做一个中间/中转实体,
也就是指令指针/程序计数器+跳jmp指令的配合. 在虚实之间跳.
没有它就无法实现无从谈起.
原先我以为需要驱动, 但之后越来越理解后, 发现是发展到EFI后, 它自带驱动.
只有90年代或00年, 不完善的时候才需要驱动.
注意; 我说的这个驱动不是系统内的驱动.

其本质在于, 在物理机上的硬盘(包括分区)+线缆的实体, 
到内存操作系统后, 是通过虚拟化构造出相应的数字化实体.
这个构造阶段所需驱动, 被EFI这套技术及其应用实现并解决.
其次, 你需要为这个数字化实体的虚硬件安装系统内的驱动, 也就是磁盘驱动,
这需要到系统内才能看到.
我为什么花这么多字描述跟驱动相关呢? 因为驱动理解不到位, 操作失误, 极大概率蓝屏.
所以,
我的做法是, 在制作系统镜像的时候, 备份当前宿主系统的驱动, 因为这是被验证过没问题的.
我通过vhd方式制作镜像, 你也可以用iso/wim/esd等等形式, 大差不差.
创建一个vhd文件, 到虚拟机里使用这个vhd文件, vhd就是虚硬盘, 
在虚拟机里是一块真实硬盘,
在宿主机里是一个文件.
我使用DISM++从当前宿主系统导出全部驱动, 其中包括重要的磁盘驱动,
到虚拟机里一样使用DISM++把这些驱动导入镜像.
在虚拟机里就跟操作安装普通系统一样, 你只要熟练这一点就没问题.
制作系统镜像阶段完工后, 把vhd文件放入别的盘备用.

还有一点要说明的是;
跟引导有关的文件与位置, 要分清.
因为我用的是虚拟化形式实现RAMOS, 所以我这里有两层引导.
系统内的分区和引导与系统外(裸机层)的分区和引导要分清,
你要是傻傻分不清楚, 99%会产生误操作, 导致蓝屏, 导致失败.

多练习, 多实操, 从实践里, 逐渐熟悉熟练, 以至于成为专家.

文件大小, 磁盘大小, 也是一个重点, 这需要你提前算好.
预留/保留一点余地, 给出留后路的冗余.

看了很多帖子, 我发现有很多朋友的问题, 
是因为对内存结构(物理结构、逻辑结构)、内存的使用方式, 不懂不理解其内在原理, 导致的.
内存有地址线与数据线, 一个地址号对应一个数据格(通常是8位一字节),
你可以看做是线型(一行一行地)字节序列, 根据物理内存大小, 是海量的.
这地址号与数据格可以随机访问, 访问方向就是字节序大端小端、高位低位的事.
从逻辑结构上看, 就是在物理结构上编排为嵌套的表, 术语称之为'页', 64位时代是这样,
古旧时代要复杂很多, 因为那时候是CISC+小内存时代.
现在的程序与数据, 是通过在逻辑页上, 把一段一段的字节序列视为栈或堆, 的方式进行使用,
它像是一个窗口、一个框, 术语称之为'帧', 你也可以形象理解为火车在钢轨上,
钢轨就是内存, 火车就是字节序列上的数据, 火车有头尾, 所以字节序列也有头尾/顶底, 例如栈顶、栈底.
现实里, 钢轨可能只有一股或几股,
但是内存里就不止一行了, 而是海量的行.
在逻辑上, 程序与数据结构, 皆是基于栈与堆, 意思就是放在这之上.
栈可以想象成是栈板, 堆就是海量的栈板与栈板上的货物, 编号入货架、仓库.
一般, 栈与堆, 在内存的两头, 即-高位低位.
因为内存是随机访问的, 所以不管程序与数据在两头还是中间, 都是同时触发.

其中, 指针特别重要.
不管是程序, 还是系统, 还是别的什么, 包括这RAMOS,
它们能实现各种高阶抽象的功能, 大都基于指针, 
高级语言或脚本语言内操作底层功能, 是因为底层语言封装了指针很多功能作为API给它们调用.

指针, 就是变量.
变量可以存数据, 也可以存地址.
本来地址号与数据格, 是分立且关联地存在,
当人类把地址号存到数据格里时, 指针这一概念就创造出来了.
数据格又可以代表地址号, 数据格配上长度与类型, 就是变量.
于是, 什么抽象、逻辑、虚拟化, 等等, 一切都可以实现了.
多级指针, 就是下一个数据格存储上一个数据格的地址, 而上一个数据格里存的也是一个地址.

那么这RAMOS就好理解了, 
启动后, 多级引导, 每一步读取下一个引导程序的地址, 放入指令指针/程序计数器(是一个寄存器),
用跳jmp指令, 跳到这个地址, 就能执行这个程序. 
这就是其链式引导的实现方式, 链载入chainloader, 链是动词/谓词.
整个启动过程, 就是在每一步引导程序实现的功能越来越多、复杂, 
像阶梯或锁链一样, 直至跳到系统内核的地址, 系统逐渐启动完成.
这被称之为自举.
编译器也有自举, 它们在广义上是相同的, 只是实现与运行时不同.

不单单是这里的举例,
其实很多技术点都是这样应用,
例如编程里的条件判断、循环, 函数调用, API调用, 等等, 

/
换成grub2引导.
需要复制 .efi 文件到物理硬盘的ESP分区.
编辑一个 .cfg 文件后一并复制去.
再使用磁盘精灵或bootice修改裸机UEFI的启动顺序, 指向新的 .efi 文件, 并创建它的启动项.

使用一个修改版的grub2; wuyou.net/forum.php?mod=viewthread&tid=417233 ,

