/*
** $Id: lparser.c $
** Lua Parser
** See Copyright Notice in lua.h
*/

#define lparser_c
#define 应程接_月亮_内核_宏名

#include "lprefix.h"


#include <limits.h>
#include <string.h>

#include "lua.h"

#include "lcode.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "llex.h"
#include "lmem.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lparser.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"



/* maximum number of local variables per function (must be smaller
   than 250, due 到_变量 the bytecode 格式_变量) */
#define 解析器_最大变量_宏名		200


#define 解析器_有多个返回值_宏名(k)		((k) == 虚调用_种类 || (k) == 虚变量实参_种类)


/* because all strings are unified by the scanner, the parser
   can use pointer equality for string equality */
#define 解析器_串相等_宏名(a,b)	((a) == (b))


/*
** nodes for 月解析器_块_函 列表_变量 (列表_变量 of active blocks)
*/
typedef struct 块继续_结 {
  struct 块继续_结 *前一个_变量;  /* chain */
  int 首个标号_圆;  /* index of 首先_变量 标号_圆 in this 月解析器_块_函 */
  int 首个去到_圆;  /* index of 首先_变量 pending goto in this 月解析器_块_函 */
  路_字节型 活动变量数_缩;  /* # active locals outside the 月解析器_块_函 */
  路_字节型 上值_变量;  /* true if some variable in the 月解析器_块_函 is an 上值_圆 */
  路_字节型 是环吗_圆;  /* true if '月解析器_块_函' is a 环_变量 */
  路_字节型 内塞待关闭_缩;  /* true if inside the scope of a 到_变量-be-closed 变_短变量. */
} 块继续_结;



/*
** prototypes for recursive non-terminal functions
*/
static void 月解析器_语句_函 (词法状态机_结 *状列_缩变量);
static void 月解析器_表达式_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v);


static 限制_l_无返回值_宏名 月解析器_错误_期望_函 (词法状态机_结 *状列_缩变量, int 牌_小写) {
  月亮分析_句法错误_函(状列_缩变量,
      月亮对象_推入格式化字符串_函(状列_缩变量->L, "%s expected", 月亮分析_牌到串_函(状列_缩变量, 牌_小写)));
}


static 限制_l_无返回值_宏名 月解析器_错误限制_函 (函状态机_结 *字段静态_变量, int 限制_变量, const char *什么_变量) {
  炉_状态机结 *L = 字段静态_变量->状列_缩变量->L;
  const char *消息_缩变量;
  int 行_变量 = 字段静态_变量->f->已定义行_小写;
  const char *哪儿_变量 = (行_变量 == 0)
                      ? "main function"
                      : 月亮对象_推入格式化字符串_函(L, "function at 行_变量 %d", 行_变量);
  消息_缩变量 = 月亮对象_推入格式化字符串_函(L, "too many %s (限制_变量 is %d) in %s",
                             什么_变量, 限制_变量, 哪儿_变量);
  月亮分析_句法错误_函(字段静态_变量->状列_缩变量, 消息_缩变量);
}


static void 月解析器_检查限制_函 (函状态机_结 *字段静态_变量, int v, int l, const char *什么_变量) {
  if (v > l) 月解析器_错误限制_函(字段静态_变量, l, 什么_变量);
}


/*
** Test whether 下一个_变量 牌_小写 is 'c'; if so, skip it.
*/
static int 月解析器_测试下一个_函 (词法状态机_结 *状列_缩变量, int c) {
  if (状列_缩变量->t.牌_小写 == c) {
    月亮分析_下一个_函(状列_缩变量);
    return 1;
  }
  else return 0;
}


/*
** Check that 下一个_变量 牌_小写 is 'c'.
*/
static void 月解析器_检查_函 (词法状态机_结 *状列_缩变量, int c) {
  if (状列_缩变量->t.牌_小写 != c)
    月解析器_错误_期望_函(状列_缩变量, c);
}


/*
** Check that 下一个_变量 牌_小写 is 'c' and skip it.
*/
static void 月解析器_检查下一个_函 (词法状态机_结 *状列_缩变量, int c) {
  月解析器_检查_函(状列_缩变量, c);
  月亮分析_下一个_函(状列_缩变量);
}


#define 解析器_检查_条件_宏名(状列_缩变量,c,消息_缩变量)	{ if (!(c)) 月亮分析_句法错误_函(状列_缩变量, 消息_缩变量); }


/*
** Check that 下一个_变量 牌_小写 is '什么_变量' and skip it. In case of 错误_小变量,
** raise an 错误_小变量 that the expected '什么_变量' should 月串库_匹配_函 a 'who'
** in 行_变量 '哪儿_变量' (if that is not the 当前_圆 行_变量).
*/
static void 月解析器_检查_匹配_函 (词法状态机_结 *状列_缩变量, int 什么_变量, int who, int 哪儿_变量) {
  if (配置_l_可能性低_宏名(!月解析器_测试下一个_函(状列_缩变量, 什么_变量))) {
    if (哪儿_变量 == 状列_缩变量->行数目_小写)  /* all in the same 行_变量? */
      月解析器_错误_期望_函(状列_缩变量, 什么_变量);  /* do not need a complex message */
    else {
      月亮分析_句法错误_函(状列_缩变量, 月亮对象_推入格式化字符串_函(状列_缩变量->L,
             "%s expected (到_变量 关闭_圆 %s at 行_变量 %d)",
              月亮分析_牌到串_函(状列_缩变量, 什么_变量), 月亮分析_牌到串_函(状列_缩变量, who), 哪儿_变量));
    }
  }
}


static 标签字符串_结 *月解析器_串_检查名称_函 (词法状态机_结 *状列_缩变量) {
  标签字符串_结 *类s_变量;
  月解析器_检查_函(状列_缩变量, 终结牌_名称);
  类s_变量 = 状列_缩变量->t.语义信息_小写.类s_变量;
  月亮分析_下一个_函(状列_缩变量);
  return 类s_变量;
}


static void 月解析器_初始的_表达式_函 (表达式描述_结 *e, 表达式种类_枚举 k, int i) {
  e->f = e->t = 代码_无_跳转_宏名;
  e->k = k;
  e->u.信息_短变量 = i;
}


static void 月解析器_代码字符串_函 (表达式描述_结 *e, 标签字符串_结 *s) {
  e->f = e->t = 代码_无_跳转_宏名;
  e->k = 虚常串_种类;
  e->u.串值_短 = s;
}


static void 月解析器_代码名称_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *e) {
  月解析器_代码字符串_函(e, 月解析器_串_检查名称_函(状列_缩变量));
}


/*
** Register a new local variable in the active '原型_结' (for debug
** information).
*/
static int 月解析器_寄存器本地变量_函 (词法状态机_结 *状列_缩变量, 函状态机_结 *字段静态_变量, 标签字符串_结 *变量名称_变量) {
  原型_结 *f = 字段静态_变量->f;
  int 旧大小_变量 = f->本地变量大小_短;
  内存_月亮M_增长向量_宏名(状列_缩变量->L, f->本地变量们_短, 字段静态_变量->调试变量数_缩, f->本地变量大小_短,
                  本地变量_结, SHRT_MAX, "local variables");
  while (旧大小_变量 < f->本地变量大小_短)
    f->本地变量们_短[旧大小_变量++].变量名称_变量 = NULL;
  f->本地变量们_短[字段静态_变量->调试变量数_缩].变量名称_变量 = 变量名称_变量;
  f->本地变量们_短[字段静态_变量->调试变量数_缩].始程计_缩 = 字段静态_变量->程序计数_变量;
  垃圾回收_月亮C_对象屏障_宏名(状列_缩变量->L, f, 变量名称_变量);
  return 字段静态_变量->调试变量数_缩++;
}


/*
** Create a new local variable with the given '名称_变量'. Return its index
** in the function.
*/
static int 月解析器_新_本地变量_函 (词法状态机_结 *状列_缩变量, 标签字符串_结 *名称_变量) {
  炉_状态机结 *L = 状列_缩变量->L;
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  动态数据_结 *定你数_缩变量 = 状列_缩变量->定你数_缩变量;
  变量描述_联 *变_短变量;
  月解析器_检查限制_函(字段静态_变量, 定你数_缩变量->活动变量_结.n + 1 - 字段静态_变量->首个本地_圆,
                 解析器_最大变量_宏名, "local variables");
  内存_月亮M_增长向量_宏名(L, 定你数_缩变量->活动变量_结.arr, 定你数_缩变量->活动变量_结.n + 1,
                  定你数_缩变量->活动变量_结.大小_变量, 变量描述_联, USHRT_MAX, "local variables");
  变_短变量 = &定你数_缩变量->活动变量_结.arr[定你数_缩变量->活动变量_结.n++];
  变_短变量->有效数据_变量.种类_变量 = 解析器_变量D种类寄存器_宏名;  /* default */
  变_短变量->有效数据_变量.名称_变量 = 名称_变量;
  return 定你数_缩变量->活动变量_结.n - 1 - 字段静态_变量->首个本地_圆;
}

#define 解析器_新_本地变量字面_宏名(状列_缩变量,v) \
    月解析器_新_本地变量_函(状列_缩变量,  \
      月亮分析_新字符串_函(状列_缩变量, "" v, (sizeof(v)/sizeof(char)) - 1));



/*
** Return the "variable description" (变量描述_联) of a given variable.
** (Unless noted otherwise, all variables are referred 到_变量 by their
** compiler indices.)
*/
static 变量描述_联 *月解析器_获取本地变量描述_函 (函状态机_结 *字段静态_变量, int 变索引_变量) {
  return &字段静态_变量->状列_缩变量->定你数_缩变量->活动变量_结.arr[字段静态_变量->首个本地_圆 + 变索引_变量];
}


/*
** Convert '变量数目_缩变量', a compiler index 层级_变量, 到_变量 its corresponding
** register. For that, search for the highest variable below that 层级_变量
** that is in a register and uses its register index ('寄索引_缩短') plus one.
*/
static int 寄存层级_变量 (函状态机_结 *字段静态_变量, int 变量数目_缩变量) {
  while (变量数目_缩变量-- > 0) {
    变量描述_联 *有效数据_变量 = 月解析器_获取本地变量描述_函(字段静态_变量, 变量数目_缩变量);  /* get 前一个_变量 variable */
    if (有效数据_变量->有效数据_变量.种类_变量 != 解析器_寄存器D种类代码到常量_宏名)  /* is in a register? */
      return 有效数据_变量->有效数据_变量.寄索引_缩短 + 1;
  }
  return 0;  /* no variables in registers */
}


/*
** Return the number of variables in the register 栈_圆小 for the given
** function.
*/
int 月亮解析_n变量栈_函 (函状态机_结 *字段静态_变量) {
  return 寄存层级_变量(字段静态_变量, 字段静态_变量->活动变量数_缩);
}


/*
** Get the debug-information entry for 当前_圆 variable '变索引_变量'.
*/
static 本地变量_结 *月解析器_本地调试信息_函 (函状态机_结 *字段静态_变量, int 变索引_变量) {
  变量描述_联 *有效数据_变量 = 月解析器_获取本地变量描述_函(字段静态_变量,  变索引_变量);
  if (有效数据_变量->有效数据_变量.种类_变量 == 解析器_寄存器D种类代码到常量_宏名)
    return NULL;  /* no debug 信息_短变量. for constants */
  else {
    int 索引_缩变量 = 有效数据_变量->有效数据_变量.原型索引_缩短;
    限制_月亮_断言_宏名(索引_缩变量 < 字段静态_变量->调试变量数_缩);
    return &字段静态_变量->f->本地变量们_短[索引_缩变量];
  }
}


/*
** Create an expression representing variable '变索引_变量'
*/
static void 月解析器_初始的_变量_函 (函状态机_结 *字段静态_变量, 表达式描述_结 *e, int 变索引_变量) {
  e->f = e->t = 代码_无_跳转_宏名;
  e->k = 虚本地_种类;
  e->u.变_短变量.变索引_变量 = 变索引_变量;
  e->u.变_短变量.寄索引_缩短 = 月解析器_获取本地变量描述_函(字段静态_变量, 变索引_变量)->有效数据_变量.寄索引_缩短;
}


/*
** Raises an 错误_小变量 if variable described by 'e' is read only
*/
static void 月解析器_检查_只读_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *e) {
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  标签字符串_结 *变量名称_变量 = NULL;  /* 到_变量 be set if variable is const */
  switch (e->k) {
    case 虚常字面_种类: {
      变量名称_变量 = 状列_缩变量->定你数_缩变量->活动变量_结.arr[e->u.信息_短变量].有效数据_变量.名称_变量;
      break;
    }
    case 虚本地_种类: {
      变量描述_联 *变量描述_变量 = 月解析器_获取本地变量描述_函(字段静态_变量, e->u.变_短变量.变索引_变量);
      if (变量描述_变量->有效数据_变量.种类_变量 != 解析器_变量D种类寄存器_宏名)  /* not a regular variable? */
        变量名称_变量 = 变量描述_变量->有效数据_变量.名称_变量;
      break;
    }
    case 虚上值_种类: {
      上值描述_结 *上_小变量 = &字段静态_变量->f->上值们_小写[e->u.信息_短变量];
      if (上_小变量->种类_变量 != 解析器_变量D种类寄存器_宏名)
        变量名称_变量 = 上_小变量->名称_变量;
      break;
    }
    default:
      return;  /* other cases 月编译器_不能_函 be read-only */
  }
  if (变量名称_变量) {
    const char *消息_缩变量 = 月亮对象_推入格式化字符串_函(状列_缩变量->L,
       "attempt 到_变量 assign 到_变量 const variable '%s'", 对象_获取串_宏名(变量名称_变量));
    月亮常量_语义错误_函(状列_缩变量, 消息_缩变量);  /* 错误_小变量 */
  }
}


/*
** Start the scope for the 最后_变量 '数变量们_变量' created variables.
*/
static void 月解析器_调整本地变量们_函 (词法状态机_结 *状列_缩变量, int 数变量们_变量) {
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 寄存层级_变量 = 月亮解析_n变量栈_函(字段静态_变量);
  int i;
  for (i = 0; i < 数变量们_变量; i++) {
    int 变索引_变量 = 字段静态_变量->活动变量数_缩++;
    变量描述_联 *变_短变量 = 月解析器_获取本地变量描述_函(字段静态_变量, 变索引_变量);
    变_短变量->有效数据_变量.寄索引_缩短 = 寄存层级_变量++;
    变_短变量->有效数据_变量.原型索引_缩短 = 月解析器_寄存器本地变量_函(状列_缩变量, 字段静态_变量, 变_短变量->有效数据_变量.名称_变量);
  }
}


/*
** Close the scope for all variables 上_小变量 到_变量 层级_变量 'tolevel'.
** (debug 信息_短变量.)
*/
static void 月解析器_移除变量们_函 (函状态机_结 *字段静态_变量, int tolevel) {
  字段静态_变量->状列_缩变量->定你数_缩变量->活动变量_结.n -= (字段静态_变量->活动变量数_缩 - tolevel);
  while (字段静态_变量->活动变量数_缩 > tolevel) {
    本地变量_结 *变_短变量 = 月解析器_本地调试信息_函(字段静态_变量, --字段静态_变量->活动变量数_缩);
    if (变_短变量)  /* does it have debug information? */
      变_短变量->终程计_缩 = 字段静态_变量->程序计数_变量;
  }
}


/*
** Search the 上值们_小写 of the function '字段静态_变量' for one
** with the given '名称_变量'.
*/
static int 月解析器_搜索上值_函 (函状态机_结 *字段静态_变量, 标签字符串_结 *名称_变量) {
  int i;
  上值描述_结 *上_小变量 = 字段静态_变量->f->上值们_小写;
  for (i = 0; i < 字段静态_变量->上值数_短缩; i++) {
    if (解析器_串相等_宏名(上_小变量[i].名称_变量, 名称_变量)) return i;
  }
  return -1;  /* not found */
}


static 上值描述_结 *月解析器_分配上值_函 (函状态机_结 *字段静态_变量) {
  原型_结 *f = 字段静态_变量->f;
  int 旧大小_变量 = f->上值大小_小写;
  月解析器_检查限制_函(字段静态_变量, 字段静态_变量->上值数_短缩 + 1, 函_最大上值_宏名, "上值们_小写");
  内存_月亮M_增长向量_宏名(字段静态_变量->状列_缩变量->L, f->上值们_小写, 字段静态_变量->上值数_短缩, f->上值大小_小写,
                  上值描述_结, 函_最大上值_宏名, "上值们_小写");
  while (旧大小_变量 < f->上值大小_小写)
    f->上值们_小写[旧大小_变量++].名称_变量 = NULL;
  return &f->上值们_小写[字段静态_变量->上值数_短缩++];
}


static int 月解析器_新上值_函 (函状态机_结 *字段静态_变量, 标签字符串_结 *名称_变量, 表达式描述_结 *v) {
  上值描述_结 *上_小变量 = 月解析器_分配上值_函(字段静态_变量);
  函状态机_结 *前一_短变量 = 字段静态_变量->前一_短变量;
  if (v->k == 虚本地_种类) {
    上_小变量->栈内_小写 = 1;
    上_小变量->索引_缩变量 = v->u.变_短变量.寄索引_缩短;
    上_小变量->种类_变量 = 月解析器_获取本地变量描述_函(前一_短变量, v->u.变_短变量.变索引_变量)->有效数据_变量.种类_变量;
    限制_月亮_断言_宏名(解析器_串相等_宏名(名称_变量, 月解析器_获取本地变量描述_函(前一_短变量, v->u.变_短变量.变索引_变量)->有效数据_变量.名称_变量));
  }
  else {
    上_小变量->栈内_小写 = 0;
    上_小变量->索引_缩变量 = 限制_类型转换_字节_宏名(v->u.信息_短变量);
    上_小变量->种类_变量 = 前一_短变量->f->上值们_小写[v->u.信息_短变量].种类_变量;
    限制_月亮_断言_宏名(解析器_串相等_宏名(名称_变量, 前一_短变量->f->上值们_小写[v->u.信息_短变量].名称_变量));
  }
  上_小变量->名称_变量 = 名称_变量;
  垃圾回收_月亮C_对象屏障_宏名(字段静态_变量->状列_缩变量->L, 字段静态_变量->f, 名称_变量);
  return 字段静态_变量->上值数_短缩 - 1;
}


/*
** Look for an active local variable with the 名称_变量 'n' in the
** function '字段静态_变量'. If found, initialize '变_短变量' with it and return
** its expression 种类_变量; otherwise return -1.
*/
static int 月解析器_搜索变量_函 (函状态机_结 *字段静态_变量, 标签字符串_结 *n, 表达式描述_结 *变_短变量) {
  int i;
  for (i = 限制_类型转换_整型_宏名(字段静态_变量->活动变量数_缩) - 1; i >= 0; i--) {
    变量描述_联 *有效数据_变量 = 月解析器_获取本地变量描述_函(字段静态_变量, i);
    if (解析器_串相等_宏名(n, 有效数据_变量->有效数据_变量.名称_变量)) {  /* found? */
      if (有效数据_变量->有效数据_变量.种类_变量 == 解析器_寄存器D种类代码到常量_宏名)  /* compile-time constant? */
        月解析器_初始的_表达式_函(变_短变量, 虚常字面_种类, 字段静态_变量->首个本地_圆 + i);
      else  /* real variable */
        月解析器_初始的_变量_函(字段静态_变量, 变_短变量, i);
      return 变_短变量->k;
    }
  }
  return -1;  /* not found */
}


/*
** Mark 月解析器_块_函 哪儿_变量 variable at given 层级_变量 was defined
** (到_变量 emit 关闭_圆 instructions later).
*/
static void 月解析器_记号上值_函 (函状态机_结 *字段静态_变量, int 层级_变量) {
  块继续_结 *基本逻辑_变量 = 字段静态_变量->基本逻辑_变量;
  while (基本逻辑_变量->活动变量数_缩 > 层级_变量)
    基本逻辑_变量 = 基本逻辑_变量->前一个_变量;
  基本逻辑_变量->上值_变量 = 1;
  字段静态_变量->需要关闭_圆 = 1;
}


/*
** Mark that 当前_圆 月解析器_块_函 has a 到_变量-be-closed variable.
*/
static void 月解析器_记号待关闭_函 (函状态机_结 *字段静态_变量) {
  块继续_结 *基本逻辑_变量 = 字段静态_变量->基本逻辑_变量;
  基本逻辑_变量->上值_变量 = 1;
  基本逻辑_变量->内塞待关闭_缩 = 1;
  字段静态_变量->需要关闭_圆 = 1;
}


/*
** Find a variable with the given 名称_变量 'n'. If it is an 上值_圆, add
** this 上值_圆 into all intermediate functions. If it is a global, set
** '变_短变量' as 'void' as a flag.
*/
static void 月解析器_单变量辅助_函 (函状态机_结 *字段静态_变量, 标签字符串_结 *n, 表达式描述_结 *变_短变量, int 基本_变量) {
  if (字段静态_变量 == NULL)  /* no 更多_变量 levels? */
    月解析器_初始的_表达式_函(变_短变量, 虚空的_种类, 0);  /* default is global */
  else {
    int v = 月解析器_搜索变量_函(字段静态_变量, n, 变_短变量);  /* look 上_小变量 locals at 当前_圆 层级_变量 */
    if (v >= 0) {  /* found? */
      if (v == 虚本地_种类 && !基本_变量)
        月解析器_记号上值_函(字段静态_变量, 变_短变量->u.变_短变量.变索引_变量);  /* local will be used as an 上值_变量 */
    }
    else {  /* not found as local at 当前_圆 层级_变量; try 上值们_小写 */
      int 索引_缩变量 = 月解析器_搜索上值_函(字段静态_变量, n);  /* try existing 上值们_小写 */
      if (索引_缩变量 < 0) {  /* not found? */
        月解析器_单变量辅助_函(字段静态_变量->前一_短变量, n, 变_短变量, 0);  /* try upper levels */
        if (变_短变量->k == 虚本地_种类 || 变_短变量->k == 虚上值_种类)  /* local or 上值_圆? */
          索引_缩变量  = 月解析器_新上值_函(字段静态_变量, n, 变_短变量);  /* will be a new 上值_圆 */
        else  /* it is a global or a constant */
          return;  /* don't need 到_变量 do anything at this 层级_变量 */
      }
      月解析器_初始的_表达式_函(变_短变量, 虚上值_种类, 索引_缩变量);  /* new or 旧_变量 上值_圆 */
    }
  }
}


/*
** Find a variable with the given 名称_变量 'n', handling global variables
** too.
*/
static void 月解析器_单变量_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *变_短变量) {
  标签字符串_结 *变量名称_变量 = 月解析器_串_检查名称_函(状列_缩变量);
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  月解析器_单变量辅助_函(字段静态_变量, 变量名称_变量, 变_短变量, 1);
  if (变_短变量->k == 虚空的_种类) {  /* global 名称_变量? */
    表达式描述_结 键_小变量;
    月解析器_单变量辅助_函(字段静态_变量, 状列_缩变量->环境名_短, 变_短变量, 1);  /* get environment variable */
    限制_月亮_断言_宏名(变_短变量->k != 虚空的_种类);  /* this one must exist */
    月亮常量_表达式到任意寄存器更新_函(字段静态_变量, 变_短变量);  /* but could be a constant */
    月解析器_代码字符串_函(&键_小变量, 变量名称_变量);  /* 键_小变量 is variable 名称_变量 */
    月亮常量_已索引_函(字段静态_变量, 变_短变量, &键_小变量);  /* 环境_短变量[变量名称_变量] */
  }
}


/*
** Adjust the number of results from an expression 列表_变量 'e' with '表达式数目_变量'
** expressions 到_变量 '数变量们_变量' values.
*/
static void 月解析器_调整_赋值_函 (词法状态机_结 *状列_缩变量, int 数变量们_变量, int 表达式数目_变量, 表达式描述_结 *e) {
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 已需要_变量 = 数变量们_变量 - 表达式数目_变量;  /* 额外_变量 values 已需要_变量 */
  if (解析器_有多个返回值_宏名(e->k)) {  /* 最后_变量 expression has multiple returns? */
    int 额外_变量 = 已需要_变量 + 1;  /* discount 最后_变量 expression itself */
    if (额外_变量 < 0)
      额外_变量 = 0;
    月亮常量_设置返回值_函(字段静态_变量, e, 额外_变量);  /* 最后_变量 exp. provides the difference */
  }
  else {
    if (e->k != 虚空的_种类)  /* at least one expression? */
      月亮常量_表达式到下一个寄存器_函(字段静态_变量, e);  /* 关闭_圆 最后_变量 expression */
    if (已需要_变量 > 0)  /* missing values? */
      月亮常量_空值_函(字段静态_变量, 字段静态_变量->是否寄存_短, 已需要_变量);  /* complete with nils */
  }
  if (已需要_变量 > 0)
    月亮常量_保留寄存器们_函(字段静态_变量, 已需要_变量);  /* registers for 额外_变量 values */
  else  /* adding '已需要_变量' is actually a subtraction */
    字段静态_变量->是否寄存_短 += 已需要_变量;  /* remove 额外_变量 values */
}


#define 解析器_进入层级_宏名(状列_缩变量)	月亮错误_递增C栈_函(状列_缩变量->L)


#define 解析器_离开层级_宏名(状列_缩变量) ((状列_缩变量)->L->C调用们数_缩圆--)


/*
** Generates an 错误_小变量 that a goto jumps into the scope of some
** local variable.
*/
static 限制_l_无返回值_宏名 月解析器_跳转作用域错误_函 (词法状态机_结 *状列_缩变量, 标号描述_结 *全局表_缩变量) {
  const char *变量名称_变量 = 对象_获取串_宏名(月解析器_获取本地变量描述_函(状列_缩变量->字段静态_变量, 全局表_缩变量->活动变量数_缩)->有效数据_变量.名称_变量);
  const char *消息_缩变量 = "<goto %s> at 行_变量 %d jumps into the scope of local '%s'";
  消息_缩变量 = 月亮对象_推入格式化字符串_函(状列_缩变量->L, 消息_缩变量, 对象_获取串_宏名(全局表_缩变量->名称_变量), 全局表_缩变量->行_变量, 变量名称_变量);
  月亮常量_语义错误_函(状列_缩变量, 消息_缩变量);  /* raise the 错误_小变量 */
}


/*
** Solves the goto at index 'g' 到_变量 given '标号_圆' and removes it
** from the 列表_变量 of pending gotos.
** If it jumps into the scope of some variable, raises an 错误_小变量.
*/
static void 月解析器_解决去到_函 (词法状态机_结 *状列_缩变量, int g, 标号描述_结 *标号_圆) {
  int i;
  标号列表_结 *全局逻辑_变量 = &状列_缩变量->定你数_缩变量->全局表_缩变量;  /* 列表_变量 of gotos */
  标号描述_结 *全局表_缩变量 = &全局逻辑_变量->arr[g];  /* goto 到_变量 be resolved */
  限制_月亮_断言_宏名(解析器_串相等_宏名(全局表_缩变量->名称_变量, 标号_圆->名称_变量));
  if (配置_l_可能性低_宏名(全局表_缩变量->活动变量数_缩 < 标号_圆->活动变量数_缩))  /* enter some scope? */
    月解析器_跳转作用域错误_函(状列_缩变量, 全局表_缩变量);
  月亮常量_补丁列表_函(状列_缩变量->字段静态_变量, 全局表_缩变量->程序计数_变量, 标号_圆->程序计数_变量);
  for (i = g; i < 全局逻辑_变量->n - 1; i++)  /* remove goto from pending 列表_变量 */
    全局逻辑_变量->arr[i] = 全局逻辑_变量->arr[i + 1];
  全局逻辑_变量->n--;
}


/*
** Search for an active 标号_圆 with the given 名称_变量.
*/
static 标号描述_结 *月解析器_找标号_函 (词法状态机_结 *状列_缩变量, 标签字符串_结 *名称_变量) {
  int i;
  动态数据_结 *定你数_缩变量 = 状列_缩变量->定你数_缩变量;
  /* 月解析器_检查_函 labels in 当前_圆 function for a 月串库_匹配_函 */
  for (i = 状列_缩变量->字段静态_变量->首个标号_圆; i < 定你数_缩变量->标号_圆.n; i++) {
    标号描述_结 *lb = &定你数_缩变量->标号_圆.arr[i];
    if (解析器_串相等_宏名(lb->名称_变量, 名称_变量))  /* correct 标号_圆? */
      return lb;
  }
  return NULL;  /* 标号_圆 not found */
}


/*
** Adds a new 标号_圆/goto in the corresponding 列表_变量.
*/
static int 月解析器_新标号条目_函 (词法状态机_结 *状列_缩变量, 标号列表_结 *l, 标签字符串_结 *名称_变量,
                          int 行_变量, int 程序计数_变量) {
  int n = l->n;
  内存_月亮M_增长向量_宏名(状列_缩变量->L, l->arr, n, l->大小_变量,
                  标号描述_结, SHRT_MAX, "labels/gotos");
  l->arr[n].名称_变量 = 名称_变量;
  l->arr[n].行_变量 = 行_变量;
  l->arr[n].活动变量数_缩 = 状列_缩变量->字段静态_变量->活动变量数_缩;
  l->arr[n].关闭_圆 = 0;
  l->arr[n].程序计数_变量 = 程序计数_变量;
  l->n = n + 1;
  return n;
}


static int 月解析器_新去到条目_函 (词法状态机_结 *状列_缩变量, 标签字符串_结 *名称_变量, int 行_变量, int 程序计数_变量) {
  return 月解析器_新标号条目_函(状列_缩变量, &状列_缩变量->定你数_缩变量->全局表_缩变量, 名称_变量, 行_变量, 程序计数_变量);
}


/*
** Solves forward jumps. Check whether new 标号_圆 'lb' matches any
** pending gotos in 当前_圆 月解析器_块_函 and solves them. Return true
** if any of the gotos need 到_变量 关闭_圆 上值们_小写.
*/
static int 月解析器_解决去到们_函 (词法状态机_结 *状列_缩变量, 标号描述_结 *lb) {
  标号列表_结 *全局逻辑_变量 = &状列_缩变量->定你数_缩变量->全局表_缩变量;
  int i = 状列_缩变量->字段静态_变量->基本逻辑_变量->首个去到_圆;
  int 需关闭_变量 = 0;
  while (i < 全局逻辑_变量->n) {
    if (解析器_串相等_宏名(全局逻辑_变量->arr[i].名称_变量, lb->名称_变量)) {
      需关闭_变量 |= 全局逻辑_变量->arr[i].关闭_圆;
      月解析器_解决去到_函(状列_缩变量, i, lb);  /* will remove 'i' from the 列表_变量 */
    }
    else
      i++;
  }
  return 需关闭_变量;
}


/*
** Create a new 标号_圆 with the given '名称_变量' at the given '行_变量'.
** '最后_变量' tells whether 标号_圆 is the 最后_变量 non-操作_短变量 月解析器_语句_函 in its
** 月解析器_块_函. Solves all pending gotos 到_变量 this new 标号_圆 and adds
** a 关闭_圆 instruction if necessary.
** Returns true iff it added a 关闭_圆 instruction.
*/
static int 月解析器_创建标号_函 (词法状态机_结 *状列_缩变量, 标签字符串_结 *名称_变量, int 行_变量,
                        int 最后_变量) {
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  标号列表_结 *ll = &状列_缩变量->定你数_缩变量->标号_圆;
  int l = 月解析器_新标号条目_函(状列_缩变量, ll, 名称_变量, 行_变量, 月亮常量_获取标号_函(字段静态_变量));
  if (最后_变量) {  /* 标号_圆 is 最后_变量 no-操作_短变量 月解析器_语句_函 in the 月解析器_块_函? */
    /* assume that locals are already out of scope */
    ll->arr[l].活动变量数_缩 = 字段静态_变量->基本逻辑_变量->活动变量数_缩;
  }
  if (月解析器_解决去到们_函(状列_缩变量, &ll->arr[l])) {  /* need 关闭_圆? */
    代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_关闭, 月亮解析_n变量栈_函(字段静态_变量), 0, 0);
    return 1;
  }
  return 0;
}


/*
** Adjust pending gotos 到_变量 outer 层级_变量 of a 月解析器_块_函.
*/
static void 月解析器_移动去到们出_函 (函状态机_结 *字段静态_变量, 块继续_结 *基本逻辑_变量) {
  int i;
  标号列表_结 *全局逻辑_变量 = &字段静态_变量->状列_缩变量->定你数_缩变量->全局表_缩变量;
  /* correct pending gotos 到_变量 当前_圆 月解析器_块_函 */
  for (i = 基本逻辑_变量->首个去到_圆; i < 全局逻辑_变量->n; i++) {  /* for each pending goto */
    标号描述_结 *全局表_缩变量 = &全局逻辑_变量->arr[i];
    /* leaving a variable scope? */
    if (寄存层级_变量(字段静态_变量, 全局表_缩变量->活动变量数_缩) > 寄存层级_变量(字段静态_变量, 基本逻辑_变量->活动变量数_缩))
      全局表_缩变量->关闭_圆 |= 基本逻辑_变量->上值_变量;  /* jump may need a 关闭_圆 */
    全局表_缩变量->活动变量数_缩 = 基本逻辑_变量->活动变量数_缩;  /* update goto 层级_变量 */
  }
}


static void 月解析器_进入块_函 (函状态机_结 *字段静态_变量, 块继续_结 *基本逻辑_变量, 路_字节型 是环吗_圆) {
  基本逻辑_变量->是环吗_圆 = 是环吗_圆;
  基本逻辑_变量->活动变量数_缩 = 字段静态_变量->活动变量数_缩;
  基本逻辑_变量->首个标号_圆 = 字段静态_变量->状列_缩变量->定你数_缩变量->标号_圆.n;
  基本逻辑_变量->首个去到_圆 = 字段静态_变量->状列_缩变量->定你数_缩变量->全局表_缩变量.n;
  基本逻辑_变量->上值_变量 = 0;
  基本逻辑_变量->内塞待关闭_缩 = (字段静态_变量->基本逻辑_变量 != NULL && 字段静态_变量->基本逻辑_变量->内塞待关闭_缩);
  基本逻辑_变量->前一个_变量 = 字段静态_变量->基本逻辑_变量;
  字段静态_变量->基本逻辑_变量 = 基本逻辑_变量;
  限制_月亮_断言_宏名(字段静态_变量->是否寄存_短 == 月亮解析_n变量栈_函(字段静态_变量));
}


/*
** generates an 错误_小变量 for an undefined 'goto'.
*/
static 限制_l_无返回值_宏名 月解析器_未定义去到_函 (词法状态机_结 *状列_缩变量, 标号描述_结 *全局表_缩变量) {
  const char *消息_缩变量;
  if (解析器_串相等_宏名(全局表_缩变量->名称_变量, 字符串_月亮S_新字面_宏名(状列_缩变量->L, "break"))) {
    消息_缩变量 = "break outside 环_变量 at 行_变量 %d";
    消息_缩变量 = 月亮对象_推入格式化字符串_函(状列_缩变量->L, 消息_缩变量, 全局表_缩变量->行_变量);
  }
  else {
    消息_缩变量 = "no visible 标号_圆 '%s' for <goto> at 行_变量 %d";
    消息_缩变量 = 月亮对象_推入格式化字符串_函(状列_缩变量->L, 消息_缩变量, 对象_获取串_宏名(全局表_缩变量->名称_变量), 全局表_缩变量->行_变量);
  }
  月亮常量_语义错误_函(状列_缩变量, 消息_缩变量);
}


static void 月解析器_离开块_函 (函状态机_结 *字段静态_变量) {
  块继续_结 *基本逻辑_变量 = 字段静态_变量->基本逻辑_变量;
  词法状态机_结 *状列_缩变量 = 字段静态_变量->状列_缩变量;
  int 有关闭_变量 = 0;
  int 栈层级_变量 = 寄存层级_变量(字段静态_变量, 基本逻辑_变量->活动变量数_缩);  /* 层级_变量 outside the 月解析器_块_函 */
  月解析器_移除变量们_函(字段静态_变量, 基本逻辑_变量->活动变量数_缩);  /* remove 月解析器_块_函 locals */
  限制_月亮_断言_宏名(基本逻辑_变量->活动变量数_缩 == 字段静态_变量->活动变量数_缩);  /* back 到_变量 层级_变量 on entry */
  if (基本逻辑_变量->是环吗_圆)  /* has 到_变量 fix pending breaks? */
    有关闭_变量 = 月解析器_创建标号_函(状列_缩变量, 字符串_月亮S_新字面_宏名(状列_缩变量->L, "break"), 0, 0);
  if (!有关闭_变量 && 基本逻辑_变量->前一个_变量 && 基本逻辑_变量->上值_变量)  /* still need a '关闭_圆'? */
    代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_关闭, 栈层级_变量, 0, 0);
  字段静态_变量->是否寄存_短 = 栈层级_变量;  /* free registers */
  状列_缩变量->定你数_缩变量->标号_圆.n = 基本逻辑_变量->首个标号_圆;  /* remove local labels */
  字段静态_变量->基本逻辑_变量 = 基本逻辑_变量->前一个_变量;  /* 当前_圆 月解析器_块_函 now is 前一个_变量 one */
  if (基本逻辑_变量->前一个_变量)  /* was it a nested 月解析器_块_函? */
    月解析器_移动去到们出_函(字段静态_变量, 基本逻辑_变量);  /* update pending gotos 到_变量 enclosing 月解析器_块_函 */
  else {
    if (基本逻辑_变量->首个去到_圆 < 状列_缩变量->定你数_缩变量->全局表_缩变量.n)  /* still pending gotos? */
      月解析器_未定义去到_函(状列_缩变量, &状列_缩变量->定你数_缩变量->全局表_缩变量.arr[基本逻辑_变量->首个去到_圆]);  /* 错误_小变量 */
  }
}


/*
** adds a new prototype into 列表_变量 of prototypes
*/
static 原型_结 *月解析器_添加原型_函 (词法状态机_结 *状列_缩变量) {
  原型_结 *类共财产_变量;
  炉_状态机结 *L = 状列_缩变量->L;
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  原型_结 *f = 字段静态_变量->f;  /* prototype of 当前_圆 function */
  if (字段静态_变量->np >= f->p大小_缩) {
    int 旧大小_变量 = f->p大小_缩;
    内存_月亮M_增长向量_宏名(L, f->p, 字段静态_变量->np, f->p大小_缩, 原型_结 *, 操作码_最大实参_Bx_宏名, "functions");
    while (旧大小_变量 < f->p大小_缩)
      f->p[旧大小_变量++] = NULL;
  }
  f->p[字段静态_变量->np++] = 类共财产_变量 = 月亮函数_新原型_函(L);
  垃圾回收_月亮C_对象屏障_宏名(L, f, 类共财产_变量);
  return 类共财产_变量;
}


/*
** codes instruction 到_变量 create new closure in parent function.
** The 操作_闭包 instruction uses the 最后_变量 available register,
** so that, if it invokes the GC, the GC knows which registers
** are in use at that time.

*/
static void 月解析器_代码闭包_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量->前一_短变量;
  月解析器_初始的_表达式_函(v, 虚重定位_种类, 月亮常量_代码ABx_函(字段静态_变量, 操作_闭包, 0, 字段静态_变量->np - 1));
  月亮常量_表达式到下一个寄存器_函(字段静态_变量, v);  /* fix it at the 最后_变量 register */
}


static void 月解析器_打开_函_函 (词法状态机_结 *状列_缩变量, 函状态机_结 *字段静态_变量, 块继续_结 *基本逻辑_变量) {
  原型_结 *f = 字段静态_变量->f;
  字段静态_变量->前一_短变量 = 状列_缩变量->字段静态_变量;  /* linked 列表_变量 of funcstates */
  字段静态_变量->状列_缩变量 = 状列_缩变量;
  状列_缩变量->字段静态_变量 = 字段静态_变量;
  字段静态_变量->程序计数_变量 = 0;
  字段静态_变量->前个行_圆 = f->已定义行_小写;
  字段静态_变量->指令与绝对行_短缩 = 0;
  字段静态_变量->最后目标_圆 = 0;
  字段静态_变量->是否寄存_短 = 0;
  字段静态_变量->nk = 0;
  字段静态_变量->绝对行信息数_ = 0;
  字段静态_变量->np = 0;
  字段静态_变量->上值数_短缩 = 0;
  字段静态_变量->调试变量数_缩 = 0;
  字段静态_变量->活动变量数_缩 = 0;
  字段静态_变量->需要关闭_圆 = 0;
  字段静态_变量->首个本地_圆 = 状列_缩变量->定你数_缩变量->活动变量_结.n;
  字段静态_变量->首个标号_圆 = 状列_缩变量->定你数_缩变量->标号_圆.n;
  字段静态_变量->基本逻辑_变量 = NULL;
  f->源_圆 = 状列_缩变量->源_圆;
  垃圾回收_月亮C_对象屏障_宏名(状列_缩变量->L, f, f->源_圆);
  f->最大栈大小_小写 = 2;  /* registers 0/1 are always 有效_变量 */
  月解析器_进入块_函(字段静态_变量, 基本逻辑_变量, 0);
}


static void 月解析器_关闭_函_函 (词法状态机_结 *状列_缩变量) {
  炉_状态机结 *L = 状列_缩变量->L;
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  原型_结 *f = 字段静态_变量->f;
  月亮常量_返回_函(字段静态_变量, 月亮解析_n变量栈_函(字段静态_变量), 0);  /* 最终_变量 return */
  月解析器_离开块_函(字段静态_变量);
  限制_月亮_断言_宏名(字段静态_变量->基本逻辑_变量 == NULL);
  月亮常量_完成_函(字段静态_变量);
  内存_月亮M_缩放向量_宏名(L, f->代码_变量, f->代码大小_小写, 字段静态_变量->程序计数_变量, Instruction);
  内存_月亮M_缩放向量_宏名(L, f->行信息_变量, f->行信息大小_小写, 字段静态_变量->程序计数_变量, ls_byte);
  内存_月亮M_缩放向量_宏名(L, f->绝对行信息_小写, f->绝对行信息大小_小写,
                       字段静态_变量->绝对行信息数_, 绝对行信息_结);
  内存_月亮M_缩放向量_宏名(L, f->k, f->k大小_缩, 字段静态_变量->nk, 标签值_结);
  内存_月亮M_缩放向量_宏名(L, f->p, f->p大小_缩, 字段静态_变量->np, 原型_结 *);
  内存_月亮M_缩放向量_宏名(L, f->本地变量们_短, f->本地变量大小_短, 字段静态_变量->调试变量数_缩, 本地变量_结);
  内存_月亮M_缩放向量_宏名(L, f->上值们_小写, f->上值大小_小写, 字段静态_变量->上值数_短缩, 上值描述_结);
  状列_缩变量->字段静态_变量 = 字段静态_变量->前一_短变量;
  垃圾回收_月亮C_检查GC_宏名(L);
}



/*============================================================*/
/* GRAMMAR RULES */
/*============================================================*/


/*
** 月解析器_检查_函 whether 当前_圆 牌_小写 is in the follow set of a 月解析器_块_函.
** 'until' closes syntactical blocks, but do not 关闭_圆 scope,
** so it is handled in separate.
*/
static int 月解析器_块_跟随_函 (词法状态机_结 *状列_缩变量, int withuntil) {
  switch (状列_缩变量->t.牌_小写) {
    case 终结牌_否则: case 终结牌_否若:
    case 终结牌_终: case 终结牌_流终:
      return 1;
    case 终结牌_直到: return withuntil;
    default: return 0;
  }
}


static void 月解析器_语句列表_函 (词法状态机_结 *状列_缩变量) {
  /* 月解析器_语句列表_函 -> { 状态_短变量 [';'] } */
  while (!月解析器_块_跟随_函(状列_缩变量, 1)) {
    if (状列_缩变量->t.牌_小写 == 终结牌_返回) {
      月解析器_语句_函(状列_缩变量);
      return;  /* 'return' must be 最后_变量 月解析器_语句_函 */
    }
    月解析器_语句_函(状列_缩变量);
  }
}


static void 月解析器_字段选择_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  /* 月解析器_字段选择_函 -> ['.' | ':'] NAME */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  表达式描述_结 键_小变量;
  月亮常量_表达式到任意寄存器更新_函(字段静态_变量, v);
  月亮分析_下一个_函(状列_缩变量);  /* skip the 点_变量 or colon */
  月解析器_代码名称_函(状列_缩变量, &键_小变量);
  月亮常量_已索引_函(字段静态_变量, v, &键_小变量);
}


static void 月解析器_y索引_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  /* index -> '[' 月解析器_表达式_函 ']' */
  月亮分析_下一个_函(状列_缩变量);  /* skip the '[' */
  月解析器_表达式_函(状列_缩变量, v);
  月亮常量_表达式到值_函(状列_缩变量->字段静态_变量, v);
  月解析器_检查下一个_函(状列_缩变量, ']');
}


/*
** {======================================================================
** Rules for Constructors
** =======================================================================
*/


typedef struct 构造控制_结 {
  表达式描述_结 v;  /* 最后_变量 列表_变量 item read */
  表达式描述_结 *t;  /* table descriptor */
  int nh;  /* 总数_变量 number of 'record' elements */
  int 数量a_变量;  /* number of 数组_圆 elements already stored */
  int 到存储_小写;  /* number of 数组_圆 elements pending 到_变量 be stored */
} 构造控制_结;


static void 月解析器_记录字段_函 (词法状态机_结 *状列_缩变量, 构造控制_结 *类构造_变量) {
  /* 月解析器_记录字段_函 -> (NAME | '['exp']') = exp */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 寄存_短变量 = 状列_缩变量->字段静态_变量->是否寄存_短;
  表达式描述_结 表_短_变量, 键_小变量, 值_变量;
  if (状列_缩变量->t.牌_小写 == 终结牌_名称) {
    月解析器_检查限制_函(字段静态_变量, 类构造_变量->nh, 限制_最大_整型_宏名, "items in a 月解析器_构造器_函");
    月解析器_代码名称_函(状列_缩变量, &键_小变量);
  }
  else  /* 状列_缩变量->t.牌_小写 == '[' */
    月解析器_y索引_函(状列_缩变量, &键_小变量);
  类构造_变量->nh++;
  月解析器_检查下一个_函(状列_缩变量, '=');
  表_短_变量 = *类构造_变量->t;
  月亮常量_已索引_函(字段静态_变量, &表_短_变量, &键_小变量);
  月解析器_表达式_函(状列_缩变量, &值_变量);
  月亮常量_存储变量_函(字段静态_变量, &表_短_变量, &值_变量);
  字段静态_变量->是否寄存_短 = 寄存_短变量;  /* free registers */
}


static void 月解析器_关闭列表字段_函 (函状态机_结 *字段静态_变量, 构造控制_结 *类构造_变量) {
  if (类构造_变量->v.k == 虚空的_种类) return;  /* there is no 列表_变量 item */
  月亮常量_表达式到下一个寄存器_函(字段静态_变量, &类构造_变量->v);
  类构造_变量->v.k = 虚空的_种类;
  if (类构造_变量->到存储_小写 == 操作码_字段_每次_刷新_宏名) {
    月亮常量_设置列表_函(字段静态_变量, 类构造_变量->t->u.信息_短变量, 类构造_变量->数量a_变量, 类构造_变量->到存储_小写);  /* flush */
    类构造_变量->数量a_变量 += 类构造_变量->到存储_小写;
    类构造_变量->到存储_小写 = 0;  /* no 更多_变量 items pending */
  }
}


static void 月解析器_最后列表字段_函 (函状态机_结 *字段静态_变量, 构造控制_结 *类构造_变量) {
  if (类构造_变量->到存储_小写 == 0) return;
  if (解析器_有多个返回值_宏名(类构造_变量->v.k)) {
    代码_月亮K_设置多返回_宏名(字段静态_变量, &类构造_变量->v);
    月亮常量_设置列表_函(字段静态_变量, 类构造_变量->t->u.信息_短变量, 类构造_变量->数量a_变量, 月头_月亮_多返回_宏名);
    类构造_变量->数量a_变量--;  /* do not 计数_变量 最后_变量 expression (unknown number of elements) */
  }
  else {
    if (类构造_变量->v.k != 虚空的_种类)
      月亮常量_表达式到下一个寄存器_函(字段静态_变量, &类构造_变量->v);
    月亮常量_设置列表_函(字段静态_变量, 类构造_变量->t->u.信息_短变量, 类构造_变量->数量a_变量, 类构造_变量->到存储_小写);
  }
  类构造_变量->数量a_变量 += 类构造_变量->到存储_小写;
}


static void 月解析器_列表字段_函 (词法状态机_结 *状列_缩变量, 构造控制_结 *类构造_变量) {
  /* 月解析器_列表字段_函 -> exp */
  月解析器_表达式_函(状列_缩变量, &类构造_变量->v);
  类构造_变量->到存储_小写++;
}


static void 月解析器_字段_函 (词法状态机_结 *状列_缩变量, 构造控制_结 *类构造_变量) {
  /* 月解析器_字段_函 -> 月解析器_列表字段_函 | 月解析器_记录字段_函 */
  switch(状列_缩变量->t.牌_小写) {
    case 终结牌_名称: {  /* may be '月解析器_列表字段_函' or '月解析器_记录字段_函' */
      if (月亮分析_看向前_函(状列_缩变量) != '=')  /* expression? */
        月解析器_列表字段_函(状列_缩变量, 类构造_变量);
      else
        月解析器_记录字段_函(状列_缩变量, 类构造_变量);
      break;
    }
    case '[': {
      月解析器_记录字段_函(状列_缩变量, 类构造_变量);
      break;
    }
    default: {
      月解析器_列表字段_函(状列_缩变量, 类构造_变量);
      break;
    }
  }
}


static void 月解析器_构造器_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *t) {
  /* 月解析器_构造器_函 -> '{' [ 月解析器_字段_函 { 分隔_变量 月解析器_字段_函 } [分隔_变量] ] '}'
     分隔_变量 -> ',' | ';' */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 行_变量 = 状列_缩变量->行数目_小写;
  int 程序计数_变量 = 代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_新表, 0, 0, 0);
  构造控制_结 类构造_变量;
  月亮常量_代码_函(字段静态_变量, 0);  /* 空间_圆 for 额外_变量 实参_短变量. */
  类构造_变量.数量a_变量 = 类构造_变量.nh = 类构造_变量.到存储_小写 = 0;
  类构造_变量.t = t;
  月解析器_初始的_表达式_函(t, 虚没有重定位_种类, 字段静态_变量->是否寄存_短);  /* table will be at 栈_圆小 顶部_变量 */
  月亮常量_保留寄存器们_函(字段静态_变量, 1);
  月解析器_初始的_表达式_函(&类构造_变量.v, 虚空的_种类, 0);  /* no 值_圆 (yet) */
  月解析器_检查下一个_函(状列_缩变量, '{');
  do {
    限制_月亮_断言_宏名(类构造_变量.v.k == 虚空的_种类 || 类构造_变量.到存储_小写 > 0);
    if (状列_缩变量->t.牌_小写 == '}') break;
    月解析器_关闭列表字段_函(字段静态_变量, &类构造_变量);
    月解析器_字段_函(状列_缩变量, &类构造_变量);
  } while (月解析器_测试下一个_函(状列_缩变量, ',') || 月解析器_测试下一个_函(状列_缩变量, ';'));
  月解析器_检查_匹配_函(状列_缩变量, '}', '{', 行_变量);
  月解析器_最后列表字段_函(字段静态_变量, &类构造_变量);
  月亮常量_设置表大小_函(字段静态_变量, 程序计数_变量, t->u.信息_短变量, 类构造_变量.数量a_变量, 类构造_变量.nh);
}

/* }====================================================================== */


static void 月解析器_设置变量实参_函 (函状态机_结 *字段静态_变量, int 形参数量_变量) {
  字段静态_变量->f->是否_变量实参短 = 1;
  代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_变量实参预备, 形参数量_变量, 0, 0);
}


static void 月解析器_形参列表_函 (词法状态机_结 *状列_缩变量) {
  /* 月解析器_形参列表_函 -> [ {NAME ','} (NAME | '...') ] */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  原型_结 *f = 字段静态_变量->f;
  int 形参数量_变量 = 0;
  int 是变量实参吗_变量 = 0;
  if (状列_缩变量->t.牌_小写 != ')') {  /* is '月解析器_形参列表_函' not 空容器_变量? */
    do {
      switch (状列_缩变量->t.牌_小写) {
        case 终结牌_名称: {
          月解析器_新_本地变量_函(状列_缩变量, 月解析器_串_检查名称_函(状列_缩变量));
          形参数量_变量++;
          break;
        }
        case 终结牌_省略: {
          月亮分析_下一个_函(状列_缩变量);
          是变量实参吗_变量 = 1;
          break;
        }
        default: 月亮分析_句法错误_函(状列_缩变量, "<名称_变量> or '...' expected");
      }
    } while (!是变量实参吗_变量 && 月解析器_测试下一个_函(状列_缩变量, ','));
  }
  月解析器_调整本地变量们_函(状列_缩变量, 形参数量_变量);
  f->形参数_小写 = 限制_类型转换_字节_宏名(字段静态_变量->活动变量数_缩);
  if (是变量实参吗_变量)
    月解析器_设置变量实参_函(字段静态_变量, f->形参数_小写);  /* declared vararg */
  月亮常量_保留寄存器们_函(字段静态_变量, 字段静态_变量->活动变量数_缩);  /* reserve registers for parameters */
}


static void 月解析器_身体_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *e, int 是方法吗_变量, int 行_变量) {
  /* 月解析器_身体_函 ->  '(' 月解析器_形参列表_函 ')' 月解析器_块_函 END */
  函状态机_结 新_字静_变量;
  块继续_结 基本逻辑_变量;
  新_字静_变量.f = 月解析器_添加原型_函(状列_缩变量);
  新_字静_变量.f->已定义行_小写 = 行_变量;
  月解析器_打开_函_函(状列_缩变量, &新_字静_变量, &基本逻辑_变量);
  月解析器_检查下一个_函(状列_缩变量, '(');
  if (是方法吗_变量) {
    解析器_新_本地变量字面_宏名(状列_缩变量, "self");  /* create 'self' parameter */
    月解析器_调整本地变量们_函(状列_缩变量, 1);
  }
  月解析器_形参列表_函(状列_缩变量);
  月解析器_检查下一个_函(状列_缩变量, ')');
  月解析器_语句列表_函(状列_缩变量);
  新_字静_变量.f->最后已定义行_小写 = 状列_缩变量->行数目_小写;
  月解析器_检查_匹配_函(状列_缩变量, 终结牌_终, 终结牌_函数, 行_变量);
  月解析器_代码闭包_函(状列_缩变量, e);
  月解析器_关闭_函_函(状列_缩变量);
}


static int 月解析器_表达式列表_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  /* 月解析器_表达式列表_函 -> 月解析器_表达式_函 { ',' 月解析器_表达式_函 } */
  int n = 1;  /* at least one expression */
  月解析器_表达式_函(状列_缩变量, v);
  while (月解析器_测试下一个_函(状列_缩变量, ',')) {
    月亮常量_表达式到下一个寄存器_函(状列_缩变量->字段静态_变量, v);
    月解析器_表达式_函(状列_缩变量, v);
    n++;
  }
  return n;
}


static void 月解析器_函实参们_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *f, int 行_变量) {
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  表达式描述_结 实参们_短变量;
  int 基本_变量, 形参数量_变量;
  switch (状列_缩变量->t.牌_小写) {
    case '(': {  /* 月解析器_函实参们_函 -> '(' [ 月解析器_表达式列表_函 ] ')' */
      月亮分析_下一个_函(状列_缩变量);
      if (状列_缩变量->t.牌_小写 == ')')  /* 实参_短变量 列表_变量 is 空容器_变量? */
        实参们_短变量.k = 虚空的_种类;
      else {
        月解析器_表达式列表_函(状列_缩变量, &实参们_短变量);
        if (解析器_有多个返回值_宏名(实参们_短变量.k))
          代码_月亮K_设置多返回_宏名(字段静态_变量, &实参们_短变量);
      }
      月解析器_检查_匹配_函(状列_缩变量, ')', '(', 行_变量);
      break;
    }
    case '{': {  /* 月解析器_函实参们_函 -> 月解析器_构造器_函 */
      月解析器_构造器_函(状列_缩变量, &实参们_短变量);
      break;
    }
    case 终结牌_字符串: {  /* 月解析器_函实参们_函 -> STRING */
      月解析器_代码字符串_函(&实参们_短变量, 状列_缩变量->t.语义信息_小写.类s_变量);
      月亮分析_下一个_函(状列_缩变量);  /* must use '语义信息_小写' before '下一个_变量' */
      break;
    }
    default: {
      月亮分析_句法错误_函(状列_缩变量, "function arguments expected");
    }
  }
  限制_月亮_断言_宏名(f->k == 虚没有重定位_种类);
  基本_变量 = f->u.信息_短变量;  /* 基本_变量 register for call */
  if (解析器_有多个返回值_宏名(实参们_短变量.k))
    形参数量_变量 = 月头_月亮_多返回_宏名;  /* 打开_圆 call */
  else {
    if (实参们_短变量.k != 虚空的_种类)
      月亮常量_表达式到下一个寄存器_函(字段静态_变量, &实参们_短变量);  /* 关闭_圆 最后_变量 argument */
    形参数量_变量 = 字段静态_变量->是否寄存_短 - (基本_变量+1);
  }
  月解析器_初始的_表达式_函(f, 虚调用_种类, 代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_调用, 基本_变量, 形参数量_变量+1, 2));
  月亮常量_修正行号_函(字段静态_变量, 行_变量);
  字段静态_变量->是否寄存_短 = 基本_变量+1;  /* call remove function and arguments and leaves
                            (unless 已更改_变量) one 结果_变量 */
}




/*
** {======================================================================
** Expression parsing
** =======================================================================
*/


static void 月解析器_首要表达式_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  /* 月解析器_首要表达式_函 -> NAME | '(' 月解析器_表达式_函 ')' */
  switch (状列_缩变量->t.牌_小写) {
    case '(': {
      int 行_变量 = 状列_缩变量->行数目_小写;
      月亮分析_下一个_函(状列_缩变量);
      月解析器_表达式_函(状列_缩变量, v);
      月解析器_检查_匹配_函(状列_缩变量, ')', '(', 行_变量);
      月亮常量_卸货变量们_函(状列_缩变量->字段静态_变量, v);
      return;
    }
    case 终结牌_名称: {
      月解析器_单变量_函(状列_缩变量, v);
      return;
    }
    default: {
      月亮分析_句法错误_函(状列_缩变量, "unexpected symbol");
    }
  }
}


static void 月解析器_已下标表达式_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  /* 月解析器_已下标表达式_函 ->
       月解析器_首要表达式_函 { '.' NAME | '[' exp ']' | ':' NAME 月解析器_函实参们_函 | 月解析器_函实参们_函 } */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 行_变量 = 状列_缩变量->行数目_小写;
  月解析器_首要表达式_函(状列_缩变量, v);
  for (;;) {
    switch (状列_缩变量->t.牌_小写) {
      case '.': {  /* 月解析器_字段选择_函 */
        月解析器_字段选择_函(状列_缩变量, v);
        break;
      }
      case '[': {  /* '[' exp ']' */
        表达式描述_结 键_小变量;
        月亮常量_表达式到任意寄存器更新_函(字段静态_变量, v);
        月解析器_y索引_函(状列_缩变量, &键_小变量);
        月亮常量_已索引_函(字段静态_变量, v, &键_小变量);
        break;
      }
      case ':': {  /* ':' NAME 月解析器_函实参们_函 */
        表达式描述_结 键_小变量;
        月亮分析_下一个_函(状列_缩变量);
        月解析器_代码名称_函(状列_缩变量, &键_小变量);
        月亮常量_自身_函(字段静态_变量, v, &键_小变量);
        月解析器_函实参们_函(状列_缩变量, v, 行_变量);
        break;
      }
      case '(': case 终结牌_字符串: case '{': {  /* 月解析器_函实参们_函 */
        月亮常量_表达式到下一个寄存器_函(字段静态_变量, v);
        月解析器_函实参们_函(状列_缩变量, v, 行_变量);
        break;
      }
      default: return;
    }
  }
}


static void 月解析器_简单表达式_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  /* 月解析器_简单表达式_函 -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
                  月解析器_构造器_函 | 编译器_函数_宏名 月解析器_身体_函 | 月解析器_已下标表达式_函 */
  switch (状列_缩变量->t.牌_小写) {
    case 终结牌_浮点: {
      月解析器_初始的_表达式_函(v, 虚常浮点_种类, 0);
      v->u.n值_缩 = 状列_缩变量->t.语义信息_小写.r;
      break;
    }
    case 终结牌_整型: {
      月解析器_初始的_表达式_函(v, 虚常整型_种类, 0);
      v->u.i值_缩 = 状列_缩变量->t.语义信息_小写.i;
      break;
    }
    case 终结牌_字符串: {
      月解析器_代码字符串_函(v, 状列_缩变量->t.语义信息_小写.类s_变量);
      break;
    }
    case 终结牌_空值: {
      月解析器_初始的_表达式_函(v, 虚空值_种类, 0);
      break;
    }
    case 终结牌_真: {
      月解析器_初始的_表达式_函(v, 虚真_种类, 0);
      break;
    }
    case 终结牌_假: {
      月解析器_初始的_表达式_函(v, 虚假_种类, 0);
      break;
    }
    case 终结牌_省略: {  /* vararg */
      函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
      解析器_检查_条件_宏名(状列_缩变量, 字段静态_变量->f->是否_变量实参短,
                      "月编译器_不能_函 use '...' outside a vararg function");
      月解析器_初始的_表达式_函(v, 虚变量实参_种类, 代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_变量实参, 0, 0, 1));
      break;
    }
    case '{': {  /* 月解析器_构造器_函 */
      月解析器_构造器_函(状列_缩变量, v);
      return;
    }
    case 终结牌_函数: {
      月亮分析_下一个_函(状列_缩变量);
      月解析器_身体_函(状列_缩变量, v, 0, 状列_缩变量->行数目_小写);
      return;
    }
    default: {
      月解析器_已下标表达式_函(状列_缩变量, v);
      return;
    }
  }
  月亮分析_下一个_函(状列_缩变量);
}


static 一元操作者_枚举 月解析器_获取一元操作_函 (int 操作_短变量) {
  switch (操作_短变量) {
    case 终结牌_非: return 操作者_非;
    case '-': return 操作者_减号;
    case '~': return 操作者_位非;
    case '#': return 操作者_长度;
    default: return 操作者_禁一元操作者;
  }
}


static 二元操作者_枚举 月解析器_获取二元操作_函 (int 操作_短变量) {
  switch (操作_短变量) {
    case '+': return 操作者_加法;
    case '-': return 操作者_减法;
    case '*': return 操作者_乘法;
    case '%': return 操作者_取模;
    case '^': return 操作者_幂运算;
    case '/': return 操作者_除法;
    case 终结牌_整数除: return 操作者_整数除;
    case '&': return 操作者_位与;
    case '|': return 操作者_位或;
    case '~': return 操作者_位异或;
    case 终结牌_左移: return 操作者_左移;
    case 终结牌_右移: return 操作者_右移;
    case 终结牌_拼接: return 操作者_拼接;
    case 终结牌_不等: return 操作者_不等;
    case 终结牌_相等: return 操作者_相等;
    case '<': return 操作者_小于;
    case 终结牌_小于: return 操作者_小等;
    case '>': return 操作者_大于;
    case 终结牌_大于: return 操作者_大等;
    case 终结牌_与: return 操作者_与;
    case 终结牌_或: return 操作者_或;
    default: return 操作者_禁二元操作者;
  }
}


/*
** Priority table for binary operators.
*/
static const struct {
  路_字节型 左_圆;  /* 左_圆 优先度_变量 for each binary operator */
  路_字节型 右_圆; /* 右_圆 优先度_变量 */
} 优先度_变量[] = {  /* ORDER OPR */
   {10, 10}, {10, 10},           /* '+' '-' */
   {11, 11}, {11, 11},           /* '*' '%' */
   {14, 13},                  /* '^' (右_圆 associative) */
   {11, 11}, {11, 11},           /* '/' '//' */
   {6, 6}, {4, 4}, {5, 5},   /* '&' '|' '~' */
   {7, 7}, {7, 7},           /* '<<' '>>' */
   {9, 8},                   /* '..' (右_圆 associative) */
   {3, 3}, {3, 3}, {3, 3},   /* ==, <, <= */
   {3, 3}, {3, 3}, {3, 3},   /* ~=, >, >= */
   {2, 2}, {1, 1}            /* and, or */
};

#define 解析器_一元运算符_优先权_宏名	12  /* 优先度_变量 for unary operators */


/*
** 月解析器_子表达式_函 -> (月解析器_简单表达式_函 | unop 月解析器_子表达式_函) { binop 月解析器_子表达式_函 }
** 哪儿_变量 'binop' is any binary operator with a 优先度_变量 higher than '限制_变量'
*/
static 二元操作者_枚举 月解析器_子表达式_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v, int 限制_变量) {
  二元操作者_枚举 操作_短变量;
  一元操作者_枚举 实或助_变量;
  解析器_进入层级_宏名(状列_缩变量);
  实或助_变量 = 月解析器_获取一元操作_函(状列_缩变量->t.牌_小写);
  if (实或助_变量 != 操作者_禁一元操作者) {  /* prefix (unary) operator? */
    int 行_变量 = 状列_缩变量->行数目_小写;
    月亮分析_下一个_函(状列_缩变量);  /* skip operator */
    月解析器_子表达式_函(状列_缩变量, v, 解析器_一元运算符_优先权_宏名);
    月亮常量_前缀_函(状列_缩变量->字段静态_变量, 实或助_变量, v, 行_变量);
  }
  else 月解析器_简单表达式_函(状列_缩变量, v);
  /* expand while operators have priorities higher than '限制_变量' */
  操作_短变量 = 月解析器_获取二元操作_函(状列_缩变量->t.牌_小写);
  while (操作_短变量 != 操作者_禁二元操作者 && 优先度_变量[操作_短变量].左_圆 > 限制_变量) {
    表达式描述_结 变2_缩变量;
    二元操作者_枚举 下个操作_变量;
    int 行_变量 = 状列_缩变量->行数目_小写;
    月亮分析_下一个_函(状列_缩变量);  /* skip operator */
    月亮常量_中缀_函(状列_缩变量->字段静态_变量, 操作_短变量, v);
    /* read sub-expression with higher 优先度_变量 */
    下个操作_变量 = 月解析器_子表达式_函(状列_缩变量, &变2_缩变量, 优先度_变量[操作_短变量].右_圆);
    月亮常量_后缀_函(状列_缩变量->字段静态_变量, 操作_短变量, v, &变2_缩变量, 行_变量);
    操作_短变量 = 下个操作_变量;
  }
  解析器_离开层级_宏名(状列_缩变量);
  return 操作_短变量;  /* return 首先_变量 untreated operator */
}


static void 月解析器_表达式_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  月解析器_子表达式_函(状列_缩变量, v, 0);
}

/* }==================================================================== */



/*
** {======================================================================
** Rules for Statements
** =======================================================================
*/


static void 月解析器_块_函 (词法状态机_结 *状列_缩变量) {
  /* 月解析器_块_函 -> 月解析器_语句列表_函 */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  块继续_结 基本逻辑_变量;
  月解析器_进入块_函(字段静态_变量, &基本逻辑_变量, 0);
  月解析器_语句列表_函(状列_缩变量);
  月解析器_离开块_函(字段静态_变量);
}


/*
** structure 到_变量 chain all variables in the 左_圆-hand side of an
** assignment
*/
struct 左手塞_赋值结 {
  struct 左手塞_赋值结 *前一_短变量;
  表达式描述_结 v;  /* variable (global, local, 上值_圆, or indexed) */
};


/*
** 月解析器_检查_函 whether, in an assignment 到_变量 an 上值_圆/local variable, the
** 上值_圆/local variable is begin used in a 前一个_变量 assignment 到_变量 a
** table. If so, 月词法_保存_函 original 上值_圆/local 值_圆 in a safe place and
** use this safe copy in the 前一个_变量 assignment.
*/
static void 月解析器_检查_冲突_函 (词法状态机_结 *状列_缩变量, struct 左手塞_赋值结 *lh, 表达式描述_结 *v) {
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 额外_变量 = 字段静态_变量->是否寄存_短;  /* eventual position 到_变量 月词法_保存_函 local variable */
  int 冲突_变量 = 0;
  for (; lh; lh = lh->前一_短变量) {  /* 月解析器_检查_函 all 前一个_变量 assignments */
    if (解析器_变量种类是否已索引_宏名(lh->v.k)) {  /* assignment 到_变量 table 月解析器_字段_函? */
      if (lh->v.k == 虚索引上值_种类) {  /* is table an 上值_圆? */
        if (v->k == 虚上值_种类 && lh->v.u.ind.t == v->u.信息_短变量) {
          冲突_变量 = 1;  /* table is the 上值_圆 being assigned now */
          lh->v.k = 虚索引串_种类;
          lh->v.u.ind.t = 额外_变量;  /* assignment will use safe copy */
        }
      }
      else {  /* table is a register */
        if (v->k == 虚本地_种类 && lh->v.u.ind.t == v->u.变_短变量.寄索引_缩短) {
          冲突_变量 = 1;  /* table is the local being assigned now */
          lh->v.u.ind.t = 额外_变量;  /* assignment will use safe copy */
        }
        /* is index the local being assigned? */
        if (lh->v.k == 虚已索引_种类 && v->k == 虚本地_种类 &&
            lh->v.u.ind.索引_缩变量 == v->u.变_短变量.寄索引_缩短) {
          冲突_变量 = 1;
          lh->v.u.ind.索引_缩变量 = 额外_变量;  /* 前一个_变量 assignment will use safe copy */
        }
      }
    }
  }
  if (冲突_变量) {
    /* copy 上值_圆/local 值_圆 到_变量 a temporary (in position '额外_变量') */
    if (v->k == 虚本地_种类)
      代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_移, 额外_变量, v->u.变_短变量.寄索引_缩短, 0);
    else
      代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_获取上值, 额外_变量, v->u.信息_短变量, 0);
    月亮常量_保留寄存器们_函(字段静态_变量, 1);
  }
}

/*
** Parse and compile a multiple assignment. The 首先_变量 "variable"
** (a '月解析器_已下标表达式_函') was already read by the caller.
**
** assignment -> 月解析器_已下标表达式_函 月解析器_剩余赋值_函
** 月解析器_剩余赋值_函 -> ',' 月解析器_已下标表达式_函 月解析器_剩余赋值_函 | '=' 月解析器_表达式列表_函
*/
static void 月解析器_剩余赋值_函 (词法状态机_结 *状列_缩变量, struct 左手塞_赋值结 *lh, int 数变量们_变量) {
  表达式描述_结 e;
  解析器_检查_条件_宏名(状列_缩变量, 解析器_变量种类是否变量_宏名(lh->v.k), "syntax 错误_小变量");
  月解析器_检查_只读_函(状列_缩变量, &lh->v);
  if (月解析器_测试下一个_函(状列_缩变量, ',')) {  /* 月解析器_剩余赋值_函 -> ',' 月解析器_已下标表达式_函 月解析器_剩余赋值_函 */
    struct 左手塞_赋值结 新版_缩变量;
    新版_缩变量.前一_短变量 = lh;
    月解析器_已下标表达式_函(状列_缩变量, &新版_缩变量.v);
    if (!解析器_变量种类是否已索引_宏名(新版_缩变量.v.k))
      月解析器_检查_冲突_函(状列_缩变量, lh, &新版_缩变量.v);
    解析器_进入层级_宏名(状列_缩变量);  /* control recursion depth */
    月解析器_剩余赋值_函(状列_缩变量, &新版_缩变量, 数变量们_变量+1);
    解析器_离开层级_宏名(状列_缩变量);
  }
  else {  /* 月解析器_剩余赋值_函 -> '=' 月解析器_表达式列表_函 */
    int 表达式数目_变量;
    月解析器_检查下一个_函(状列_缩变量, '=');
    表达式数目_变量 = 月解析器_表达式列表_函(状列_缩变量, &e);
    if (表达式数目_变量 != 数变量们_变量)
      月解析器_调整_赋值_函(状列_缩变量, 数变量们_变量, 表达式数目_变量, &e);
    else {
      月亮常量_设置一个返回_函(状列_缩变量->字段静态_变量, &e);  /* 关闭_圆 最后_变量 expression */
      月亮常量_存储变量_函(状列_缩变量->字段静态_变量, &lh->v, &e);
      return;  /* avoid default */
    }
  }
  月解析器_初始的_表达式_函(&e, 虚没有重定位_种类, 状列_缩变量->字段静态_变量->是否寄存_短-1);  /* default assignment */
  月亮常量_存储变量_函(状列_缩变量->字段静态_变量, &lh->v, &e);
}


static int 条件_变量 (词法状态机_结 *状列_缩变量) {
  /* 条件_变量 -> exp */
  表达式描述_结 v;
  月解析器_表达式_函(状列_缩变量, &v);  /* read condition */
  if (v.k == 虚空值_种类) v.k = 虚假_种类;  /* 'falses' are all equal here */
  月亮常量_去若真_函(状列_缩变量->字段静态_变量, &v);
  return v.f;
}


static void 月解析器_去到语句_函 (词法状态机_结 *状列_缩变量) {
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 行_变量 = 状列_缩变量->行数目_小写;
  标签字符串_结 *名称_变量 = 月解析器_串_检查名称_函(状列_缩变量);  /* 标号_圆's 名称_变量 */
  标号描述_结 *lb = 月解析器_找标号_函(状列_缩变量, 名称_变量);
  if (lb == NULL)  /* no 标号_圆? */
    /* forward jump; will be resolved when the 标号_圆 is declared */
    月解析器_新去到条目_函(状列_缩变量, 名称_变量, 行_变量, 月亮常量_跳转_函(字段静态_变量));
  else {  /* found a 标号_圆 */
    /* backward jump; will be resolved here */
    int 逻辑块层级_变量 = 寄存层级_变量(字段静态_变量, lb->活动变量数_缩);  /* 标号_圆 层级_变量 */
    if (月亮解析_n变量栈_函(字段静态_变量) > 逻辑块层级_变量)  /* leaving the scope of a variable? */
      代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_关闭, 逻辑块层级_变量, 0, 0);
    /* create jump and link it 到_变量 the 标号_圆 */
    月亮常量_补丁列表_函(字段静态_变量, 月亮常量_跳转_函(字段静态_变量), lb->程序计数_变量);
  }
}


/*
** Break 月解析器_语句_函. Semantically equivalent 到_变量 "goto break".
*/
static void 月解析器_破断语句_函 (词法状态机_结 *状列_缩变量) {
  int 行_变量 = 状列_缩变量->行数目_小写;
  月亮分析_下一个_函(状列_缩变量);  /* skip break */
  月解析器_新去到条目_函(状列_缩变量, 字符串_月亮S_新字面_宏名(状列_缩变量->L, "break"), 行_变量, 月亮常量_跳转_函(状列_缩变量->字段静态_变量));
}


/*
** Check whether there is already a 标号_圆 with the given '名称_变量'.
*/
static void 月解析器_检查已重复_函 (词法状态机_结 *状列_缩变量, 标签字符串_结 *名称_变量) {
  标号描述_结 *lb = 月解析器_找标号_函(状列_缩变量, 名称_变量);
  if (配置_l_可能性低_宏名(lb != NULL)) {  /* already defined? */
    const char *消息_缩变量 = "标号_圆 '%s' already defined on 行_变量 %d";
    消息_缩变量 = 月亮对象_推入格式化字符串_函(状列_缩变量->L, 消息_缩变量, 对象_获取串_宏名(名称_变量), lb->行_变量);
    月亮常量_语义错误_函(状列_缩变量, 消息_缩变量);  /* 错误_小变量 */
  }
}


static void 月解析器_标号语句_函 (词法状态机_结 *状列_缩变量, 标签字符串_结 *名称_变量, int 行_变量) {
  /* 标号_圆 -> '::' NAME '::' */
  月解析器_检查下一个_函(状列_缩变量, 终结牌_双冒号);  /* skip double colon */
  while (状列_缩变量->t.牌_小写 == ';' || 状列_缩变量->t.牌_小写 == 终结牌_双冒号)
    月解析器_语句_函(状列_缩变量);  /* skip other no-操作_短变量 statements */
  月解析器_检查已重复_函(状列_缩变量, 名称_变量);  /* 月解析器_检查_函 for repeated labels */
  月解析器_创建标号_函(状列_缩变量, 名称_变量, 行_变量, 月解析器_块_跟随_函(状列_缩变量, 0));
}


static void 月解析器_一会儿语句_函 (词法状态机_结 *状列_缩变量, int 行_变量) {
  /* 月解析器_一会儿语句_函 -> WHILE 条件_变量 DO 月解析器_块_函 END */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 一会儿初始_变量;
  int 条件出口_变量;
  块继续_结 基本逻辑_变量;
  月亮分析_下一个_函(状列_缩变量);  /* skip WHILE */
  一会儿初始_变量 = 月亮常量_获取标号_函(字段静态_变量);
  条件出口_变量 = 条件_变量(状列_缩变量);
  月解析器_进入块_函(字段静态_变量, &基本逻辑_变量, 1);
  月解析器_检查下一个_函(状列_缩变量, 终结牌_做);
  月解析器_块_函(状列_缩变量);
  代码_月亮K_跳转到_宏名(字段静态_变量, 一会儿初始_变量);
  月解析器_检查_匹配_函(状列_缩变量, 终结牌_终, 终结牌_一会儿, 行_变量);
  月解析器_离开块_函(字段静态_变量);
  月亮常量_补丁到这里_函(字段静态_变量, 条件出口_变量);  /* false conditions finish the 环_变量 */
}


static void 月解析器_重复语句_函 (词法状态机_结 *状列_缩变量, int 行_变量) {
  /* 月解析器_重复语句_函 -> REPEAT 月解析器_块_函 UNTIL 条件_变量 */
  int 条件出口_变量;
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 重复_初始的_变量 = 月亮常量_获取标号_函(字段静态_变量);
  块继续_结 基逻1_变量, 基逻2_变量;
  月解析器_进入块_函(字段静态_变量, &基逻1_变量, 1);  /* 环_变量 月解析器_块_函 */
  月解析器_进入块_函(字段静态_变量, &基逻2_变量, 0);  /* scope 月解析器_块_函 */
  月亮分析_下一个_函(状列_缩变量);  /* skip REPEAT */
  月解析器_语句列表_函(状列_缩变量);
  月解析器_检查_匹配_函(状列_缩变量, 终结牌_直到, 终结牌_重复, 行_变量);
  条件出口_变量 = 条件_变量(状列_缩变量);  /* read condition (inside scope 月解析器_块_函) */
  月解析器_离开块_函(字段静态_变量);  /* finish scope */
  if (基逻2_变量.上值_变量) {  /* 上值们_小写? */
    int 出口_变量 = 月亮常量_跳转_函(字段静态_变量);  /* normal 出口_变量 must jump over fix */
    月亮常量_补丁到这里_函(字段静态_变量, 条件出口_变量);  /* repetition must 关闭_圆 上值们_小写 */
    代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_关闭, 寄存层级_变量(字段静态_变量, 基逻2_变量.活动变量数_缩), 0, 0);
    条件出口_变量 = 月亮常量_跳转_函(字段静态_变量);  /* repeat after closing 上值们_小写 */
    月亮常量_补丁到这里_函(字段静态_变量, 出口_变量);  /* normal 出口_变量 comes 到_变量 here */
  }
  月亮常量_补丁列表_函(字段静态_变量, 条件出口_变量, 重复_初始的_变量);  /* 关闭_圆 the 环_变量 */
  月解析器_离开块_函(字段静态_变量);  /* finish 环_变量 */
}


/*
** Read an expression and generate 代码_变量 到_变量 put its results in 下一个_变量
** 栈_圆小 插槽_变量.
**
*/
static void 表达式1_变量 (词法状态机_结 *状列_缩变量) {
  表达式描述_结 e;
  月解析器_表达式_函(状列_缩变量, &e);
  月亮常量_表达式到下一个寄存器_函(状列_缩变量->字段静态_变量, &e);
  限制_月亮_断言_宏名(e.k == 虚没有重定位_种类);
}


/*
** Fix for instruction at position '程序计数_变量' 到_变量 jump 到_变量 '目的地_变量'.
** (Jump addresses are relative in Lua). 'back' true means
** a back jump.
*/
static void 月解析器_修复为跳转_函 (函状态机_结 *字段静态_变量, int 程序计数_变量, int 目的地_变量, int back) {
  Instruction *跳转_变量 = &字段静态_变量->f->代码_变量[程序计数_变量];
  int 偏移_变量 = 目的地_变量 - (程序计数_变量 + 1);
  if (back)
    偏移_变量 = -偏移_变量;
  if (配置_l_可能性低_宏名(偏移_变量 > 操作码_最大实参_Bx_宏名))
    月亮分析_句法错误_函(字段静态_变量->状列_缩变量, "control structure too long");
  操作码_设置实参_Bx_宏名(*跳转_变量, 偏移_变量);
}


/*
** Generate 代码_变量 for a 'for' 环_变量.
*/
static void 月解析器_为身体_函 (词法状态机_结 *状列_缩变量, int 基本_变量, int 行_变量, int 数变量们_变量, int isgen) {
  /* 月解析器_为身体_函 -> DO 月解析器_块_函 */
  static const 操作码_枚举 为预备_变量[2] = {操作_为预备, 操作_泛型为预备};
  static const 操作码_枚举 为环_变量[2] = {操作_为环, 操作_泛型为环};
  块继续_结 基本逻辑_变量;
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 预备_变量, 终为_变量;
  月解析器_检查下一个_函(状列_缩变量, 终结牌_做);
  预备_变量 = 月亮常量_代码ABx_函(字段静态_变量, 为预备_变量[isgen], 基本_变量, 0);
  月解析器_进入块_函(字段静态_变量, &基本逻辑_变量, 0);  /* scope for declared variables */
  月解析器_调整本地变量们_函(状列_缩变量, 数变量们_变量);
  月亮常量_保留寄存器们_函(字段静态_变量, 数变量们_变量);
  月解析器_块_函(状列_缩变量);
  月解析器_离开块_函(字段静态_变量);  /* 终_变量 of scope for declared variables */
  月解析器_修复为跳转_函(字段静态_变量, 预备_变量, 月亮常量_获取标号_函(字段静态_变量), 0);
  if (isgen) {  /* generic for? */
    代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_泛型为调用, 基本_变量, 0, 数变量们_变量);
    月亮常量_修正行号_函(字段静态_变量, 行_变量);
  }
  终为_变量 = 月亮常量_代码ABx_函(字段静态_变量, 为环_变量[isgen], 基本_变量, 0);
  月解析器_修复为跳转_函(字段静态_变量, 终为_变量, 预备_变量 + 1, 1);
  月亮常量_修正行号_函(字段静态_变量, 行_变量);
}


static void 月解析器_为数值_函 (词法状态机_结 *状列_缩变量, 标签字符串_结 *变量名称_变量, int 行_变量) {
  /* 月解析器_为数值_函 -> NAME = exp,exp[,exp] 月解析器_为身体_函 */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 基本_变量 = 字段静态_变量->是否寄存_短;
  解析器_新_本地变量字面_宏名(状列_缩变量, "(for 状态机_变量)");
  解析器_新_本地变量字面_宏名(状列_缩变量, "(for 状态机_变量)");
  解析器_新_本地变量字面_宏名(状列_缩变量, "(for 状态机_变量)");
  月解析器_新_本地变量_函(状列_缩变量, 变量名称_变量);
  月解析器_检查下一个_函(状列_缩变量, '=');
  表达式1_变量(状列_缩变量);  /* initial 值_圆 */
  月解析器_检查下一个_函(状列_缩变量, ',');
  表达式1_变量(状列_缩变量);  /* 限制_变量 */
  if (月解析器_测试下一个_函(状列_缩变量, ','))
    表达式1_变量(状列_缩变量);  /* optional 步进_变量 */
  else {  /* default 步进_变量 = 1 */
    月亮常量_整型_函(字段静态_变量, 字段静态_变量->是否寄存_短, 1);
    月亮常量_保留寄存器们_函(字段静态_变量, 1);
  }
  月解析器_调整本地变量们_函(状列_缩变量, 3);  /* control variables */
  月解析器_为身体_函(状列_缩变量, 基本_变量, 行_变量, 1, 0);
}


static void 月解析器_为列表_函 (词法状态机_结 *状列_缩变量, 标签字符串_结 *indexname) {
  /* 月解析器_为列表_函 -> NAME {,NAME} IN 月解析器_表达式列表_函 月解析器_为身体_函 */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  表达式描述_结 e;
  int 数变量们_变量 = 5;  /* gen, 状态机_变量, control, 到关闭_变量, 'indexname' */
  int 行_变量;
  int 基本_变量 = 字段静态_变量->是否寄存_短;
  /* create control variables */
  解析器_新_本地变量字面_宏名(状列_缩变量, "(for 状态机_变量)");
  解析器_新_本地变量字面_宏名(状列_缩变量, "(for 状态机_变量)");
  解析器_新_本地变量字面_宏名(状列_缩变量, "(for 状态机_变量)");
  解析器_新_本地变量字面_宏名(状列_缩变量, "(for 状态机_变量)");
  /* create declared variables */
  月解析器_新_本地变量_函(状列_缩变量, indexname);
  while (月解析器_测试下一个_函(状列_缩变量, ',')) {
    月解析器_新_本地变量_函(状列_缩变量, 月解析器_串_检查名称_函(状列_缩变量));
    数变量们_变量++;
  }
  月解析器_检查下一个_函(状列_缩变量, 终结牌_在内);
  行_变量 = 状列_缩变量->行数目_小写;
  月解析器_调整_赋值_函(状列_缩变量, 4, 月解析器_表达式列表_函(状列_缩变量, &e), &e);
  月解析器_调整本地变量们_函(状列_缩变量, 4);  /* control variables */
  月解析器_记号待关闭_函(字段静态_变量);  /* 最后_变量 control 变_短变量. must be closed */
  月亮常量_检查栈_函(字段静态_变量, 3);  /* 额外_变量 空间_圆 到_变量 call generator */
  月解析器_为身体_函(状列_缩变量, 基本_变量, 行_变量, 数变量们_变量 - 4, 1);
}


static void 月解析器_为语句_函 (词法状态机_结 *状列_缩变量, int 行_变量) {
  /* 月解析器_为语句_函 -> FOR (月解析器_为数值_函 | 月解析器_为列表_函) END */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  标签字符串_结 *变量名称_变量;
  块继续_结 基本逻辑_变量;
  月解析器_进入块_函(字段静态_变量, &基本逻辑_变量, 1);  /* scope for 环_变量 and control variables */
  月亮分析_下一个_函(状列_缩变量);  /* skip 'for' */
  变量名称_变量 = 月解析器_串_检查名称_函(状列_缩变量);  /* 首先_变量 variable 名称_变量 */
  switch (状列_缩变量->t.牌_小写) {
    case '=': 月解析器_为数值_函(状列_缩变量, 变量名称_变量, 行_变量); break;
    case ',': case 终结牌_在内: 月解析器_为列表_函(状列_缩变量, 变量名称_变量); break;
    default: 月亮分析_句法错误_函(状列_缩变量, "'=' or 'in' expected");
  }
  月解析器_检查_匹配_函(状列_缩变量, 终结牌_终, 终结牌_为, 行_变量);
  月解析器_离开块_函(字段静态_变量);  /* 环_变量 scope ('break' jumps 到_变量 this 针点_变量) */
}


static void 月解析器_测试_那么_块_函 (词法状态机_结 *状列_缩变量, int *转义列表_变量) {
  /* 月解析器_测试_那么_块_函 -> [IF | ELSEIF] 条件_变量 THEN 月解析器_块_函 */
  块继续_结 基本逻辑_变量;
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  表达式描述_结 v;
  int 仅标志_变量;  /* instruction 到_变量 skip 'then' 代码_变量 (if condition is false) */
  月亮分析_下一个_函(状列_缩变量);  /* skip IF or ELSEIF */
  月解析器_表达式_函(状列_缩变量, &v);  /* read condition */
  月解析器_检查下一个_函(状列_缩变量, 终结牌_那么);
  if (状列_缩变量->t.牌_小写 == 终结牌_破断) {  /* 'if x then break' ? */
    int 行_变量 = 状列_缩变量->行数目_小写;
    月亮常量_去若假_函(状列_缩变量->字段静态_变量, &v);  /* will jump if condition is true */
    月亮分析_下一个_函(状列_缩变量);  /* skip 'break' */
    月解析器_进入块_函(字段静态_变量, &基本逻辑_变量, 0);  /* must enter 月解析器_块_函 before 'goto' */
    月解析器_新去到条目_函(状列_缩变量, 字符串_月亮S_新字面_宏名(状列_缩变量->L, "break"), 行_变量, v.t);
    while (月解析器_测试下一个_函(状列_缩变量, ';')) {}  /* skip semicolons */
    if (月解析器_块_跟随_函(状列_缩变量, 0)) {  /* jump is the entire 月解析器_块_函? */
      月解析器_离开块_函(字段静态_变量);
      return;  /* and that is it */
    }
    else  /* must skip over 'then' part if condition is false */
      仅标志_变量 = 月亮常量_跳转_函(字段静态_变量);
  }
  else {  /* regular case (not a break) */
    月亮常量_去若真_函(状列_缩变量->字段静态_变量, &v);  /* skip over 月解析器_块_函 if condition is false */
    月解析器_进入块_函(字段静态_变量, &基本逻辑_变量, 0);
    仅标志_变量 = v.f;
  }
  月解析器_语句列表_函(状列_缩变量);  /* 'then' part */
  月解析器_离开块_函(字段静态_变量);
  if (状列_缩变量->t.牌_小写 == 终结牌_否则 ||
      状列_缩变量->t.牌_小写 == 终结牌_否若)  /* followed by 'else'/'elseif'? */
    月亮常量_拼接_函(字段静态_变量, 转义列表_变量, 月亮常量_跳转_函(字段静态_变量));  /* must jump over it */
  月亮常量_补丁到这里_函(字段静态_变量, 仅标志_变量);
}


static void 月解析器_若语句_函 (词法状态机_结 *状列_缩变量, int 行_变量) {
  /* 月解析器_若语句_函 -> IF 条件_变量 THEN 月解析器_块_函 {ELSEIF 条件_变量 THEN 月解析器_块_函} [ELSE 月解析器_块_函] END */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 转义列表_变量 = 代码_无_跳转_宏名;  /* 出口_变量 列表_变量 for finished parts */
  月解析器_测试_那么_块_函(状列_缩变量, &转义列表_变量);  /* IF 条件_变量 THEN 月解析器_块_函 */
  while (状列_缩变量->t.牌_小写 == 终结牌_否若)
    月解析器_测试_那么_块_函(状列_缩变量, &转义列表_变量);  /* ELSEIF 条件_变量 THEN 月解析器_块_函 */
  if (月解析器_测试下一个_函(状列_缩变量, 终结牌_否则))
    月解析器_块_函(状列_缩变量);  /* 'else' part */
  月解析器_检查_匹配_函(状列_缩变量, 终结牌_终, 终结牌_若, 行_变量);
  月亮常量_补丁到这里_函(字段静态_变量, 转义列表_变量);  /* patch escape 列表_变量 到_变量 'if' 终_变量 */
}


static void 月解析器_本地函_函 (词法状态机_结 *状列_缩变量) {
  表达式描述_结 b;
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 函变量_变量 = 字段静态_变量->活动变量数_缩;  /* function's variable index */
  月解析器_新_本地变量_函(状列_缩变量, 月解析器_串_检查名称_函(状列_缩变量));  /* new local variable */
  月解析器_调整本地变量们_函(状列_缩变量, 1);  /* enter its scope */
  月解析器_身体_函(状列_缩变量, &b, 0, 状列_缩变量->行数目_小写);  /* function created in 下一个_变量 register */
  /* debug information will only see the variable after this 针点_变量! */
  月解析器_本地调试信息_函(字段静态_变量, 函变量_变量)->始程计_缩 = 字段静态_变量->程序计数_变量;
}


static int 月解析器_获取本地属性_函 (词法状态机_结 *状列_缩变量) {
  /* ATTRIB -> ['<' Name '>'] */
  if (月解析器_测试下一个_函(状列_缩变量, '<')) {
    const char *属_短变量 = 对象_获取串_宏名(月解析器_串_检查名称_函(状列_缩变量));
    月解析器_检查下一个_函(状列_缩变量, '>');
    if (strcmp(属_短变量, "const") == 0)
      return 解析器_寄存器D种类常量_宏名;  /* read-only variable */
    else if (strcmp(属_短变量, "关闭_圆") == 0)
      return 解析器_寄存器D种类待关闭_宏名;  /* 到_变量-be-closed variable */
    else
      月亮常量_语义错误_函(状列_缩变量,
        月亮对象_推入格式化字符串_函(状列_缩变量->L, "unknown attribute '%s'", 属_短变量));
  }
  return 解析器_变量D种类寄存器_宏名;  /* regular variable */
}


static void 月解析器_检查待关闭_函 (函状态机_结 *字段静态_变量, int 层级_变量) {
  if (层级_变量 != -1) {  /* is there a 到_变量-be-closed variable? */
    月解析器_记号待关闭_函(字段静态_变量);
    代码_月亮K_编码ABC_宏名(字段静态_变量, 操作_待关闭, 寄存层级_变量(字段静态_变量, 层级_变量), 0, 0);
  }
}


static void 月解析器_本地语句_函 (词法状态机_结 *状列_缩变量) {
  /* 状态_短变量 -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' 月解析器_表达式列表_函] */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  int 到关闭_变量 = -1;  /* index of 到_变量-be-closed variable (if any) */
  变量描述_联 *变_短变量;  /* 最后_变量 variable */
  int 变索引_变量, 种类_变量;  /* index and 种类_变量 of 最后_变量 variable */
  int 数变量们_变量 = 0;
  int 表达式数目_变量;
  表达式描述_结 e;
  do {
    变索引_变量 = 月解析器_新_本地变量_函(状列_缩变量, 月解析器_串_检查名称_函(状列_缩变量));
    种类_变量 = 月解析器_获取本地属性_函(状列_缩变量);
    月解析器_获取本地变量描述_函(字段静态_变量, 变索引_变量)->有效数据_变量.种类_变量 = 种类_变量;
    if (种类_变量 == 解析器_寄存器D种类待关闭_宏名) {  /* 到_变量-be-closed? */
      if (到关闭_变量 != -1)  /* one already present? */
        月亮常量_语义错误_函(状列_缩变量, "multiple 到_变量-be-closed variables in local 列表_变量");
      到关闭_变量 = 字段静态_变量->活动变量数_缩 + 数变量们_变量;
    }
    数变量们_变量++;
  } while (月解析器_测试下一个_函(状列_缩变量, ','));
  if (月解析器_测试下一个_函(状列_缩变量, '='))
    表达式数目_变量 = 月解析器_表达式列表_函(状列_缩变量, &e);
  else {
    e.k = 虚空的_种类;
    表达式数目_变量 = 0;
  }
  变_短变量 = 月解析器_获取本地变量描述_函(字段静态_变量, 变索引_变量);  /* get 最后_变量 variable */
  if (数变量们_变量 == 表达式数目_变量 &&  /* no adjustments? */
      变_短变量->有效数据_变量.种类_变量 == 解析器_寄存器D种类常量_宏名 &&  /* 最后_变量 variable is const? */
      月亮常量_表达式到常量_函(字段静态_变量, &e, &变_短变量->k)) {  /* compile-time constant? */
    变_短变量->有效数据_变量.种类_变量 = 解析器_寄存器D种类代码到常量_宏名;  /* variable is a compile-time constant */
    月解析器_调整本地变量们_函(状列_缩变量, 数变量们_变量 - 1);  /* exclude 最后_变量 variable */
    字段静态_变量->活动变量数_缩++;  /* but 计数_变量 it */
  }
  else {
    月解析器_调整_赋值_函(状列_缩变量, 数变量们_变量, 表达式数目_变量, &e);
    月解析器_调整本地变量们_函(状列_缩变量, 数变量们_变量);
  }
  月解析器_检查待关闭_函(字段静态_变量, 到关闭_变量);
}


static int 月解析器_函名_函 (词法状态机_结 *状列_缩变量, 表达式描述_结 *v) {
  /* 月解析器_函名_函 -> NAME {月解析器_字段选择_函} [':' NAME] */
  int 是方法吗_变量 = 0;
  月解析器_单变量_函(状列_缩变量, v);
  while (状列_缩变量->t.牌_小写 == '.')
    月解析器_字段选择_函(状列_缩变量, v);
  if (状列_缩变量->t.牌_小写 == ':') {
    是方法吗_变量 = 1;
    月解析器_字段选择_函(状列_缩变量, v);
  }
  return 是方法吗_变量;
}


static void 月解析器_函语句_函 (词法状态机_结 *状列_缩变量, int 行_变量) {
  /* 月解析器_函语句_函 -> 编译器_函数_宏名 月解析器_函名_函 月解析器_身体_函 */
  int 是方法吗_变量;
  表达式描述_结 v, b;
  月亮分析_下一个_函(状列_缩变量);  /* skip 编译器_函数_宏名 */
  是方法吗_变量 = 月解析器_函名_函(状列_缩变量, &v);
  月解析器_身体_函(状列_缩变量, &b, 是方法吗_变量, 行_变量);
  月解析器_检查_只读_函(状列_缩变量, &v);
  月亮常量_存储变量_函(状列_缩变量->字段静态_变量, &v, &b);
  月亮常量_修正行号_函(状列_缩变量->字段静态_变量, 行_变量);  /* definition "happens" in the 首先_变量 行_变量 */
}


static void 月解析器_表达式语句_函 (词法状态机_结 *状列_缩变量) {
  /* 状态_短变量 -> 函_短变量 | assignment */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  struct 左手塞_赋值结 v;
  月解析器_已下标表达式_函(状列_缩变量, &v.v);
  if (状列_缩变量->t.牌_小写 == '=' || 状列_缩变量->t.牌_小写 == ',') { /* 状态_短变量 -> assignment ? */
    v.前一_短变量 = NULL;
    月解析器_剩余赋值_函(状列_缩变量, &v, 1);
  }
  else {  /* 状态_短变量 -> 函_短变量 */
    Instruction *指令_短变量;
    解析器_检查_条件_宏名(状列_缩变量, v.v.k == 虚调用_种类, "syntax 错误_小变量");
    指令_短变量 = &代码_获取指令_宏名(字段静态_变量, &v.v);
    操作码_设置实参_C_宏名(*指令_短变量, 1);  /* call 月解析器_语句_函 uses no results */
  }
}


static void 月解析器_返回语句_函 (词法状态机_结 *状列_缩变量) {
  /* 状态_短变量 -> RETURN [月解析器_表达式列表_函] [';'] */
  函状态机_结 *字段静态_变量 = 状列_缩变量->字段静态_变量;
  表达式描述_结 e;
  int 返数_缩变量;  /* number of values being returned */
  int 首先_变量 = 月亮解析_n变量栈_函(字段静态_变量);  /* 首先_变量 插槽_变量 到_变量 be returned */
  if (月解析器_块_跟随_函(状列_缩变量, 1) || 状列_缩变量->t.牌_小写 == ';')
    返数_缩变量 = 0;  /* return no values */
  else {
    返数_缩变量 = 月解析器_表达式列表_函(状列_缩变量, &e);  /* optional return values */
    if (解析器_有多个返回值_宏名(e.k)) {
      代码_月亮K_设置多返回_宏名(字段静态_变量, &e);
      if (e.k == 虚调用_种类 && 返数_缩变量 == 1 && !字段静态_变量->基本逻辑_变量->内塞待关闭_缩) {  /* tail call? */
        操作码_设置_操作码_宏名(代码_获取指令_宏名(字段静态_变量,&e), 操作_尾调用);
        限制_月亮_断言_宏名(操作码_获取实参_A_宏名(代码_获取指令_宏名(字段静态_变量,&e)) == 月亮解析_n变量栈_函(字段静态_变量));
      }
      返数_缩变量 = 月头_月亮_多返回_宏名;  /* return all values */
    }
    else {
      if (返数_缩变量 == 1)  /* only one single 值_圆? */
        首先_变量 = 月亮常量_表达式到任意寄存器_函(字段静态_变量, &e);  /* can use original 插槽_变量 */
      else {  /* values must go 到_变量 the 顶部_变量 of the 栈_圆小 */
        月亮常量_表达式到下一个寄存器_函(字段静态_变量, &e);
        限制_月亮_断言_宏名(返数_缩变量 == 字段静态_变量->是否寄存_短 - 首先_变量);
      }
    }
  }
  月亮常量_返回_函(字段静态_变量, 首先_变量, 返数_缩变量);
  月解析器_测试下一个_函(状列_缩变量, ';');  /* skip optional semicolon */
}


static void 月解析器_语句_函 (词法状态机_结 *状列_缩变量) {
  int 行_变量 = 状列_缩变量->行数目_小写;  /* may be 已需要_变量 for 错误_小变量 messages */
  解析器_进入层级_宏名(状列_缩变量);
  switch (状列_缩变量->t.牌_小写) {
    case ';': {  /* 状态_短变量 -> ';' (空容器_变量 月解析器_语句_函) */
      月亮分析_下一个_函(状列_缩变量);  /* skip ';' */
      break;
    }
    case 终结牌_若: {  /* 状态_短变量 -> 月解析器_若语句_函 */
      月解析器_若语句_函(状列_缩变量, 行_变量);
      break;
    }
    case 终结牌_一会儿: {  /* 状态_短变量 -> 月解析器_一会儿语句_函 */
      月解析器_一会儿语句_函(状列_缩变量, 行_变量);
      break;
    }
    case 终结牌_做: {  /* 状态_短变量 -> DO 月解析器_块_函 END */
      月亮分析_下一个_函(状列_缩变量);  /* skip DO */
      月解析器_块_函(状列_缩变量);
      月解析器_检查_匹配_函(状列_缩变量, 终结牌_终, 终结牌_做, 行_变量);
      break;
    }
    case 终结牌_为: {  /* 状态_短变量 -> 月解析器_为语句_函 */
      月解析器_为语句_函(状列_缩变量, 行_变量);
      break;
    }
    case 终结牌_重复: {  /* 状态_短变量 -> 月解析器_重复语句_函 */
      月解析器_重复语句_函(状列_缩变量, 行_变量);
      break;
    }
    case 终结牌_函数: {  /* 状态_短变量 -> 月解析器_函语句_函 */
      月解析器_函语句_函(状列_缩变量, 行_变量);
      break;
    }
    case 终结牌_本地: {  /* 状态_短变量 -> 月解析器_本地语句_函 */
      月亮分析_下一个_函(状列_缩变量);  /* skip LOCAL */
      if (月解析器_测试下一个_函(状列_缩变量, 终结牌_函数))  /* local function? */
        月解析器_本地函_函(状列_缩变量);
      else
        月解析器_本地语句_函(状列_缩变量);
      break;
    }
    case 终结牌_双冒号: {  /* 状态_短变量 -> 标号_圆 */
      月亮分析_下一个_函(状列_缩变量);  /* skip double colon */
      月解析器_标号语句_函(状列_缩变量, 月解析器_串_检查名称_函(状列_缩变量), 行_变量);
      break;
    }
    case 终结牌_返回: {  /* 状态_短变量 -> 月解析器_返回语句_函 */
      月亮分析_下一个_函(状列_缩变量);  /* skip RETURN */
      月解析器_返回语句_函(状列_缩变量);
      break;
    }
    case 终结牌_破断: {  /* 状态_短变量 -> 月解析器_破断语句_函 */
      月解析器_破断语句_函(状列_缩变量);
      break;
    }
    case 终结牌_去到: {  /* 状态_短变量 -> 'goto' NAME */
      月亮分析_下一个_函(状列_缩变量);  /* skip 'goto' */
      月解析器_去到语句_函(状列_缩变量);
      break;
    }
    default: {  /* 状态_短变量 -> 函_短变量 | assignment */
      月解析器_表达式语句_函(状列_缩变量);
      break;
    }
  }
  限制_月亮_断言_宏名(状列_缩变量->字段静态_变量->f->最大栈大小_小写 >= 状列_缩变量->字段静态_变量->是否寄存_短 &&
             状列_缩变量->字段静态_变量->是否寄存_短 >= 月亮解析_n变量栈_函(状列_缩变量->字段静态_变量));
  状列_缩变量->字段静态_变量->是否寄存_短 = 月亮解析_n变量栈_函(状列_缩变量->字段静态_变量);  /* free registers */
  解析器_离开层级_宏名(状列_缩变量);
}

/* }====================================================================== */


/*
** compiles the main function, which is a regular vararg function with an
** 上值_圆 named 词法_月亮_环境_宏名
*/
static void 月解析器_主函_函 (词法状态机_结 *状列_缩变量, 函状态机_结 *字段静态_变量) {
  块继续_结 基本逻辑_变量;
  上值描述_结 *环境_短变量;
  月解析器_打开_函_函(状列_缩变量, 字段静态_变量, &基本逻辑_变量);
  月解析器_设置变量实参_函(字段静态_变量, 0);  /* main function is always declared vararg */
  环境_短变量 = 月解析器_分配上值_函(字段静态_变量);  /* ...set environment 上值_圆 */
  环境_短变量->栈内_小写 = 1;
  环境_短变量->索引_缩变量 = 0;
  环境_短变量->种类_变量 = 解析器_变量D种类寄存器_宏名;
  环境_短变量->名称_变量 = 状列_缩变量->环境名_短;
  垃圾回收_月亮C_对象屏障_宏名(状列_缩变量->L, 字段静态_变量->f, 环境_短变量->名称_变量);
  月亮分析_下一个_函(状列_缩变量);  /* read 首先_变量 牌_小写 */
  月解析器_语句列表_函(状列_缩变量);  /* parse main 月解析器_身体_函 */
  月解析器_检查_函(状列_缩变量, 终结牌_流终);
  月解析器_关闭_函_函(状列_缩变量);
}


L闭包_结 *月亮解析_解析器_函 (炉_状态机结 *L, 入出流_结 *z, M缓冲区_结 *缓冲_变量,
                       动态数据_结 *定你数_缩变量, const char *名称_变量, int firstchar) {
  词法状态机_结 词法状态机_变量;
  函状态机_结 函状态机_变量;
  L闭包_结 *闭包_短变量 = 月亮函数_新L闭包_函(L, 1);  /* create main closure */
  对象_设置闭包L值到s_宏名(L, L->顶部_变量.p, 闭包_短变量);  /* 锚点_变量 it (到_变量 avoid being collected) */
  月亮调度_递增顶_函(L);
  词法状态机_变量.h = 月亮哈希表_新_函(L);  /* create table for scanner */
  对象_设置哈希值到s_宏名(L, L->顶部_变量.p, 词法状态机_变量.h);  /* 锚点_变量 it */
  月亮调度_递增顶_函(L);
  函状态机_变量.f = 闭包_短变量->p = 月亮函数_新原型_函(L);
  垃圾回收_月亮C_对象屏障_宏名(L, 闭包_短变量, 闭包_短变量->p);
  函状态机_变量.f->源_圆 = 月亮字符串_新_函(L, 名称_变量);  /* create and 锚点_变量 标签字符串_结 */
  垃圾回收_月亮C_对象屏障_宏名(L, 函状态机_变量.f, 函状态机_变量.f->源_圆);
  词法状态机_变量.缓冲_变量 = 缓冲_变量;
  词法状态机_变量.定你数_缩变量 = 定你数_缩变量;
  定你数_缩变量->活动变量_结.n = 定你数_缩变量->全局表_缩变量.n = 定你数_缩变量->标号_圆.n = 0;
  月亮分析_设置输入_函(L, &词法状态机_变量, z, 函状态机_变量.f->源_圆, firstchar);
  月解析器_主函_函(&词法状态机_变量, &函状态机_变量);
  限制_月亮_断言_宏名(!函状态机_变量.前一_短变量 && 函状态机_变量.上值数_短缩 == 1 && !词法状态机_变量.字段静态_变量);
  /* all scopes should be correctly finished */
  限制_月亮_断言_宏名(定你数_缩变量->活动变量_结.n == 0 && 定你数_缩变量->全局表_缩变量.n == 0 && 定你数_缩变量->标号_圆.n == 0);
  L->顶部_变量.p--;  /* remove scanner's table */
  return 闭包_短变量;  /* closure is on the 栈_圆小, too */
}

