/*
** $Id: lapi.c $
** Lua API
** See Copyright Notice in lua.h
*/

#define lapi_c
#define 应程接_月亮_内核_宏名

#include "lprefix.h"


#include <limits.h>
#include <stdarg.h>
#include <string.h>

#include "lua.h"

#include "lapi.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lgc.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"
#include "lundump.h"
#include "lvm.h"



const char 月亮_标识_变量[] =
  "$LuaVersion: " 月头_月亮_版权_宏名 " $"
  "$LuaAuthors: " 月头_月亮_作者_宏名 " $";



/*
** Test for a 有效_变量 index (one that is not the '空值的值_圆').
** '!对象_tt是否空值_宏名(o)' implies 'o != &G(L)->空值的值_圆', so it is not 已需要_变量.
** However, it covers the most common cases in a faster way.
*/
#define 应程接_是否有效_宏名(L, o)	(!对象_tt是否空值_宏名(o) || o != &G(L)->空值的值_圆)


/* test for pseudo index */
#define 应程接_是否伪造_宏名(i)		((i) <= 月头_月亮_注册表索引_宏名)

/* test for 上值_圆 */
#define 应程接_是否上值_宏名(i)		((i) < 月头_月亮_注册表索引_宏名)


/*
** Convert an acceptable index 到_变量 a pointer 到_变量 its respective 值_圆.
** Non-有效_变量 indices return the special nil 值_圆 'G(L)->空值的值_圆'.
*/
static 标签值_结 *月应程接_索引到值_函 (炉_状态机结 *L, int 索引_缩变量) {
  调用信息_结 *调信_缩变量 = L->调信_缩变量;
  if (索引_缩变量 > 0) {
    栈身份_型 o = 调信_缩变量->函_短变量.p + 索引_缩变量;
    限制_应程接_检查_宏名(L, 索引_缩变量 <= 调信_缩变量->顶部_变量.p - (调信_缩变量->函_短变量.p + 1), "unacceptable index");
    if (o >= L->顶部_变量.p) return &G(L)->空值的值_圆;
    else return 对象_s到v_宏名(o);
  }
  else if (!应程接_是否伪造_宏名(索引_缩变量)) {  /* negative index */
    限制_应程接_检查_宏名(L, 索引_缩变量 != 0 && -索引_缩变量 <= L->顶部_变量.p - (调信_缩变量->函_短变量.p + 1),
                 "invalid index");
    return 对象_s到v_宏名(L->顶部_变量.p + 索引_缩变量);
  }
  else if (索引_缩变量 == 月头_月亮_注册表索引_宏名)
    return &G(L)->l_注册表半;
  else {  /* 上值们_小写 */
    索引_缩变量 = 月头_月亮_注册表索引_宏名 - 索引_缩变量;
    限制_应程接_检查_宏名(L, 索引_缩变量 <= 函_最大上值_宏名 + 1, "上值_圆 index too large");
    if (对象_tt是否C闭包_宏名(对象_s到v_宏名(调信_缩变量->函_短变量.p))) {  /* C closure? */
      C闭包_结 *函_短变量 = 对象_闭包C值_宏名(对象_s到v_宏名(调信_缩变量->函_短变量.p));
      return (索引_缩变量 <= 函_短变量->nupvalues) ? &函_短变量->上值_圆[索引_缩变量-1]
                                      : &G(L)->空值的值_圆;
    }
    else {  /* light C function or Lua function (through a 钩子_变量)?) */
      限制_应程接_检查_宏名(L, 对象_tt是否L闭包函_宏名(对象_s到v_宏名(调信_缩变量->函_短变量.p)), "caller not a C function");
      return &G(L)->空值的值_圆;  /* no 上值们_小写 */
    }
  }
}



/*
** Convert a 有效_变量 实际上_变量 index (not a pseudo-index) 到_变量 its address.
*/
l_sinline 栈身份_型 月应程接_索引到栈_函 (炉_状态机结 *L, int 索引_缩变量) {
  调用信息_结 *调信_缩变量 = L->调信_缩变量;
  if (索引_缩变量 > 0) {
    栈身份_型 o = 调信_缩变量->函_短变量.p + 索引_缩变量;
    限制_应程接_检查_宏名(L, o < L->顶部_变量.p, "invalid index");
    return o;
  }
  else {    /* non-positive index */
    限制_应程接_检查_宏名(L, 索引_缩变量 != 0 && -索引_缩变量 <= L->顶部_变量.p - (调信_缩变量->函_短变量.p + 1),
                 "invalid index");
    限制_应程接_检查_宏名(L, !应程接_是否伪造_宏名(索引_缩变量), "invalid index");
    return L->顶部_变量.p + 索引_缩变量;
  }
}


配置_月亮_应程接_宏名 int 月亮_检查栈空间_函 (炉_状态机结 *L, int n) {
  int 结果_短变量;
  调用信息_结 *调信_缩变量;
  限制_月亮_锁_宏名(L);
  调信_缩变量 = L->调信_缩变量;
  限制_应程接_检查_宏名(L, n >= 0, "negative 'n'");
  if (L->栈_最后圆.p - L->顶部_变量.p > n)  /* 栈_圆小 large enough? */
    结果_短变量 = 1;  /* yes; 月解析器_检查_函 is OK */
  else  /* need 到_变量 grow 栈_圆小 */
    结果_短变量 = 月亮调度_增长栈_函(L, n, 0);
  if (结果_短变量 && 调信_缩变量->顶部_变量.p < L->顶部_变量.p + n)
    调信_缩变量->顶部_变量.p = L->顶部_变量.p + n;  /* adjust frame 顶部_变量 */
  限制_月亮_解锁_宏名(L);
  return 结果_短变量;
}


配置_月亮_应程接_宏名 void 月亮_传递数据_函 (炉_状态机结 *from, 炉_状态机结 *到_变量, int n) {
  int i;
  if (from == 到_变量) return;
  限制_月亮_锁_宏名(到_变量);
  应程接_API检查n元素们_宏名(from, n);
  限制_应程接_检查_宏名(from, G(from) == G(到_变量), "moving among independent states");
  限制_应程接_检查_宏名(from, 到_变量->调信_缩变量->顶部_变量.p - 到_变量->顶部_变量.p >= n, "栈_圆小 overflow");
  from->顶部_变量.p -= n;
  for (i = 0; i < n; i++) {
    对象_设置对象s到s_宏名(到_变量, 到_变量->顶部_变量.p, from->顶部_变量.p + i);
    到_变量->顶部_变量.p++;  /* 栈_圆小 already checked by 前一个_变量 '限制_应程接_检查_宏名' */
  }
  限制_月亮_解锁_宏名(到_变量);
}


配置_月亮_应程接_宏名 炉_C函数半 月亮_设置恐慌函数_函 (炉_状态机结 *L, 炉_C函数半 panicf) {
  炉_C函数半 旧_变量;
  限制_月亮_锁_宏名(L);
  旧_变量 = G(L)->恐慌_圆;
  G(L)->恐慌_圆 = panicf;
  限制_月亮_解锁_宏名(L);
  return 旧_变量;
}


配置_月亮_应程接_宏名 炉_数目型 月亮_版本_函 (炉_状态机结 *L) {
  限制_未使用_宏名(L);
  return 月头_月亮_版本_数目_宏名;
}



/*
** basic 栈_圆小 manipulation
*/


/*
** convert an acceptable 栈_圆小 index into an absolute index
*/
配置_月亮_应程接_宏名 int 月亮_绝对索引_函 (炉_状态机结 *L, int 索引_缩变量) {
  return (索引_缩变量 > 0 || 应程接_是否伪造_宏名(索引_缩变量))
         ? 索引_缩变量
         : 限制_类型转换_整型_宏名(L->顶部_变量.p - L->调信_缩变量->函_短变量.p) + 索引_缩变量;
}


配置_月亮_应程接_宏名 int 月亮_获取顶_函 (炉_状态机结 *L) {
  return 限制_类型转换_整型_宏名(L->顶部_变量.p - (L->调信_缩变量->函_短变量.p + 1));
}


配置_月亮_应程接_宏名 void 月亮_设置顶_函 (炉_状态机结 *L, int 索引_缩变量) {
  调用信息_结 *调信_缩变量;
  栈身份_型 函_短变量, 新顶部_变量;
  ptrdiff_t diff;  /* difference for new 顶部_变量 */
  限制_月亮_锁_宏名(L);
  调信_缩变量 = L->调信_缩变量;
  函_短变量 = 调信_缩变量->函_短变量.p;
  if (索引_缩变量 >= 0) {
    限制_应程接_检查_宏名(L, 索引_缩变量 <= 调信_缩变量->顶部_变量.p - (函_短变量 + 1), "new 顶部_变量 too large");
    diff = ((函_短变量 + 1) + 索引_缩变量) - L->顶部_变量.p;
    for (; diff > 0; diff--)
      对象_设置空值的值_宏名(对象_s到v_宏名(L->顶部_变量.p++));  /* clear new slots */
  }
  else {
    限制_应程接_检查_宏名(L, -(索引_缩变量+1) <= (L->顶部_变量.p - (函_短变量 + 1)), "invalid new 顶部_变量");
    diff = 索引_缩变量 + 1;  /* will "subtract" index (as it is negative) */
  }
  限制_应程接_检查_宏名(L, L->待关闭列表_结.p < L->顶部_变量.p, "前一个_变量 pop of an unclosed 插槽_变量");
  新顶部_变量 = L->顶部_变量.p + diff;
  if (diff < 0 && L->待关闭列表_结.p >= 新顶部_变量) {
    限制_月亮_断言_宏名(应程接_必须关闭C函数_宏名(调信_缩变量->结果数目_变量));
    新顶部_变量 = 月亮函数_关闭_函(L, 新顶部_变量, 函_关闭栈顶_宏名, 0);
  }
  L->顶部_变量.p = 新顶部_变量;  /* correct 顶部_变量 only after closing any 上值_圆 */
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮_关闭槽_函 (炉_状态机结 *L, int 索引_缩变量) {
  栈身份_型 层级_变量;
  限制_月亮_锁_宏名(L);
  层级_变量 = 月应程接_索引到栈_函(L, 索引_缩变量);
  限制_应程接_检查_宏名(L, 应程接_必须关闭C函数_宏名(L->调信_缩变量->结果数目_变量) && L->待关闭列表_结.p == 层级_变量,
     "no variable 到_变量 关闭_圆 at given 层级_变量");
  层级_变量 = 月亮函数_关闭_函(L, 层级_变量, 函_关闭栈顶_宏名, 0);
  对象_设置空值的值_宏名(对象_s到v_宏名(层级_变量));
  限制_月亮_解锁_宏名(L);
}


/*
** Reverse the 栈_圆小 segment from 'from' 到_变量 '到_变量'
** (auxiliary 到_变量 '月亮_旋转_函')
** Note that we move(copy) only the 值_圆 inside the 栈_圆小.
** (We do not move additional fields that may exist.)
*/
l_sinline void 月应程接_逆向_函 (炉_状态机结 *L, 栈身份_型 from, 栈身份_型 到_变量) {
  for (; from < 到_变量; from++, 到_变量--) {
    标签值_结 临时_变量;
    对象_设置对象_宏名(L, &临时_变量, 对象_s到v_宏名(from));
    对象_设置对象s到s_宏名(L, from, 到_变量);
    对象_设置对象到s_宏名(L, 到_变量, &临时_变量);
  }
}


/*
** Let x = AB, 哪儿_变量 A is a prefix of length 'n'. Then,
** rotate x n == BA. But BA == (A^r . B^r)^r.
*/
配置_月亮_应程接_宏名 void 月亮_旋转_函 (炉_状态机结 *L, int 索引_缩变量, int n) {
  栈身份_型 p, t, m;
  限制_月亮_锁_宏名(L);
  t = L->顶部_变量.p - 1;  /* 终_变量 of 栈_圆小 segment being rotated */
  p = 月应程接_索引到栈_函(L, 索引_缩变量);  /* 起始_变量 of segment */
  限制_应程接_检查_宏名(L, (n >= 0 ? n : -n) <= (t - p + 1), "invalid 'n'");
  m = (n >= 0 ? t - n : p - n - 1);  /* 终_变量 of prefix */
  月应程接_逆向_函(L, p, m);  /* 月应程接_逆向_函 the prefix with length 'n' */
  月应程接_逆向_函(L, m + 1, t);  /* 月应程接_逆向_函 the suffix */
  月应程接_逆向_函(L, p, t);  /* 月应程接_逆向_函 the entire segment */
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮_复制_函 (炉_状态机结 *L, int fromidx, int toidx) {
  标签值_结 *来自_短变量, *到_变量;
  限制_月亮_锁_宏名(L);
  来自_短变量 = 月应程接_索引到值_函(L, fromidx);
  到_变量 = 月应程接_索引到值_函(L, toidx);
  限制_应程接_检查_宏名(L, 应程接_是否有效_宏名(L, 到_变量), "invalid index");
  对象_设置对象_宏名(L, 到_变量, 来自_短变量);
  if (应程接_是否上值_宏名(toidx))  /* function 上值_圆? */
    垃圾回收_月亮C_屏障_宏名(L, 对象_闭包C值_宏名(对象_s到v_宏名(L->调信_缩变量->函_短变量.p)), 来自_短变量);
  /* 月头_月亮_注册表索引_宏名 does not need 垃回_小写缩 barrier
     (collector revisits it before finishing collection) */
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮_推入值_函 (炉_状态机结 *L, int 索引_缩变量) {
  限制_月亮_锁_宏名(L);
  对象_设置对象到s_宏名(L, L->顶部_变量.p, 月应程接_索引到值_函(L, 索引_缩变量));
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
}



/*
** access functions (栈_圆小 -> C)
*/


配置_月亮_应程接_宏名 int 月亮_类型_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return (应程接_是否有效_宏名(L, o) ? 对象_t类型_宏名(o) : 月头_月亮_T没有_宏名);
}


配置_月亮_应程接_宏名 const char *月亮_类型名称_函 (炉_状态机结 *L, int t) {
  限制_未使用_宏名(L);
  限制_应程接_检查_宏名(L, 月头_月亮_T没有_宏名 <= t && t < 炉_类型数们, "invalid type");
  return 标签方法_t类型名称_宏名(t);
}


配置_月亮_应程接_宏名 int 月亮_是否C函数_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return (对象_tt是否L闭包函_宏名(o) || (对象_tt是否C闭包_宏名(o)));
}


配置_月亮_应程接_宏名 int 月亮_是否整数_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return 对象_tt是否整数_宏名(o);
}


配置_月亮_应程接_宏名 int 月亮_是否数目_函 (炉_状态机结 *L, int 索引_缩变量) {
  炉_数目型 n;
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return 虚机头_到数目_宏名(o, &n);
}


配置_月亮_应程接_宏名 int 月亮_是否字符串_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return (对象_tt是否字符串_宏名(o) || 虚机头_转化到串_宏名(o));
}


配置_月亮_应程接_宏名 int 月亮_是否用户数据_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return (对象_tt是否完全用户数据_宏名(o) || 对象_tt是否轻量用户数据_宏名(o));
}


配置_月亮_应程接_宏名 int 月亮原始相等_函 (炉_状态机结 *L, int index1, int index2) {
  const 标签值_结 *操1_变量 = 月应程接_索引到值_函(L, index1);
  const 标签值_结 *操2_变量 = 月应程接_索引到值_函(L, index2);
  return (应程接_是否有效_宏名(L, 操1_变量) && 应程接_是否有效_宏名(L, 操2_变量)) ? 虚机头_月亮V_原始相等对象_宏名(操1_变量, 操2_变量) : 0;
}


配置_月亮_应程接_宏名 void 月亮算术_函 (炉_状态机结 *L, int 操作_短变量) {
  限制_月亮_锁_宏名(L);
  if (操作_短变量 != 月头_月亮_操作负号_宏名 && 操作_短变量 != 月头_月亮_操作按位非_宏名)
    应程接_API检查n元素们_宏名(L, 2);  /* all other operations expect two operands */
  else {  /* for unary operations, add fake 2nd operand */
    应程接_API检查n元素们_宏名(L, 1);
    对象_设置对象s到s_宏名(L, L->顶部_变量.p, L->顶部_变量.p - 1);
    应程接_API_递增_顶部_宏名(L);
  }
  /* 首先_变量 operand at 顶部_变量 - 2, second at 顶部_变量 - 1; 结果_变量 go 到_变量 顶部_变量 - 2 */
  月亮对象_算术_函(L, 操作_短变量, 对象_s到v_宏名(L->顶部_变量.p - 2), 对象_s到v_宏名(L->顶部_变量.p - 1), L->顶部_变量.p - 2);
  L->顶部_变量.p--;  /* remove second operand */
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 int 月亮对比_函 (炉_状态机结 *L, int index1, int index2, int 操作_短变量) {
  const 标签值_结 *操1_变量;
  const 标签值_结 *操2_变量;
  int i = 0;
  限制_月亮_锁_宏名(L);  /* may call tag method */
  操1_变量 = 月应程接_索引到值_函(L, index1);
  操2_变量 = 月应程接_索引到值_函(L, index2);
  if (应程接_是否有效_宏名(L, 操1_变量) && 应程接_是否有效_宏名(L, 操2_变量)) {
    switch (操作_短变量) {
      case 月头_月亮_操作等于_宏名: i = 月亮虚拟机_相等对象_函(L, 操1_变量, 操2_变量); break;
      case 月头_月亮_操作小于_宏名: i = 月亮虚拟机_小于_函(L, 操1_变量, 操2_变量); break;
      case 月头_月亮_操作小等_宏名: i = 月亮虚拟机_小于等于_函(L, 操1_变量, 操2_变量); break;
      default: 限制_应程接_检查_宏名(L, 0, "invalid 选项_变量");
    }
  }
  限制_月亮_解锁_宏名(L);
  return i;
}


配置_月亮_应程接_宏名 size_t 月亮_字符串到数目_函 (炉_状态机结 *L, const char *s) {
  size_t 大小_短变量 = 月亮对象_字符串到数目_函(s, 对象_s到v_宏名(L->顶部_变量.p));
  if (大小_短变量 != 0)
    应程接_API_递增_顶部_宏名(L);
  return 大小_短变量;
}


配置_月亮_应程接_宏名 炉_数目型 月亮_到数目x_函 (炉_状态机结 *L, int 索引_缩变量, int *pisnum) {
  炉_数目型 n = 0;
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  int 是否数目_变量 = 虚机头_到数目_宏名(o, &n);
  if (pisnum)
    *pisnum = 是否数目_变量;
  return n;
}


配置_月亮_应程接_宏名 炉_整数型 月亮_到整数x_函 (炉_状态机结 *L, int 索引_缩变量, int *pisnum) {
  炉_整数型 结果_短变量 = 0;
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  int 是否数目_变量 = 虚机头_到整数_宏名(o, &结果_短变量);
  if (pisnum)
    *pisnum = 是否数目_变量;
  return 结果_短变量;
}


配置_月亮_应程接_宏名 int 月亮_到布尔值_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return !对象_l_是否假_宏名(o);
}


配置_月亮_应程接_宏名 const char *月亮_到长字符串_函 (炉_状态机结 *L, int 索引_缩变量, size_t *长度_短变量) {
  标签值_结 *o;
  限制_月亮_锁_宏名(L);
  o = 月应程接_索引到值_函(L, 索引_缩变量);
  if (!对象_tt是否字符串_宏名(o)) {
    if (!虚机头_转化到串_宏名(o)) {  /* not convertible? */
      if (长度_短变量 != NULL) *长度_短变量 = 0;
      限制_月亮_解锁_宏名(L);
      return NULL;
    }
    月亮对象_到字符串_函(L, o);
    垃圾回收_月亮C_检查GC_宏名(L);
    o = 月应程接_索引到值_函(L, 索引_缩变量);  /* 前一个_变量 call may reallocate the 栈_圆小 */
  }
  if (长度_短变量 != NULL)
    *长度_短变量 = 对象_vs长度_宏名(o);
  限制_月亮_解锁_宏名(L);
  return 对象_s值_宏名(o);
}


配置_月亮_应程接_宏名 lua_Unsigned 月亮_原始长度_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  switch (对象_t类型标签_宏名(o)) {
    case 对象_月亮_V短型串_宏名: return 对象_ts值_宏名(o)->短串长_小写;
    case 对象_月亮_V长型串_宏名: return 对象_ts值_宏名(o)->u.长串长_短;
    case 对象_月亮_V用户数据_宏名: return 对象_u值_宏名(o)->长度_短变量;
    case 对象_月亮_V表_宏名: return 月亮哈希表_获取n_函(对象_哈希值_宏名(o));
    default: return 0;
  }
}


配置_月亮_应程接_宏名 炉_C函数半 月亮_到C函数_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  if (对象_tt是否L闭包函_宏名(o)) return 对象_函值_宏名(o);
  else if (对象_tt是否C闭包_宏名(o))
    return 对象_闭包C值_宏名(o)->f;
  else return NULL;  /* not a C function */
}


l_sinline void *月应程接_到用户数据_函 (const 标签值_结 *o) {
  switch (对象_t类型_宏名(o)) {
    case 月头_月亮_T用户数据_宏名: return 对象_获取用户数据内存_宏名(对象_u值_宏名(o));
    case 月头_月亮_T轻量用户数据_宏名: return 对象_p值_宏名(o);
    default: return NULL;
  }
}


配置_月亮_应程接_宏名 void *月亮_到用户数据_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return 月应程接_到用户数据_函(o);
}


配置_月亮_应程接_宏名 炉_状态机结 *月亮到线程_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  return (!对象_tt是否线程_宏名(o)) ? NULL : 对象_线程值_宏名(o);
}


/*
** Returns a pointer 到_变量 the internal representation of an object.
** Note that ANSI C does not allow the conversion of a pointer 到_变量
** function 到_变量 a 'void*', so the conversion here goes through
** a 'size_t'. (As the returned pointer is only informative, this
** conversion should not be a problem.)
*/
配置_月亮_应程接_宏名 const void *月亮到指针_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *o = 月应程接_索引到值_函(L, 索引_缩变量);
  switch (对象_t类型标签_宏名(o)) {
    case 对象_月亮_VL闭包函_宏名: return 限制_类型转换_空的指针_宏名(限制_类型转换_大小t_宏名(对象_函值_宏名(o)));
    case 对象_月亮_V用户数据_宏名: case 对象_月亮_V轻量用户数据_宏名:
      return 月应程接_到用户数据_函(o);
    default: {
      if (对象_是否可收集_宏名(o))
        return 对象_垃圾回收值_宏名(o);
      else
        return NULL;
    }
  }
}



/*
** push functions (C -> 栈_圆小)
*/


配置_月亮_应程接_宏名 void 月亮推入空值_函 (炉_状态机结 *L) {
  限制_月亮_锁_宏名(L);
  对象_设置空值的值_宏名(对象_s到v_宏名(L->顶部_变量.p));
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮推入数目_函 (炉_状态机结 *L, 炉_数目型 n) {
  限制_月亮_锁_宏名(L);
  对象_设置浮点值_宏名(对象_s到v_宏名(L->顶部_变量.p), n);
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮推入整数_函 (炉_状态机结 *L, 炉_整数型 n) {
  限制_月亮_锁_宏名(L);
  对象_设置整数值_宏名(对象_s到v_宏名(L->顶部_变量.p), n);
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
}


/*
** Pushes on the 栈_圆小 a string with given length. Avoid using 's' when
** '长度_短变量' == 0 (as 's' can be NULL in that case), due 到_变量 later use of
** 'memcmp' and 'memcpy'.
*/
配置_月亮_应程接_宏名 const char *月亮推入长字符串_函 (炉_状态机结 *L, const char *s, size_t 长度_短变量) {
  标签字符串_结 *类s_变量;
  限制_月亮_锁_宏名(L);
  类s_变量 = (长度_短变量 == 0) ? 月亮字符串_新_函(L, "") : 月亮字符串_新长串_函(L, s, 长度_短变量);
  对象_设置ts值到s_宏名(L, L->顶部_变量.p, 类s_变量);
  应程接_API_递增_顶部_宏名(L);
  垃圾回收_月亮C_检查GC_宏名(L);
  限制_月亮_解锁_宏名(L);
  return 对象_获取串_宏名(类s_变量);
}


配置_月亮_应程接_宏名 const char *月亮推入字符串_函 (炉_状态机结 *L, const char *s) {
  限制_月亮_锁_宏名(L);
  if (s == NULL)
    对象_设置空值的值_宏名(对象_s到v_宏名(L->顶部_变量.p));
  else {
    标签字符串_结 *类s_变量;
    类s_变量 = 月亮字符串_新_函(L, s);
    对象_设置ts值到s_宏名(L, L->顶部_变量.p, 类s_变量);
    s = 对象_获取串_宏名(类s_变量);  /* internal copy's address */
  }
  应程接_API_递增_顶部_宏名(L);
  垃圾回收_月亮C_检查GC_宏名(L);
  限制_月亮_解锁_宏名(L);
  return s;
}


配置_月亮_应程接_宏名 const char *月亮推入可变格式字符串_函 (炉_状态机结 *L, const char *格式_短变量,
                                      va_list argp) {
  const char *返回_短变量;
  限制_月亮_锁_宏名(L);
  返回_短变量 = 月亮对象_推入可变格式化字符串_函(L, 格式_短变量, argp);
  垃圾回收_月亮C_检查GC_宏名(L);
  限制_月亮_解锁_宏名(L);
  return 返回_短变量;
}


配置_月亮_应程接_宏名 const char *月亮推入格式化字符串_函 (炉_状态机结 *L, const char *格式_短变量, ...) {
  const char *返回_短变量;
  va_list argp;
  限制_月亮_锁_宏名(L);
  va_start(argp, 格式_短变量);
  返回_短变量 = 月亮对象_推入可变格式化字符串_函(L, 格式_短变量, argp);
  va_end(argp);
  垃圾回收_月亮C_检查GC_宏名(L);
  限制_月亮_解锁_宏名(L);
  return 返回_短变量;
}


配置_月亮_应程接_宏名 void 月亮推入C闭包_函 (炉_状态机结 *L, 炉_C函数半 fn, int n) {
  限制_月亮_锁_宏名(L);
  if (n == 0) {
    对象_设置函值_宏名(对象_s到v_宏名(L->顶部_变量.p), fn);
    应程接_API_递增_顶部_宏名(L);
  }
  else {
    C闭包_结 *闭包_短变量;
    应程接_API检查n元素们_宏名(L, n);
    限制_应程接_检查_宏名(L, n <= 函_最大上值_宏名, "上值_圆 index too large");
    闭包_短变量 = 月亮函数_新C闭包_函(L, n);
    闭包_短变量->f = fn;
    L->顶部_变量.p -= n;
    while (n--) {
      对象_设置对象到n_宏名(L, &闭包_短变量->上值_圆[n], 对象_s到v_宏名(L->顶部_变量.p + n));
      /* does not need barrier because closure is 白色_变量 */
      限制_月亮_断言_宏名(垃圾回收_是否白色_宏名(闭包_短变量));
    }
    对象_设置闭包C值_宏名(L, 对象_s到v_宏名(L->顶部_变量.p), 闭包_短变量);
    应程接_API_递增_顶部_宏名(L);
    垃圾回收_月亮C_检查GC_宏名(L);
  }
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮推入布尔值_函 (炉_状态机结 *L, int b) {
  限制_月亮_锁_宏名(L);
  if (b)
    对象_设置布尔真值_宏名(对象_s到v_宏名(L->顶部_变量.p));
  else
    对象_设置布尔假值_宏名(对象_s到v_宏名(L->顶部_变量.p));
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮推入轻量用户数据_函 (炉_状态机结 *L, void *p) {
  限制_月亮_锁_宏名(L);
  对象_设置p值_宏名(对象_s到v_宏名(L->顶部_变量.p), p);
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 int 月亮推入线程_函 (炉_状态机结 *L) {
  限制_月亮_锁_宏名(L);
  对象_设置线程值_宏名(L, 对象_s到v_宏名(L->顶部_变量.p), L);
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
  return (G(L)->主线程_圆 == L);
}



/*
** get functions (Lua -> 栈_圆小)
*/


l_sinline int 月应程接_辅助获取串_函 (炉_状态机结 *L, const 标签值_结 *t, const char *k) {
  const 标签值_结 *插槽_变量;
  标签字符串_结 *串_变量 = 月亮字符串_新_函(L, k);
  if (虚机头_月亮V_快速获取_宏名(L, t, 串_变量, 插槽_变量, 月亮哈希表_获取串键_函)) {
    对象_设置对象到s_宏名(L, L->顶部_变量.p, 插槽_变量);
    应程接_API_递增_顶部_宏名(L);
  }
  else {
    对象_设置ts值到s_宏名(L, L->顶部_变量.p, 串_变量);
    应程接_API_递增_顶部_宏名(L);
    月亮虚拟机_完成获取_函(L, t, 对象_s到v_宏名(L->顶部_变量.p - 1), L->顶部_变量.p - 1, 插槽_变量);
  }
  限制_月亮_解锁_宏名(L);
  return 对象_t类型_宏名(对象_s到v_宏名(L->顶部_变量.p - 1));
}


/*
** Get the global table in the 注册表_变量. Since all predefined
** indices in the 注册表_变量 were inserted 右_圆 when the 注册表_变量
** was created and never removed, they must always be in the 数组_圆
** part of the 注册表_变量.
*/
#define 应程接_获取全局表_宏名(L)  \
	(&对象_哈希值_宏名(&G(L)->l_注册表半)->数组_圆[月头_月亮_注册索引_全局的_宏名 - 1])


配置_月亮_应程接_宏名 int 月亮获取全局变量_函 (炉_状态机结 *L, const char *名称_变量) {
  const 标签值_结 *G;
  限制_月亮_锁_宏名(L);
  G = 应程接_获取全局表_宏名(L);
  return 月应程接_辅助获取串_函(L, G, 名称_变量);
}


配置_月亮_应程接_宏名 int 月亮获取表_函 (炉_状态机结 *L, int 索引_缩变量) {
  const 标签值_结 *插槽_变量;
  标签值_结 *t;
  限制_月亮_锁_宏名(L);
  t = 月应程接_索引到值_函(L, 索引_缩变量);
  if (虚机头_月亮V_快速获取_宏名(L, t, 对象_s到v_宏名(L->顶部_变量.p - 1), 插槽_变量, 月亮哈希表_获取键_函)) {
    对象_设置对象到s_宏名(L, L->顶部_变量.p - 1, 插槽_变量);
  }
  else
    月亮虚拟机_完成获取_函(L, t, 对象_s到v_宏名(L->顶部_变量.p - 1), L->顶部_变量.p - 1, 插槽_变量);
  限制_月亮_解锁_宏名(L);
  return 对象_t类型_宏名(对象_s到v_宏名(L->顶部_变量.p - 1));
}


配置_月亮_应程接_宏名 int 月亮获取字段_函 (炉_状态机结 *L, int 索引_缩变量, const char *k) {
  限制_月亮_锁_宏名(L);
  return 月应程接_辅助获取串_函(L, 月应程接_索引到值_函(L, 索引_缩变量), k);
}


配置_月亮_应程接_宏名 int 月亮获取索引_函 (炉_状态机结 *L, int 索引_缩变量, 炉_整数型 n) {
  标签值_结 *t;
  const 标签值_结 *插槽_变量;
  限制_月亮_锁_宏名(L);
  t = 月应程接_索引到值_函(L, 索引_缩变量);
  if (虚机头_月亮V_快速获取索引_宏名(L, t, n, 插槽_变量)) {
    对象_设置对象到s_宏名(L, L->顶部_变量.p, 插槽_变量);
  }
  else {
    标签值_结 辅助_变量;
    对象_设置整数值_宏名(&辅助_变量, n);
    月亮虚拟机_完成获取_函(L, t, &辅助_变量, L->顶部_变量.p, 插槽_变量);
  }
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
  return 对象_t类型_宏名(对象_s到v_宏名(L->顶部_变量.p - 1));
}


l_sinline int 月应程接_完成原始获取_函 (炉_状态机结 *L, const 标签值_结 *值_变量) {
  if (对象_是否空容器_宏名(值_变量))  /* avoid copying 空容器_变量 items 到_变量 the 栈_圆小 */
    对象_设置空值的值_宏名(对象_s到v_宏名(L->顶部_变量.p));
  else
    对象_设置对象到s_宏名(L, L->顶部_变量.p, 值_变量);
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
  return 对象_t类型_宏名(对象_s到v_宏名(L->顶部_变量.p - 1));
}


static 表_结 *月应程接_获取表_函 (炉_状态机结 *L, int 索引_缩变量) {
  标签值_结 *t = 月应程接_索引到值_函(L, 索引_缩变量);
  限制_应程接_检查_宏名(L, 对象_tt是否表_宏名(t), "table expected");
  return 对象_哈希值_宏名(t);
}


配置_月亮_应程接_宏名 int 月亮获取原始_函 (炉_状态机结 *L, int 索引_缩变量) {
  表_结 *t;
  const 标签值_结 *值_变量;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, 1);
  t = 月应程接_获取表_函(L, 索引_缩变量);
  值_变量 = 月亮哈希表_获取键_函(t, 对象_s到v_宏名(L->顶部_变量.p - 1));
  L->顶部_变量.p--;  /* remove 键_小变量 */
  return 月应程接_完成原始获取_函(L, 值_变量);
}


配置_月亮_应程接_宏名 int 月亮获取原始索引_函 (炉_状态机结 *L, int 索引_缩变量, 炉_整数型 n) {
  表_结 *t;
  限制_月亮_锁_宏名(L);
  t = 月应程接_获取表_函(L, 索引_缩变量);
  return 月应程接_完成原始获取_函(L, 月亮哈希表_获取整型键_函(t, n));
}


配置_月亮_应程接_宏名 int 月亮获取原始指针_函 (炉_状态机结 *L, int 索引_缩变量, const void *p) {
  表_结 *t;
  标签值_结 k;
  限制_月亮_锁_宏名(L);
  t = 月应程接_获取表_函(L, 索引_缩变量);
  对象_设置p值_宏名(&k, 限制_类型转换_空的指针_宏名(p));
  return 月应程接_完成原始获取_函(L, 月亮哈希表_获取键_函(t, &k));
}


配置_月亮_应程接_宏名 void 月亮创建表_函 (炉_状态机结 *L, int narray, int nrec) {
  表_结 *t;
  限制_月亮_锁_宏名(L);
  t = 月亮哈希表_新_函(L);
  对象_设置哈希值到s_宏名(L, L->顶部_变量.p, t);
  应程接_API_递增_顶部_宏名(L);
  if (narray > 0 || nrec > 0)
    月亮哈希表_调整大小_函(L, t, narray, nrec);
  垃圾回收_月亮C_检查GC_宏名(L);
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 int 月亮获取元表_函 (炉_状态机结 *L, int objindex) {
  const 标签值_结 *对象_变量;
  表_结 *元表_缩变量;
  int 结果_短变量 = 0;
  限制_月亮_锁_宏名(L);
  对象_变量 = 月应程接_索引到值_函(L, objindex);
  switch (对象_t类型_宏名(对象_变量)) {
    case 月头_月亮_T表_宏名:
      元表_缩变量 = 对象_哈希值_宏名(对象_变量)->元表_小写;
      break;
    case 月头_月亮_T用户数据_宏名:
      元表_缩变量 = 对象_u值_宏名(对象_变量)->元表_小写;
      break;
    default:
      元表_缩变量 = G(L)->元表_缩变量[对象_t类型_宏名(对象_变量)];
      break;
  }
  if (元表_缩变量 != NULL) {
    对象_设置哈希值到s_宏名(L, L->顶部_变量.p, 元表_缩变量);
    应程接_API_递增_顶部_宏名(L);
    结果_短变量 = 1;
  }
  限制_月亮_解锁_宏名(L);
  return 结果_短变量;
}


配置_月亮_应程接_宏名 int 月亮获取索引用户值_函 (炉_状态机结 *L, int 索引_缩变量, int n) {
  标签值_结 *o;
  int t;
  限制_月亮_锁_宏名(L);
  o = 月应程接_索引到值_函(L, 索引_缩变量);
  限制_应程接_检查_宏名(L, 对象_tt是否完全用户数据_宏名(o), "full userdata expected");
  if (n <= 0 || n > 对象_u值_宏名(o)->用户值数_缩) {
    对象_设置空值的值_宏名(对象_s到v_宏名(L->顶部_变量.p));
    t = 月头_月亮_T没有_宏名;
  }
  else {
    对象_设置对象到s_宏名(L, L->顶部_变量.p, &对象_u值_宏名(o)->上值_缩变量[n - 1].上值_缩变量);
    t = 对象_t类型_宏名(对象_s到v_宏名(L->顶部_变量.p));
  }
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
  return t;
}


/*
** set functions (栈_圆小 -> Lua)
*/

/*
** t[k] = 值_圆 at the 顶部_变量 of the 栈_圆小 (哪儿_变量 'k' is a string)
*/
static void 月应程接_辅助设置串_函 (炉_状态机结 *L, const 标签值_结 *t, const char *k) {
  const 标签值_结 *插槽_变量;
  标签字符串_结 *串_变量 = 月亮字符串_新_函(L, k);
  应程接_API检查n元素们_宏名(L, 1);
  if (虚机头_月亮V_快速获取_宏名(L, t, 串_变量, 插槽_变量, 月亮哈希表_获取串键_函)) {
    虚机头_月亮V_结束快速设置_宏名(L, t, 插槽_变量, 对象_s到v_宏名(L->顶部_变量.p - 1));
    L->顶部_变量.p--;  /* pop 值_圆 */
  }
  else {
    对象_设置ts值到s_宏名(L, L->顶部_变量.p, 串_变量);  /* push '串_变量' (到_变量 make it a 标签值_结) */
    应程接_API_递增_顶部_宏名(L);
    月亮虚拟机_完成设置_函(L, t, 对象_s到v_宏名(L->顶部_变量.p - 1), 对象_s到v_宏名(L->顶部_变量.p - 2), 插槽_变量);
    L->顶部_变量.p -= 2;  /* pop 值_圆 and 键_小变量 */
  }
  限制_月亮_解锁_宏名(L);  /* lock done by caller */
}


配置_月亮_应程接_宏名 void 月亮设置全局变量_函 (炉_状态机结 *L, const char *名称_变量) {
  const 标签值_结 *G;
  限制_月亮_锁_宏名(L);  /* unlock done in '月应程接_辅助设置串_函' */
  G = 应程接_获取全局表_宏名(L);
  月应程接_辅助设置串_函(L, G, 名称_变量);
}


配置_月亮_应程接_宏名 void 月亮设置表_函 (炉_状态机结 *L, int 索引_缩变量) {
  标签值_结 *t;
  const 标签值_结 *插槽_变量;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, 2);
  t = 月应程接_索引到值_函(L, 索引_缩变量);
  if (虚机头_月亮V_快速获取_宏名(L, t, 对象_s到v_宏名(L->顶部_变量.p - 2), 插槽_变量, 月亮哈希表_获取键_函)) {
    虚机头_月亮V_结束快速设置_宏名(L, t, 插槽_变量, 对象_s到v_宏名(L->顶部_变量.p - 1));
  }
  else
    月亮虚拟机_完成设置_函(L, t, 对象_s到v_宏名(L->顶部_变量.p - 2), 对象_s到v_宏名(L->顶部_变量.p - 1), 插槽_变量);
  L->顶部_变量.p -= 2;  /* pop index and 值_圆 */
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮设置字段_函 (炉_状态机结 *L, int 索引_缩变量, const char *k) {
  限制_月亮_锁_宏名(L);  /* unlock done in '月应程接_辅助设置串_函' */
  月应程接_辅助设置串_函(L, 月应程接_索引到值_函(L, 索引_缩变量), k);
}


配置_月亮_应程接_宏名 void 月亮_设置索引_函 (炉_状态机结 *L, int 索引_缩变量, 炉_整数型 n) {
  标签值_结 *t;
  const 标签值_结 *插槽_变量;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, 1);
  t = 月应程接_索引到值_函(L, 索引_缩变量);
  if (虚机头_月亮V_快速获取索引_宏名(L, t, n, 插槽_变量)) {
    虚机头_月亮V_结束快速设置_宏名(L, t, 插槽_变量, 对象_s到v_宏名(L->顶部_变量.p - 1));
  }
  else {
    标签值_结 辅助_变量;
    对象_设置整数值_宏名(&辅助_变量, n);
    月亮虚拟机_完成设置_函(L, t, &辅助_变量, 对象_s到v_宏名(L->顶部_变量.p - 1), 插槽_变量);
  }
  L->顶部_变量.p--;  /* pop 值_圆 */
  限制_月亮_解锁_宏名(L);
}


static void 月应程接_辅助_原始设置_函 (炉_状态机结 *L, int 索引_缩变量, 标签值_结 *键_小变量, int n) {
  表_结 *t;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, n);
  t = 月应程接_获取表_函(L, 索引_缩变量);
  月亮哈希表_设置键_函(L, t, 键_小变量, 对象_s到v_宏名(L->顶部_变量.p - 1));
  表_废弃标签方法缓存_宏名(t);
  垃圾回收_月亮C_屏障后退_宏名(L, 状态机_对象到垃圾回收对象_宏名(t), 对象_s到v_宏名(L->顶部_变量.p - 1));
  L->顶部_变量.p -= n;
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮_设置原始_函 (炉_状态机结 *L, int 索引_缩变量) {
  月应程接_辅助_原始设置_函(L, 索引_缩变量, 对象_s到v_宏名(L->顶部_变量.p - 2), 2);
}


配置_月亮_应程接_宏名 void 月亮_设置原始指针_函 (炉_状态机结 *L, int 索引_缩变量, const void *p) {
  标签值_结 k;
  对象_设置p值_宏名(&k, 限制_类型转换_空的指针_宏名(p));
  月应程接_辅助_原始设置_函(L, 索引_缩变量, &k, 1);
}


配置_月亮_应程接_宏名 void 月亮_设置原始索引_函 (炉_状态机结 *L, int 索引_缩变量, 炉_整数型 n) {
  表_结 *t;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, 1);
  t = 月应程接_获取表_函(L, 索引_缩变量);
  月亮哈希表_设置整型键_函(L, t, n, 对象_s到v_宏名(L->顶部_变量.p - 1));
  垃圾回收_月亮C_屏障后退_宏名(L, 状态机_对象到垃圾回收对象_宏名(t), 对象_s到v_宏名(L->顶部_变量.p - 1));
  L->顶部_变量.p--;
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 int 月亮_设置元表_函 (炉_状态机结 *L, int objindex) {
  标签值_结 *对象_变量;
  表_结 *元表_缩变量;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, 1);
  对象_变量 = 月应程接_索引到值_函(L, objindex);
  if (对象_tt是否空值_宏名(对象_s到v_宏名(L->顶部_变量.p - 1)))
    元表_缩变量 = NULL;
  else {
    限制_应程接_检查_宏名(L, 对象_tt是否表_宏名(对象_s到v_宏名(L->顶部_变量.p - 1)), "table expected");
    元表_缩变量 = 对象_哈希值_宏名(对象_s到v_宏名(L->顶部_变量.p - 1));
  }
  switch (对象_t类型_宏名(对象_变量)) {
    case 月头_月亮_T表_宏名: {
      对象_哈希值_宏名(对象_变量)->元表_小写 = 元表_缩变量;
      if (元表_缩变量) {
        垃圾回收_月亮C_对象屏障_宏名(L, 对象_垃圾回收值_宏名(对象_变量), 元表_缩变量);
        月亮编译_检查终结器_函(L, 对象_垃圾回收值_宏名(对象_变量), 元表_缩变量);
      }
      break;
    }
    case 月头_月亮_T用户数据_宏名: {
      对象_u值_宏名(对象_变量)->元表_小写 = 元表_缩变量;
      if (元表_缩变量) {
        垃圾回收_月亮C_对象屏障_宏名(L, 对象_u值_宏名(对象_变量), 元表_缩变量);
        月亮编译_检查终结器_函(L, 对象_垃圾回收值_宏名(对象_变量), 元表_缩变量);
      }
      break;
    }
    default: {
      G(L)->元表_缩变量[对象_t类型_宏名(对象_变量)] = 元表_缩变量;
      break;
    }
  }
  L->顶部_变量.p--;
  限制_月亮_解锁_宏名(L);
  return 1;
}


配置_月亮_应程接_宏名 int 月亮_设置索引用户值_函 (炉_状态机结 *L, int 索引_缩变量, int n) {
  标签值_结 *o;
  int 结果_短变量;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, 1);
  o = 月应程接_索引到值_函(L, 索引_缩变量);
  限制_应程接_检查_宏名(L, 对象_tt是否完全用户数据_宏名(o), "full userdata expected");
  if (!(限制_类型转换_无符整型_宏名(n) - 1u < 限制_类型转换_无符整型_宏名(对象_u值_宏名(o)->用户值数_缩)))
    结果_短变量 = 0;  /* 'n' not in [1, 对象_u值_宏名(o)->用户值数_缩] */
  else {
    对象_设置对象_宏名(L, &对象_u值_宏名(o)->上值_缩变量[n - 1].上值_缩变量, 对象_s到v_宏名(L->顶部_变量.p - 1));
    垃圾回收_月亮C_屏障后退_宏名(L, 对象_垃圾回收值_宏名(o), 对象_s到v_宏名(L->顶部_变量.p - 1));
    结果_短变量 = 1;
  }
  L->顶部_变量.p--;
  限制_月亮_解锁_宏名(L);
  return 结果_短变量;
}


/*
** 'load' and 'call' functions (run Lua 代码_变量)
*/


#define 应程接_检查结果们_宏名(L,数量a_变量,数寄_缩变量) \
     限制_应程接_检查_宏名(L, (数寄_缩变量) == 月头_月亮_多返回_宏名 \
               || (L->调信_缩变量->顶部_变量.p - L->顶部_变量.p >= (数寄_缩变量) - (数量a_变量)), \
	"results from function overflow 当前_圆 栈_圆小 大小_变量")


配置_月亮_应程接_宏名 void 月亮_调用常量_函 (炉_状态机结 *L, int 实参数们_变量, int 结果数目_变量,
                        炉_K上下文型 ctx, 炉_K函数型 k) {
  栈身份_型 函_短变量;
  限制_月亮_锁_宏名(L);
  限制_应程接_检查_宏名(L, k == NULL || !状态机_是否月亮_宏名(L->调信_缩变量),
    "月编译器_不能_函 use continuations inside hooks");
  应程接_API检查n元素们_宏名(L, 实参数们_变量+1);
  限制_应程接_检查_宏名(L, L->状态码_变量 == LUA_OK, "月编译器_不能_函 do calls on non-normal 线程_变量");
  应程接_检查结果们_宏名(L, 实参数们_变量, 结果数目_变量);
  函_短变量 = L->顶部_变量.p - (实参数们_变量+1);
  if (k != NULL && 状态机_可让步_宏名(L)) {  /* need 到_变量 prepare continuation? */
    L->调信_缩变量->u.c.k = k;  /* 月词法_保存_函 continuation */
    L->调信_缩变量->u.c.ctx = ctx;  /* 月词法_保存_函 context */
    月亮调度_调用_函(L, 函_短变量, 结果数目_变量);  /* do the call */
  }
  else  /* no continuation or no 状态机_可让步_宏名 */
    月亮调度_调用无产出_函(L, 函_短变量, 结果数目_变量);  /* just do the call */
  应程接_调整结果们_宏名(L, 结果数目_变量);
  限制_月亮_解锁_宏名(L);
}



/*
** Execute a protected call.
*/
struct 安全调用_结 {  /* 数据_变量 到_变量 '月应程接_函_调用_函' */
  栈身份_型 函_短变量;
  int 结果数目_变量;
};


static void 月应程接_函_调用_函 (炉_状态机结 *L, void *用数_缩变量) {
  struct 安全调用_结 *c = 限制_类型转换_宏名(struct 安全调用_结 *, 用数_缩变量);
  月亮调度_调用无产出_函(L, c->函_短变量, c->结果数目_变量);
}



配置_月亮_应程接_宏名 int 月亮_保护调用常量_函 (炉_状态机结 *L, int 实参数们_变量, int 结果数目_变量, int 错函_短变量,
                        炉_K上下文型 ctx, 炉_K函数型 k) {
  struct 安全调用_结 c;
  int 状态码_变量;
  ptrdiff_t 函_短变量;
  限制_月亮_锁_宏名(L);
  限制_应程接_检查_宏名(L, k == NULL || !状态机_是否月亮_宏名(L->调信_缩变量),
    "月编译器_不能_函 use continuations inside hooks");
  应程接_API检查n元素们_宏名(L, 实参数们_变量+1);
  限制_应程接_检查_宏名(L, L->状态码_变量 == LUA_OK, "月编译器_不能_函 do calls on non-normal 线程_变量");
  应程接_检查结果们_宏名(L, 实参数们_变量, 结果数目_变量);
  if (错函_短变量 == 0)
    函_短变量 = 0;
  else {
    栈身份_型 o = 月应程接_索引到栈_函(L, 错函_短变量);
    限制_应程接_检查_宏名(L, 对象_tt是否函数_宏名(对象_s到v_宏名(o)), "错误_小变量 handler must be a function");
    函_短变量 = 做_保存栈_宏名(L, o);
  }
  c.函_短变量 = L->顶部_变量.p - (实参数们_变量+1);  /* function 到_变量 be called */
  if (k == NULL || !状态机_可让步_宏名(L)) {  /* no continuation or no 状态机_可让步_宏名? */
    c.结果数目_变量 = 结果数目_变量;  /* do a 'conventional' protected call */
    状态码_变量 = 月亮调度_预处理调用_函(L, 月应程接_函_调用_函, &c, 做_保存栈_宏名(L, c.函_短变量), 函_短变量);
  }
  else {  /* prepare continuation (call is already protected by '月做_恢复_函') */
    调用信息_结 *调信_缩变量 = L->调信_缩变量;
    调信_缩变量->u.c.k = k;  /* 月词法_保存_函 continuation */
    调信_缩变量->u.c.ctx = ctx;  /* 月词法_保存_函 context */
    /* 月词法_保存_函 information for 错误_小变量 recovery */
    调信_缩变量->u2.函索引_短 = 限制_类型转换_整型_宏名(做_保存栈_宏名(L, c.函_短变量));
    调信_缩变量->u.c.旧_错函短 = L->错函_短变量;
    L->错函_短变量 = 函_短变量;
    状态机_设置旧活动钩子_宏名(调信_缩变量->调用状态码_圆, L->允许钩子_圆);  /* 月词法_保存_函 值_圆 of '允许钩子_圆' */
    调信_缩变量->调用状态码_圆 |= 状态机_调信状型_让步保护调用_宏名;  /* function can do 错误_小变量 recovery */
    月亮调度_调用_函(L, c.函_短变量, 结果数目_变量);  /* do the call */
    调信_缩变量->调用状态码_圆 &= ~状态机_调信状型_让步保护调用_宏名;
    L->错函_短变量 = 调信_缩变量->u.c.旧_错函短;
    状态码_变量 = LUA_OK;  /* if it is here, there were no errors */
  }
  应程接_调整结果们_宏名(L, 结果数目_变量);
  限制_月亮_解锁_宏名(L);
  return 状态码_变量;
}


配置_月亮_应程接_宏名 int 月亮_加载_函 (炉_状态机结 *L, 炉_读器型 读器_圆, void *数据_变量,
                      const char *大块名_变量, const char *模块_变量) {
  入出流_结 z;
  int 状态码_变量;
  限制_月亮_锁_宏名(L);
  if (!大块名_变量) 大块名_变量 = "?";
  月亮流_初始的_函(L, &z, 读器_圆, 数据_变量);
  状态码_变量 = 月亮调度_受保护解析器_函(L, &z, 大块名_变量, 模块_变量);
  if (状态码_变量 == LUA_OK) {  /* no errors? */
    L闭包_结 *f = 对象_闭包L值_宏名(对象_s到v_宏名(L->顶部_变量.p - 1));  /* get new function */
    if (f->nupvalues >= 1) {  /* does it have an 上值_圆? */
      /* get global table from 注册表_变量 */
      const 标签值_结 *全局表_缩变量 = 应程接_获取全局表_宏名(L);
      /* set global table as 1st 上值_圆 of 'f' (may be 词法_月亮_环境_宏名) */
      对象_设置对象_宏名(L, f->上值们_短[0]->v.p, 全局表_缩变量);
      垃圾回收_月亮C_屏障_宏名(L, f->上值们_短[0], 全局表_缩变量);
    }
  }
  限制_月亮_解锁_宏名(L);
  return 状态码_变量;
}


配置_月亮_应程接_宏名 int 月亮_转储_函 (炉_状态机结 *L, 炉_写器结 写器_小写, void *数据_变量, int 剥离_变量) {
  int 状态码_变量;
  标签值_结 *o;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, 1);
  o = 对象_s到v_宏名(L->顶部_变量.p - 1);
  if (对象_是否L函数_宏名(o))
    状态码_变量 = 月亮实用工具_转储_函(L, 对象_获取原型_宏名(o), 写器_小写, 数据_变量, 剥离_变量);
  else
    状态码_变量 = 1;
  限制_月亮_解锁_宏名(L);
  return 状态码_变量;
}


配置_月亮_应程接_宏名 int 月亮_状态码_函 (炉_状态机结 *L) {
  return L->状态码_变量;
}


/*
** Garbage-collection function
*/
配置_月亮_应程接_宏名 int 月亮_垃圾回收_函 (炉_状态机结 *L, int 什么_变量, ...) {
  va_list argp;
  int 结果_短变量 = 0;
  全局_状态机结 *g = G(L);
  if (g->垃回步进_短缩 & 垃圾回收_GC停止GC_宏名)  /* internal stop? */
    return -1;  /* all 选项们_变量 are invalid when stopped */
  限制_月亮_锁_宏名(L);
  va_start(argp, 什么_变量);
  switch (什么_变量) {
    case 月头_月亮_垃圾回收停止_宏名: {
      g->垃回步进_短缩 = 垃圾回收_GC停止用户_宏名;  /* stopped by the user */
      break;
    }
    case 月头_月亮_垃圾回收重启_宏名: {
      月亮错误_设置债务_函(g, 0);
      g->垃回步进_短缩 = 0;  /* (垃圾回收_GC停止GC_宏名 must be already zero here) */
      break;
    }
    case 月头_月亮_垃圾回收收集_宏名: {
      月亮编译_完全垃圾回收_函(L, 0);
      break;
    }
    case 月头_月亮_垃圾回收计数_宏名: {
      /* GC values are expressed in Kbytes: #bytes/2^10 */
      结果_短变量 = 限制_类型转换_整型_宏名(状态机_获取全部字节_宏名(g) >> 10);
      break;
    }
    case 月头_月亮_垃圾回收计数B_宏名: {
      结果_短变量 = 限制_类型转换_整型_宏名(状态机_获取全部字节_宏名(g) & 0x3ff);
      break;
    }
    case 月头_月亮_垃圾回收步进_宏名: {
      int 数据_变量 = va_arg(argp, int);
      l_内存缩 负债_变量 = 1;  /* =1 到_变量 signal that it did an 实际上_变量 步进_变量 */
      路_字节型 旧栈指针_变量 = g->垃回步进_短缩;
      g->垃回步进_短缩 = 0;  /* allow GC 到_变量 run (垃圾回收_GC停止GC_宏名 must be zero here) */
      if (数据_变量 == 0) {
        月亮错误_设置债务_函(g, 0);  /* do a basic 步进_变量 */
        月亮编译_步进_函(L);
      }
      else {  /* add '数据_变量' 到_变量 总数_变量 负债_变量 */
        负债_变量 = 限制_类型转换_宏名(l_内存缩, 数据_变量) * 1024 + g->垃回债_缩;
        月亮错误_设置债务_函(g, 负债_变量);
        垃圾回收_月亮C_检查GC_宏名(L);
      }
      g->垃回步进_短缩 = 旧栈指针_变量;  /* restore 前一个_变量 状态机_变量 */
      if (负债_变量 > 0 && g->垃回状态机_缩小写 == 垃圾回收_GCS暂停_宏名)  /* 终_变量 of cycle? */
        结果_短变量 = 1;  /* signal it */
      break;
    }
    case 月头_月亮_垃圾回收设置暂停_宏名: {
      int 数据_变量 = va_arg(argp, int);
      结果_短变量 = 垃圾回收_获取gc形参_宏名(g->垃回暂停_缩圆);
      垃圾回收_设置gc形参_宏名(g->垃回暂停_缩圆, 数据_变量);
      break;
    }
    case 月头_月亮_垃圾回收设置步进乘法_宏名: {
      int 数据_变量 = va_arg(argp, int);
      结果_短变量 = 垃圾回收_获取gc形参_宏名(g->垃回步进乘法_短缩);
      垃圾回收_设置gc形参_宏名(g->垃回步进乘法_短缩, 数据_变量);
      break;
    }
    case 月头_月亮_垃圾回收是否正在跑_宏名: {
      结果_短变量 = 垃圾回收_gc正在跑_宏名(g);
      break;
    }
    case 月头_月亮_垃圾回收生成_宏名: {
      int 主乘数_变量 = va_arg(argp, int);
      int 副乘数_变量 = va_arg(argp, int);
      结果_短变量 = 垃圾回收_是否减少GC模式生成_宏名(g) ? 月头_月亮_垃圾回收生成_宏名 : 月头_月亮_垃圾回收递增_宏名;
      if (主乘数_变量 != 0)
        g->生成副乘法_缩 = 主乘数_变量;
      if (副乘数_变量 != 0)
        垃圾回收_设置gc形参_宏名(g->生成主乘法_缩, 副乘数_变量);
      月亮编译_改变模式_函(L, 状态机_K垃圾回收_生成_宏名);
      break;
    }
    case 月头_月亮_垃圾回收递增_宏名: {
      int 暂停_变量 = va_arg(argp, int);
      int 步进乘数_变量 = va_arg(argp, int);
      int 步进大小_变量 = va_arg(argp, int);
      结果_短变量 = 垃圾回收_是否减少GC模式生成_宏名(g) ? 月头_月亮_垃圾回收生成_宏名 : 月头_月亮_垃圾回收递增_宏名;
      if (暂停_变量 != 0)
        垃圾回收_设置gc形参_宏名(g->垃回暂停_缩圆, 暂停_变量);
      if (步进乘数_变量 != 0)
        垃圾回收_设置gc形参_宏名(g->垃回步进乘法_短缩, 步进乘数_变量);
      if (步进大小_变量 != 0)
        g->垃回步进大小_缩圆 = 步进大小_变量;
      月亮编译_改变模式_函(L, 状态机_K垃圾回收_递增_宏名);
      break;
    }
    default: 结果_短变量 = -1;  /* invalid 选项_变量 */
  }
  va_end(argp);
  限制_月亮_解锁_宏名(L);
  return 结果_短变量;
}



/*
** miscellaneous functions
*/


配置_月亮_应程接_宏名 int 月亮_错误_函 (炉_状态机结 *L) {
  标签值_结 *错误对象_变量;
  限制_月亮_锁_宏名(L);
  错误对象_变量 = 对象_s到v_宏名(L->顶部_变量.p - 1);
  应程接_API检查n元素们_宏名(L, 1);
  /* 错误_小变量 object is the memory 错误_小变量 message? */
  if (对象_tt是否短型字符串_宏名(错误对象_变量) && 字符串_相等短型串_宏名(对象_ts值_宏名(错误对象_变量), G(L)->内存错误消息_短))
    内存_月亮M_错误_宏名(L);  /* raise a memory 错误_小变量 */
  else
    月亮全局_错误消息_函(L);  /* raise a regular 错误_小变量 */
  /* 代码_变量 unreachable; will unlock when control actually leaves the kernel */
  return 0;  /* 到_变量 avoid warnings */
}


配置_月亮_应程接_宏名 int 月亮_下一个_函 (炉_状态机结 *L, int 索引_缩变量) {
  表_结 *t;
  int 更多_变量;
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, 1);
  t = 月应程接_获取表_函(L, 索引_缩变量);
  更多_变量 = 月亮哈希表_下一个_函(L, t, L->顶部_变量.p - 1);
  if (更多_变量) {
    应程接_API_递增_顶部_宏名(L);
  }
  else  /* no 更多_变量 elements */
    L->顶部_变量.p -= 1;  /* remove 键_小变量 */
  限制_月亮_解锁_宏名(L);
  return 更多_变量;
}


配置_月亮_应程接_宏名 void 月亮_到关闭_函 (炉_状态机结 *L, int 索引_缩变量) {
  int 结果数目_变量;
  栈身份_型 o;
  限制_月亮_锁_宏名(L);
  o = 月应程接_索引到栈_函(L, 索引_缩变量);
  结果数目_变量 = L->调信_缩变量->结果数目_变量;
  限制_应程接_检查_宏名(L, L->待关闭列表_结.p < o, "given index below or equal a 已记号_变量 one");
  月亮函数_新待关闭上值_函(L, o);  /* create new 到_变量-be-closed 上值_圆 */
  if (!应程接_必须关闭C函数_宏名(结果数目_变量))  /* function not 已记号_变量 yet? */
    L->调信_缩变量->结果数目_变量 = 应程接_编码N结果们_宏名(结果数目_变量);  /* 记号_变量 it */
  限制_月亮_断言_宏名(应程接_必须关闭C函数_宏名(L->调信_缩变量->结果数目_变量));
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮_拼接_函 (炉_状态机结 *L, int n) {
  限制_月亮_锁_宏名(L);
  应程接_API检查n元素们_宏名(L, n);
  if (n > 0)
    月亮虚拟机_拼接_函(L, n);
  else {  /* nothing 到_变量 concatenate */
    对象_设置ts值到s_宏名(L, L->顶部_变量.p, 月亮字符串_新长串_函(L, "", 0));  /* push 空容器_变量 string */
    应程接_API_递增_顶部_宏名(L);
  }
  垃圾回收_月亮C_检查GC_宏名(L);
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 void 月亮_长度_函 (炉_状态机结 *L, int 索引_缩变量) {
  标签值_结 *t;
  限制_月亮_锁_宏名(L);
  t = 月应程接_索引到值_函(L, 索引_缩变量);
  月亮虚拟机_对象长度_函(L, L->顶部_变量.p, t);
  应程接_API_递增_顶部_宏名(L);
  限制_月亮_解锁_宏名(L);
}


配置_月亮_应程接_宏名 炉_分配半 月亮_获取分配函数_函 (炉_状态机结 *L, void **用数_缩变量) {
  炉_分配半 f;
  限制_月亮_锁_宏名(L);
  if (用数_缩变量) *用数_缩变量 = G(L)->用数_缩变量;
  f = G(L)->函重新分配_缩;
  限制_月亮_解锁_宏名(L);
  return f;
}


配置_月亮_应程接_宏名 void 月亮_设置分配函数_函 (炉_状态机结 *L, 炉_分配半 f, void *用数_缩变量) {
  限制_月亮_锁_宏名(L);
  G(L)->用数_缩变量 = 用数_缩变量;
  G(L)->函重新分配_缩 = f;
  限制_月亮_解锁_宏名(L);
}


void 月亮_设置警告函数_函 (炉_状态机结 *L, 炉_警告函数型 f, void *用数_缩变量) {
  限制_月亮_锁_宏名(L);
  G(L)->用h数j_警告缩 = 用数_缩变量;
  G(L)->警函_短缩 = f;
  限制_月亮_解锁_宏名(L);
}


void 月亮_警告_函 (炉_状态机结 *L, const char *消息_缩变量, int tocont) {
  限制_月亮_锁_宏名(L);
  月亮错误_警告_函(L, 消息_缩变量, tocont);
  限制_月亮_解锁_宏名(L);
}



配置_月亮_应程接_宏名 void *月亮创建新的用户数据uv_函 (炉_状态机结 *L, size_t 大小_变量, int 用户值数_缩) {
  用户数据_结 *u;
  限制_月亮_锁_宏名(L);
  限制_应程接_检查_宏名(L, 0 <= 用户值数_缩 && 用户值数_缩 < USHRT_MAX, "invalid 值_圆");
  u = 月亮字符串_新用户数据_函(L, 大小_变量, 用户值数_缩);
  对象_设置u值_宏名(L, 对象_s到v_宏名(L->顶部_变量.p), u);
  应程接_API_递增_顶部_宏名(L);
  垃圾回收_月亮C_检查GC_宏名(L);
  限制_月亮_解锁_宏名(L);
  return 对象_获取用户数据内存_宏名(u);
}



static const char *月应程接_辅助_上值_函 (标签值_结 *文信_缩变量, int n, 标签值_结 **值_变量,
                                垃回对象_结 **所有者_变量) {
  switch (对象_t类型标签_宏名(文信_缩变量)) {
    case 对象_月亮_VC闭包L_宏名: {  /* C closure */
      C闭包_结 *f = 对象_闭包C值_宏名(文信_缩变量);
      if (!(限制_类型转换_无符整型_宏名(n) - 1u < 限制_类型转换_无符整型_宏名(f->nupvalues)))
        return NULL;  /* 'n' not in [1, f->nupvalues] */
      *值_变量 = &f->上值_圆[n-1];
      if (所有者_变量) *所有者_变量 = 状态机_对象到垃圾回收对象_宏名(f);
      return "";
    }
    case 对象_月亮_VL闭包L_宏名: {  /* Lua closure */
      L闭包_结 *f = 对象_闭包L值_宏名(文信_缩变量);
      标签字符串_结 *名称_变量;
      原型_结 *p = f->p;
      if (!(限制_类型转换_无符整型_宏名(n) - 1u  < 限制_类型转换_无符整型_宏名(p->上值大小_小写)))
        return NULL;  /* 'n' not in [1, p->上值大小_小写] */
      *值_变量 = f->上值们_短[n-1]->v.p;
      if (所有者_变量) *所有者_变量 = 状态机_对象到垃圾回收对象_宏名(f->上值们_短[n - 1]);
      名称_变量 = p->上值们_小写[n-1].名称_变量;
      return (名称_变量 == NULL) ? "(no 名称_变量)" : 对象_获取串_宏名(名称_变量);
    }
    default: return NULL;  /* not a closure */
  }
}


配置_月亮_应程接_宏名 const char *月亮_获取上值_函 (炉_状态机结 *L, int funcindex, int n) {
  const char *名称_变量;
  标签值_结 *值_变量 = NULL;  /* 到_变量 avoid warnings */
  限制_月亮_锁_宏名(L);
  名称_变量 = 月应程接_辅助_上值_函(月应程接_索引到值_函(L, funcindex), n, &值_变量, NULL);
  if (名称_变量) {
    对象_设置对象到s_宏名(L, L->顶部_变量.p, 值_变量);
    应程接_API_递增_顶部_宏名(L);
  }
  限制_月亮_解锁_宏名(L);
  return 名称_变量;
}


配置_月亮_应程接_宏名 const char *月亮_设置上值_函 (炉_状态机结 *L, int funcindex, int n) {
  const char *名称_变量;
  标签值_结 *值_变量 = NULL;  /* 到_变量 avoid warnings */
  垃回对象_结 *所有者_变量 = NULL;  /* 到_变量 avoid warnings */
  标签值_结 *文信_缩变量;
  限制_月亮_锁_宏名(L);
  文信_缩变量 = 月应程接_索引到值_函(L, funcindex);
  应程接_API检查n元素们_宏名(L, 1);
  名称_变量 = 月应程接_辅助_上值_函(文信_缩变量, n, &值_变量, &所有者_变量);
  if (名称_变量) {
    L->顶部_变量.p--;
    对象_设置对象_宏名(L, 值_变量, 对象_s到v_宏名(L->顶部_变量.p));
    垃圾回收_月亮C_屏障_宏名(L, 所有者_变量, 值_变量);
  }
  限制_月亮_解锁_宏名(L);
  return 名称_变量;
}


static 上值_结 **月应程接_获取上值引用_函 (炉_状态机结 *L, int fidx, int n, L闭包_结 **pf) {
  static const 上值_结 *const 空针上_变量 = NULL;
  L闭包_结 *f;
  标签值_结 *文信_缩变量 = 月应程接_索引到值_函(L, fidx);
  限制_应程接_检查_宏名(L, 对象_tt是否L闭包_宏名(文信_缩变量), "Lua function expected");
  f = 对象_闭包L值_宏名(文信_缩变量);
  if (pf) *pf = f;
  if (1 <= n && n <= f->p->上值大小_小写)
    return &f->上值们_短[n - 1];  /* get its 上值_圆 pointer */
  else
    return (上值_结**)&空针上_变量;
}


配置_月亮_应程接_宏名 void *月亮_上值ID_函 (炉_状态机结 *L, int fidx, int n) {
  标签值_结 *文信_缩变量 = 月应程接_索引到值_函(L, fidx);
  switch (对象_t类型标签_宏名(文信_缩变量)) {
    case 对象_月亮_VL闭包L_宏名: {  /* lua closure */
      return *月应程接_获取上值引用_函(L, fidx, n, NULL);
    }
    case 对象_月亮_VC闭包L_宏名: {  /* C closure */
      C闭包_结 *f = 对象_闭包C值_宏名(文信_缩变量);
      if (1 <= n && n <= f->nupvalues)
        return &f->上值_圆[n - 1];
      /* else */
    }  /* FALLTHROUGH */
    case 对象_月亮_VL闭包函_宏名:
      return NULL;  /* light C functions have no 上值们_小写 */
    default: {
      限制_应程接_检查_宏名(L, 0, "function expected");
      return NULL;
    }
  }
}


配置_月亮_应程接_宏名 void 月亮_上值加入_函 (炉_状态机结 *L, int fidx1, int 数1_缩变量,
                                            int fidx2, int 数2_缩变量) {
  L闭包_结 *函1_短变量;
  上值_结 **上1_变量 = 月应程接_获取上值引用_函(L, fidx1, 数1_缩变量, &函1_短变量);
  上值_结 **上2_变量 = 月应程接_获取上值引用_函(L, fidx2, 数2_缩变量, NULL);
  限制_应程接_检查_宏名(L, *上1_变量 != NULL && *上2_变量 != NULL, "invalid 上值_圆 index");
  *上1_变量 = *上2_变量;
  垃圾回收_月亮C_对象屏障_宏名(L, 函1_短变量, *上1_变量);
}


