/*
** $Id: lstate.c $
** Global State
** See Copyright Notice in lua.h
*/

#define lstate_c
#define 应程接_月亮_内核_宏名

#include "lprefix.h"


#include <stddef.h>
#include <string.h>

#include "lua.h"

#include "lapi.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lgc.h"
#include "llex.h"
#include "lmem.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"



/*
** 线程_变量 状态机_变量 + 额外_变量 空间_圆
*/
typedef struct LX {
  路_字节型 额外_[炉_额外空间];
  炉_状态机结 l;
} LX;


/*
** Main 线程_变量 combines a 线程_变量 状态机_变量 and the global 状态机_变量
*/
typedef struct LG {
  LX l;
  全局_状态机结 g;
} LG;



#define 状态机_来自状态机_宏名(L)	(限制_类型转换_宏名(LX *, 限制_类型转换_宏名(路_字节型 *, (L)) - offsetof(LX, l)))


/*
** A macro 到_变量 create a "random" 种籽_圆 when a 状态机_变量 is created;
** the 种籽_圆 is used 到_变量 randomize string hashes.
*/
#if !defined(月状态机_月亮i_制作种子_函)

#include <time.h>

/*
** Compute an initial 种籽_圆 with some 层级_变量 of randomness.
** Rely on Address Space Layout Randomization (if present) and
** 当前_圆 time.
*/
#define 状态机_添加缓冲_宏名(b,p,e) \
  { size_t t = 限制_类型转换_大小t_宏名(e); \
    memcpy(b + p, &t, sizeof(t)); p += sizeof(t); }

static unsigned int 月状态机_月亮i_制作种子_函 (炉_状态机结 *L) {
  char 缓冲_变量[3 * sizeof(size_t)];
  unsigned int h = 限制_类型转换_无符整型_宏名(time(NULL));
  int p = 0;
  状态机_添加缓冲_宏名(缓冲_变量, p, L);  /* heap variable */
  状态机_添加缓冲_宏名(缓冲_变量, p, &h);  /* local variable */
  状态机_添加缓冲_宏名(缓冲_变量, p, &月亮_新状态机_函);  /* public function */
  限制_月亮_断言_宏名(p == sizeof(缓冲_变量));
  return 月亮字符串_哈希_函(缓冲_变量, p, h);
}

#endif


/*
** set 垃回债_缩 到_变量 a new 值_圆 keeping the 值_圆 (总共字节们_圆 + 垃回债_缩)
** invariant (and avoiding underflows in '总共字节们_圆')
*/
void 月亮错误_设置债务_函 (全局_状态机结 *g, l_内存缩 负债_变量) {
  l_内存缩 临时块_变量 = 状态机_获取全部字节_宏名(g);
  限制_月亮_断言_宏名(临时块_变量 > 0);
  if (负债_变量 < 临时块_变量 - 限制_最大_L内存_宏名)
    负债_变量 = 临时块_变量 - 限制_最大_L内存_宏名;  /* will make '总共字节们_圆 == 限制_最大_L内存_宏名' */
  g->总共字节们_圆 = 临时块_变量 - 负债_变量;
  g->垃回债_缩 = 负债_变量;
}


配置_月亮_应程接_宏名 int 月亮_设置C栈限制_函 (炉_状态机结 *L, unsigned int 限制_变量) {
  限制_未使用_宏名(L); 限制_未使用_宏名(限制_变量);
  return 限制_月亮I_最大C调用们_宏名;  /* warning?? */
}


调用信息_结 *月亮错误_扩展调用信息_函 (炉_状态机结 *L) {
  调用信息_结 *调信_缩变量;
  限制_月亮_断言_宏名(L->调信_缩变量->下一个_变量 == NULL);
  调信_缩变量 = 内存_月亮M_新_宏名(L, 调用信息_结);
  限制_月亮_断言_宏名(L->调信_缩变量->下一个_变量 == NULL);
  L->调信_缩变量->下一个_变量 = 调信_缩变量;
  调信_缩变量->前一个_变量 = L->调信_缩变量;
  调信_缩变量->下一个_变量 = NULL;
  调信_缩变量->u.l.陷阱_变量 = 0;
  L->调信数_全缩++;
  return 调信_缩变量;
}


/*
** free all 调用信息_结 structures not in use by a 线程_变量
*/
void 月亮错误_释放调用信息_函 (炉_状态机结 *L) {
  调用信息_结 *调信_缩变量 = L->调信_缩变量;
  调用信息_结 *下一个_变量 = 调信_缩变量->下一个_变量;
  调信_缩变量->下一个_变量 = NULL;
  while ((调信_缩变量 = 下一个_变量) != NULL) {
    下一个_变量 = 调信_缩变量->下一个_变量;
    内存_月亮M_释放_宏名(L, 调信_缩变量);
    L->调信数_全缩--;
  }
}


/*
** free half of the 调用信息_结 structures not in use by a 线程_变量,
** keeping the 首先_变量 one.
*/
void 月亮错误_收缩调用信息_函 (炉_状态机结 *L) {
  调用信息_结 *调信_缩变量 = L->调信_缩变量->下一个_变量;  /* 首先_变量 free 调用信息_结 */
  调用信息_结 *下一个_变量;
  if (调信_缩变量 == NULL)
    return;  /* no 额外_变量 elements */
  while ((下一个_变量 = 调信_缩变量->下一个_变量) != NULL) {  /* two 额外_变量 elements? */
    调用信息_结 *下个2_变量 = 下一个_变量->下一个_变量;  /* 下一个_变量's 下一个_变量 */
    调信_缩变量->下一个_变量 = 下个2_变量;  /* remove 下一个_变量 from the 列表_变量 */
    L->调信数_全缩--;
    内存_月亮M_释放_宏名(L, 下一个_变量);  /* free 下一个_变量 */
    if (下个2_变量 == NULL)
      break;  /* no 更多_变量 elements */
    else {
      下个2_变量->前一个_变量 = 调信_缩变量;
      调信_缩变量 = 下个2_变量;  /* continue */
    }
  }
}


/*
** Called when '状态机_获取C调用_宏名(L)' larger or equal 到_变量 限制_月亮I_最大C调用们_宏名.
** If equal, raises an overflow 错误_小变量. If 值_圆 is larger than
** 限制_月亮I_最大C调用们_宏名 (which means it is handling an overflow) but
** not much larger, does not 月解释器_报告_函 an 错误_小变量 (到_变量 allow overflow
** handling 到_变量 工作_变量).
*/
void 月亮错误_检查C栈_函 (炉_状态机结 *L) {
  if (状态机_获取C调用_宏名(L) == 限制_月亮I_最大C调用们_宏名)
    月亮全局_跑错误_函(L, "C 栈_圆小 overflow");
  else if (状态机_获取C调用_宏名(L) >= (限制_月亮I_最大C调用们_宏名 / 10 * 11))
    月亮调度_抛出_函(L, 月头_月亮_错误中的错误_宏名);  /* 错误_小变量 while handling 栈_圆小 错误_小变量 */
}


配置_月亮I_函_宏名 void 月亮错误_递增C栈_函 (炉_状态机结 *L) {
  L->C调用们数_缩圆++;
  if (配置_l_可能性低_宏名(状态机_获取C调用_宏名(L) >= 限制_月亮I_最大C调用们_宏名))
    月亮错误_检查C栈_函(L);
}


static void 月状态机_栈_初始的_函 (炉_状态机结 *L1, 炉_状态机结 *L) {
  int i; 调用信息_结 *调信_缩变量;
  /* initialize 栈_圆小 数组_圆 */
  L1->栈_圆小.p = 内存_月亮M_新向量_宏名(L, 状态机_基本_栈_大小_宏名 + 状态机_额外_栈_宏名, 栈值_联);
  L1->待关闭列表_结.p = L1->栈_圆小.p;
  for (i = 0; i < 状态机_基本_栈_大小_宏名 + 状态机_额外_栈_宏名; i++)
    对象_设置空值的值_宏名(对象_s到v_宏名(L1->栈_圆小.p + i));  /* erase new 栈_圆小 */
  L1->顶部_变量.p = L1->栈_圆小.p;
  L1->栈_最后圆.p = L1->栈_圆小.p + 状态机_基本_栈_大小_宏名;
  /* initialize 首先_变量 调信_缩变量 */
  调信_缩变量 = &L1->基本_调信圆缩;
  调信_缩变量->下一个_变量 = 调信_缩变量->前一个_变量 = NULL;
  调信_缩变量->调用状态码_圆 = 状态机_调信状型_C_宏名;
  调信_缩变量->函_短变量.p = L1->顶部_变量.p;
  调信_缩变量->u.c.k = NULL;
  调信_缩变量->结果数目_变量 = 0;
  对象_设置空值的值_宏名(对象_s到v_宏名(L1->顶部_变量.p));  /* 'function' entry for this '调信_缩变量' */
  L1->顶部_变量.p++;
  调信_缩变量->顶部_变量.p = L1->顶部_变量.p + 月头_月亮_最小栈_宏名;
  L1->调信_缩变量 = 调信_缩变量;
}


static void 月状态机_释放栈_函 (炉_状态机结 *L) {
  if (L->栈_圆小.p == NULL)
    return;  /* 栈_圆小 not completely built yet */
  L->调信_缩变量 = &L->基本_调信圆缩;  /* free the entire '调信_缩变量' 列表_变量 */
  月亮错误_释放调用信息_函(L);
  限制_月亮_断言_宏名(L->调信数_全缩 == 0);
  内存_月亮M_释放数组_宏名(L, L->栈_圆小.p, 状态机_栈大小_宏名(L) + 状态机_额外_栈_宏名);  /* free 栈_圆小 */
}


/*
** Create 注册表_变量 table and its predefined values
*/
static void 月状态机_初始的_注册表_函 (炉_状态机结 *L, 全局_状态机结 *g) {
  /* create 注册表_变量 */
  表_结 *注册表_变量 = 月亮哈希表_新_函(L);
  对象_设置哈希值_宏名(L, &g->l_注册表半, 注册表_变量);
  月亮哈希表_调整大小_函(L, 注册表_变量, 月头_月亮_注册索引_最后的_宏名, 0);
  /* 注册表_变量[月头_月亮_注册索引_主线程_宏名] = L */
  对象_设置线程值_宏名(L, &注册表_变量->数组_圆[月头_月亮_注册索引_主线程_宏名 - 1], L);
  /* 注册表_变量[月头_月亮_注册索引_全局的_宏名] = new table (table of globals) */
  对象_设置哈希值_宏名(L, &注册表_变量->数组_圆[月头_月亮_注册索引_全局的_宏名 - 1], 月亮哈希表_新_函(L));
}


/*
** 打开_圆 parts of the 状态机_变量 that may cause memory-allocation errors.
*/
static void 月状态机_f_月亮打开_函 (炉_状态机结 *L, void *用数_缩变量) {
  全局_状态机结 *g = G(L);
  限制_未使用_宏名(用数_缩变量);
  月状态机_栈_初始的_函(L, L);  /* 初始的_变量 栈_圆小 */
  月状态机_初始的_注册表_函(L, g);
  月亮字符串_初始的_函(L);
  月亮类型_初始化_函(L);
  月亮分析_初始的_函(L);
  g->垃回步进_短缩 = 0;  /* allow 垃回_小写缩 */
  对象_设置空值的值_宏名(&g->空值的值_圆);  /* now 状态机_变量 is complete */
  限制_月亮i_用户状态打开_宏名(L);
}


/*
** preinitialize a 线程_变量 with consistent values without allocating
** any memory (到_变量 avoid errors)
*/
static void 月状态机_预备初始的_线程_函 (炉_状态机结 *L, 全局_状态机结 *g) {
  G(L) = g;
  L->栈_圆小.p = NULL;
  L->调信_缩变量 = NULL;
  L->调信数_全缩 = 0;
  L->线程与上值_短缩 = L;  /* 线程_变量 has no 上值们_小写 */
  L->C调用们数_缩圆 = 0;
  L->错误跳_圆缩 = NULL;
  L->钩子_变量 = NULL;
  L->钩子掩码_圆 = 0;
  L->基本钩子计数_圆 = 0;
  L->允许钩子_圆 = 1;
  调试_重置钩子计数_宏名(L);
  L->打开上值_圆小 = NULL;
  L->状态码_变量 = LUA_OK;
  L->错函_短变量 = 0;
  L->旧程计_变量 = 0;
}


static void 月状态机_关闭_状态机_函 (炉_状态机结 *L) {
  全局_状态机结 *g = G(L);
  if (!状态机_完成状态_宏名(g))  /* closing a partially built 状态机_变量? */
    月亮编译_释放所有对象们_函(L);  /* just collect its objects */
  else {  /* closing a fully built 状态机_变量 */
    L->调信_缩变量 = &L->基本_调信圆缩;  /* unwind 调用信息_结 列表_变量 */
    月亮调度_关闭受保护_函(L, 1, LUA_OK);  /* 关闭_圆 all 上值们_小写 */
    月亮编译_释放所有对象们_函(L);  /* collect all objects */
    限制_月亮i_用户状态关闭_宏名(L);
  }
  内存_月亮M_释放数组_宏名(L, G(L)->串的表_缩.哈希_小写, G(L)->串的表_缩.大小_变量);
  月状态机_释放栈_函(L);
  限制_月亮_断言_宏名(状态机_获取全部字节_宏名(g) == sizeof(LG));
  (*g->函重新分配_缩)(g->用数_缩变量, 状态机_来自状态机_宏名(L), sizeof(LG), 0);  /* free main 月解析器_块_函 */
}


配置_月亮_应程接_宏名 炉_状态机结 *月亮_新线程_函 (炉_状态机结 *L) {
  全局_状态机结 *g = G(L);
  垃回对象_结 *o;
  炉_状态机结 *L1;
  限制_月亮_锁_宏名(L);
  垃圾回收_月亮C_检查GC_宏名(L);
  /* create new 线程_变量 */
  o = 月亮编译_新对象dt_函(L, 月头_月亮_T线程_宏名, sizeof(LX), offsetof(LX, l));
  L1 = 状态机_垃圾回收对象到th_宏名(o);
  /* 锚点_变量 it on L 栈_圆小 */
  对象_设置线程值到s_宏名(L, L->顶部_变量.p, L1);
  应程接_API_递增_顶部_宏名(L);
  月状态机_预备初始的_线程_函(L1, g);
  L1->钩子掩码_圆 = L->钩子掩码_圆;
  L1->基本钩子计数_圆 = L->基本钩子计数_圆;
  L1->钩子_变量 = L->钩子_变量;
  调试_重置钩子计数_宏名(L1);
  /* initialize L1 额外_变量 空间_圆 */
  memcpy(月头_月亮_获取额外空间_宏名(L1), 月头_月亮_获取额外空间_宏名(g->主线程_圆),
         炉_额外空间);
  限制_月亮i_用户状态线程_宏名(L, L1);
  月状态机_栈_初始的_函(L1, L);  /* 初始的_变量 栈_圆小 */
  限制_月亮_解锁_宏名(L);
  return L1;
}


void 月亮错误_释放线程_函 (炉_状态机结 *L, 炉_状态机结 *L1) {
  LX *l = 状态机_来自状态机_宏名(L1);
  月亮函数_关闭上值_函(L1, L1->栈_圆小.p);  /* 关闭_圆 all 上值们_小写 */
  限制_月亮_断言_宏名(L1->打开上值_圆小 == NULL);
  限制_月亮i_用户状态释放_宏名(L, L1);
  月状态机_释放栈_函(L1);
  内存_月亮M_释放_宏名(L, l);
}


int 月亮错误_重置线程_函 (炉_状态机结 *L, int 状态码_变量) {
  调用信息_结 *调信_缩变量 = L->调信_缩变量 = &L->基本_调信圆缩;  /* unwind 调用信息_结 列表_变量 */
  对象_设置空值的值_宏名(对象_s到v_宏名(L->栈_圆小.p));  /* 'function' entry for basic '调信_缩变量' */
  调信_缩变量->函_短变量.p = L->栈_圆小.p;
  调信_缩变量->调用状态码_圆 = 状态机_调信状型_C_宏名;
  if (状态码_变量 == 月头_月亮_让步_宏名)
    状态码_变量 = LUA_OK;
  L->状态码_变量 = LUA_OK;  /* so it can run __close metamethods */
  状态码_变量 = 月亮调度_关闭受保护_函(L, 1, 状态码_变量);
  if (状态码_变量 != LUA_OK)  /* errors? */
    月亮调度_设置错误对象_函(L, 状态码_变量, L->栈_圆小.p + 1);
  else
    L->顶部_变量.p = L->栈_圆小.p + 1;
  调信_缩变量->顶部_变量.p = L->顶部_变量.p + 月头_月亮_最小栈_宏名;
  月亮调度_重新分配栈_函(L, 限制_类型转换_整型_宏名(调信_缩变量->顶部_变量.p - L->栈_圆小.p), 0);
  return 状态码_变量;
}


配置_月亮_应程接_宏名 int 月亮_关闭线程_函 (炉_状态机结 *L, 炉_状态机结 *from) {
  int 状态码_变量;
  限制_月亮_锁_宏名(L);
  L->C调用们数_缩圆 = (from) ? 状态机_获取C调用_宏名(from) : 0;
  状态码_变量 = 月亮错误_重置线程_函(L, L->状态码_变量);
  限制_月亮_解锁_宏名(L);
  return 状态码_变量;
}


/*
** Deprecated! Use '月亮_关闭线程_函' instead.
*/
配置_月亮_应程接_宏名 int 月亮_重置线程_函 (炉_状态机结 *L) {
  return 月亮_关闭线程_函(L, NULL);
}


配置_月亮_应程接_宏名 炉_状态机结 *月亮_新状态机_函 (炉_分配半 f, void *用数_缩变量) {
  int i;
  炉_状态机结 *L;
  全局_状态机结 *g;
  LG *l = 限制_类型转换_宏名(LG *, (*f)(用数_缩变量, NULL, 月头_月亮_T线程_宏名, sizeof(LG)));
  if (l == NULL) return NULL;
  L = &l->l.l;
  g = &l->g;
  L->类标_缩变量 = 对象_月亮_V线程_宏名;
  g->当前白色_圆 = 垃圾回收_位掩码_宏名(垃圾回收_白色0位_宏名);
  L->已记号_变量 = 垃圾回收_月亮C_白色_宏名(g);
  月状态机_预备初始的_线程_函(L, g);
  g->全部垃回_圆缩 = 状态机_对象到垃圾回收对象_宏名(L);  /* by now, only object is the main 线程_变量 */
  L->下一个_变量 = NULL;
  状态机_递增n不让步_宏名(L);  /* main 线程_变量 is always non 状态机_可让步_宏名 */
  g->函重新分配_缩 = f;
  g->用数_缩变量 = 用数_缩变量;
  g->警函_短缩 = NULL;
  g->用h数j_警告缩 = NULL;
  g->主线程_圆 = L;
  g->种籽_圆 = 月状态机_月亮i_制作种子_函(L);
  g->垃回步进_短缩 = 垃圾回收_GC停止GC_宏名;  /* no GC while building 状态机_变量 */
  g->串的表_缩.大小_变量 = g->串的表_缩.使用数_缩 = 0;
  g->串的表_缩.哈希_小写 = NULL;
  对象_设置空值的值_宏名(&g->l_注册表半);
  g->恐慌_圆 = NULL;
  g->垃回状态机_缩小写 = 垃圾回收_GCS暂停_宏名;
  g->垃回种类_缩小写 = 状态机_K垃圾回收_递增_宏名;
  g->垃回紧急停_缩 = 0;
  g->垃回紧急_缩圆 = 0;
  g->最终对象_缩 = g->待fnz_缩半 = g->固定垃回_圆缩 = NULL;
  g->首先旧1_圆 = g->生存_圆 = g->旧的1_小写 = g->真的旧_圆 = NULL;
  g->最终对象生存_短小写 = g->最终对象旧1_缩 = g->最终对象真的旧_缩 = NULL;
  g->扫除垃回_圆缩 = NULL;
  g->灰的色_圆 = g->再次灰色_变量 = NULL;
  g->弱的_圆 = g->短命的_圆 = g->全部弱_圆 = NULL;
  g->线程与上值_短缩 = NULL;
  g->总共字节们_圆 = sizeof(LG);
  g->垃回债_缩 = 0;
  g->最后原子_变量 = 0;
  对象_设置整数值_宏名(&g->空值的值_圆, 0);  /* 到_变量 signal that 状态机_变量 is not yet built */
  垃圾回收_设置gc形参_宏名(g->垃回暂停_缩圆, 垃圾回收_月亮I_GC暂停_宏名);
  垃圾回收_设置gc形参_宏名(g->垃回步进乘法_短缩, 垃圾回收_月亮I_GC乘数_宏名);
  g->垃回步进大小_缩圆 = 垃圾回收_月亮I_GC步大小_宏名;
  垃圾回收_设置gc形参_宏名(g->生成主乘法_缩, 垃圾回收_月亮I_生成主要乘数_宏名);
  g->生成副乘法_缩 = 垃圾回收_月亮I_生成次要乘数_宏名;
  for (i=0; i < 月头_月亮_标签数目_宏名; i++) g->元表_缩变量[i] = NULL;
  if (月亮调度_原始跑受保护_函(L, 月状态机_f_月亮打开_函, NULL) != LUA_OK) {
    /* memory allocation 错误_小变量: free partial 状态机_变量 */
    月状态机_关闭_状态机_函(L);
    L = NULL;
  }
  return L;
}


配置_月亮_应程接_宏名 void 月亮_关闭_函 (炉_状态机结 *L) {
  限制_月亮_锁_宏名(L);
  L = G(L)->主线程_圆;  /* only the main 线程_变量 can be closed */
  月状态机_关闭_状态机_函(L);
}


void 月亮错误_警告_函 (炉_状态机结 *L, const char *消息_缩变量, int tocont) {
  炉_警告函数型 工作函_变量 = G(L)->警函_短缩;
  if (工作函_变量 != NULL)
    工作函_变量(G(L)->用h数j_警告缩, 消息_缩变量, tocont);
}


/*
** Generate a warning from an 错误_小变量 message
*/
void 月亮错误_警告错误_函 (炉_状态机结 *L, const char *哪儿_变量) {
  标签值_结 *错误对象_变量 = 对象_s到v_宏名(L->顶部_变量.p - 1);  /* 错误_小变量 object */
  const char *消息_缩变量 = (对象_tt是否字符串_宏名(错误对象_变量))
                  ? 对象_s值_宏名(错误对象_变量)
                  : "错误_小变量 object is not a string";
  /* produce warning "错误_小变量 in %s (%s)" (哪儿_变量, 消息_缩变量) */
  月亮错误_警告_函(L, "错误_小变量 in ", 1);
  月亮错误_警告_函(L, 哪儿_变量, 1);
  月亮错误_警告_函(L, " (", 1);
  月亮错误_警告_函(L, 消息_缩变量, 1);
  月亮错误_警告_函(L, ")", 0);
}

