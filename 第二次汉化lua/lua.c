/*
** $Id: lua.c $
** Lua stand-alone interpreter
** See Copyright Notice in lua.h
*/

#define lua_c

#include "lprefix.h"


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <signal.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


#if !defined(解释器_月亮_程序名_宏名)
#define 解释器_月亮_程序名_宏名		"lua"
#endif

#if !defined(解释器_月亮_初始_变量_宏名)
#define 解释器_月亮_初始_变量_宏名		"LUA_INIT"
#endif

#define 解释器_月亮_初始变量版本_宏名	解释器_月亮_初始_变量_宏名 库_月亮_版本后缀_宏名


static 炉_状态机结 *全局L_变量 = NULL;

static const char *程序名_变量 = 解释器_月亮_程序名_宏名;


#if defined(配置_月亮_用_POSIX_宏名)   /* { */

/*
** Use 'sigaction' when available.
*/
static void 解释器_设置信号_宏名 (int 信号_短变量, void (*handler)(int)) {
  struct sigaction sa;
  sa.sa_handler = handler;
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);  /* do not 掩码_变量 any signal */
  sigaction(信号_短变量, &sa, NULL);
}

#else           /* }{ */

#define 解释器_设置信号_宏名            signal

#endif                               /* } */


/*
** Hook set by signal function 到_变量 stop the interpreter.
*/
static void 月解释器_l停止_函 (炉_状态机结 *L, 炉_调试结 *活记_缩变量) {
  (void)活记_缩变量;  /* unused 实参_短变量. */
  月亮_设置钩子_函(L, NULL, 0, 0);  /* reset 钩子_变量 */
  月亮状态_错误_函(L, "interrupted!");
}


/*
** Function 到_变量 be called at a C signal. Because a C signal 月编译器_不能_函
** just 改变_变量 a Lua 状态机_变量 (as there is no proper synchronization),
** this function only sets a 钩子_变量 that, when called, will stop the
** interpreter.
*/
static void 月解释器_l活动_函 (int i) {
  int flag = 月头_月亮_掩码调用_宏名 | 月头_月亮_掩码返回_宏名 | 月头_月亮_掩码行_宏名 | 月头_月亮_掩码计数_宏名;
  解释器_设置信号_宏名(i, SIG_DFL); /* if another SIGINT happens, terminate process */
  月亮_设置钩子_函(全局L_变量, 月解释器_l停止_函, flag, 1);
}


static void 月解释器_打印_用法_函 (const char *badoption) {
  辅助库_月亮_写字符串错误_宏名("%s: ", 程序名_变量);
  if (badoption[1] == 'e' || badoption[1] == 'l')
    辅助库_月亮_写字符串错误_宏名("'%s' needs argument\n", badoption);
  else
    辅助库_月亮_写字符串错误_宏名("unrecognized 选项_变量 '%s'\n", badoption);
  辅助库_月亮_写字符串错误_宏名(
  "月编译器_用法_函: %s [选项们_变量] [脚本_变量 [实参们_短变量]]\n"
  "Available 选项们_变量 are:\n"
  "  -e 状态_短变量   execute string '状态_短变量'\n"
  "  -i        enter interactive 模块_变量 after executing '脚本_变量'\n"
  "  -l mod    require library 'mod' into global 'mod'\n"
  "  -l g=mod  require library 'mod' into global 'g'\n"
  "  -v        show 版本_变量 information\n"
  "  -E        ignore environment variables\n"
  "  -W        turn warnings on\n"
  "  --        stop handling 选项们_变量\n"
  "  -         stop handling 选项们_变量 and execute stdin\n"
  ,
  程序名_变量);
}


/*
** Prints an 错误_小变量 message, adding the program 名称_变量 in front of it
** (if present)
*/
static void 月解释器_l_消息_函 (const char *pname, const char *消息_缩变量) {
  if (pname) 辅助库_月亮_写字符串错误_宏名("%s: ", pname);
  辅助库_月亮_写字符串错误_宏名("%s\n", 消息_缩变量);
}


/*
** Check whether '状态码_变量' is not OK and, if so, prints the 错误_小变量
** message on the 顶部_变量 of the 栈_圆小. It assumes that the 错误_小变量 object
** is a string, as it was either generated by Lua or by '月解释器_消息手握_函'.
*/
static int 月解释器_报告_函 (炉_状态机结 *L, int 状态码_变量) {
  if (状态码_变量 != LUA_OK) {
    const char *消息_缩变量 = 月头_月亮_到字符串_宏名(L, -1);
    月解释器_l_消息_函(程序名_变量, 消息_缩变量);
    月头_月亮_弹出_宏名(L, 1);  /* remove message */
  }
  return 状态码_变量;
}


/*
** Message handler used 到_变量 run all chunks
*/
static int 月解释器_消息手握_函 (炉_状态机结 *L) {
  const char *消息_缩变量 = 月头_月亮_到字符串_宏名(L, 1);
  if (消息_缩变量 == NULL) {  /* is 错误_小变量 object not a string? */
    if (月亮状态_调用元_函(L, 1, "__tostring") &&  /* does it have a metamethod */
        月亮_类型_函(L, -1) == 月头_月亮_T字符串_宏名)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      消息_缩变量 = 月亮推入格式化字符串_函(L, "(错误_小变量 object is a %s 值_圆)",
                               辅助库_月亮l_类型名称_宏名(L, 1));
  }
  月亮状态_跟踪回溯_函(L, L, 消息_缩变量, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}


/*
** Interface 到_变量 '月头_月亮_保护调用_宏名', which sets appropriate message function
** and C-signal handler. Used 到_变量 run all chunks.
*/
static int 月解释器_做调用_函 (炉_状态机结 *L, int 实参数_变量, int 结果数目_变量) {
  int 状态码_变量;
  int 基本_变量 = 月亮_获取顶_函(L) - 实参数_变量;  /* function index */
  月头_月亮_推C函数_宏名(L, 月解释器_消息手握_函);  /* push message handler */
  月头_月亮_插入_宏名(L, 基本_变量);  /* put it under function and 实参们_短变量 */
  全局L_变量 = L;  /* 到_变量 be available 到_变量 '月解释器_l活动_函' */
  解释器_设置信号_宏名(SIGINT, 月解释器_l活动_函);  /* set C-signal handler */
  状态码_变量 = 月头_月亮_保护调用_宏名(L, 实参数_变量, 结果数目_变量, 基本_变量);
  解释器_设置信号_宏名(SIGINT, SIG_DFL); /* reset C-signal handler */
  月头_月亮_移除_宏名(L, 基本_变量);  /* remove message handler from the 栈_圆小 */
  return 状态码_变量;
}


static void 月解释器_打印_版本_函 (void) {
  辅助库_月亮_写字符串_宏名(月头_月亮_版权_宏名, strlen(月头_月亮_版权_宏名));
  辅助库_月亮_写行_宏名();
}


/*
** Create the '实参_短变量' table, which stores all arguments from the
** command 行_变量 ('实参值_变量'). It should be aligned so that, at index 0,
** it has '实参值_变量[脚本_变量]', which is the 脚本_变量 名称_变量. The arguments
** 到_变量 the 脚本_变量 (everything after '脚本_变量') go 到_变量 positive indices;
** other arguments (before the 脚本_变量 名称_变量) go 到_变量 negative indices.
** If there is no 脚本_变量 名称_变量, assume interpreter's 名称_变量 as 基本_变量.
** (If there is no interpreter's 名称_变量 either, '脚本_变量' is -1, so
** table sizes are zero.)
*/
static void 月解释器_创建实参表_函 (炉_状态机结 *L, char **实参值_变量, int 实参计数_变量, int 脚本_变量) {
  int i, 实参数_变量;
  实参数_变量 = 实参计数_变量 - (脚本_变量 + 1);  /* number of positive indices */
  月亮创建表_函(L, 实参数_变量, 脚本_变量 + 1);
  for (i = 0; i < 实参计数_变量; i++) {
    月亮推入字符串_函(L, 实参值_变量[i]);
    月亮_设置原始索引_函(L, -2, i - 脚本_变量);
  }
  月亮设置全局变量_函(L, "实参_短变量");
}


static int 月解释器_做大块_函 (炉_状态机结 *L, int 状态码_变量) {
  if (状态码_变量 == LUA_OK) 状态码_变量 = 月解释器_做调用_函(L, 0, 0);
  return 月解释器_报告_函(L, 状态码_变量);
}


static int 月解释器_做文件_函 (炉_状态机结 *L, const char *名称_变量) {
  return 月解释器_做大块_函(L, 辅助库_月亮l_载入文件_宏名(L, 名称_变量));
}


static int 月解释器_做字符串_函 (炉_状态机结 *L, const char *s, const char *名称_变量) {
  return 月解释器_做大块_函(L, 辅助库_月亮l_载入缓冲区_宏名(L, s, strlen(s), 名称_变量));
}


/*
** Receives 'globname[=模名_变量]' and runs 'globname = require(模名_变量)'.
*/
static int 月解释器_做库_函 (炉_状态机结 *L, char *globname) {
  int 状态码_变量;
  char *模名_变量 = strchr(globname, '=');
  if (模名_变量 == NULL)  /* no explicit 名称_变量? */
    模名_变量 = globname;  /* module 名称_变量 is equal 到_变量 global 名称_变量 */
  else {
    *模名_变量 = '\0';  /* global 名称_变量 ends here */
    模名_变量++;  /* module 名称_变量 starts after the '=' */
  }
  月亮获取全局变量_函(L, "require");
  月亮推入字符串_函(L, 模名_变量);
  状态码_变量 = 月解释器_做调用_函(L, 1, 1);  /* call 'require(模名_变量)' */
  if (状态码_变量 == LUA_OK)
    月亮设置全局变量_函(L, globname);  /* globname = require(模名_变量) */
  return 月解释器_报告_函(L, 状态码_变量);
}


/*
** Push on the 栈_圆小 the 内容_小写 of table '实参_短变量' from 1 到_变量 #实参_短变量
*/
static int 月解释器_推实参们_函 (炉_状态机结 *L) {
  int i, n;
  if (月亮获取全局变量_函(L, "实参_短变量") != 月头_月亮_T表_宏名)
    月亮状态_错误_函(L, "'实参_短变量' is not a table");
  n = (int)月亮状态_长度_函(L, -1);
  月亮状态_检查栈_函(L, n + 3, "too many arguments 到_变量 脚本_变量");
  for (i = 1; i <= n; i++)
    月亮获取原始索引_函(L, -i, i);
  月头_月亮_移除_宏名(L, -i);  /* remove table from the 栈_圆小 */
  return n;
}


static int 月解释器_手握_脚本_函 (炉_状态机结 *L, char **实参值_变量) {
  int 状态码_变量;
  const char *函名_缩变量 = 实参值_变量[0];
  if (strcmp(函名_缩变量, "-") == 0 && strcmp(实参值_变量[-1], "--") != 0)
    函名_缩变量 = NULL;  /* stdin */
  状态码_变量 = 辅助库_月亮l_载入文件_宏名(L, 函名_缩变量);
  if (状态码_变量 == LUA_OK) {
    int n = 月解释器_推实参们_函(L);  /* push arguments 到_变量 脚本_变量 */
    状态码_变量 = 月解释器_做调用_函(L, n, 月头_月亮_多返回_宏名);
  }
  return 月解释器_报告_函(L, 状态码_变量);
}


/* bits of various argument indicators in '实参们_短变量' */
#define 解释器_有_错误_宏名	1	/* bad 选项_变量 */
#define 解释器_有_i_宏名		2	/* -i */
#define 解释器_有_v_宏名		4	/* -v */
#define 解释器_有_e_宏名		8	/* -e */
#define 解释器_有_E_宏名		16	/* -E */


/*
** Traverses all arguments from '实参值_变量', returning a 掩码_变量 with those
** 已需要_变量 before running any Lua 代码_变量 or an 错误_小变量 代码_变量 if it finds any
** invalid argument. In case of 错误_小变量, '首先_变量' is the index of the bad
** argument.  Otherwise, '首先_变量' is -1 if there is no program 名称_变量,
** 0 if there is no 脚本_变量 名称_变量, or the index of the 脚本_变量 名称_变量.
*/
static int 月解释器_收集实参们_函 (char **实参值_变量, int *首先_变量) {
  int 实参们_短变量 = 0;
  int i;
  if (实参值_变量[0] != NULL) {  /* is there a program 名称_变量? */
    if (实参值_变量[0][0])  /* not 空容器_变量? */
      程序名_变量 = 实参值_变量[0];  /* 月词法_保存_函 it */
  }
  else {  /* no program 名称_变量 */
    *首先_变量 = -1;
    return 0;
  }
  for (i = 1; 实参值_变量[i] != NULL; i++) {  /* handle arguments */
    *首先_变量 = i;
    if (实参值_变量[i][0] != '-')  /* not an 选项_变量? */
        return 实参们_短变量;  /* stop handling 选项们_变量 */
    switch (实参值_变量[i][1]) {  /* else 月解析器_检查_函 选项_变量 */
      case '-':  /* '--' */
        if (实参值_变量[i][2] != '\0')  /* 额外_变量 characters after '--'? */
          return 解释器_有_错误_宏名;  /* invalid 选项_变量 */
        *首先_变量 = i + 1;
        return 实参们_短变量;
      case '\0':  /* '-' */
        return 实参们_短变量;  /* 脚本_变量 "名称_变量" is '-' */
      case 'E':
        if (实参值_变量[i][2] != '\0')  /* 额外_变量 characters? */
          return 解释器_有_错误_宏名;  /* invalid 选项_变量 */
        实参们_短变量 |= 解释器_有_E_宏名;
        break;
      case 'W':
        if (实参值_变量[i][2] != '\0')  /* 额外_变量 characters? */
          return 解释器_有_错误_宏名;  /* invalid 选项_变量 */
        break;
      case 'i':
        实参们_短变量 |= 解释器_有_i_宏名;  /* (-i implies -v) *//* FALLTHROUGH */
      case 'v':
        if (实参值_变量[i][2] != '\0')  /* 额外_变量 characters? */
          return 解释器_有_错误_宏名;  /* invalid 选项_变量 */
        实参们_短变量 |= 解释器_有_v_宏名;
        break;
      case 'e':
        实参们_短变量 |= 解释器_有_e_宏名;  /* FALLTHROUGH */
      case 'l':  /* both 选项们_变量 need an argument */
        if (实参值_变量[i][2] == '\0') {  /* no concatenated argument? */
          i++;  /* try 下一个_变量 '实参值_变量' */
          if (实参值_变量[i] == NULL || 实参值_变量[i][0] == '-')
            return 解释器_有_错误_宏名;  /* no 下一个_变量 argument or it is another 选项_变量 */
        }
        break;
      default:  /* invalid 选项_变量 */
        return 解释器_有_错误_宏名;
    }
  }
  *首先_变量 = 0;  /* no 脚本_变量 名称_变量 */
  return 实参们_短变量;
}


/*
** Processes 选项们_变量 'e' and 'l', which involve running Lua 代码_变量, and
** 'W', which also affects the 状态机_变量.
** Returns 0 if some 代码_变量 raises an 错误_小变量.
*/
static int 月解释器_跑实参们_函 (炉_状态机结 *L, char **实参值_变量, int n) {
  int i;
  for (i = 1; i < n; i++) {
    int 选项_变量 = 实参值_变量[i][1];
    限制_月亮_断言_宏名(实参值_变量[i][0] == '-');  /* already checked */
    switch (选项_变量) {
      case 'e':  case 'l': {
        int 状态码_变量;
        char *额外_变量 = 实参值_变量[i] + 2;  /* both 选项们_变量 need an argument */
        if (*额外_变量 == '\0') 额外_变量 = 实参值_变量[++i];
        限制_月亮_断言_宏名(额外_变量 != NULL);
        状态码_变量 = (选项_变量 == 'e')
                 ? 月解释器_做字符串_函(L, 额外_变量, "=(command 行_变量)")
                 : 月解释器_做库_函(L, 额外_变量);
        if (状态码_变量 != LUA_OK) return 0;
        break;
      }
      case 'W':
        月亮_警告_函(L, "@on", 0);  /* warnings on */
        break;
    }
  }
  return 1;
}


static int 月解释器_手握_月亮初始的_函 (炉_状态机结 *L) {
  const char *名称_变量 = "=" 解释器_月亮_初始变量版本_宏名;
  const char *初始的_变量 = getenv(名称_变量 + 1);
  if (初始的_变量 == NULL) {
    名称_变量 = "=" 解释器_月亮_初始_变量_宏名;
    初始的_变量 = getenv(名称_变量 + 1);  /* try alternative 名称_变量 */
  }
  if (初始的_变量 == NULL) return LUA_OK;
  else if (初始的_变量[0] == '@')
    return 月解释器_做文件_函(L, 初始的_变量+1);
  else
    return 月解释器_做字符串_函(L, 初始的_变量, 名称_变量);
}


/*
** {==================================================================
** Read-Eval-Print Loop (REPL)
** ===================================================================
*/

#if !defined(解释器_月亮_提示符_宏名)
#define 解释器_月亮_提示符_宏名		"> "
#define 解释器_月亮_提示符2_宏名		">> "
#endif

#if !defined(解释器_月亮_最大输入_宏名)
#define 解释器_月亮_最大输入_宏名		512
#endif


/*
** 解释器_月亮_标准_是否_tty_宏名 detects whether the standard input is a 'tty' (that
** is, whether we're running lua interactively).
*/
#if !defined(解释器_月亮_标准_是否_tty_宏名)	/* { */

#if defined(配置_月亮_用_POSIX_宏名)	/* { */

#include <unistd.h>
#define 解释器_月亮_标准_是否_tty_宏名()	isatty(0)

#elif defined(配置_月亮_用_WINDOWS_宏名)	/* }{ */

#include <io.h>
#include <windows.h>

#define 解释器_月亮_标准_是否_tty_宏名()	_isatty(_fileno(stdin))

#else				/* }{ */

/* ISO C definition */
#define 解释器_月亮_标准_是否_tty_宏名()	1  /* assume stdin is a tty */

#endif				/* } */

#endif				/* } */


/*
** 解释器_月亮_读行_宏名 defines how 到_变量 show a prompt and then read a 行_变量 from
** the standard input.
** 解释器_月亮_保存行_宏名 defines how 到_变量 "月词法_保存_函" a read 行_变量 in a "history".
** 解释器_月亮_释放行_宏名 defines how 到_变量 free a 行_变量 read by 解释器_月亮_读行_宏名.
*/
#if !defined(解释器_月亮_读行_宏名)	/* { */

#if defined(LUA_USE_READLINE)	/* { */

#include <readline/readline.h>
#include <readline/history.h>
#define 解释器_月亮_初始读行_宏名(L)	((void)L, rl_readline_name="lua")
#define 解释器_月亮_读行_宏名(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
#define 解释器_月亮_保存行_宏名(L,行_变量)	((void)L, add_history(行_变量))
#define 解释器_月亮_释放行_宏名(L,b)	((void)L, free(b))

#else				/* }{ */

#define 解释器_月亮_初始读行_宏名(L)  ((void)L)
#define 解释器_月亮_读行_宏名(L,b,p) \
        ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
        fgets(b, 解释器_月亮_最大输入_宏名, stdin) != NULL)  /* get 行_变量 */
#define 解释器_月亮_保存行_宏名(L,行_变量)	{ (void)L; (void)行_变量; }
#define 解释器_月亮_释放行_宏名(L,b)	{ (void)L; (void)b; }

#endif				/* } */

#endif				/* } */


/*
** Return the string 到_变量 be used as a prompt by the interpreter. Leave
** the string (or nil, if using the default 值_圆) on the 栈_圆小, 到_变量 keep
** it anchored.
*/
static const char *月解释器_获取_提示符_函 (炉_状态机结 *L, int firstline) {
  if (月亮获取全局变量_函(L, firstline ? "_PROMPT" : "_PROMPT2") == 月头_月亮_T空值_宏名)
    return (firstline ? 解释器_月亮_提示符_宏名 : 解释器_月亮_提示符2_宏名);  /* use the default */
  else {  /* apply '虚拟机_到字符串_宏名' over the 值_圆 */
    const char *p = 月亮状态_到字符串_函(L, -1, NULL);
    月头_月亮_移除_宏名(L, -2);  /* remove original 值_圆 */
    return p;
  }
}

/* 记号_变量 in 错误_小变量 messages for 月解释器_不完整的_函 statements */
#define 解释器_EOF记号_宏名		"<eof>"
#define 解释器_记号长度_宏名		(sizeof(解释器_EOF记号_宏名)/sizeof(char) - 1)


/*
** Check whether '状态码_变量' signals a syntax 错误_小变量 and the 错误_小变量
** message at the 顶部_变量 of the 栈_圆小 ends with the above 记号_变量 for
** 月解释器_不完整的_函 statements.
*/
static int 月解释器_不完整的_函 (炉_状态机结 *L, int 状态码_变量) {
  if (状态码_变量 == 月头_月亮_句法错误_宏名) {
    size_t l消息_变量;
    const char *消息_缩变量 = 月亮_到长字符串_函(L, -1, &l消息_变量);
    if (l消息_变量 >= 解释器_记号长度_宏名 && strcmp(消息_缩变量 + l消息_变量 - 解释器_记号长度_宏名, 解释器_EOF记号_宏名) == 0) {
      月头_月亮_弹出_宏名(L, 1);
      return 1;
    }
  }
  return 0;  /* else... */
}


/*
** Prompt the user, read a 行_变量, and push it into the Lua 栈_圆小.
*/
static int 月解释器_推行_函 (炉_状态机结 *L, int firstline) {
  char 缓冲区_变量[解释器_月亮_最大输入_宏名];
  char *b = 缓冲区_变量;
  size_t l;
  const char *提示_缩变量 = 月解释器_获取_提示符_函(L, firstline);
  int 读状态码_变量 = 解释器_月亮_读行_宏名(L, b, 提示_缩变量);
  if (读状态码_变量 == 0)
    return 0;  /* no input (prompt will be popped by caller) */
  月头_月亮_弹出_宏名(L, 1);  /* remove prompt */
  l = strlen(b);
  if (l > 0 && b[l-1] == '\n')  /* 行_变量 ends with 新行_小变量? */
    b[--l] = '\0';  /* remove it */
  if (firstline && b[0] == '=')  /* for compatibility with 5.2, ... */
    月亮推入格式化字符串_函(L, "return %s", b + 1);  /* 改变_变量 '=' 到_变量 'return' */
  else
    月亮推入长字符串_函(L, b, l);
  解释器_月亮_释放行_宏名(L, b);
  return 1;
}


/*
** Try 到_变量 compile 行_变量 on the 栈_圆小 as 'return <行_变量>;'; on return, 栈_圆小
** has either compiled chunk or original 行_变量 (if compilation failed).
*/
static int 月解释器_添加返回_函 (炉_状态机结 *L) {
  const char *行_变量 = 月头_月亮_到字符串_宏名(L, -1);  /* original 行_变量 */
  const char *返回行_变量 = 月亮推入格式化字符串_函(L, "return %s;", 行_变量);
  int 状态码_变量 = 辅助库_月亮l_载入缓冲区_宏名(L, 返回行_变量, strlen(返回行_变量), "=stdin");
  if (状态码_变量 == LUA_OK) {
    月头_月亮_移除_宏名(L, -2);  /* remove modified 行_变量 */
    if (行_变量[0] != '\0')  /* non 空容器_变量? */
      解释器_月亮_保存行_宏名(L, 行_变量);  /* keep history */
  }
  else
    月头_月亮_弹出_宏名(L, 2);  /* pop 结果_变量 from '辅助库_月亮l_载入缓冲区_宏名' and modified 行_变量 */
  return 状态码_变量;
}


/*
** Read multiple lines until a complete Lua 月解析器_语句_函
*/
static int 月解释器_多行_函 (炉_状态机结 *L) {
  for (;;) {  /* repeat until gets a complete 月解析器_语句_函 */
    size_t 长度_短变量;
    const char *行_变量 = 月亮_到长字符串_函(L, 1, &长度_短变量);  /* get 什么_变量 it has */
    int 状态码_变量 = 辅助库_月亮l_载入缓冲区_宏名(L, 行_变量, 长度_短变量, "=stdin");  /* try it */
    if (!月解释器_不完整的_函(L, 状态码_变量) || !月解释器_推行_函(L, 0)) {
      解释器_月亮_保存行_宏名(L, 行_变量);  /* keep history */
      return 状态码_变量;  /* 月编译器_不能_函 or should not try 到_变量 add continuation 行_变量 */
    }
    月头_月亮_推字面_宏名(L, "\n");  /* add 新行_小变量... */
    月头_月亮_插入_宏名(L, -2);  /* ...between the two lines */
    月亮_拼接_函(L, 3);  /* join them */
  }
}


/*
** Read a 行_变量 and try 到_变量 load (compile) it 首先_变量 as an expression (by
** adding "return " in front of it) and second as a 月解析器_语句_函. Return
** the 最终_变量 状态码_变量 of load/call with the resulting function (if any)
** in the 顶部_变量 of the 栈_圆小.
*/
static int 月解释器_载入行_函 (炉_状态机结 *L) {
  int 状态码_变量;
  月亮_设置顶_函(L, 0);
  if (!月解释器_推行_函(L, 1))
    return -1;  /* no input */
  if ((状态码_变量 = 月解释器_添加返回_函(L)) != LUA_OK)  /* 'return ...' did not 工作_变量? */
    状态码_变量 = 月解释器_多行_函(L);  /* try as command, maybe with continuation lines */
  月头_月亮_移除_宏名(L, 1);  /* remove 行_变量 from the 栈_圆小 */
  限制_月亮_断言_宏名(月亮_获取顶_函(L) == 1);
  return 状态码_变量;
}


/*
** Prints (calling the Lua 'print' function) any values on the 栈_圆小
*/
static void 月解释器_l_打印_函 (炉_状态机结 *L) {
  int n = 月亮_获取顶_函(L);
  if (n > 0) {  /* any 结果_变量 到_变量 be printed? */
    月亮状态_检查栈_函(L, 月头_月亮_最小栈_宏名, "too many results 到_变量 print");
    月亮获取全局变量_函(L, "print");
    月头_月亮_插入_宏名(L, 1);
    if (月头_月亮_保护调用_宏名(L, n, 0, 0) != LUA_OK)
      月解释器_l_消息_函(程序名_变量, 月亮推入格式化字符串_函(L, "错误_小变量 calling 'print' (%s)",
                                             月头_月亮_到字符串_宏名(L, -1)));
  }
}


/*
** Do the REPL: repeatedly read (load) a 行_变量, evaluate (call) it, and
** print any results.
*/
static void 月解释器_做读求值印环_函 (炉_状态机结 *L) {
  int 状态码_变量;
  const char *旧程序名_变量 = 程序名_变量;
  程序名_变量 = NULL;  /* no '程序名_变量' on errors in interactive 模块_变量 */
  解释器_月亮_初始读行_宏名(L);
  while ((状态码_变量 = 月解释器_载入行_函(L)) != -1) {
    if (状态码_变量 == LUA_OK)
      状态码_变量 = 月解释器_做调用_函(L, 0, 月头_月亮_多返回_宏名);
    if (状态码_变量 == LUA_OK) 月解释器_l_打印_函(L);
    else 月解释器_报告_函(L, 状态码_变量);
  }
  月亮_设置顶_函(L, 0);  /* clear 栈_圆小 */
  辅助库_月亮_写行_宏名();
  程序名_变量 = 旧程序名_变量;
}

/* }================================================================== */


/*
** Main 月解析器_身体_函 of stand-alone interpreter (到_变量 be called in protected 模块_变量).
** Reads the 选项们_变量 and handles them all.
*/
static int 月解释器_保护主函_函 (炉_状态机结 *L) {
  int 实参计数_变量 = (int)月头_月亮_到整数_宏名(L, 1);
  char **实参值_变量 = (char **)月亮_到用户数据_函(L, 2);
  int 脚本_变量;
  int 实参们_短变量 = 月解释器_收集实参们_函(实参值_变量, &脚本_变量);
  int 优化限制_变量 = (脚本_变量 > 0) ? 脚本_变量 : 实参计数_变量; /* 首先_变量 实参值_变量 not an 选项_变量 */
  辅助库_月亮l_检查版本_宏名(L);  /* 月解析器_检查_函 that interpreter has correct 版本_变量 */
  if (实参们_短变量 == 解释器_有_错误_宏名) {  /* bad 实参_短变量? */
    月解释器_打印_用法_函(实参值_变量[脚本_变量]);  /* '脚本_变量' has index of bad 实参_短变量. */
    return 0;
  }
  if (实参们_短变量 & 解释器_有_v_宏名)  /* 选项_变量 '-v'? */
    月解释器_打印_版本_函();
  if (实参们_短变量 & 解释器_有_E_宏名) {  /* 选项_变量 '-E'? */
    月亮推入布尔值_函(L, 1);  /* signal for libraries 到_变量 ignore 环境_短变量. vars. */
    月亮设置字段_函(L, 月头_月亮_注册表索引_宏名, "LUA_NOENV");
  }
  月亮库打开库们_函(L);  /* 打开_圆 standard libraries */
  月解释器_创建实参表_函(L, 实参值_变量, 实参计数_变量, 脚本_变量);  /* create table '实参_短变量' */
  月亮_垃圾回收_函(L, 月头_月亮_垃圾回收重启_宏名);  /* 起始_变量 GC... */
  月亮_垃圾回收_函(L, 月头_月亮_垃圾回收生成_宏名, 0, 0);  /* ...in generational 模块_变量 */
  if (!(实参们_短变量 & 解释器_有_E_宏名)) {  /* no 选项_变量 '-E'? */
    if (月解释器_手握_月亮初始的_函(L) != LUA_OK)  /* run LUA_INIT */
      return 0;  /* 错误_小变量 running LUA_INIT */
  }
  if (!月解释器_跑实参们_函(L, 实参值_变量, 优化限制_变量))  /* execute arguments -e and -l */
    return 0;  /* something failed */
  if (脚本_变量 > 0) {  /* execute main 脚本_变量 (if there is one) */
    if (月解释器_手握_脚本_函(L, 实参值_变量 + 脚本_变量) != LUA_OK)
      return 0;  /* interrupt in case of 错误_小变量 */
  }
  if (实参们_短变量 & 解释器_有_i_宏名)  /* -i 选项_变量? */
    月解释器_做读求值印环_函(L);  /* do read-eval-print 环_变量 */
  else if (脚本_变量 < 1 && !(实参们_短变量 & (解释器_有_e_宏名 | 解释器_有_v_宏名))) { /* no active 选项_变量? */
    if (解释器_月亮_标准_是否_tty_宏名()) {  /* running in interactive 模块_变量? */
      月解释器_打印_版本_函();
      月解释器_做读求值印环_函(L);  /* do read-eval-print 环_变量 */
    }
    else 月解释器_做文件_函(L, NULL);  /* executes stdin as a file */
  }
  月亮推入布尔值_函(L, 1);  /* signal no errors */
  return 1;
}


int main (int 实参计数_变量, char **实参值_变量) {
  int 状态码_变量, 结果_变量;
  炉_状态机结 *L = 月亮状态_新状态_函();  /* create 状态机_变量 */
  if (L == NULL) {
    月解释器_l_消息_函(实参值_变量[0], "月编译器_不能_函 create 状态机_变量: not enough memory");
    return EXIT_FAILURE;
  }
  月亮_垃圾回收_函(L, 月头_月亮_垃圾回收停止_宏名);  /* stop GC while building 状态机_变量 */
  月头_月亮_推C函数_宏名(L, &月解释器_保护主函_函);  /* 到_变量 call '月解释器_保护主函_函' in protected 模块_变量 */
  月亮推入整数_函(L, 实参计数_变量);  /* 1st argument */
  月亮推入轻量用户数据_函(L, 实参值_变量); /* 2nd argument */
  状态码_变量 = 月头_月亮_保护调用_宏名(L, 2, 1, 0);  /* do the call */
  结果_变量 = 月亮_到布尔值_函(L, -1);  /* get 结果_变量 */
  月解释器_报告_函(L, 状态码_变量);
  月亮_关闭_函(L);
  return (结果_变量 && 状态码_变量 == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
}

